{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#cmtj","title":"CMTJ","text":""},{"location":"#short-description","title":"Short description","text":"<p>A name may be misleading -- the MTJ (Magnetic Tunnel Junctions) are not the only structures that may be simulated. The library allows for macromagnetic simulation of various multilayer spintronic structures. The package uses C++ implementation of (s)LLGS (stochastic Landau-Lifschitz-Gilbert-Slonczewski) equation with various field contributions included for instance: anisotropy, interlayer exchange coupling, demagnetisation, dipole fields etc. It is also possible to connect devices in parallel or in series to have electrically coupled arrays.</p>"},{"location":"#quickstart","title":"Quickstart","text":""},{"location":"#installation-rocket","title":"Installation :rocket:","text":"<p>Installation is as easy as doing: A recommended way is to use the <code>pip</code> package manager and virtualenv (or conda).</p> <ol> <li>With <code>virtualenv</code> (recommended):</li> </ol> <pre><code>$(bash) python -m venv .my-venv\n$(bash) source .my-venv/bin/activate\n$(.my-venv) python -m pip install cmtj\n</code></pre> <ol> <li>Straight from <code>pip</code>:</li> </ol> <pre><code>python3 -m pip install cmtj\n</code></pre> <ol> <li>Straight from source:</li> </ol> <pre><code>python3 -m pip install https://github.com/LemurPwned/cmtj.git\n</code></pre> <ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/LemurPwned/cmtj.git\npython3 -m pip install .\n</code></pre>"},{"location":"#extra-dependencies","title":"Extra dependencies","text":"<p>The package requires (if <code>utils</code> subpackage is used):</p> <pre><code>- numpy\n- scipy\n- matplotlib\n</code></pre>"},{"location":"#read-the-docs","title":"Read the docs","text":"<p>Documentation: https://lemurpwned.github.io/cmtj</p>"},{"location":"#extensions","title":"Extensions","text":"<p>There's a GUI version available! If you wish to conduct a subset of simulations, mainly for experimental modelling, please see the PyMag project. It uses CMTJ as a backend for fast computation.</p>"},{"location":"#citing","title":"Citing","text":"<p>We would appreciate citing either of the listed work if you decide to use the project or using the cite button on the right hand side panel of the repository:</p> <p>cmtj: Simulation package for analysis of multilayer spintronic devices</p> <pre><code>@article{mojsiejuk_cmtj_2023,\n    title = {cmtj: Simulation package for analysis of multilayer spintronic devices},\n    volume = {9},\n    issn = {2057-3960},\n    url = {https://www.nature.com/articles/s41524-023-01002-x},\n    doi = {10.1038/s41524-023-01002-x},\n    pages = {54},\n    number = {1},\n    journaltitle = {npj Comput Mater},\n    author = {Mojsiejuk, Jakub and Zi\u0119tek, S\u0142awomir and Grochot, Krzysztof and Skowro\u0144ski, Witold and Stobiecki, Tomasz},\n    date = {2023-04-06},\n}\n</code></pre>"},{"location":"#development","title":"Development","text":""},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Many thanks to professor Jack Sankey for his help with the development of thermal contributions, with inspiration from the macrospinmob project.</p>"},{"location":"#contributions","title":"Contributions","text":"<p>All contributions are welcome, please leave an issue if you've encountered any trouble with setup or running the library.</p>"},{"location":"#precommit","title":"Precommit","text":"<p>There's a <code>.pre-commit-config.yaml</code> that does some basic python and cpp lints and checks. More static analysis to come in the future. This may be run with:</p> <pre><code>pre-commit run -v\n</code></pre> <p>or</p> <pre><code>pre-commit run -a (or --files core/* cmtj/*)\n</code></pre>"},{"location":"#documentation-builds","title":"Documentation builds","text":"<p>There are couple of stages to building the documentation</p> <ol> <li>Build Doxygen documentation    <pre><code>doxygen Doxyfile\n</code></pre>    This is mostly for the C++ documentation. Furture changes may couple C++ and Python docs.</li> <li>Build stubs    The stubgen is <code>pybind11-stubgen</code> or <code>mypy stubgen</code> with the latter being preferred now.    E.g. to generate <code>Stack</code> module stubs we can go:    <pre><code>stubgen -m cmtj.stack -o target-stub-dir/\n</code></pre>    More info here: https://mypy.readthedocs.io/en/stable/stubgen.html.</li> <li>Parse stubs to Markdown.    This stage is done by running:    <code>python3 docs/docgen.py</code>    The deployment of the documentation is done via:    <pre><code>mkdocs gh-deploy\n</code></pre>    But first, worth a check:    <pre><code>mkdocs serve\n</code></pre></li> </ol>"},{"location":"docgen/","title":"Docgen","text":"In\u00a0[\u00a0]: Copied! <pre>import glob\nimport os\nimport re\nfrom dataclasses import dataclass\nfrom email.policy import default\nfrom pydoc import doc\n</pre> import glob import os import re from dataclasses import dataclass from email.policy import default from pydoc import doc In\u00a0[\u00a0]: Copied! <pre>py_signature = r\"(def (.+?) -&gt; ([\\'\\[\\]\\,\\sA-z]+)\\:)\"\nc_py_signature = re.compile(py_signature)\n</pre> py_signature = r\"(def (.+?) -&gt; ([\\'\\[\\]\\,\\sA-z]+)\\:)\" c_py_signature = re.compile(py_signature) In\u00a0[\u00a0]: Copied! <pre>joint_py = r\"(def (.+?) -&gt; ([\\'\\[\\]\\,\\sA-z]+)\\:)\\n{0,}\\s{8}(\\\"{3}(.+?)\\\"{3})(?s)\"\nc_joint_py = re.compile(joint_py)\n</pre> joint_py = r\"(def (.+?) -&gt; ([\\'\\[\\]\\,\\sA-z]+)\\:)\\n{0,}\\s{8}(\\\"{3}(.+?)\\\"{3})(?s)\" c_joint_py = re.compile(joint_py) In\u00a0[\u00a0]: Copied! <pre>pydoc_regex = r\"(\\\"{3}(.+?)\\\"{3})(?s)\"\nc_pydoc_rgx = re.compile(pydoc_regex)\narg_pydoc = r\"(\\:param ([A-z0-9]+)\\:(.+)\\n)\"\npy_arg_rgx = re.compile(arg_pydoc)\n</pre> pydoc_regex = r\"(\\\"{3}(.+?)\\\"{3})(?s)\" c_pydoc_rgx = re.compile(pydoc_regex) arg_pydoc = r\"(\\:param ([A-z0-9]+)\\:(.+)\\n)\" py_arg_rgx = re.compile(arg_pydoc) In\u00a0[\u00a0]: Copied! <pre>cdoc_regex = r\"(\\/\\*{2}(.+?)\\*\\/{1})(?s)\"  # ?s is an inline DOTALL flag\narg_cdoc = r\"(\\@param ([A-z0-9]+)\\:(.+)\\n)\"\nc_cdoc_rgx = re.compile(cdoc_regex)\nc_arg_rgx = re.compile(arg_cdoc)\n</pre> cdoc_regex = r\"(\\/\\*{2}(.+?)\\*\\/{1})(?s)\"  # ?s is an inline DOTALL flag arg_cdoc = r\"(\\@param ([A-z0-9]+)\\:(.+)\\n)\" c_cdoc_rgx = re.compile(cdoc_regex) c_arg_rgx = re.compile(arg_cdoc) In\u00a0[\u00a0]: Copied! <pre>GEN_FOLDER = \"gen-docs\"\n</pre> GEN_FOLDER = \"gen-docs\" In\u00a0[\u00a0]: Copied! <pre>@dataclass\nclass PythonDocstring:\n    signature: str\n    rtype: str\n    docstring: str\n\n    def extract_signature_types(self):\n        type_map = {}\n        rtype_map = {}\n        first_bracket = self.signature.index(\"(\")\n        second_bracket = self.signature.index(\")\")\n        args = self.signature[first_bracket + 1:second_bracket].split(\",\")\n        args = [arg.strip() for arg in args if arg != \"self\"]\n        for arg in args:\n            if \":\" in arg:\n                key_, type_ = arg.split(\":\")\n                key_ = key_.strip()\n                type_ = type_.strip()\n                default_ = \"-\"\n                if \"=\" in type_:\n                    type_, default_ = type_.split(\"=\")\n                    type_ = type_.strip()\n                    default_ = default_.strip()\n                type_map[key_] = type_\n                rtype_map[key_] = default_\n        return type_map, rtype_map\n\n    def py_signature_to_markdown(self):\n        # form type map first\n        type_map, rtype_map = self.extract_signature_types()\n\n        arg_template = \"**`{}`** | `{}` | {} | `{}`\"\n        table = (\"\"\"Name | Type | Description | Default\\n\"\"\"\n                 \"\"\"------ | ---- | ----------- | -------\"\"\")\n        table = \"#### **Parameters** \\n\" + table\n        arg_count = 0\n        for arg in py_arg_rgx.findall(self.docstring):\n            if arg:\n                arg_count += 1\n                real_arg = arg[1].replace(\"\\n\", \"\")\n                arg_desc = arg[2].replace(\"\\n\", \"\")\n\n                table += \"\\n\" + arg_template.format(\n                    real_arg,\n                    type_map.get(real_arg, \"-\"),\n                    arg_desc,\n                    rtype_map.get(real_arg, \"-\"),\n                )\n        fnsignature = self.docstring.split(\":param\")[0].strip()\n        sig = self.signature.replace(\"\\n\", \"\").replace(\"\\t\",\n                                                       \"\").replace(\"    \", \"\")\n        if arg_count:\n            return f\"### `{sig}`\\n\\n{fnsignature}\\n{table}\\n\\n\"\n        return f\"### `{sig}`\\n\\n{fnsignature}\\n\\n\\n\"\n</pre> @dataclass class PythonDocstring:     signature: str     rtype: str     docstring: str      def extract_signature_types(self):         type_map = {}         rtype_map = {}         first_bracket = self.signature.index(\"(\")         second_bracket = self.signature.index(\")\")         args = self.signature[first_bracket + 1:second_bracket].split(\",\")         args = [arg.strip() for arg in args if arg != \"self\"]         for arg in args:             if \":\" in arg:                 key_, type_ = arg.split(\":\")                 key_ = key_.strip()                 type_ = type_.strip()                 default_ = \"-\"                 if \"=\" in type_:                     type_, default_ = type_.split(\"=\")                     type_ = type_.strip()                     default_ = default_.strip()                 type_map[key_] = type_                 rtype_map[key_] = default_         return type_map, rtype_map      def py_signature_to_markdown(self):         # form type map first         type_map, rtype_map = self.extract_signature_types()          arg_template = \"**`{}`** | `{}` | {} | `{}`\"         table = (\"\"\"Name | Type | Description | Default\\n\"\"\"                  \"\"\"------ | ---- | ----------- | -------\"\"\")         table = \"#### **Parameters** \\n\" + table         arg_count = 0         for arg in py_arg_rgx.findall(self.docstring):             if arg:                 arg_count += 1                 real_arg = arg[1].replace(\"\\n\", \"\")                 arg_desc = arg[2].replace(\"\\n\", \"\")                  table += \"\\n\" + arg_template.format(                     real_arg,                     type_map.get(real_arg, \"-\"),                     arg_desc,                     rtype_map.get(real_arg, \"-\"),                 )         fnsignature = self.docstring.split(\":param\")[0].strip()         sig = self.signature.replace(\"\\n\", \"\").replace(\"\\t\",                                                        \"\").replace(\"    \", \"\")         if arg_count:             return f\"### `{sig}`\\n\\n{fnsignature}\\n{table}\\n\\n\"         return f\"### `{sig}`\\n\\n{fnsignature}\\n\\n\\n\" In\u00a0[\u00a0]: Copied! <pre>def extract_python_docs(file_text):\n    for captured in c_joint_py.findall(file_text):\n        if captured:\n            yield PythonDocstring(\n                signature=captured[1].strip().replace(\"\\n\", \"\"),\n                rtype=captured[2].strip().replace(\"\\n\", \"\"),\n                docstring=captured[-1].strip(),\n            )\n</pre> def extract_python_docs(file_text):     for captured in c_joint_py.findall(file_text):         if captured:             yield PythonDocstring(                 signature=captured[1].strip().replace(\"\\n\", \"\"),                 rtype=captured[2].strip().replace(\"\\n\", \"\"),                 docstring=captured[-1].strip(),             ) In\u00a0[\u00a0]: Copied! <pre>def extract_cpp_docs(file_text):\n    for captured in c_cdoc_rgx.findall(file_text):\n        if captured:\n            yield captured[1].strip()\n</pre> def extract_cpp_docs(file_text):     for captured in c_cdoc_rgx.findall(file_text):         if captured:             yield captured[1].strip() In\u00a0[\u00a0]: Copied! <pre>def create_api_markdown_file(src_filename):\n    _, file_extension = os.path.splitext(src_filename)\n    target_filename = os.path.basename(os.path.dirname(src_filename)).replace(\n        file_extension, \".md\")\n    if not target_filename.endswith(\".md\"):\n        target_filename += \".md\"\n\n    md_fn = \"\"\n    with open(src_filename, \"r\") as f:\n        ftext = f.read()\n\n        class_docs = ftext.split(\"class\")[1:]\n        for i, doc_ in enumerate(class_docs):\n            class_name = doc_.partition(\"\\n\")[0].replace(\":\", \"\").strip()\n            print(i, class_name)\n            md_fn += f\"## `{class_name}`\"\n            for g in extract_python_docs(doc_):\n                sig = g.py_signature_to_markdown()\n                md_fn += f\"\\n{sig}\\n\"\n            md_fn += \"  \\n\"\n\n    with open(\n            os.path.join(os.path.dirname(__file__), GEN_FOLDER,\n                         target_filename), \"w\") as f:\n        f.write(md_fn)\n</pre> def create_api_markdown_file(src_filename):     _, file_extension = os.path.splitext(src_filename)     target_filename = os.path.basename(os.path.dirname(src_filename)).replace(         file_extension, \".md\")     if not target_filename.endswith(\".md\"):         target_filename += \".md\"      md_fn = \"\"     with open(src_filename, \"r\") as f:         ftext = f.read()          class_docs = ftext.split(\"class\")[1:]         for i, doc_ in enumerate(class_docs):             class_name = doc_.partition(\"\\n\")[0].replace(\":\", \"\").strip()             print(i, class_name)             md_fn += f\"## `{class_name}`\"             for g in extract_python_docs(doc_):                 sig = g.py_signature_to_markdown()                 md_fn += f\"\\n{sig}\\n\"             md_fn += \"  \\n\"      with open(             os.path.join(os.path.dirname(__file__), GEN_FOLDER,                          target_filename), \"w\") as f:         f.write(md_fn) In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    fn_lists = [\n        *glob.glob(\n            os.path.join(os.path.dirname(__file__), \"..\", \"cmtj/*/*.pyi\")),\n        *glob.glob(os.path.join(os.path.dirname(__file__), \"..\",\n                                \"cmtj/*.pyi\")),\n    ]\n    for fn in fn_lists:\n        create_api_markdown_file(fn)\n</pre> if __name__ == \"__main__\":     fn_lists = [         *glob.glob(             os.path.join(os.path.dirname(__file__), \"..\", \"cmtj/*/*.pyi\")),         *glob.glob(os.path.join(os.path.dirname(__file__), \"..\",                                 \"cmtj/*.pyi\")),     ]     for fn in fn_lists:         create_api_markdown_file(fn)"},{"location":"overview/","title":"Overview","text":"<p>The <code>cmtj</code> library is a macrospin library. That means that it is efficient and easy to use. It is also a collection of utilities that are useful for macrospin analysis, such as selected procedures, energy calculations, and parallelization.</p>"},{"location":"overview/#installation","title":"Installation","text":"<p>Installation is as easy as doing:</p> <pre><code>python3 -m pip install cmtj\n</code></pre>"},{"location":"overview/#how-do-i-get-started","title":"How do I get started?","text":"<p>The best way to get started is to modify one of the examples in the Examples section. If you're looking for a more in-depth look at the library, please see the API section.</p>"},{"location":"overview/#functionalities","title":"Functionalities","text":""},{"location":"overview/#junction-system","title":"Junction system","text":"<p>Primarily you will be using the <code>Junction</code> class to create a multilayer device. This need not to be an MTJ, it can be of any ferromagnetic (FM) type. Remember, that the FM type is solely dependent on the parameters you pass to the constructor of the <code>Layer</code> class, such as \\(M_\\textrm{s}\\) or \\(K_\\textrm{s}\\) (magnetisation saturation and anisotropy respectively).</p>"},{"location":"overview/#how-do-i-model-the-spaceroxide","title":"How do I model the spacer/oxide?","text":"<p>The funny thing is you don't do that directly. The effects of the spacer are effectively modeled by the <code>Junction</code> class in the following ways:</p> <ul> <li>the STT/SOT parameters, depending on the oxide type or thickness parameters such as \\(H_\\textrm{DL}\\) of \\(H_\\textrm{FL}\\) may get smaller or larger.</li> <li>the effective anisotropy in either of layers creating the junction may be dependent on the interface mixing or interface assymetry, so you can model that, for instance, by modifying one layer's anisotropy adequately.</li> <li>various modifications to magnetoresistance computation may be necessary, depending on the type of junction and the type of the oxide.</li> <li>addition of the <code>dipole</code> or <code>IEC</code> interaction is also a part of the junction model. Sometimes the coupling is so small, it may be neglected. See more in the Core section to see how to enable those (<code>setLayerIEC</code> and <code>setLayerTopDipole</code>).</li> </ul>"},{"location":"overview/#stack-system","title":"Stack system","text":"<p>The junctions can be further stacked to create a stack of junctions. The stacking is done by creating a <code>Stack</code> object which can either be <code>Parallel</code> stack or <code>Series</code> stack. The type depends on the electrical connection between the junctions.</p>"},{"location":"tipsandtricks/","title":"Tips and tricks","text":"<p>This is a loose collection of observations and tips that may help you in your work with the library.</p> <ul> <li>While scanning with a parameter use the previous value as the starting point. This will speed up the scan. However, remember to perturb the parameter by a small amount, otherwise the simulation may converge to a local minimum. Usually, for obtaining spectra this has no effect, but for obtaining the magnetisation profile it is important.</li> <li>Use <code>utils.Filters</code> for postprocessing the data. Not only logarithm, but detrending the spectra may help in obtaining a clearer picture. Using a <code>uniform_filter</code> from scipy may also help in smoothing the data.</li> <li>Try out integration times no lower than \\(10^{-12}\\). For large IEC coupling values (in the ballpark of \\(10^{-4}\\) or larger than that) you may need to go even much lower. You can always start up higher and then reduce step size to confirm that it has no effect on the results and convergence.</li> <li>Use <code>junction.clearLog()</code> and <code>stack.clearLogs()</code> to clear the log of the junction and stack. This will save you a lot of memory if you're doing a lot of scans and will vastly speed up the processing.</li> </ul>"},{"location":"api/energy-reference/","title":"Energy","text":""},{"location":"api/energy-reference/#cmtj.utils.energy.EnergyCompute","title":"<code>EnergyCompute</code>","text":"<p>Energy density in [J/m^3] computing functions</p> Source code in <code>cmtj/utils/energy.py</code> <pre><code>class EnergyCompute:\n    \"\"\"Energy density in [J/m^3] computing functions\"\"\"\n\n    def __init__(self, cell_surface: float, thickness: float,\n                 log: Dict[str, List[float]]) -&gt; None:\n        \"\"\"Initialise energy computation class\n        :param cell_surface: surface of the cell in [m^2]\n        :param thickness: thickness of the cell in [m]\n        :param log: log of the simulation (directly from .getLog())\"\"\"\n        self.cell_surface = cell_surface\n        self.thickness = thickness\n        self.cell_volumne = self.cell_surface * thickness\n        self.log = log\n\n    def compute_from_log(self) -&gt; Dict[str, List[float]]:\n        \"\"\"\n        Computes a log of energies over time and returns it\n        in the same form of the\n        \"\"\"\n        field_keys = list({k[:-1] for k in self.log if \"_H\" in k})\n        mag_k = (k.replace(\"_mx\", \"\") for k in self.log if \"_mx\" in k)\n        mag_vectors = {\n            k: np.asarray([\n                self.log[f\"{k}_mx\"], self.log[f\"{k}_my\"], self.log[f\"{k}_mz\"]\n            ])\n            for k in mag_k\n        }\n        energy_data = {}\n        for field_key in field_keys:\n            if \"J_\" in field_key:\n                eng_fn = self.calculate_energy_from_field_interfacial\n            else:\n                eng_fn = self.calculate_energy_from_field\n\n            m_key = field_key.split(\"_\")[0]  # get m key\n            m = mag_vectors[m_key]\n            field_series = np.asarray([\n                self.log[f\"{field_key}x\"],\n                self.log[f\"{field_key}y\"],\n                self.log[f\"{field_key}z\"],\n            ])\n            energy_data[f\"energy_{field_key}\"] = eng_fn(m, field_series)\n\n        return energy_data\n\n    def calculate_energy_from_field(self, m: np.ndarray,\n                                    field_vector: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        :param m: magnetisation\n        :param field_vector: magnetic field vector (can be external, Oersted etc.)\n        Compute generic energy density\n        E = H * (mi0 Ms/V)\n        where mi0 Ms is in [T], Ms in [A/m], H in [A/m]\n        \"\"\"\n        return -np.sum(m * field_vector, axis=0) / self.cell_volumne\n\n    def calculate_energy_from_field_interfacial(\n            self, m: np.ndarray, field_vector: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        :param m: magnetisation\n        :param field_vector: magnetic field vector (can be IEC etc.)\n        Compute generic energy density\n        E = H * (mi0 Ms/A)\n        where mi0 Ms is in [T], Ms in [A/m], H in [A/m]\n        \"\"\"\n        return -np.sum(m * field_vector, axis=0) / self.cell_surface\n</code></pre>"},{"location":"api/energy-reference/#cmtj.utils.energy.EnergyCompute.__init__","title":"<code>__init__(cell_surface, thickness, log)</code>","text":"<p>Initialise energy computation class</p> <p>Parameters:</p> Name Type Description Default <code>cell_surface</code> <code>float</code> <p>surface of the cell in [m^2]</p> required <code>thickness</code> <code>float</code> <p>thickness of the cell in [m]</p> required <code>log</code> <code>Dict[str, List[float]]</code> <p>log of the simulation (directly from .getLog())</p> required Source code in <code>cmtj/utils/energy.py</code> <pre><code>def __init__(self, cell_surface: float, thickness: float,\n             log: Dict[str, List[float]]) -&gt; None:\n    \"\"\"Initialise energy computation class\n    :param cell_surface: surface of the cell in [m^2]\n    :param thickness: thickness of the cell in [m]\n    :param log: log of the simulation (directly from .getLog())\"\"\"\n    self.cell_surface = cell_surface\n    self.thickness = thickness\n    self.cell_volumne = self.cell_surface * thickness\n    self.log = log\n</code></pre>"},{"location":"api/energy-reference/#cmtj.utils.energy.EnergyCompute.calculate_energy_from_field","title":"<code>calculate_energy_from_field(m, field_vector)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>m</code> <code>np.ndarray</code> <p>magnetisation</p> required <code>field_vector</code> <code>np.ndarray</code> <p>magnetic field vector (can be external, Oersted etc.) Compute generic energy density E = H * (mi0 Ms/V) where mi0 Ms is in [T], Ms in [A/m], H in [A/m]</p> required Source code in <code>cmtj/utils/energy.py</code> <pre><code>def calculate_energy_from_field(self, m: np.ndarray,\n                                field_vector: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    :param m: magnetisation\n    :param field_vector: magnetic field vector (can be external, Oersted etc.)\n    Compute generic energy density\n    E = H * (mi0 Ms/V)\n    where mi0 Ms is in [T], Ms in [A/m], H in [A/m]\n    \"\"\"\n    return -np.sum(m * field_vector, axis=0) / self.cell_volumne\n</code></pre>"},{"location":"api/energy-reference/#cmtj.utils.energy.EnergyCompute.calculate_energy_from_field_interfacial","title":"<code>calculate_energy_from_field_interfacial(m, field_vector)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>m</code> <code>np.ndarray</code> <p>magnetisation</p> required <code>field_vector</code> <code>np.ndarray</code> <p>magnetic field vector (can be IEC etc.) Compute generic energy density E = H * (mi0 Ms/A) where mi0 Ms is in [T], Ms in [A/m], H in [A/m]</p> required Source code in <code>cmtj/utils/energy.py</code> <pre><code>def calculate_energy_from_field_interfacial(\n        self, m: np.ndarray, field_vector: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    :param m: magnetisation\n    :param field_vector: magnetic field vector (can be IEC etc.)\n    Compute generic energy density\n    E = H * (mi0 Ms/A)\n    where mi0 Ms is in [T], Ms in [A/m], H in [A/m]\n    \"\"\"\n    return -np.sum(m * field_vector, axis=0) / self.cell_surface\n</code></pre>"},{"location":"api/energy-reference/#cmtj.utils.energy.EnergyCompute.compute_from_log","title":"<code>compute_from_log()</code>","text":"<p>Computes a log of energies over time and returns it in the same form of the</p> Source code in <code>cmtj/utils/energy.py</code> <pre><code>def compute_from_log(self) -&gt; Dict[str, List[float]]:\n    \"\"\"\n    Computes a log of energies over time and returns it\n    in the same form of the\n    \"\"\"\n    field_keys = list({k[:-1] for k in self.log if \"_H\" in k})\n    mag_k = (k.replace(\"_mx\", \"\") for k in self.log if \"_mx\" in k)\n    mag_vectors = {\n        k: np.asarray([\n            self.log[f\"{k}_mx\"], self.log[f\"{k}_my\"], self.log[f\"{k}_mz\"]\n        ])\n        for k in mag_k\n    }\n    energy_data = {}\n    for field_key in field_keys:\n        if \"J_\" in field_key:\n            eng_fn = self.calculate_energy_from_field_interfacial\n        else:\n            eng_fn = self.calculate_energy_from_field\n\n        m_key = field_key.split(\"_\")[0]  # get m key\n        m = mag_vectors[m_key]\n        field_series = np.asarray([\n            self.log[f\"{field_key}x\"],\n            self.log[f\"{field_key}y\"],\n            self.log[f\"{field_key}z\"],\n        ])\n        energy_data[f\"energy_{field_key}\"] = eng_fn(m, field_series)\n\n    return energy_data\n</code></pre>"},{"location":"api/ensemble-reference/","title":"Ensemble functions","text":"<p>This module contains functions for computing simple fits and models.</p>"},{"location":"api/ensemble-reference/#cmtj.models.ensemble.antisymmetric_lorentz","title":"<code>antisymmetric_lorentz(H, dH, Hr, Vas)</code>","text":"<p>Antisymmetric Lorentzian function.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <p>applied field in A/m</p> required <code>dH</code> <p>half width at half maximum in A/m</p> required <code>Hr</code> <p>resonance field in A/m</p> required Source code in <code>cmtj/models/ensemble.py</code> <pre><code>def antisymmetric_lorentz(H, dH, Hr, Vas):\n    \"\"\"\n    Antisymmetric Lorentzian function.\n    :param H: applied field in A/m\n    :param dH: half width at half maximum in A/m\n    :param Hr: resonance field in A/m\n    \"\"\"\n    dH2 = dH**2\n    dHr = H - Hr\n    return Vas * dH * dHr / (np.power(dHr, 2) + dH2)\n</code></pre>"},{"location":"api/ensemble-reference/#cmtj.models.ensemble.meinert_model","title":"<code>meinert_model(phi, V1, V2, phase_offset, offset)</code>","text":"<p>Fits to Meinert model.</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <p>angle in degrees, given parameter</p> required <code>V1</code> <p>(Hfl/Hext), fitting parameter</p> required <code>V2</code> <p>(Va*Hdl/Heff), fitting parameter</p> required <code>phase_offset</code> <p>phase offset in degrees, fitting parameter</p> required <code>offset</code> <p>offset in V, fitting parameter V2omega = (Acos(2(phi - phase_offset)) - B)*cos(phi - phase_offset) + offset</p> required Source code in <code>cmtj/models/ensemble.py</code> <pre><code>def meinert_model(phi, V1, V2, phase_offset, offset):\n    \"\"\"\n    Fits to Meinert model.\n    :param phi: angle in degrees, given parameter\n    :param V1: (Hfl/Hext), fitting parameter\n    :param V2: (Va*Hdl/Heff), fitting parameter\n    :param phase_offset: phase offset in degrees, fitting parameter\n    :param offset: offset in V, fitting parameter\n    V2omega = (Acos(2(phi - phase_offset)) - B)*cos(phi - phase_offset) + offset\n    \"\"\"\n    deg_rad = np.deg2rad(phi - phase_offset)\n    return (V1 * np.cos(2 * (deg_rad)) - V2) * np.cos(deg_rad) + offset\n</code></pre>"},{"location":"api/ensemble-reference/#cmtj.models.ensemble.mixed_lorentz","title":"<code>mixed_lorentz(H, dH, Hr, Va, Vas)</code>","text":"<p>Mixed Lorentzian function.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <p>applied field in A/m</p> required <code>dH</code> <p>half width at half maximum in A/m</p> required <code>Hr</code> <p>resonance field in A/m</p> required <code>Va</code> <p>amplitude of symmetric Lorentzian</p> required <code>Vas</code> <p>amplitude of antisymmetric Lorentzian</p> required Source code in <code>cmtj/models/ensemble.py</code> <pre><code>def mixed_lorentz(H, dH, Hr, Va, Vas):\n    \"\"\"\n    Mixed Lorentzian function.\n    :param H: applied field in A/m\n    :param dH: half width at half maximum in A/m\n    :param Hr: resonance field in A/m\n    :param Va: amplitude of symmetric Lorentzian\n    :param Vas: amplitude of antisymmetric Lorentzian\n    \"\"\"\n    return symmetric_lorentz(H, dH, Hr, Va) + antisymmetric_lorentz(\n        H, dH, Hr, Vas)\n</code></pre>"},{"location":"api/ensemble-reference/#cmtj.models.ensemble.symmetric_lorentz","title":"<code>symmetric_lorentz(H, dH, Hr, Vs)</code>","text":"<p>Symmetric Lorentzian function.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <p>applied field in A/m</p> required <code>dH</code> <p>half width at half maximum in A/m</p> required <code>Hr</code> <p>resonance field in A/m</p> required Source code in <code>cmtj/models/ensemble.py</code> <pre><code>def symmetric_lorentz(H, dH, Hr, Vs):\n    \"\"\"\n    Symmetric Lorentzian function.\n    :param H: applied field in A/m\n    :param dH: half width at half maximum in A/m\n    :param Hr: resonance field in A/m\n    \"\"\"\n    dH2 = dH**2\n    return Vs * dH2 / ((H - Hr)**2 + dH2)\n</code></pre>"},{"location":"api/filters-reference/","title":"Filters","text":""},{"location":"api/filters-reference/#cmtj.utils.filters.Filters","title":"<code>Filters</code>","text":"Source code in <code>cmtj/utils/filters.py</code> <pre><code>class Filters:\n\n    @staticmethod\n    def butter_bandpass_filter(data: np.ndarray,\n                               pass_freq: Tuple[float, float],\n                               fs: float,\n                               order: int = 5):\n        \"\"\"Basic bandpass (notch) butterworth filter.\n        :param data: input data.\n        :param pass_freq: the tuple of (low, high) band frequencies.\n        :param fs: sampling frequency.\n        \"\"\"\n        # Nyquist is half of the sampling freq\n        nyq = 0.5 * fs\n        if isinstance(pass_freq, float):\n            if pass_freq == 0:\n                pass_freq = 0.1\n                try:\n                    b, a = butter(\n                        order,\n                        [0.9 * pass_freq / nyq, pass_freq / nyq],\n                        btype=\"bandpass\",\n                        analog=False,\n                    )\n                except ValueError as e:\n                    print(fs, pass_freq, nyq, 0.9 * pass_freq / nyq,\n                          pass_freq / nyq)\n                    raise ValueError(\"Error in filtering\") from e\n        elif isinstance(pass_freq, tuple):\n            b, a = butter(order, [pass_freq[0], pass_freq[1]],\n                          btype=\"bandpass\",\n                          analog=False)\n        return lfilter(b, a, data, zi=None)\n\n    @staticmethod\n    def butter_lowpass_filter(data: np.ndarray,\n                              cutoff: float,\n                              fs: float,\n                              order: int = 5):\n        \"\"\"Low pass digital filter.\n        :param data: data to be filtered.\n        :param cutoff: cutoff frequency of the filter.\n        :param fs: sampling frequency.\n        :param order: order of the filter.\n        \"\"\"\n        nyq = 0.5 * fs\n        normal_cutoff = cutoff / nyq\n        b, a = butter(order, normal_cutoff, btype=\"low\", analog=False)\n        return lfilter(b, a, data, zi=None)\n\n    @staticmethod\n    def detrend_axis(arr, axis):\n        \"\"\"Detrend axis for better spectrum visibility.\n        :param arr: input array (spectrum)\n        :param axis: axis along which to detrend\n        \"\"\"\n        medians = np.median(arr, axis=axis)\n        return (arr.T - medians).T if axis else arr - medians\n</code></pre>"},{"location":"api/filters-reference/#cmtj.utils.filters.Filters.butter_bandpass_filter","title":"<code>butter_bandpass_filter(data, pass_freq, fs, order=5)</code>  <code>staticmethod</code>","text":"<p>Basic bandpass (notch) butterworth filter.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>np.ndarray</code> <p>input data.</p> required <code>pass_freq</code> <code>Tuple[float, float]</code> <p>the tuple of (low, high) band frequencies.</p> required <code>fs</code> <code>float</code> <p>sampling frequency.</p> required Source code in <code>cmtj/utils/filters.py</code> <pre><code>@staticmethod\ndef butter_bandpass_filter(data: np.ndarray,\n                           pass_freq: Tuple[float, float],\n                           fs: float,\n                           order: int = 5):\n    \"\"\"Basic bandpass (notch) butterworth filter.\n    :param data: input data.\n    :param pass_freq: the tuple of (low, high) band frequencies.\n    :param fs: sampling frequency.\n    \"\"\"\n    # Nyquist is half of the sampling freq\n    nyq = 0.5 * fs\n    if isinstance(pass_freq, float):\n        if pass_freq == 0:\n            pass_freq = 0.1\n            try:\n                b, a = butter(\n                    order,\n                    [0.9 * pass_freq / nyq, pass_freq / nyq],\n                    btype=\"bandpass\",\n                    analog=False,\n                )\n            except ValueError as e:\n                print(fs, pass_freq, nyq, 0.9 * pass_freq / nyq,\n                      pass_freq / nyq)\n                raise ValueError(\"Error in filtering\") from e\n    elif isinstance(pass_freq, tuple):\n        b, a = butter(order, [pass_freq[0], pass_freq[1]],\n                      btype=\"bandpass\",\n                      analog=False)\n    return lfilter(b, a, data, zi=None)\n</code></pre>"},{"location":"api/filters-reference/#cmtj.utils.filters.Filters.butter_lowpass_filter","title":"<code>butter_lowpass_filter(data, cutoff, fs, order=5)</code>  <code>staticmethod</code>","text":"<p>Low pass digital filter.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>np.ndarray</code> <p>data to be filtered.</p> required <code>cutoff</code> <code>float</code> <p>cutoff frequency of the filter.</p> required <code>fs</code> <code>float</code> <p>sampling frequency.</p> required <code>order</code> <code>int</code> <p>order of the filter.</p> <code>5</code> Source code in <code>cmtj/utils/filters.py</code> <pre><code>@staticmethod\ndef butter_lowpass_filter(data: np.ndarray,\n                          cutoff: float,\n                          fs: float,\n                          order: int = 5):\n    \"\"\"Low pass digital filter.\n    :param data: data to be filtered.\n    :param cutoff: cutoff frequency of the filter.\n    :param fs: sampling frequency.\n    :param order: order of the filter.\n    \"\"\"\n    nyq = 0.5 * fs\n    normal_cutoff = cutoff / nyq\n    b, a = butter(order, normal_cutoff, btype=\"low\", analog=False)\n    return lfilter(b, a, data, zi=None)\n</code></pre>"},{"location":"api/filters-reference/#cmtj.utils.filters.Filters.detrend_axis","title":"<code>detrend_axis(arr, axis)</code>  <code>staticmethod</code>","text":"<p>Detrend axis for better spectrum visibility.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <p>input array (spectrum)</p> required <code>axis</code> <p>axis along which to detrend</p> required Source code in <code>cmtj/utils/filters.py</code> <pre><code>@staticmethod\ndef detrend_axis(arr, axis):\n    \"\"\"Detrend axis for better spectrum visibility.\n    :param arr: input array (spectrum)\n    :param axis: axis along which to detrend\n    \"\"\"\n    medians = np.median(arr, axis=axis)\n    return (arr.T - medians).T if axis else arr - medians\n</code></pre>"},{"location":"api/general-reference/","title":"Miscellaneous Utilities","text":"<p>Contains definition of a base vector object used in the models such as Domain Wall Dynamics or Smit-Beljers model.</p>"},{"location":"api/general-reference/#cmtj.utils.general.VectorObj","title":"<code>VectorObj</code>  <code>dataclass</code>","text":"<p>Vector object for standard manipulation. Alternative to CVectors (which are used in the C++ code). Easier to modify and manipulate, but slower.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>positive z-axis angle (in xz plane) in radians.</p> required <code>phi</code> <code>float</code> <p>positive x-axis (in xy plane) angle in radians</p> required <code>mag</code> <code>float</code> <p>magnitude of the vector, if not set defaults to 1 unit vector</p> <code>1</code> Source code in <code>cmtj/utils/general.py</code> <pre><code>@dataclass\nclass VectorObj:\n    \"\"\"Vector object for standard manipulation.\n    Alternative to CVectors (which are used in the C++ code).\n    Easier to modify and manipulate, but slower.\n    :param theta: positive z-axis angle (in xz plane) in radians.\n    :param phi: positive x-axis (in xy plane) angle in radians\n    :param mag: magnitude of the vector, if not set defaults to 1 *unit vector*\n    \"\"\"\n    theta: float  # in radians\n    phi: float  # rad\n    mag: float = 1\n\n    def __add__(self, other):\n        \"\"\"Adds two vectors\"\"\"\n        return VectorObj.from_cvector(self.to_cvector() + other.to_cvector())\n\n    def __mul__(self, other: Union[\"VectorObj\", float]):\n        \"\"\"Multiplies a vector by a scalar\"\"\"\n        if isinstance(other, VectorObj):\n            return self._componentwise_mul(other)\n        return VectorObj.from_cvector(self.to_cvector() * other)\n\n    def __rmul__(self, other: Union[\"VectorObj\", float]):\n        \"\"\"Multiplies a vector by a scalar\"\"\"\n        return self.__mul__(other)\n\n    def __repr__(self) -&gt; str:\n        return f\"VectorObj(theta={self.theta}, phi={self.phi}, mag={self.mag})\"\n\n    def __hash__(self) -&gt; int:\n        return hash(str(self))\n\n    def __eq__(self, __value: \"VectorObj\") -&gt; bool:\n        return self.theta == __value.theta and self.phi == __value.phi and self.mag == __value.mag\n\n    def _componentwise_mul(self, other):\n        coors = self.get_cartesian()\n        other_coords = other.get_cartesian()\n        return VectorObj.from_cartesian(\n            coors[0] * other_coords[0],\n            coors[1] * other_coords[1],\n            coors[2] * other_coords[2],\n        )\n\n    def get_cartesian(self):\n        \"\"\"Returns the vector in Cartesian coordinates with (x, y, z) compnents\"\"\"\n        return VectorObj.from_spherical(self.theta, self.phi, self.mag)\n\n    @staticmethod\n    def from_spherical(theta, phi, mag=1):\n        \"\"\"Creates a Cartesian vector from spherical components\"\"\"\n        return [\n            mag * math.sin(theta) * math.cos(phi),\n            mag * math.sin(theta) * math.sin(phi), mag * math.cos(theta)\n        ]\n\n    @staticmethod\n    def from_cartesian(x: float, y: float, z: float):\n        \"\"\"Creates a spherical vector from Cartesian components\"\"\"\n        mag = math.sqrt(x**2 + y**2 + z**2)\n        theta = math.acos(z / mag)\n        phi = math.atan2(y, x)\n        return VectorObj(theta, phi, mag)\n\n    @staticmethod\n    def from_cvector(cvector: CVector):\n        \"\"\"Creates a spherical vector from Cartesian components\"\"\"\n        mag = cvector.length()\n        theta = math.acos(cvector.z / mag)\n        phi = math.atan2(cvector.y, cvector.x)\n        return VectorObj(theta, phi, mag)\n\n    def to_cvector(self):\n        \"\"\"Creates a Cartesian vector from spherical components\"\"\"\n        return CVector(*self.get_cartesian())\n</code></pre>"},{"location":"api/general-reference/#cmtj.utils.general.VectorObj.__add__","title":"<code>__add__(other)</code>","text":"<p>Adds two vectors</p> Source code in <code>cmtj/utils/general.py</code> <pre><code>def __add__(self, other):\n    \"\"\"Adds two vectors\"\"\"\n    return VectorObj.from_cvector(self.to_cvector() + other.to_cvector())\n</code></pre>"},{"location":"api/general-reference/#cmtj.utils.general.VectorObj.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiplies a vector by a scalar</p> Source code in <code>cmtj/utils/general.py</code> <pre><code>def __mul__(self, other: Union[\"VectorObj\", float]):\n    \"\"\"Multiplies a vector by a scalar\"\"\"\n    if isinstance(other, VectorObj):\n        return self._componentwise_mul(other)\n    return VectorObj.from_cvector(self.to_cvector() * other)\n</code></pre>"},{"location":"api/general-reference/#cmtj.utils.general.VectorObj.__rmul__","title":"<code>__rmul__(other)</code>","text":"<p>Multiplies a vector by a scalar</p> Source code in <code>cmtj/utils/general.py</code> <pre><code>def __rmul__(self, other: Union[\"VectorObj\", float]):\n    \"\"\"Multiplies a vector by a scalar\"\"\"\n    return self.__mul__(other)\n</code></pre>"},{"location":"api/general-reference/#cmtj.utils.general.VectorObj.from_cartesian","title":"<code>from_cartesian(x, y, z)</code>  <code>staticmethod</code>","text":"<p>Creates a spherical vector from Cartesian components</p> Source code in <code>cmtj/utils/general.py</code> <pre><code>@staticmethod\ndef from_cartesian(x: float, y: float, z: float):\n    \"\"\"Creates a spherical vector from Cartesian components\"\"\"\n    mag = math.sqrt(x**2 + y**2 + z**2)\n    theta = math.acos(z / mag)\n    phi = math.atan2(y, x)\n    return VectorObj(theta, phi, mag)\n</code></pre>"},{"location":"api/general-reference/#cmtj.utils.general.VectorObj.from_cvector","title":"<code>from_cvector(cvector)</code>  <code>staticmethod</code>","text":"<p>Creates a spherical vector from Cartesian components</p> Source code in <code>cmtj/utils/general.py</code> <pre><code>@staticmethod\ndef from_cvector(cvector: CVector):\n    \"\"\"Creates a spherical vector from Cartesian components\"\"\"\n    mag = cvector.length()\n    theta = math.acos(cvector.z / mag)\n    phi = math.atan2(cvector.y, cvector.x)\n    return VectorObj(theta, phi, mag)\n</code></pre>"},{"location":"api/general-reference/#cmtj.utils.general.VectorObj.from_spherical","title":"<code>from_spherical(theta, phi, mag=1)</code>  <code>staticmethod</code>","text":"<p>Creates a Cartesian vector from spherical components</p> Source code in <code>cmtj/utils/general.py</code> <pre><code>@staticmethod\ndef from_spherical(theta, phi, mag=1):\n    \"\"\"Creates a Cartesian vector from spherical components\"\"\"\n    return [\n        mag * math.sin(theta) * math.cos(phi),\n        mag * math.sin(theta) * math.sin(phi), mag * math.cos(theta)\n    ]\n</code></pre>"},{"location":"api/general-reference/#cmtj.utils.general.VectorObj.get_cartesian","title":"<code>get_cartesian()</code>","text":"<p>Returns the vector in Cartesian coordinates with (x, y, z) compnents</p> Source code in <code>cmtj/utils/general.py</code> <pre><code>def get_cartesian(self):\n    \"\"\"Returns the vector in Cartesian coordinates with (x, y, z) compnents\"\"\"\n    return VectorObj.from_spherical(self.theta, self.phi, self.mag)\n</code></pre>"},{"location":"api/general-reference/#cmtj.utils.general.VectorObj.to_cvector","title":"<code>to_cvector()</code>","text":"<p>Creates a Cartesian vector from spherical components</p> Source code in <code>cmtj/utils/general.py</code> <pre><code>def to_cvector(self):\n    \"\"\"Creates a Cartesian vector from spherical components\"\"\"\n    return CVector(*self.get_cartesian())\n</code></pre>"},{"location":"api/general-reference/#cmtj.utils.general.box_muller_random","title":"<code>box_muller_random(mean, std)</code>","text":"<p>Generates Gaussian noise with mean and standard deviation using the Box-Muller transform. https://en.wikipedia.org/wiki/Box\u2013Muller_transform</p> <p>Parameters:</p> Name Type Description Default <code>mean</code> <p>mean of the Gaussian.</p> required <code>std</code> <p>standard deviation of the Gaussian.</p> required Source code in <code>cmtj/utils/general.py</code> <pre><code>def box_muller_random(mean, std):\n    \"\"\"\n    Generates Gaussian noise with mean and standard deviation\n    using the Box-Muller transform.\n    https://en.wikipedia.org/wiki/Box\u2013Muller_transform\n    :param mean: mean of the Gaussian.\n    :param std: standard deviation of the Gaussian.\n    \"\"\"\n    u1 = np.random.uniform(0, 1)\n    u2 = np.random.uniform(0, 1)\n    mag = std * math.sqrt(-2.0 * math.log(u1))\n    z0 = mag * math.cos(2 * math.pi * u2) + mean\n    z1 = mag * math.sin(2 * math.pi * u2) + mean\n    return z0, z1\n</code></pre>"},{"location":"api/general-reference/#cmtj.utils.general.perturb_position","title":"<code>perturb_position(eq_point, pmax=0.001)</code>","text":"<p>Perturbs an equilibrium point by a random amount.</p> Source code in <code>cmtj/utils/general.py</code> <pre><code>def perturb_position(eq_point, pmax=1e-3):\n    \"\"\"\n    Perturbs an equilibrium point by a random amount.\n    \"\"\"\n    return np.asarray(eq_point) + np.random.normal(0, pmax, len(eq_point))\n</code></pre>"},{"location":"api/linear-reference/","title":"Linear","text":""},{"location":"api/linear-reference/#cmtj.utils.linear.FieldScan","title":"<code>FieldScan</code>","text":"Source code in <code>cmtj/utils/linear.py</code> <pre><code>class FieldScan:\n\n    @staticmethod\n    def _trig_compute(theta, phi) -&gt; Tuple:\n        \"\"\"Compute trigonometric functions for theta and phi.\n        :param theta: theta angle in [deg].\n        :param phi: phi angle in [deg].\n        :returns: trigonometric functions for theta and phi.\"\"\"\n        st = np.sin(np.deg2rad(theta))\n        ct = np.cos(np.deg2rad(theta))\n        sp = np.sin(np.deg2rad(phi))\n        cp = np.cos(np.deg2rad(phi))\n        return st, ct, sp, cp\n\n    @staticmethod\n    def angle2vector(theta, phi, amplitude=1) -&gt; CVector:\n        \"\"\"Convert spherical coordinates to cartesian coordinates.\n        :param theta: polar angle in degrees.\n        :param phi: azimuthal angle in degrees.\n        :param amplitude: amplitude of target vector.\n        :returns: cartesian vector.\"\"\"\n        st, ct, sp, cp = FieldScan._trig_compute(theta, phi)\n        return CVector(\n            st * cp * amplitude,\n            st * sp * amplitude,\n            ct * amplitude,\n        )\n\n    @staticmethod\n    def vector2angle(x, y, z) -&gt; Tuple:\n        \"\"\"Convert cartesian coordinates to spherical coordinates.\n        :param x: x coordinate of the vector.\n        :param y: y coordinate of the vector.\n        :param z: z coordinate of the vector.\n        :returns (theta, phi, r)\n        https://github.com/numpy/numpy/issues/5228\n        \"\"\"\n        r = np.sqrt(x**2 + y**2 + z**2)\n        theta = np.rad2deg(np.arctan2(np.sqrt(x**2 + y**2), z))\n        phi = np.rad2deg(np.arctan2(y, x))\n        return theta, phi, r\n\n    @staticmethod\n    def cvector2angle(vector: CVector) -&gt; Tuple:\n        \"\"\"\n        :param vector: cartesian vector.\n        :returns (theta, phi, r)\n        https://github.com/numpy/numpy/issues/5228\n        \"\"\"\n        return FieldScan.vector2angle(vector.x, vector.y, vector.z)\n\n    @staticmethod\n    def amplitude_scan(\n        start: float,\n        stop: float,\n        steps: int,\n        theta: float,\n        phi: float,\n        back: bool = False,\n    ) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Compute a linear magnitude sweep. Angles given in deg.\n        :param start: start of the sweep\n        :param stop: end of the sweep\n        :param steps: number of steps\n        :param theta: polar angle in deg.\n        :param phi: azimuthal angle in deg.\n        :returns: linear amplitude, field vectors\n        \"\"\"\n        Hspan = np.linspace(start, stop, endpoint=True, num=steps)\n        st, ct, sp, cp = FieldScan._trig_compute(theta, phi)\n        Hx = st * cp * Hspan\n        Hy = st * sp * Hspan\n        Hz = ct * Hspan\n        if back:\n            forward = np.vstack((Hx, Hy, Hz)).T\n            back = forward[::-1]\n            return np.concatenate((Hspan, Hspan[::-1]),\n                                  axis=0), np.concatenate((forward, back),\n                                                          axis=0)\n        return Hspan, np.vstack((Hx, Hy, Hz)).T\n\n    @staticmethod\n    def theta_scan(start: float, stop: float, steps: int, amplitude: float,\n                   phi: float) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Compute a linear theta angle sweep. Angles given in deg.\n        :param start: polar angle start of the sweep\n        :param stop: polar angle end of the sweep\n        :param steps: number of steps\n        :param amplitude: amplitude of the scanned field.\n        :param phi: azimuthal angle in deg.\n        \"\"\"\n        theta_span = np.linspace(start, stop, endpoint=True, num=steps)\n        st, ct, sp, cp = FieldScan._trig_compute(theta_span, phi)\n        Hx = st * cp * amplitude\n        Hy = st * sp * amplitude\n        Hz = ct * amplitude\n        return theta_span, np.vstack((Hx, Hy, Hz)).T\n\n    @staticmethod\n    def phi_scan(start: float, stop: float, steps: int, amplitude: float,\n                 theta: float) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Compute a linear phi angle sweep. Angles given in deg.\n        :param start: azimuthal angle start of the sweep\n        :param stop: azimuthal angle end of the sweep\n        :param steps: number of steps\n        :param amplitude: amplitude of the scanned field\n        :param theta: polar angle in deg.\n        \"\"\"\n        phi_span = np.linspace(start, stop, endpoint=True, num=steps)\n        st, ct, sp, cp = FieldScan._trig_compute(theta, phi_span)\n        Hx = st * cp * amplitude\n        Hy = st * sp * amplitude\n        Hz = ct * amplitude * np.ones_like(Hy)\n        return phi_span, np.vstack((Hx, Hy, Hz)).T\n</code></pre>"},{"location":"api/linear-reference/#cmtj.utils.linear.FieldScan.amplitude_scan","title":"<code>amplitude_scan(start, stop, steps, theta, phi, back=False)</code>  <code>staticmethod</code>","text":"<p>Compute a linear magnitude sweep. Angles given in deg.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>start of the sweep</p> required <code>stop</code> <code>float</code> <p>end of the sweep</p> required <code>steps</code> <code>int</code> <p>number of steps</p> required <code>theta</code> <code>float</code> <p>polar angle in deg.</p> required <code>phi</code> <code>float</code> <p>azimuthal angle in deg.</p> required <p>Returns:</p> Type Description <code>Tuple[np.ndarray, np.ndarray]</code> <p>linear amplitude, field vectors</p> Source code in <code>cmtj/utils/linear.py</code> <pre><code>@staticmethod\ndef amplitude_scan(\n    start: float,\n    stop: float,\n    steps: int,\n    theta: float,\n    phi: float,\n    back: bool = False,\n) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Compute a linear magnitude sweep. Angles given in deg.\n    :param start: start of the sweep\n    :param stop: end of the sweep\n    :param steps: number of steps\n    :param theta: polar angle in deg.\n    :param phi: azimuthal angle in deg.\n    :returns: linear amplitude, field vectors\n    \"\"\"\n    Hspan = np.linspace(start, stop, endpoint=True, num=steps)\n    st, ct, sp, cp = FieldScan._trig_compute(theta, phi)\n    Hx = st * cp * Hspan\n    Hy = st * sp * Hspan\n    Hz = ct * Hspan\n    if back:\n        forward = np.vstack((Hx, Hy, Hz)).T\n        back = forward[::-1]\n        return np.concatenate((Hspan, Hspan[::-1]),\n                              axis=0), np.concatenate((forward, back),\n                                                      axis=0)\n    return Hspan, np.vstack((Hx, Hy, Hz)).T\n</code></pre>"},{"location":"api/linear-reference/#cmtj.utils.linear.FieldScan.angle2vector","title":"<code>angle2vector(theta, phi, amplitude=1)</code>  <code>staticmethod</code>","text":"<p>Convert spherical coordinates to cartesian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <p>polar angle in degrees.</p> required <code>phi</code> <p>azimuthal angle in degrees.</p> required <code>amplitude</code> <p>amplitude of target vector.</p> <code>1</code> <p>Returns:</p> Type Description <code>CVector</code> <p>cartesian vector.</p> Source code in <code>cmtj/utils/linear.py</code> <pre><code>@staticmethod\ndef angle2vector(theta, phi, amplitude=1) -&gt; CVector:\n    \"\"\"Convert spherical coordinates to cartesian coordinates.\n    :param theta: polar angle in degrees.\n    :param phi: azimuthal angle in degrees.\n    :param amplitude: amplitude of target vector.\n    :returns: cartesian vector.\"\"\"\n    st, ct, sp, cp = FieldScan._trig_compute(theta, phi)\n    return CVector(\n        st * cp * amplitude,\n        st * sp * amplitude,\n        ct * amplitude,\n    )\n</code></pre>"},{"location":"api/linear-reference/#cmtj.utils.linear.FieldScan.cvector2angle","title":"<code>cvector2angle(vector)</code>  <code>staticmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>vector</code> <code>CVector</code> <p>cartesian vector.</p> required <p>Returns:</p> Type Description <code>Tuple</code> <p>//github.com/numpy/numpy/issues/5228</p> Source code in <code>cmtj/utils/linear.py</code> <pre><code>@staticmethod\ndef cvector2angle(vector: CVector) -&gt; Tuple:\n    \"\"\"\n    :param vector: cartesian vector.\n    :returns (theta, phi, r)\n    https://github.com/numpy/numpy/issues/5228\n    \"\"\"\n    return FieldScan.vector2angle(vector.x, vector.y, vector.z)\n</code></pre>"},{"location":"api/linear-reference/#cmtj.utils.linear.FieldScan.phi_scan","title":"<code>phi_scan(start, stop, steps, amplitude, theta)</code>  <code>staticmethod</code>","text":"<p>Compute a linear phi angle sweep. Angles given in deg.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>azimuthal angle start of the sweep</p> required <code>stop</code> <code>float</code> <p>azimuthal angle end of the sweep</p> required <code>steps</code> <code>int</code> <p>number of steps</p> required <code>amplitude</code> <code>float</code> <p>amplitude of the scanned field</p> required <code>theta</code> <code>float</code> <p>polar angle in deg.</p> required Source code in <code>cmtj/utils/linear.py</code> <pre><code>@staticmethod\ndef phi_scan(start: float, stop: float, steps: int, amplitude: float,\n             theta: float) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Compute a linear phi angle sweep. Angles given in deg.\n    :param start: azimuthal angle start of the sweep\n    :param stop: azimuthal angle end of the sweep\n    :param steps: number of steps\n    :param amplitude: amplitude of the scanned field\n    :param theta: polar angle in deg.\n    \"\"\"\n    phi_span = np.linspace(start, stop, endpoint=True, num=steps)\n    st, ct, sp, cp = FieldScan._trig_compute(theta, phi_span)\n    Hx = st * cp * amplitude\n    Hy = st * sp * amplitude\n    Hz = ct * amplitude * np.ones_like(Hy)\n    return phi_span, np.vstack((Hx, Hy, Hz)).T\n</code></pre>"},{"location":"api/linear-reference/#cmtj.utils.linear.FieldScan.theta_scan","title":"<code>theta_scan(start, stop, steps, amplitude, phi)</code>  <code>staticmethod</code>","text":"<p>Compute a linear theta angle sweep. Angles given in deg.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>polar angle start of the sweep</p> required <code>stop</code> <code>float</code> <p>polar angle end of the sweep</p> required <code>steps</code> <code>int</code> <p>number of steps</p> required <code>amplitude</code> <code>float</code> <p>amplitude of the scanned field.</p> required <code>phi</code> <code>float</code> <p>azimuthal angle in deg.</p> required Source code in <code>cmtj/utils/linear.py</code> <pre><code>@staticmethod\ndef theta_scan(start: float, stop: float, steps: int, amplitude: float,\n               phi: float) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Compute a linear theta angle sweep. Angles given in deg.\n    :param start: polar angle start of the sweep\n    :param stop: polar angle end of the sweep\n    :param steps: number of steps\n    :param amplitude: amplitude of the scanned field.\n    :param phi: azimuthal angle in deg.\n    \"\"\"\n    theta_span = np.linspace(start, stop, endpoint=True, num=steps)\n    st, ct, sp, cp = FieldScan._trig_compute(theta_span, phi)\n    Hx = st * cp * amplitude\n    Hy = st * sp * amplitude\n    Hz = ct * amplitude\n    return theta_span, np.vstack((Hx, Hy, Hz)).T\n</code></pre>"},{"location":"api/linear-reference/#cmtj.utils.linear.FieldScan.vector2angle","title":"<code>vector2angle(x, y, z)</code>  <code>staticmethod</code>","text":"<p>Convert cartesian coordinates to spherical coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>x coordinate of the vector.</p> required <code>y</code> <p>y coordinate of the vector.</p> required <code>z</code> <p>z coordinate of the vector.</p> required <p>Returns:</p> Type Description <code>Tuple</code> <p>//github.com/numpy/numpy/issues/5228</p> Source code in <code>cmtj/utils/linear.py</code> <pre><code>@staticmethod\ndef vector2angle(x, y, z) -&gt; Tuple:\n    \"\"\"Convert cartesian coordinates to spherical coordinates.\n    :param x: x coordinate of the vector.\n    :param y: y coordinate of the vector.\n    :param z: z coordinate of the vector.\n    :returns (theta, phi, r)\n    https://github.com/numpy/numpy/issues/5228\n    \"\"\"\n    r = np.sqrt(x**2 + y**2 + z**2)\n    theta = np.rad2deg(np.arctan2(np.sqrt(x**2 + y**2), z))\n    phi = np.rad2deg(np.arctan2(y, x))\n    return theta, phi, r\n</code></pre>"},{"location":"api/optimization-reference/","title":"Optimization","text":""},{"location":"api/optimization-reference/#cmtj.utils.optimization.coordinate_descent","title":"<code>coordinate_descent(operating_point, fn, best_mse=float('-inf'), granularity=10, percentage=0.05)</code>","text":"<p>Performs coordinate descent on the operating point.</p> <p>Parameters:</p> Name Type Description Default <code>operating_point</code> <code>Dict[str, float]</code> <p>operating point to be optimised. Order of that dict matters.</p> required <code>fn</code> <code>Callable</code> <p>function to be optimised</p> required <code>best_mse</code> <code>float</code> <p>best mse so far</p> <code>float('-inf')</code> <code>granularity</code> <code>int</code> <p>granularity of the search</p> <code>10</code> <code>percentage</code> <code>float</code> <p>percentage of the search</p> <code>0.05</code> <p>Returns:</p> Type Description <p>best operating point, best mse</p> Source code in <code>cmtj/utils/optimization.py</code> <pre><code>def coordinate_descent(operating_point: Dict[str, float],\n                       fn: Callable,\n                       best_mse: float = float(\"-inf\"),\n                       granularity: int = 10,\n                       percentage: float = 0.05):\n    \"\"\"Performs coordinate descent on the operating point.\n    :param operating_point: operating point to be optimised. Order of that dict matters.\n    :param fn: function to be optimised\n    :param best_mse: best mse so far\n    :param granularity: granularity of the search\n    :param percentage: percentage of the search\n    :returns: best operating point, best mse\n    \"\"\"\n    opt_params = operating_point\n    for k, org_v in tqdm(operating_point.items(), desc=\"Coordinate descent\"):\n        new_params = operating_point.copy()\n        for v in tqdm(np.linspace((1 - percentage) * org_v,\n                                  (1 + percentage) * org_v, granularity),\n                      desc=f\"Optimising {k}\",\n                      leave=False):\n            new_params[k] = v\n            mse = fn(**new_params)\n            if mse &gt; best_mse:\n                opt_params = new_params\n                best_mse = mse\n    return opt_params, best_mse\n</code></pre>"},{"location":"api/parallel-reference/","title":"Parallel","text":""},{"location":"api/parallel-reference/#cmtj.utils.parallel.distribute","title":"<code>distribute(simulation_fn, spaces, n_cores=None, shuffle=False)</code>","text":"<p>Distribute a function over a list of parameters in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>simulation_fn</code> <code>Callable</code> <p>function to be distributed</p> required <code>spaces</code> <code>List[List[float]]</code> <p>list of lists of parameters</p> required <code>n_cores</code> <code>int</code> <p>number of cores to use.</p> <code>None</code> <p>Returns:</p> Type Description <p>index, simulation_fn output</p> Source code in <code>cmtj/utils/parallel.py</code> <pre><code>def distribute(simulation_fn: Callable,\n               spaces: List[List[float]],\n               n_cores: int = None,\n               shuffle: bool = False):\n    \"\"\"\n    Distribute a function over a list of parameters in parallel.\n    :param simulation_fn: function to be distributed\n    :param spaces: list of lists of parameters\n    :param n_cores: number of cores to use.\n    :returns: index, simulation_fn output\n    \"\"\"\n    spaces = [np.asarray(space) for space in spaces]\n\n    def _get_index(values):\n        return [\n            np.argwhere(space == values[i]).ravel()[0]\n            for i, space in enumerate(spaces)\n        ]\n\n    iterables = list(product(*spaces))\n    indexes = [_get_index(val) for val in iterables]\n    # shuffle the indexes\n    if shuffle:\n        index_reshuffle = np.arange(len(indexes))\n        np.random.shuffle(index_reshuffle)\n        # reorder the indexes\n        iterables = np.asarray(iterables)[index_reshuffle].tolist()\n        indexes = np.asarray(indexes)[index_reshuffle].tolist()\n\n    def func_wrapper(iterable):\n        return iterable, simulation_fn(*iterable)\n\n    with Pool(processes=n_cores) as pool:\n        for result in tqdm(pool.imap_unordered(func_wrapper, iterables),\n                           total=len(iterables)):\n            iterable, output = result\n            indx = indexes[iterables.index(iterable)]\n            yield indx, output\n</code></pre>"},{"location":"api/plotting-reference/","title":"Plotting","text":""},{"location":"api/plotting-reference/#cmtj.utils.plotting.create_coordinates_plot","title":"<code>create_coordinates_plot(axes, ax_names, result_map, sample=0, alpha_black=0.01)</code>","text":"<p>Create parallel coordinates plot for multidimensional parameter space. Modified from: https://stackoverflow.com/questions/8230638/parallel-coordinates-plot-in-matplotlib</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <p>N list of parameters</p> required <code>ax_names</code> <p>N list of parameter names</p> required <code>result_map</code> <p>map of values (N-dim)</p> required <code>sample</code> <p>if != 0, subsample the parameter space</p> <code>0</code> <code>alpha_black</code> <p>alpha value zero value</p> <code>0.01</code> Source code in <code>cmtj/utils/plotting.py</code> <pre><code>def create_coordinates_plot(axes,\n                            ax_names,\n                            result_map,\n                            sample=0,\n                            alpha_black=0.01):\n    \"\"\"Create parallel coordinates plot for multidimensional parameter space.\n    Modified from:\n    https://stackoverflow.com/questions/8230638/parallel-coordinates-plot-in-matplotlib\n    :param axes: N list of parameters\n    :param ax_names: N list of parameter names\n    :param result_map: map of values (N-dim)\n    :param sample: if != 0, subsample the parameter space\n    :param alpha_black: alpha value zero value\n    \"\"\"\n    import matplotlib\n    import matplotlib.cm as cm\n    import matplotlib.patches as patches\n    from matplotlib.path import Path\n    with plt.style.context(['science', 'nature']):\n        fig, host = plt.subplots(dpi=400)\n        ax_lists, value_list = unpack_ndim_map(result_map, axes)\n\n        norm = matplotlib.colors.Normalize(vmin=min(value_list),\n                                           vmax=max(value_list),\n                                           clip=True)\n        mapper = cm.ScalarMappable(norm=norm, cmap=cm.magma)\n\n        # organize the data\n        ys = np.dstack([*ax_lists, value_list])[0]\n        indices = np.arange(len(ys))\n        if sample:\n            indices = np.random.choice(indices, sample).ravel()\n        ys = ys[indices]\n\n        ymins = ys.min(axis=0)\n        ymaxs = ys.max(axis=0)\n        dys = ymaxs - ymins\n        ymins -= dys * 0.05  # add 5% padding below and above\n        ymaxs += dys * 0.05\n        dys = ymaxs - ymins\n\n        # transform all data to be compatible with the main axis\n        zs = np.zeros_like(ys)\n        zs[:, 0] = ys[:, 0]\n        zs[:, 1:] = (ys[:, 1:] - ymins[1:]) / dys[1:] * dys[0] + ymins[0]\n\n        axes = [host] + [host.twinx() for _ in range(ys.shape[1] - 1)]\n        for i, ax in enumerate(axes):\n            ax.set_ylim(ymins[i], ymaxs[i])\n            ax.spines['top'].set_visible(False)\n            ax.spines['bottom'].set_visible(False)\n            if ax != host:\n                ax.spines['left'].set_visible(False)\n                ax.yaxis.set_ticks_position('right')\n                ax.spines[\"right\"].set_position(\n                    (\"axes\", i / (ys.shape[1] - 1)))\n\n        host.set_xlim(0, ys.shape[1] - 1)\n        host.set_xticks(range(ys.shape[1]))\n        host.set_xticklabels(ax_names, fontsize=8)\n        host.tick_params(axis='x', which='major', pad=7)\n        host.spines['right'].set_visible(False)\n        host.xaxis.tick_top()\n        host.set_title('Parallel Coordinates Plot')\n\n        for j in range(ys.shape[0]):\n            # create bezier curves\n            # for each axis, there will a control vertex at the point itself, one at 1/3rd towards the previous and one\n            #   at one third towards the next axis; the first and last axis have one less control vertex\n            # x-coordinate of the control vertices: at each integer (for the axes) and two inbetween\n            # y-coordinate: repeat every point three times, except the first and last only twice\n            verts = list(\n                zip(\n                    list(\n                        np.linspace(\n                            0, len(ys) - 1, len(ys) * 3 - 2, endpoint=True\n                        )\n                    ),\n                    np.repeat(zs[j, :], 3)[1:-1],\n                )\n            )\n            # for x,y in verts: host.plot(x, y, 'go') # to show the control points of the beziers\n            codes = [Path.MOVETO\n                     ] + [Path.CURVE4 for _ in range(len(verts) - 1)]\n            path = Path(verts, codes)\n            alpha = alpha_black if ys[j, -1] == 0 else 0.8\n            patch = patches.PathPatch(path,\n                                      facecolor='none',\n                                      lw=.5,\n                                      edgecolor=mapper.to_rgba(\n                                          ys[j, -1], alpha))\n            host.add_patch(patch)\n        fig.tight_layout()\n</code></pre>"},{"location":"api/plotting-reference/#cmtj.utils.plotting.create_stack","title":"<code>create_stack(ax, colors, heights, angles, labels, width=2, labelpad_left=0.2, offset_x=0, offset_y=0, lw_arrow=1.5, ms=10, r=0.6, text_fontsize=4, reversed=True)</code>","text":"<p>Create a material stack plot. If a given layer is to have no arrow, pass None.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <p>matplotlib axis</p> required <code>colors</code> <p>list of colors</p> required <code>heights</code> <p>list of heights</p> required <code>angles</code> <p>list of angles</p> required <code>labels</code> <p>list of labels</p> required <code>width</code> <p>width of the bars</p> <code>2</code> <code>labelpad_left</code> <p>padding of the labels</p> <code>0.2</code> <code>offset_x</code> <p>offset of the patches in x direction</p> <code>0</code> <code>offset_y</code> <p>offset of the patches in y direction</p> <code>0</code> <code>lw_arrow</code> <p>linewidth of the arrows</p> <code>1.5</code> <code>ms</code> <p>mutation size of the arrows</p> <code>10</code> <code>r</code> <p>length of the arrows</p> <code>0.6</code> <code>reversed</code> <p>if True, the stack is reversed</p> <code>True</code> Source code in <code>cmtj/utils/plotting.py</code> <pre><code>def create_stack(ax,\n                 colors,\n                 heights,\n                 angles,\n                 labels,\n                 width=2,\n                 labelpad_left=.2,\n                 offset_x=0,\n                 offset_y=0,\n                 lw_arrow=1.5,\n                 ms=10,\n                 r=0.6,\n                 text_fontsize=4,\n                 reversed=True):\n    \"\"\"\n    Create a material stack plot.\n    If a given layer is to have no arrow, pass None.\n    :param ax: matplotlib axis\n    :param colors: list of colors\n    :param heights: list of heights\n    :param angles: list of angles\n    :param labels: list of labels\n    :param width: width of the bars\n    :param labelpad_left: padding of the labels\n    :param offset_x: offset of the patches in x direction\n    :param offset_y: offset of the patches in y direction\n    :param lw_arrow: linewidth of the arrows\n    :param ms: mutation size of the arrows\n    :param r: length of the arrows\n    :param reversed: if True, the stack is reversed\n    \"\"\"\n    [x, y] = [r, 0]\n    first_offset = offset_y\n    if reversed:\n        heights = heights[::-1]\n        colors = colors[::-1]\n        angles = angles[::-1]\n        labels = labels[::-1]\n    for i, (height, angle, color,\n            label) in enumerate(zip(heights, angles, colors, labels)):\n        ax.add_patch(\n            patches.Rectangle((offset_x, offset_y),\n                              width,\n                              height,\n                              fill=True,\n                              color=color,\n                              zorder=10))\n        ax.text(offset_x - labelpad_left,\n                offset_y + height / 2,\n                label,\n                horizontalalignment='center',\n                verticalalignment='center',\n                fontsize=text_fontsize,\n                zorder=11)\n        if angle is not None:\n            [dx, dy] = np.dot(rotation_matrix(np.deg2rad(angle)), [x, y])\n            x_mid = dx / 2\n            y_mid = dy / 2\n            centre_x = (offset_x + width) / 2 - x_mid\n            centre_y = offset_y + height / 2 - y_mid\n            ax.add_patch(\n                patches.FancyArrowPatch((centre_x, centre_y),\n                                        (centre_x + dx, centre_y + dy),\n                                        mutation_scale=ms,\n                                        lw=lw_arrow,\n                                        color='black',\n                                        zorder=10))\n        offset_y += height\n    ax.set_ylim([first_offset - max(heights) / 2, offset_y + max(heights) / 2])\n    ax.set_xlim([offset_x - width / 2, offset_x + width + width / 2])\n    ax.axis(\"off\")\n    return ax\n</code></pre>"},{"location":"api/plotting-reference/#cmtj.utils.plotting.plot_coloured_trajectory","title":"<code>plot_coloured_trajectory(x, y, z, colormap='plasma', ax=None)</code>","text":"<p>Plot a coloured trajectory in 3D. Normalises to unit sphere. Colour of the trajectory now designates the flow of time.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <p>matplotlib axis</p> <code>None</code> <code>x</code> <p>x-coordinates</p> required <code>y</code> <p>y-coordinates</p> required <code>z</code> <p>z-coordinates</p> required <code>colormap</code> <p>colormap to use</p> <code>'plasma'</code> Source code in <code>cmtj/utils/plotting.py</code> <pre><code>def plot_coloured_trajectory(x, y, z, colormap='plasma', ax=None):\n    \"\"\"Plot a coloured trajectory in 3D. Normalises to unit sphere.\n    Colour of the trajectory now designates the flow of time.\n    :param ax: matplotlib axis\n    :param x: x-coordinates\n    :param y: y-coordinates\n    :param z: z-coordinates\n    :param colormap: colormap to use\n    \"\"\"\n    xs, ys, zs = get_sphere()\n    m = np.asarray([x, y, z])\n    points = m.T.reshape(-1, 1, 3)\n    segs = np.concatenate([points[:-1], points[1:]], axis=1)\n    colors = sns.color_palette(colormap, len(segs))\n    if ax is None:\n        with plt.style.context(['science', 'nature']):\n            fig = plt.figure(dpi=300)\n            ax = fig.add_subplot(1, 1, 1, projection='3d')\n            # plot the sphere firext\n            ax.set_axis_off()\n            ax.plot_surface(xs,\n                            ys,\n                            zs,\n                            rstride=2,\n                            cstride=2,\n                            color='azure',\n                            alpha=0.1,\n                            linewidth=0.1)\n            ax.add_collection(Line3DCollection(segs, colors=colors, alpha=1))\n    else:\n        ax.set_axis_off()\n        ax.plot_surface(xs,\n                        ys,\n                        zs,\n                        rstride=2,\n                        cstride=2,\n                        color='azure',\n                        alpha=0.1,\n                        linewidth=0.1)\n        ax.add_collection(Line3DCollection(segs, colors=colors, alpha=1))\n</code></pre>"},{"location":"api/plotting-reference/#cmtj.utils.plotting.plot_trajectory_sphere","title":"<code>plot_trajectory_sphere(x, y, z, color='blue', alpha=1, ax=None)</code>","text":"<p>Plot a trajectory in 3D. Normalises to unit sphere</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <p>matplotlib axis</p> <code>None</code> <code>x</code> <p>x-coordinates</p> required <code>y</code> <p>y-coordinates</p> required <code>z</code> <p>z-coordinates</p> required <code>color</code> <p>color of the trajectory</p> <code>'blue'</code> <code>alpha</code> <p>alpha value of the trajectory</p> <code>1</code> Source code in <code>cmtj/utils/plotting.py</code> <pre><code>def plot_trajectory_sphere(x, y, z, color='blue', alpha=1, ax=None):\n    \"\"\"Plot a trajectory in 3D. Normalises to unit sphere\n    :param ax: matplotlib axis\n    :param x: x-coordinates\n    :param y: y-coordinates\n    :param z: z-coordinates\n    :param color: color of the trajectory\n    :param alpha: alpha value of the trajectory\n    \"\"\"\n    # Compute a unit sphere first\n    xs, ys, zs = get_sphere()\n    m = np.asarray([x, y, z])\n    # make sure we are unit norm for m\n    m = m / np.linalg.norm(m)\n    if ax is None:\n        with plt.style.context(['science', 'nature']):\n            fig = plt.figure(dpi=300)\n            ax = fig.add_subplot(1, 1, 1, projection='3d')\n            ax.plot3D(m[0], m[1], m[2], color=color, alpha=alpha)\n            ax.set_axis_off()\n            ax.plot_surface(xs,\n                            ys,\n                            zs,\n                            rstride=2,\n                            cstride=2,\n                            color='azure',\n                            alpha=0.1,\n                            linewidth=0.1)\n            ax.scatter([0], [0], [1], color='crimson', alpha=1.0)\n    else:\n        ax.plot3D(m[0], m[1], m[2], color=color, alpha=alpha)\n        ax.set_axis_off()\n        ax.plot_surface(xs,\n                        ys,\n                        zs,\n                        rstride=2,\n                        cstride=2,\n                        color='azure',\n                        alpha=0.1,\n                        linewidth=0.1)\n        ax.scatter([0], [0], [1], color='crimson', alpha=1.0)\n</code></pre>"},{"location":"api/plotting-reference/#cmtj.utils.plotting.unpack_ndim_map","title":"<code>unpack_ndim_map(map, axes)</code>","text":"<p>Unpack N-dimensional map into a list of 1-dimensional arrays</p> <p>Parameters:</p> Name Type Description Default <code>map</code> <p>N-dimensional map, each axis is separate parameter space.</p> required <code>axes</code> <p>list of axes to unpack.</p> required Source code in <code>cmtj/utils/plotting.py</code> <pre><code>def unpack_ndim_map(map, axes):\n    \"\"\"\n    Unpack N-dimensional map into a list of 1-dimensional arrays\n    :param map: N-dimensional map, each axis is separate parameter space.\n    :param axes: list of axes to unpack.\n    \"\"\"\n    # how long each one is\n    sample_length = len(axes[0])\n    perm_indx = permutations(range(sample_length), len(axes))\n\n    ax_lists = [[] for _ in axes]\n    value_list = []\n    for indx in perm_indx:\n        value_list.append(map[indx])\n        for i, ax in enumerate(axes):\n            ax_lists[i].append(ax[indx[i]])\n\n    return ax_lists, value_list\n</code></pre>"},{"location":"api/procedures-reference/","title":"Procedures","text":""},{"location":"api/procedures-reference/#cmtj.utils.procedures.ResistanceParameters","title":"<code>ResistanceParameters</code>  <code>dataclass</code>","text":"<p>A data holder for resistance parameters. Not all have to be filled in.</p> Source code in <code>cmtj/utils/procedures.py</code> <pre><code>@dataclass\nclass ResistanceParameters:\n    \"\"\"A data holder for resistance parameters. Not all have to be filled in.\"\"\"\n\n    Rxx0: float = 0\n    Rxy0: float = 0\n    Rahe: float = 0\n    Rsmr: float = 0\n    Ramr: float = 0\n    w: float = 0  # width\n    l: float = 0  # length\n</code></pre>"},{"location":"api/procedures-reference/#cmtj.utils.procedures.PIMM_procedure","title":"<code>PIMM_procedure(junction, Hvecs, int_step, resistance_params, Hoe_direction=Axis.zaxis, Hoe_excitation=50, Hoe_duration=3, simulation_duration=5e-09, wait_time=0.0, max_frequency=80000000000.0, resistance_fn=calculate_resistance_series, disturbance=0.001, take_last_n=100, full_output=False, disable_tqdm=False, static_only=False)</code>","text":"<p>Procedure for computing Pulse Induced Microwave Magnetometry. It computes both PIMM and Resistance (for instance AHE loops). Set <code>static_only</code> to True to only compute the static resistance.</p> <p>Parameters:</p> Name Type Description Default <code>junction</code> <code>Junction</code> <p>junction to be simulated.</p> required <code>Hvecs</code> <code>np.ndarray</code> <p>list of cartesian vectors. (use FieldScan.amplitude_scan or alike)</p> required <code>int_step</code> <code>float</code> <p>integration step [s].</p> required <code>resistance_params</code> <code>List[ResistanceParameters]</code> <p>list of resistance parameters.</p> required <code>Hoe_direction</code> <code>Axis</code> <p>direction of oersted field (x, y or z).</p> <code>Axis.zaxis</code> <code>simulation_duration</code> <code>float</code> <p>duration of simulation [s].</p> <code>5e-09</code> <code>wait_time</code> <code>float</code> <p>time to wait before taking vector for the fft [s].</p> <code>0.0</code> <code>Hoe_duration</code> <code>int</code> <p>duration of Hoe excitation in multiples of in step</p> <code>3</code> <code>max_frequency</code> <code>float</code> <p>maximum frequency -- larger will be dropped [Hz].</p> <code>80000000000.0</code> <code>resistance_fn</code> <code>Callable</code> <p>function to be used to compute the resistance (either calculate_resistance_series or calculate_resistance_parallel).</p> <code>calculate_resistance_series</code> <code>disturbance</code> <code>float</code> <p>disturbance to be applied to the magnetization (std of normal distribution).</p> <code>0.001</code> <code>take_last_n</code> <code>int</code> <p>number of last time steps to be taken for the compuation.</p> <code>100</code> <code>full_output</code> <code>bool</code> <p>if True, return the full trajectories and per layer spectra.</p> <code>False</code> <code>disable_tqdm</code> <code>bool</code> <p>if True, disable tqdm progress bar.</p> <code>False</code> <code>static_only</code> <code>bool</code> <p>if True, only compute the static resistance.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[np.ndarray, np.ndarray, Dict[str, Any]]</code> <p>(spectrum, frequencies, other_data) other_data is a dictionary with the following keys: - 'H': Hext field [A/m] - 'Rx': resistance in x direction [Ohm] - 'Ry': resistance in y direction [Ohm] - 'm_avg': average magnetization [unit] - 'm_traj': magnetization trajectories [unit]</p> Source code in <code>cmtj/utils/procedures.py</code> <pre><code>def PIMM_procedure(\n    junction: \"Junction\",\n    Hvecs: np.ndarray,\n    int_step: float,\n    resistance_params: List[ResistanceParameters],\n    Hoe_direction: Axis = Axis.zaxis,\n    Hoe_excitation: float = 50,\n    Hoe_duration: int = 3,\n    simulation_duration: float = 5e-9,\n    wait_time: float = 0e-9,\n    max_frequency: float = 80e9,\n    resistance_fn: Callable = calculate_resistance_series,\n    disturbance: float = 1e-3,\n    take_last_n: int = 100,\n    full_output: bool = False,\n    disable_tqdm: bool = False,\n    static_only: bool = False,\n) -&gt; Tuple[np.ndarray, np.ndarray, Dict[str, Any]]:\n    \"\"\"Procedure for computing Pulse Induced Microwave Magnetometry.\n    It computes both PIMM and Resistance (for instance AHE loops).\n    Set `static_only` to True to only compute the static resistance.\n    :param junction: junction to be simulated.\n    :param Hvecs: list of cartesian vectors. (use FieldScan.amplitude_scan or alike)\n    :param int_step: integration step [s].\n    :param resistance_params: list of resistance parameters.\n    :param Hoe_direction: direction of oersted field (x, y or z).\n    :param simulation_duration: duration of simulation [s].\n    :param wait_time: time to wait before taking vector for the fft [s].\n    :param Hoe_duration: duration of Hoe excitation in multiples of in step\n    :param max_frequency: maximum frequency -- larger will be dropped [Hz].\n    :param resistance_fn: function to be used to compute the resistance\n        (either calculate_resistance_series or calculate_resistance_parallel).\n    :param disturbance: disturbance to be applied to the magnetization (std of normal distribution).\n    :param take_last_n: number of last time steps to be taken for the compuation.\n    :param full_output: if True, return the full trajectories and per layer spectra.\n    :param disable_tqdm: if True, disable tqdm progress bar.\n    :param static_only: if True, only compute the static resistance.\n    :return: (spectrum, frequencies, other_data)\n    other_data is a dictionary with the following keys:\n    - 'H': Hext field [A/m]\n    - 'Rx': resistance in x direction [Ohm]\n    - 'Ry': resistance in y direction [Ohm]\n    - 'm_avg': average magnetization [unit]\n    - 'm_traj': magnetization trajectories [unit]\n    \"\"\"\n    if wait_time &gt; simulation_duration:\n        raise ValueError(\"wait_time must be smaller than simulation_duration!\")\n    spectrum = []\n    extraction_m_component = None\n    if Hoe_direction == Axis.zaxis:\n        extraction_m_component = \"z\"\n        oedriver = AxialDriver(\n            NullDriver(),\n            NullDriver(),\n            ScalarDriver.getStepDriver(0, Hoe_excitation, 0,\n                                       int_step * Hoe_duration),\n        )\n    elif Hoe_direction == Axis.yaxis:\n        extraction_m_component = \"y\"\n        oedriver = AxialDriver(\n            NullDriver(),\n            ScalarDriver.getStepDriver(0, Hoe_excitation, 0,\n                                       int_step * Hoe_duration),\n            NullDriver(),\n        )\n    else:\n        extraction_m_component = \"x\"\n        oedriver = AxialDriver(\n            ScalarDriver.getStepDriver(0, Hoe_excitation, 0,\n                                       int_step * Hoe_duration),\n            NullDriver(),\n            NullDriver(),\n        )\n\n    # get layer strings\n    layer_ids = junction.getLayerIds()\n    if len(layer_ids) != len(resistance_params):\n        raise ValueError(\n            \"The number of layers in the junction must match the number of resistance parameters!\"\n        )\n    output = defaultdict(list)\n    normalising_factor = np.sum(\n        [layer.thickness * layer.Ms for layer in junction.layers])\n    freqs = None  # in case of static_only\n    for H in tqdm(Hvecs, desc=\"Computing PIMM\", disable=disable_tqdm):\n        junction.clearLog()\n        junction.setLayerExternalFieldDriver(\n            \"all\",\n            AxialDriver(\n                ScalarDriver.getConstantDriver(H[0]),\n                ScalarDriver.getConstantDriver(H[1]),\n                ScalarDriver.getConstantDriver(H[2]),\n            ),\n        )\n        junction.setLayerOerstedFieldDriver(\"all\", oedriver)\n        if disturbance:\n            for layer_id in layer_ids:\n                old_mag = junction.getLayerMagnetisation(layer_id)\n                new_mag = CVector(\n                    old_mag.x + np.random.normal(0, disturbance),\n                    old_mag.y + np.random.normal(0, disturbance),\n                    old_mag.z + np.random.normal(0, disturbance),\n                )\n                new_mag.normalize()\n                junction.setLayerMagnetisation(layer_id, new_mag)\n        junction.runSimulation(simulation_duration, int_step, int_step)\n        log = junction.getLog()\n        indx = np.argwhere(np.asarray(log[\"time\"]) &gt;= wait_time).ravel()\n        m_traj = np.asarray([\n            np.asarray([\n                log[f\"{layer.id}_mx\"],\n                log[f\"{layer.id}_my\"],\n                log[f\"{layer.id}_mz\"],\n            ]) * layer.thickness * layer.Ms / normalising_factor\n            for layer in junction.layers\n        ])\n        m = m_traj[:, :,\n                   -take_last_n:]  # all layers, all x, y, z, last 100 steps\n        Rx, Ry = resistance_fn(\n            [r.Rxx0 for r in resistance_params],\n            [r.Rxy0 for r in resistance_params],\n            [r.Ramr for r in resistance_params],\n            [r.Rahe for r in resistance_params],\n            [r.Rsmr for r in resistance_params],\n            m,\n            l=[r.l for r in resistance_params],\n            w=[r.w for r in resistance_params],\n        )\n        if not static_only:\n            mixed = np.asarray([\n                np.asarray(log[f\"{layer.id}_m{extraction_m_component}\"])[indx]\n                * layer.thickness * layer.Ms / normalising_factor\n                for layer in junction.layers\n            ])\n            mixed_sum = mixed.sum(axis=0)\n            yf, freqs = compute_spectrum_strip(mixed_sum, int_step,\n                                               max_frequency)\n\n            spectrum.append(yf)\n\n        # fill the output dict\n        output[\"H\"].append(H)\n        output[\"Rx\"].append(Rx)\n        output[\"Ry\"].append(Ry)\n        output[\"m_avg\"].append(m_traj[:, :, -1].sum(0))\n        if full_output and not static_only:\n            output[\"m_traj\"].append(m_traj)\n            for li, layer_id in enumerate(layer_ids):\n                y, _ = compute_spectrum_strip(mixed[li], int_step,\n                                              max_frequency)\n                output[layer_id].append(y)\n    spectrum = np.squeeze(np.asarray(spectrum))\n    if full_output:\n        for layer_id in layer_ids:\n            output[layer_id] = np.asarray(output[layer_id]).squeeze()\n    return spectrum, freqs, output\n</code></pre>"},{"location":"api/procedures-reference/#cmtj.utils.procedures.VSD_procedure","title":"<code>VSD_procedure(junction, Hvecs, frequencies, int_step, resistance_params=[], Hoe_direction=Axis.yaxis, Hoe_excitation=50, simulation_duration=3e-08, disturbance=0.001, Rtype='Rz', resistance_fn=calculate_resistance_series, disable_tqdm=False)</code>","text":"<p>Procedure for computing Voltage-Spin Diode. We use the Oersted field sine exctitation to excite the system.</p> <p>Parameters:</p> Name Type Description Default <code>junction</code> <code>Junction</code> <p>junction to be simulated.</p> required <code>Hvecs</code> <code>np.ndarray</code> <p>list of cartesian vectors. (use FieldScan.amplitude_scan or alike)</p> required <code>frequencies</code> <code>np.ndarray</code> <p>list of frequencies [Hz].</p> required <code>int_step</code> <code>float</code> <p>integration step [s].</p> required <code>resistance_params</code> <code>List[ResistanceParameters]</code> <p>list of resistance parameters.</p> <code>[]</code> <code>Hoe_direction</code> <code>Axis</code> <p>direction of oersted field (x, y or z).</p> <code>Axis.yaxis</code> <code>Hoe_excitation</code> <code>float</code> <p>excitation amplitude of Hoe [A/m].</p> <code>50</code> <code>simulation_duration</code> <code>float</code> <p>duration of simulation [s].</p> <code>3e-08</code> <code>disturbance</code> <code>float</code> <p>disturbance to be applied to the magnetization (std of normal distribution).</p> <code>0.001</code> <code>resistance_fn</code> <code>Callable</code> <p>function to be used to compute the resistance (either calculate_resistance_series or calculate_resistance_parallel). Rz forces standard magnetores.</p> <code>calculate_resistance_series</code> <code>Rtype</code> <code>str</code> <p>type of resistance to be used. (Rx Ry or Rz)</p> <code>'Rz'</code> <code>disable_tqdm</code> <code>bool</code> <p>if True, disable tqdm progress bar.</p> <code>False</code> Source code in <code>cmtj/utils/procedures.py</code> <pre><code>def VSD_procedure(\n    junction: Junction,\n    Hvecs: np.ndarray,\n    frequencies: np.ndarray,\n    int_step: float,\n    resistance_params: List[ResistanceParameters] = [],\n    Hoe_direction: Axis = Axis.yaxis,\n    Hoe_excitation: float = 50,\n    simulation_duration: float = 30e-9,\n    disturbance: float = 1e-3,\n    Rtype: str = \"Rz\",\n    resistance_fn: Callable = calculate_resistance_series,\n    disable_tqdm: bool = False,\n):\n    \"\"\"Procedure for computing Voltage-Spin Diode.\n    We use the Oersted field sine exctitation to excite the system.\n    :param junction: junction to be simulated.\n    :param Hvecs: list of cartesian vectors. (use FieldScan.amplitude_scan or alike)\n    :param frequencies: list of frequencies [Hz].\n    :param int_step: integration step [s].\n    :param resistance_params: list of resistance parameters.\n    :param Hoe_direction: direction of oersted field (x, y or z).\n    :param Hoe_excitation: excitation amplitude of Hoe [A/m].\n    :param simulation_duration: duration of simulation [s].\n    :param disturbance: disturbance to be applied to the magnetization (std of normal distribution).\n    :param resistance_fn: function to be used to compute the resistance\n        (either calculate_resistance_series or calculate_resistance_parallel). Rz forces standard magnetores.\n    :param Rtype: type of resistance to be used. (Rx Ry or Rz)\n    :param disable_tqdm: if True, disable tqdm progress bar.\n    \"\"\"\n    layer_ids = junction.getLayerIds()\n    if Rtype == \"Rz\" and len(layer_ids) &gt; 2:\n        raise ValueError(\n            \"Rz can only be used for 2 layer junctions. Use Rx or Ry instead.\")\n    elif len(resistance_params) != len(layer_ids):\n        raise ValueError(\n            \"The number of layers in the junction must match the number of resistance parameters!\"\n        )\n\n    def simulate_VSD(H: np.ndarray, frequency: float,\n                     resistance_params: ResistanceParameters):\n        if Hoe_direction == Axis.zaxis:\n            oedriver = AxialDriver(\n                NullDriver(),\n                NullDriver(),\n                ScalarDriver.getSineDriver(0, Hoe_excitation, frequency, 0),\n            )\n        elif Hoe_direction == Axis.yaxis:\n            oedriver = AxialDriver(\n                NullDriver(),\n                ScalarDriver.getSineDriver(0, Hoe_excitation, frequency, 0),\n                NullDriver(),\n            )\n        else:\n            oedriver = AxialDriver(\n                ScalarDriver.getSineDriver(0, Hoe_excitation, frequency, 0),\n                NullDriver(),\n                NullDriver(),\n            )\n\n        junction.clearLog()\n        junction.setLayerExternalFieldDriver(\n            \"all\",\n            AxialDriver(\n                ScalarDriver.getConstantDriver(H[0]),\n                ScalarDriver.getConstantDriver(H[1]),\n                ScalarDriver.getConstantDriver(H[2]),\n            ),\n        )\n        junction.setLayerOerstedFieldDriver(\"all\", oedriver)\n        if disturbance:\n            for layer_id in layer_ids:\n                old_mag = junction.getLayerMagnetisation(layer_id)\n                new_mag = CVector(\n                    old_mag.x + np.random.normal(0, disturbance),\n                    old_mag.y + np.random.normal(0, disturbance),\n                    old_mag.z + np.random.normal(0, disturbance),\n                )\n                new_mag.normalize()\n                junction.setLayerMagnetisation(layer_id, new_mag)\n        junction.runSimulation(simulation_duration, int_step, int_step)\n        log = junction.getLog()\n        m_traj = np.asarray([[\n            log[f\"{layer_ids[i]}_mx\"],\n            log[f\"{layer_ids[i]}_my\"],\n            log[f\"{layer_ids[i]}_mz\"],\n        ] for i in range(len(layer_ids))])\n        if Rtype == \"Rz\":\n            if len(layer_ids) &gt; 2:\n                raise ValueError(\n                    \"Rz can only be used for 2 layer junctions. One layer can be fictisious.\"\n                )\n            elif len(layer_ids) == 2:\n                R = log[f\"R_{layer_ids[0]}_{layer_ids[1]}\"]\n            elif len(layer_ids) == 1:\n                R = log[\"Resistance\"]\n            else:\n                raise ValueError(\n                    \"Resistance definition ambiguous!\"\n                    \"If you want to use Rz, you must provide\"\n                    \"a single resistance parameter set or set Rp Rap\"\n                    \" at junction creation.\")\n        else:\n            Rx, Ry = resistance_fn(\n                [r.Rxx0 for r in resistance_params],\n                [r.Rxy0 for r in resistance_params],\n                [r.Ramr for r in resistance_params],\n                [r.Rahe for r in resistance_params],\n                [r.Rsmr for r in resistance_params],\n                m_traj,\n                l=[r.l for r in resistance_params],\n                w=[r.w for r in resistance_params],\n            )\n            if Rtype == \"Rx\":\n                R = Rx\n            elif Rtype == \"Ry\":\n                R = Ry\n            else:\n                raise ValueError(\"Rtype must be either Rx or Ry or Rz\")\n        dynamicI = np.sin(2 * math.pi * frequency * np.asarray(log[\"time\"]))\n        vmix = compute_sd(R, dynamicI, int_step)\n        return vmix\n\n    spectrum = np.zeros((len(Hvecs), len(frequencies)))\n    for hindx, H in enumerate(\n            tqdm(Hvecs, \"Computing VSD\", disable=disable_tqdm)):\n        for findx, f in enumerate(frequencies):\n            spectrum[hindx, findx] = simulate_VSD(H, f, resistance_params)\n    return spectrum\n</code></pre>"},{"location":"api/procedures-reference/#cmtj.utils.procedures.compute_spectrum_strip","title":"<code>compute_spectrum_strip(input_m, int_step, max_frequency)</code>","text":"<p>Compute the spectrum of a given magnetization trajectory.</p> Source code in <code>cmtj/utils/procedures.py</code> <pre><code>def compute_spectrum_strip(input_m: np.ndarray, int_step: float,\n                           max_frequency: float):\n    \"\"\"Compute the spectrum of a given magnetization trajectory.\"\"\"\n    yf = np.abs(fft(input_m))\n    freqs = fftfreq(len(yf), int_step)\n    freqs = freqs[:len(freqs) // 2]\n    yf = yf[:len(yf) // 2]\n\n    findx = np.argwhere(freqs &lt;= max_frequency)\n    freqs = freqs[findx]\n    yf = yf[findx]\n\n    return yf, freqs\n</code></pre>"},{"location":"api/resistance-reference/","title":"Resistance functions","text":"<p>Those functions are used to compute the resistance of a given system. They are all defined in the <code>resistance</code> module for version upside of 1.2.0.</p>"},{"location":"api/resistance-reference/#cmtj.utils.resistance.calculate_magnetoresistance","title":"<code>calculate_magnetoresistance(Rp, Rap, m)</code>","text":"<p>Computes the magnetoresistance using parallel and antiparallel resistance.</p> <p>Parameters:</p> Name Type Description Default <code>Rp</code> <code>float</code> <p>parallel resistance</p> required <code>Rap</code> <code>float</code> <p>antiparallel resistance</p> required <code>m</code> <code>np.ndarray</code> <p>magnetisation, 2 layers of shape [2, 3, T] where T is the time component</p> required Source code in <code>cmtj/utils/resistance.py</code> <pre><code>def calculate_magnetoresistance(Rp: float, Rap: float, m: np.ndarray):\n    \"\"\"Computes the magnetoresistance using parallel and antiparallel resistance.\n    :param Rp: parallel resistance\n    :param Rap: antiparallel resistance\n    :param m: magnetisation, 2 layers of shape [2, 3, T] where T is the time component\"\"\"\n    if not isinstance(m, np.ndarray):\n        m = np.asarray(m)\n    if m.shape[0] != 2:\n        raise ValueError(\n            \"The magnetoresistance can only be computed for 2 layers\"\n            f\". Current shape {m.shape}\")\n    return Rp + 0.5 * (Rap - Rp) * np.sum(m[0] * m[1], axis=0)\n</code></pre>"},{"location":"api/resistance-reference/#cmtj.utils.resistance.calculate_resistance_parallel","title":"<code>calculate_resistance_parallel(Rx0, Ry0, AMR, AHE, SMR, m, l, w)</code>","text":"<p>Calculates the resistance of the system in parallel. Uses Kim's formula from the paper: https://link.aps.org/doi/10.1103/PhysRevLett.116.097201</p> Source code in <code>cmtj/utils/resistance.py</code> <pre><code>def calculate_resistance_parallel(Rx0: List[float], Ry0: List[float],\n                                  AMR: List[float], AHE: List[float],\n                                  SMR: List[float], m: List[float],\n                                  l: List[float], w: List[float]):\n    \"\"\"Calculates the resistance of the system in parallel.\n    Uses Kim's formula from the paper:\n    https://link.aps.org/doi/10.1103/PhysRevLett.116.097201\"\"\"\n    SxAll, SyAll = compute_resistance(Rx0, Ry0, AMR, AHE, SMR, m, l, w)\n    Rx = 1 / np.sum(1. / SxAll, axis=0)\n    Ry = 1 / np.sum(1. / SyAll, axis=0)\n    return Rx, Ry\n</code></pre>"},{"location":"api/resistance-reference/#cmtj.utils.resistance.calculate_resistance_series","title":"<code>calculate_resistance_series(Rx0, Ry0, AMR, AHE, SMR, m, l, w)</code>","text":"<p>Calculates the resistance of the system in series. Uses Kim's formula from the paper: https://link.aps.org/doi/10.1103/PhysRevLett.116.097201</p> Source code in <code>cmtj/utils/resistance.py</code> <pre><code>def calculate_resistance_series(Rx0: List[float], Ry0: List[float],\n                                AMR: List[float], AHE: List[float],\n                                SMR: List[float], m: List[float],\n                                l: List[float], w: List[float]):\n    \"\"\"Calculates the resistance of the system in series.\n    Uses Kim's formula from the paper:\n    https://link.aps.org/doi/10.1103/PhysRevLett.116.097201\"\"\"\n    SxAll, SyAll = compute_resistance(Rx0, Ry0, AMR, AHE, SMR, m, l, w)\n    Rx = np.sum(SxAll, axis=0)\n    Ry = np.sum(SyAll, axis=0)\n    return Rx, Ry\n</code></pre>"},{"location":"api/resistance-reference/#cmtj.utils.resistance.compute_resistance","title":"<code>compute_resistance(Rx0, Ry0, AMR, AHE, SMR, m, l, w)</code>","text":"<p>Computes the resistance of the system.</p> Source code in <code>cmtj/utils/resistance.py</code> <pre><code>def compute_resistance(Rx0: List[float], Ry0: List[float], AMR: List[float],\n                       AHE: List[float], SMR: List[float],\n                       m: Union[List[float],\n                                np.ndarray], l: List[float], w: List[float]):\n    \"\"\"Computes the resistance of the system.\"\"\"\n    number_of_layers = len(Rx0)\n    if not isinstance(m, np.ndarray):\n        m = np.asarray(m)\n    if m.ndim == 2:\n        SxAll = np.zeros((number_of_layers, ))\n        SyAll = np.zeros((number_of_layers, ))\n\n    elif m.ndim == 3:\n        SxAll = np.zeros((number_of_layers, m.shape[2]))\n        SyAll = np.zeros((number_of_layers, m.shape[2]))\n\n    for i in range(0, number_of_layers):\n        w_l = w[i] / l[i]\n        SxAll[i] = (Rx0[i] + (AMR[i] * m[i, 0]**2 + SMR[i] * m[i, 1]**2))\n        SyAll[i] = (Ry0[i] + 0.5 * AHE[i] * m[i, 2] + (w_l) *\n                    (SMR[i] - AMR[i]) * m[i, 0] * m[i, 1])\n    return SxAll, SyAll\n</code></pre>"},{"location":"api/resistance-reference/#cmtj.utils.resistance.compute_sd","title":"<code>compute_sd(dynamic_r, dynamic_i, integration_step)</code>","text":"<p>Computes the SD voltage.</p> <p>Parameters:</p> Name Type Description Default <code>dynamic_r</code> <code>np.ndarray</code> <p>magnetoresistance from log</p> required <code>dynamic_i</code> <code>np.ndarray</code> <p>excitation current</p> required <code>integration_step</code> <code>float</code> <p>integration paramemter from run_simulation</p> required Source code in <code>cmtj/utils/resistance.py</code> <pre><code>def compute_sd(dynamic_r: np.ndarray, dynamic_i: np.ndarray,\n               integration_step: float) -&gt; np.ndarray:\n    \"\"\"Computes the SD voltage.\n    :param dynamic_r: magnetoresistance from log\n    :param dynamic_i: excitation current\n    :param integration_step: integration paramemter from run_simulation\n    \"\"\"\n    SD = -dynamic_i * dynamic_r\n    fs = 1.0 / integration_step\n    SD_dc = Filters.butter_lowpass_filter(SD, cutoff=10e6, fs=fs, order=3)\n    return np.mean(SD_dc)\n</code></pre>"},{"location":"api/models/dw-reference/","title":"Domain wall","text":""},{"location":"api/models/dw-reference/#cmtj.models.domain_dynamics.DW","title":"<code>DW</code>","text":"<p>Initial conditions for the phi of DW equation.</p> Source code in <code>cmtj/models/domain_dynamics.py</code> <pre><code>class DW:\n    \"\"\"Initial conditions for the phi of DW equation.\"\"\"\n    NEEL_RIGHT = 0\n    NEEL_LEFT = math.pi\n    BLOCH_UP = math.pi / 2.\n    BLOCH_DOWN = 3. * math.pi / 2.\n</code></pre>"},{"location":"api/models/dw-reference/#cmtj.models.domain_dynamics.DomainWallDynamics","title":"<code>DomainWallDynamics</code>  <code>dataclass</code>","text":"<p>Domain Wall dynamics class.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>VectorObj</code> <p>applied magnetic field vector.</p> required <code>alpha</code> <code>float</code> <p>Gilbert damping.</p> required <code>Ms</code> <code>float</code> <p>magnetisation saturation [A/m].</p> required <code>thickness</code> <code>float</code> <p>thickness of the FM material.</p> required <code>SHE_angle</code> <code>float</code> <p>Spin Hall Effect angle.</p> required <code>D</code> <code>float</code> <p>DMI constant.</p> required <code>Ku</code> <code>float</code> <p>perpendicular anisotropy constant.</p> required <code>Kp</code> <code>float</code> <p>inplane anisotropy constant.</p> required <code>A</code> <code>float</code> <p>exchange constant.</p> <code>1e-11</code> <code>beta</code> <code>float</code> <p>STT beta parameter.</p> <code>1</code> <code>p</code> <code>float</code> <p>STT polarisation efficiency.</p> <code>1</code> <code>V0_pin</code> <code>float</code> <p>pinning voltage constant.</p> <code>1.65e-20</code> <code>V0_edge</code> <code>float</code> <p>edge voltage constant.</p> <code>0</code> <code>pinning</code> <code>float</code> <p>the pinning period.</p> <code>3e-08</code> <code>Lx</code> <code>float</code> <p>z-dimension of the FM block.</p> <code>1.2e-07</code> <code>Ly</code> <code>float</code> <p>y-dimension of the FM block.</p> <code>1.2e-07</code> <code>Lz</code> <code>float</code> <p>z-dimension of the FM block.</p> <code>3e-09</code> <code>Q</code> <code>int</code> <p>up-down or down-up wall parameter (either 1 or -1).</p> <code>1</code> <code>Hr</code> <code>float</code> <p>Rashba field [A/m].</p> <code>0</code> <code>moving_field</code> <code>Literal['perpendicular', 'inplane']</code> <p>whether the anisotropy field is perpendicular or parallel</p> <code>'perpendicular'</code> <code>relax_dw</code> <code>DWRelax</code> <p>whether to relax the domain width. See DWRelax class. For classical formulation see: Current-driven dynamics of chiral ferromagnetic domain walls, Emori et al, 2013</p> <code>DWRelax.STATIC</code> Source code in <code>cmtj/models/domain_dynamics.py</code> <pre><code>@dataclass\nclass DomainWallDynamics:\n    \"\"\"Domain Wall dynamics class.\n    :param H: applied magnetic field vector.\n    :param alpha: Gilbert damping.\n    :param Ms: magnetisation saturation [A/m].\n    :param thickness: thickness of the FM material.\n    :param SHE_angle: Spin Hall Effect angle.\n    :param D: DMI constant.\n    :param Ku: perpendicular anisotropy constant.\n    :param Kp: inplane anisotropy constant.\n    :param A: exchange constant.\n    :param beta: STT beta parameter.\n    :param p: STT polarisation efficiency.\n    :param V0_pin: pinning voltage constant.\n    :param V0_edge: edge voltage constant.\n    :param pinning: the pinning period.\n    :param Lx: z-dimension of the FM block.\n    :param Ly: y-dimension of the FM block.\n    :param Lz: z-dimension of the FM block.\n    :param Q: up-down or down-up wall parameter (either 1 or -1).\n    :param Hr: Rashba field [A/m].\n    :param moving_field: whether the anisotropy field is perpendicular or parallel\n    :param relax_dw: whether to relax the domain width. See DWRelax class.\n    For classical formulation see:\n    Current-driven dynamics of chiral ferromagnetic domain walls, Emori et al, 2013\n    \"\"\"\n    H: VectorObj\n    alpha: float\n    Ms: float\n    thickness: float\n    SHE_angle: float\n    D: float\n    Ku: float  # The out-of-plane anisotropy constant\n    Kp: float  # The in-plane anisotropy constant\n    A: float = 1e-11  # J/m\n    beta: float = 1\n    p: float = 1\n    V0_pin: float = 1.65e-20\n    V0_edge: float = 0\n    pinning: float = 30e-9\n    Lx: float = 120e-9\n    Ly: float = 120e-9\n    Lz: float = 3e-9\n    Q: int = 1\n    Hr: float = 0\n    moving_field: Literal[\"perpendicular\", \"inplane\"] = \"perpendicular\"\n    relax_dw: DWRelax = DWRelax.STATIC\n    dw0: float = field(init=False)\n\n    def __post_init__(self):\n        # in post init we already have p\n        self.bj = bohr_magneton * self.p / (echarge * self.Ms)\n        self.je_driver = lambda t: 0\n        denom = (2 * self.Ms * mu0 * echarge * self.thickness)\n        self.Hshe = hbar * self.SHE_angle / denom\n        self.hx, self.hy, self.hz = self.H.get_cartesian()\n        self.dw0 = self.get_unrelaxed_domain_width()\n\n        if self.moving_field == \"perpendicular\":\n            self.Hk = self.get_perpendicular_anisotropy_field()\n        elif self.moving_field == \"inplane\":\n            self.Hk = self.get_inplane_anisotropy_field()\n\n    def get_unrelaxed_domain_width(self, effective=False):\n        \"\"\"Domain width is based off the effective perpendicular anisotropy.\n        We reduce the perpendicular anisotropy by demagnetising field\"\"\"\n        # Keff = self.Ku - 0.5*mu0*(self.Ms)**2\n        Keff = self.Ku - (0.5 * mu0) * (self.Ms**2) if effective else self.Ku\n        return math.sqrt(self.A / Keff)\n\n    def set_current_function(self, driver: Callable):\n        \"\"\"\n        :param driver: A function of time that returns the current density\n        \"\"\"\n        self.je_driver = driver\n\n    def get_Hdmi(self, domain_width):\n        \"\"\"Returns the DMI field\"\"\"\n        return self.D / (mu0 * self.Ms * domain_width)\n\n    def get_perpendicular_anisotropy_field(self):\n        \"\"\"Returns the perpeanisotropy field\"\"\"\n        return 2 * self.Ku / (mu0 * self.Ms)\n\n    def get_inplane_anisotropy_field(self):\n        \"\"\"Returns the in-plane anisotropy field\"\"\"\n        return 2 * self.Kp / (mu0 * self.Ms)\n</code></pre>"},{"location":"api/models/dw-reference/#cmtj.models.domain_dynamics.DomainWallDynamics.get_Hdmi","title":"<code>get_Hdmi(domain_width)</code>","text":"<p>Returns the DMI field</p> Source code in <code>cmtj/models/domain_dynamics.py</code> <pre><code>def get_Hdmi(self, domain_width):\n    \"\"\"Returns the DMI field\"\"\"\n    return self.D / (mu0 * self.Ms * domain_width)\n</code></pre>"},{"location":"api/models/dw-reference/#cmtj.models.domain_dynamics.DomainWallDynamics.get_inplane_anisotropy_field","title":"<code>get_inplane_anisotropy_field()</code>","text":"<p>Returns the in-plane anisotropy field</p> Source code in <code>cmtj/models/domain_dynamics.py</code> <pre><code>def get_inplane_anisotropy_field(self):\n    \"\"\"Returns the in-plane anisotropy field\"\"\"\n    return 2 * self.Kp / (mu0 * self.Ms)\n</code></pre>"},{"location":"api/models/dw-reference/#cmtj.models.domain_dynamics.DomainWallDynamics.get_perpendicular_anisotropy_field","title":"<code>get_perpendicular_anisotropy_field()</code>","text":"<p>Returns the perpeanisotropy field</p> Source code in <code>cmtj/models/domain_dynamics.py</code> <pre><code>def get_perpendicular_anisotropy_field(self):\n    \"\"\"Returns the perpeanisotropy field\"\"\"\n    return 2 * self.Ku / (mu0 * self.Ms)\n</code></pre>"},{"location":"api/models/dw-reference/#cmtj.models.domain_dynamics.DomainWallDynamics.get_unrelaxed_domain_width","title":"<code>get_unrelaxed_domain_width(effective=False)</code>","text":"<p>Domain width is based off the effective perpendicular anisotropy. We reduce the perpendicular anisotropy by demagnetising field</p> Source code in <code>cmtj/models/domain_dynamics.py</code> <pre><code>def get_unrelaxed_domain_width(self, effective=False):\n    \"\"\"Domain width is based off the effective perpendicular anisotropy.\n    We reduce the perpendicular anisotropy by demagnetising field\"\"\"\n    # Keff = self.Ku - 0.5*mu0*(self.Ms)**2\n    Keff = self.Ku - (0.5 * mu0) * (self.Ms**2) if effective else self.Ku\n    return math.sqrt(self.A / Keff)\n</code></pre>"},{"location":"api/models/dw-reference/#cmtj.models.domain_dynamics.DomainWallDynamics.set_current_function","title":"<code>set_current_function(driver)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>driver</code> <code>Callable</code> <p>A function of time that returns the current density</p> required Source code in <code>cmtj/models/domain_dynamics.py</code> <pre><code>def set_current_function(self, driver: Callable):\n    \"\"\"\n    :param driver: A function of time that returns the current density\n    \"\"\"\n    self.je_driver = driver\n</code></pre>"},{"location":"api/models/dw-reference/#cmtj.models.domain_dynamics.MultilayerWallDynamics","title":"<code>MultilayerWallDynamics</code>  <code>dataclass</code>","text":"Source code in <code>cmtj/models/domain_dynamics.py</code> <pre><code>@dataclass\nclass MultilayerWallDynamics:\n    layers: List[DomainWallDynamics]\n    J: float = 0\n    vector_size: int = 3  # 3 for X, phi, delta\n\n    def __post_init__(self):\n        if len(self.layers) &gt; 2:\n            raise ValueError(\"Wall dynamics supported up to 2 layers\")\n\n    def multilayer_dw_llg(self, t, vec):\n        \"\"\"Solve the Thiaville llg equation for LLG.\n        :param t: current simulation time.\n        :param vec: contains [X, phi, delta], current DW position, its angle and domain width.\n        :returns (dXdt, dPhidt, dDeltad): velocity and change of angle and domain width.\n        \"\"\"\n        # vector is X1, phi1, Delta1, X2, phi2, Delta2...\n        layer: DomainWallDynamics\n        new_vec = []\n        for i, layer in enumerate(self.layers):\n            je_at_t = layer.je_driver(t=t)\n            reduced_alpha = (1. + layer.alpha**2)\n            lx = vec[self.vector_size * i]\n            lphi = vec[(self.vector_size * i) + 1]\n            ldomain_width = vec[(self.vector_size * i) + 2]\n            if len(self.layers) == 1:\n                Jterm = 0\n            else:\n                Jterm = 2 * self.J / (layer.Ms * mu0 * layer.thickness)\n                otherphi = vec[self.vector_size * (i - 1) + 1]\n                Jterm *= math.sin(lphi - otherphi)\n\n            hdmi = layer.get_Hdmi(ldomain_width)\n            dXdt, dPhidt, dDeltadt = compute_dynamics(\n                X=lx,\n                phi=lphi,\n                delta=ldomain_width,\n                Q=layer.Q,\n                hx=layer.hx,\n                hy=layer.hy,\n                hz=layer.hz,\n                alpha=layer.alpha,\n                bj=layer.bj * je_at_t,\n                hr=layer.Hr,\n                beta=layer.beta,\n                hshe=layer.Hshe * je_at_t,\n                hdmi=hdmi,\n                hk=layer.Hk,\n                Ms=layer.Ms,\n                IECterm=Jterm,\n                V0_pin=layer.V0_pin,\n                V0_edge=layer.V0_edge,\n                pinning=layer.pinning,\n                Lx=layer.Lx,\n                Ly=layer.Ly,\n                Lz=layer.Lz,\n                A=layer.A,\n                Ku=layer.Ku,\n                Kp=layer.Kp,\n                thickness=layer.thickness)\n            dXdt = dXdt / reduced_alpha\n            dPhidt = dPhidt / reduced_alpha\n            if layer.relax_dw != DWRelax.DYNAMIC:\n                dDeltadt = 0  # no relaxation in the ODE\n            new_vec.extend([dXdt, dPhidt, dDeltadt])\n        return new_vec\n\n    def run(self,\n            sim_time: float,\n            starting_conditions: List[float],\n            max_step: float = 1e-10):\n        \"\"\"Run simulation of DW dynamics.\n        :param sim_time: total simulation time (simulation units).\n        :param starting_conditions: starting position and angle of the DW.\n        :param max_step: maximum allowed step of the RK45 method.\n        \"\"\"\n        integrator = RK45(fun=self.multilayer_dw_llg,\n                          t0=0.,\n                          first_step=1e-16,\n                          max_step=max_step,\n                          y0=starting_conditions,\n                          rtol=1e-12,\n                          t_bound=sim_time)\n        result = defaultdict(list)\n        while True:\n            integrator.step()\n            if integrator.status == 'failed':\n                print(\"Failed to converge\")\n                break\n            layer_vecs = integrator.y\n            result['t'].append(integrator.t)\n            for i, layer in enumerate(self.layers):\n                x, phi, dw = layer_vecs[self.vector_size * i], layer_vecs[\n                    self.vector_size * i +\n                    1], layer_vecs[self.vector_size * i + 2]\n                # static relaxation Thiaville\n                if layer.relax_dw == DWRelax.STATIC:\n                    ratio = layer.Kp / layer.Ku\n                    dw = layer.dw0 / math.sqrt(1 + ratio * math.sin(phi)**2)\n                vel = (x - integrator.y_old[2 * i]) / integrator.step_size\n                result[f'dw_{i}'].append(dw)\n                result[f'v_{i}'].append(vel)\n                result[f'x_{i}'].append(x)\n                result[f'phi_{i}'].append(phi)\n                result[f'je_{i}'].append(layer.je_driver(t=integrator.t))\n            if integrator.status == 'finished':\n                break\n\n        return result\n</code></pre>"},{"location":"api/models/dw-reference/#cmtj.models.domain_dynamics.MultilayerWallDynamics.multilayer_dw_llg","title":"<code>multilayer_dw_llg(t, vec)</code>","text":"<p>Solve the Thiaville llg equation for LLG.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <p>current simulation time.</p> required <code>vec</code> <p>contains [X, phi, delta], current DW position, its angle and domain width.</p> required <p>Returns:</p> Type Description <p>velocity and change of angle and domain width.</p> Source code in <code>cmtj/models/domain_dynamics.py</code> <pre><code>def multilayer_dw_llg(self, t, vec):\n    \"\"\"Solve the Thiaville llg equation for LLG.\n    :param t: current simulation time.\n    :param vec: contains [X, phi, delta], current DW position, its angle and domain width.\n    :returns (dXdt, dPhidt, dDeltad): velocity and change of angle and domain width.\n    \"\"\"\n    # vector is X1, phi1, Delta1, X2, phi2, Delta2...\n    layer: DomainWallDynamics\n    new_vec = []\n    for i, layer in enumerate(self.layers):\n        je_at_t = layer.je_driver(t=t)\n        reduced_alpha = (1. + layer.alpha**2)\n        lx = vec[self.vector_size * i]\n        lphi = vec[(self.vector_size * i) + 1]\n        ldomain_width = vec[(self.vector_size * i) + 2]\n        if len(self.layers) == 1:\n            Jterm = 0\n        else:\n            Jterm = 2 * self.J / (layer.Ms * mu0 * layer.thickness)\n            otherphi = vec[self.vector_size * (i - 1) + 1]\n            Jterm *= math.sin(lphi - otherphi)\n\n        hdmi = layer.get_Hdmi(ldomain_width)\n        dXdt, dPhidt, dDeltadt = compute_dynamics(\n            X=lx,\n            phi=lphi,\n            delta=ldomain_width,\n            Q=layer.Q,\n            hx=layer.hx,\n            hy=layer.hy,\n            hz=layer.hz,\n            alpha=layer.alpha,\n            bj=layer.bj * je_at_t,\n            hr=layer.Hr,\n            beta=layer.beta,\n            hshe=layer.Hshe * je_at_t,\n            hdmi=hdmi,\n            hk=layer.Hk,\n            Ms=layer.Ms,\n            IECterm=Jterm,\n            V0_pin=layer.V0_pin,\n            V0_edge=layer.V0_edge,\n            pinning=layer.pinning,\n            Lx=layer.Lx,\n            Ly=layer.Ly,\n            Lz=layer.Lz,\n            A=layer.A,\n            Ku=layer.Ku,\n            Kp=layer.Kp,\n            thickness=layer.thickness)\n        dXdt = dXdt / reduced_alpha\n        dPhidt = dPhidt / reduced_alpha\n        if layer.relax_dw != DWRelax.DYNAMIC:\n            dDeltadt = 0  # no relaxation in the ODE\n        new_vec.extend([dXdt, dPhidt, dDeltadt])\n    return new_vec\n</code></pre>"},{"location":"api/models/dw-reference/#cmtj.models.domain_dynamics.MultilayerWallDynamics.run","title":"<code>run(sim_time, starting_conditions, max_step=1e-10)</code>","text":"<p>Run simulation of DW dynamics.</p> <p>Parameters:</p> Name Type Description Default <code>sim_time</code> <code>float</code> <p>total simulation time (simulation units).</p> required <code>starting_conditions</code> <code>List[float]</code> <p>starting position and angle of the DW.</p> required <code>max_step</code> <code>float</code> <p>maximum allowed step of the RK45 method.</p> <code>1e-10</code> Source code in <code>cmtj/models/domain_dynamics.py</code> <pre><code>def run(self,\n        sim_time: float,\n        starting_conditions: List[float],\n        max_step: float = 1e-10):\n    \"\"\"Run simulation of DW dynamics.\n    :param sim_time: total simulation time (simulation units).\n    :param starting_conditions: starting position and angle of the DW.\n    :param max_step: maximum allowed step of the RK45 method.\n    \"\"\"\n    integrator = RK45(fun=self.multilayer_dw_llg,\n                      t0=0.,\n                      first_step=1e-16,\n                      max_step=max_step,\n                      y0=starting_conditions,\n                      rtol=1e-12,\n                      t_bound=sim_time)\n    result = defaultdict(list)\n    while True:\n        integrator.step()\n        if integrator.status == 'failed':\n            print(\"Failed to converge\")\n            break\n        layer_vecs = integrator.y\n        result['t'].append(integrator.t)\n        for i, layer in enumerate(self.layers):\n            x, phi, dw = layer_vecs[self.vector_size * i], layer_vecs[\n                self.vector_size * i +\n                1], layer_vecs[self.vector_size * i + 2]\n            # static relaxation Thiaville\n            if layer.relax_dw == DWRelax.STATIC:\n                ratio = layer.Kp / layer.Ku\n                dw = layer.dw0 / math.sqrt(1 + ratio * math.sin(phi)**2)\n            vel = (x - integrator.y_old[2 * i]) / integrator.step_size\n            result[f'dw_{i}'].append(dw)\n            result[f'v_{i}'].append(vel)\n            result[f'x_{i}'].append(x)\n            result[f'phi_{i}'].append(phi)\n            result[f'je_{i}'].append(layer.je_driver(t=integrator.t))\n        if integrator.status == 'finished':\n            break\n\n    return result\n</code></pre>"},{"location":"api/models/sb-general-reference/","title":"Smit-Beljers","text":"<p>This module contains the basic implementation of the Smit-Beljers model. The model is based on the following paper which introduced a corrected model: Rodr\u00edguez-Su\u00e1rez et al., \"Ferromagnetic resonance investigation of the residual coupling in spin-valve systems\" 10.1103/PhysRevB.71.224406</p>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.LayerDynamic","title":"<code>LayerDynamic</code>  <code>dataclass</code>","text":"<p>         Bases: <code>LayerSB</code></p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>@dataclass\nclass LayerDynamic(LayerSB):\n    alpha: float\n\n    def rhs_llg(self, H: sym.Matrix, J1top: float, J1bottom: float,\n                J2top: float, J2bottom: float, top_layer: \"LayerSB\",\n                down_layer: \"LayerSB\"):\n        \"\"\"Returns the symbolic expression for the RHS of the spherical LLG equation.\n        Coupling contribution comes only from the bottom layer (top-down crawl)\"\"\"\n        U = self.symbolic_layer_energy(H,\n                                       J1top=J1top,\n                                       J1bottom=J1bottom,\n                                       J2top=J2top,\n                                       J2bottom=J2bottom,\n                                       top_layer=top_layer,\n                                       down_layer=down_layer)\n        # sum all components\n        prefac = gamma_rad / (1. + self.alpha)**2\n        inv_sin = 1. / (sym.sin(self.theta) + EPS)\n        dUdtheta = sym.diff(U, self.theta)\n        dUdphi = sym.diff(U, self.phi)\n\n        dtheta = (-inv_sin * dUdphi - self.alpha * dUdtheta)\n        dphi = (inv_sin * dUdtheta - self.alpha * dUdphi * (inv_sin)**2)\n        return prefac * sym.ImmutableMatrix([dtheta, dphi]) / self.Ms\n\n    def __eq__(self, __value: \"LayerDynamic\") -&gt; bool:\n        return super().__eq__(__value) and self.alpha == __value.alpha\n\n    def __hash__(self) -&gt; int:\n        return super().__hash__()\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.LayerDynamic.rhs_llg","title":"<code>rhs_llg(H, J1top, J1bottom, J2top, J2bottom, top_layer, down_layer)</code>","text":"<p>Returns the symbolic expression for the RHS of the spherical LLG equation. Coupling contribution comes only from the bottom layer (top-down crawl)</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def rhs_llg(self, H: sym.Matrix, J1top: float, J1bottom: float,\n            J2top: float, J2bottom: float, top_layer: \"LayerSB\",\n            down_layer: \"LayerSB\"):\n    \"\"\"Returns the symbolic expression for the RHS of the spherical LLG equation.\n    Coupling contribution comes only from the bottom layer (top-down crawl)\"\"\"\n    U = self.symbolic_layer_energy(H,\n                                   J1top=J1top,\n                                   J1bottom=J1bottom,\n                                   J2top=J2top,\n                                   J2bottom=J2bottom,\n                                   top_layer=top_layer,\n                                   down_layer=down_layer)\n    # sum all components\n    prefac = gamma_rad / (1. + self.alpha)**2\n    inv_sin = 1. / (sym.sin(self.theta) + EPS)\n    dUdtheta = sym.diff(U, self.theta)\n    dUdphi = sym.diff(U, self.phi)\n\n    dtheta = (-inv_sin * dUdphi - self.alpha * dUdtheta)\n    dphi = (inv_sin * dUdtheta - self.alpha * dUdphi * (inv_sin)**2)\n    return prefac * sym.ImmutableMatrix([dtheta, dphi]) / self.Ms\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.LayerSB","title":"<code>LayerSB</code>  <code>dataclass</code>","text":"<p>Basic Layer for Smit-Beljers model.</p> <p>Parameters:</p> Name Type Description Default <code>thickness</code> <code>float</code> <p>thickness of the FM layer (effective).</p> required <code>Kv</code> <code>VectorObj</code> <p>volumetric (in-plane) anisotropy. Only phi and mag count [J/m^3].</p> required <code>Ks</code> <code>float</code> <p>surface anisotropy (out-of plane, or perpendicular) value [J/m^3].</p> required <code>Ms</code> <code>float</code> <p>magnetisation saturation value in [A/m].</p> required Source code in <code>cmtj/models/general_sb.py</code> <pre><code>@dataclass\nclass LayerSB:\n    \"\"\"Basic Layer for Smit-Beljers model.\n    :param thickness: thickness of the FM layer (effective).\n    :param Kv: volumetric (in-plane) anisotropy. Only phi and mag count [J/m^3].\n    :param Ks: surface anisotropy (out-of plane, or perpendicular) value [J/m^3].\n    :param Ms: magnetisation saturation value in [A/m].\n    \"\"\"\n    _id: int\n    thickness: float\n    Kv: VectorObj\n    Ks: float\n    Ms: float\n\n    def __post_init__(self):\n        if self._id &gt; 9:\n            raise ValueError(\"Only up to 10 layers supported.\")\n        self.theta = sym.Symbol(r\"\\theta_\" + str(self._id))\n        self.phi = sym.Symbol(r\"\\phi_\" + str(self._id))\n        self.m = sym.ImmutableMatrix([\n            sym.sin(self.theta) * sym.cos(self.phi),\n            sym.sin(self.theta) * sym.sin(self.phi),\n            sym.cos(self.theta)\n        ])\n\n    def get_coord_sym(self):\n        \"\"\"Returns the symbolic coordinates of the layer.\"\"\"\n        return self.theta, self.phi\n\n    def get_m_sym(self):\n        \"\"\"Returns the magnetisation vector.\"\"\"\n        return self.m\n\n    @lru_cache(3)\n    def symbolic_layer_energy(self, H: sym.ImmutableMatrix, J1top: float,\n                              J1bottom: float, J2top: float, J2bottom: float,\n                              top_layer: \"LayerSB\", down_layer: \"LayerSB\"):\n        \"\"\"Returns the symbolic expression for the energy of the layer.\n        Coupling contribution comes only from the bottom layer (top-down crawl)\"\"\"\n        m = self.get_m_sym()\n\n        eng_non_interaction = self.no_iec_symbolic_layer_energy(H)\n\n        top_iec_energy = 0\n        bottom_iec_energy = 0\n\n        if top_layer is not None:\n            other_m = top_layer.get_m_sym()\n            top_iec_energy = -(J1top / self.thickness) * m.dot(other_m) - (\n                J2top / self.thickness) * m.dot(other_m)**2\n        if down_layer is not None:\n            other_m = down_layer.get_m_sym()\n            bottom_iec_energy = -(J1bottom / self.thickness) * m.dot(\n                other_m) - (J2bottom / self.thickness) * m.dot(other_m)**2\n        return eng_non_interaction + top_iec_energy + bottom_iec_energy\n\n    def no_iec_symbolic_layer_energy(self, H: sym.ImmutableMatrix):\n        \"\"\"Returns the symbolic expression for the energy of the layer.\n        Coupling contribution comes only from the bottom layer (top-down crawl)\"\"\"\n        m = self.get_m_sym()\n\n        alpha = sym.ImmutableMatrix(\n            [sym.cos(self.Kv.phi),\n             sym.sin(self.Kv.phi), 0])\n\n        field_energy = -mu0 * self.Ms * m.dot(H)\n        surface_anistropy = (-self.Ks +\n                             (1. / 2.) * mu0 * self.Ms**2) * (m[-1]**2)\n        volume_anisotropy = -self.Kv.mag * (m.dot(alpha)**2)\n        return (field_energy + surface_anistropy + volume_anisotropy)\n\n    def sb_correction(self):\n        omega = sym.Symbol(r'\\omega')\n        return (omega / gamma) * self.Ms * sym.sin(self.theta) * self.thickness\n\n    def __hash__(self) -&gt; int:\n        return hash(str(self))\n\n    def __eq__(self, __value: \"LayerSB\") -&gt; bool:\n        return self._id == __value._id and self.thickness == __value.thickness and self.Kv == __value.Kv and self.Ks == __value.Ks and self.Ms == __value.Ms\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.LayerSB.get_coord_sym","title":"<code>get_coord_sym()</code>","text":"<p>Returns the symbolic coordinates of the layer.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def get_coord_sym(self):\n    \"\"\"Returns the symbolic coordinates of the layer.\"\"\"\n    return self.theta, self.phi\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.LayerSB.get_m_sym","title":"<code>get_m_sym()</code>","text":"<p>Returns the magnetisation vector.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def get_m_sym(self):\n    \"\"\"Returns the magnetisation vector.\"\"\"\n    return self.m\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.LayerSB.no_iec_symbolic_layer_energy","title":"<code>no_iec_symbolic_layer_energy(H)</code>","text":"<p>Returns the symbolic expression for the energy of the layer. Coupling contribution comes only from the bottom layer (top-down crawl)</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def no_iec_symbolic_layer_energy(self, H: sym.ImmutableMatrix):\n    \"\"\"Returns the symbolic expression for the energy of the layer.\n    Coupling contribution comes only from the bottom layer (top-down crawl)\"\"\"\n    m = self.get_m_sym()\n\n    alpha = sym.ImmutableMatrix(\n        [sym.cos(self.Kv.phi),\n         sym.sin(self.Kv.phi), 0])\n\n    field_energy = -mu0 * self.Ms * m.dot(H)\n    surface_anistropy = (-self.Ks +\n                         (1. / 2.) * mu0 * self.Ms**2) * (m[-1]**2)\n    volume_anisotropy = -self.Kv.mag * (m.dot(alpha)**2)\n    return (field_energy + surface_anistropy + volume_anisotropy)\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.LayerSB.symbolic_layer_energy","title":"<code>symbolic_layer_energy(H, J1top, J1bottom, J2top, J2bottom, top_layer, down_layer)</code>  <code>cached</code>","text":"<p>Returns the symbolic expression for the energy of the layer. Coupling contribution comes only from the bottom layer (top-down crawl)</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>@lru_cache(3)\ndef symbolic_layer_energy(self, H: sym.ImmutableMatrix, J1top: float,\n                          J1bottom: float, J2top: float, J2bottom: float,\n                          top_layer: \"LayerSB\", down_layer: \"LayerSB\"):\n    \"\"\"Returns the symbolic expression for the energy of the layer.\n    Coupling contribution comes only from the bottom layer (top-down crawl)\"\"\"\n    m = self.get_m_sym()\n\n    eng_non_interaction = self.no_iec_symbolic_layer_energy(H)\n\n    top_iec_energy = 0\n    bottom_iec_energy = 0\n\n    if top_layer is not None:\n        other_m = top_layer.get_m_sym()\n        top_iec_energy = -(J1top / self.thickness) * m.dot(other_m) - (\n            J2top / self.thickness) * m.dot(other_m)**2\n    if down_layer is not None:\n        other_m = down_layer.get_m_sym()\n        bottom_iec_energy = -(J1bottom / self.thickness) * m.dot(\n            other_m) - (J2bottom / self.thickness) * m.dot(other_m)**2\n    return eng_non_interaction + top_iec_energy + bottom_iec_energy\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver","title":"<code>Solver</code>  <code>dataclass</code>","text":"Source code in <code>cmtj/models/general_sb.py</code> <pre><code>@dataclass\nclass Solver:\n    layers: List[Union[LayerSB, LayerDynamic]]\n    J1: List[float]\n    J2: List[float]\n    H: VectorObj = None\n\n    def __post_init__(self):\n        if len(self.layers) != len(self.J1) + 1:\n            raise ValueError(\"Number of layers must be 1 more than J1.\")\n        if len(self.layers) != len(self.J2) + 1:\n            raise ValueError(\"Number of layers must be 1 more than J2.\")\n\n        id_sets = {layer._id for layer in self.layers}\n        ideal_set = set(range(len(self.layers)))\n        if id_sets != ideal_set:\n            raise ValueError(\"Layer ids must be 0, 1, 2, ... and unique.\"\n                             \"Ids must start from 0.\")\n\n    def get_layer_references(self, layer_indx, interaction_constant):\n        \"\"\"Returns the references to the layers above and below the layer\n        with index layer_indx.\"\"\"\n        if len(self.layers) == 1:\n            return None, None, 0, 0\n        if layer_indx == 0:\n            return None, self.layers[layer_indx +\n                                     1], 0, interaction_constant[0]\n        elif layer_indx == len(self.layers) - 1:\n            return self.layers[layer_indx -\n                               1], None, interaction_constant[-1], 0\n        return self.layers[layer_indx - 1], self.layers[\n            layer_indx +\n            1], interaction_constant[layer_indx -\n                                     1], interaction_constant[layer_indx]\n\n    def compose_llg_jacobian(self, H: VectorObj):\n        \"\"\"Create a symbolic jacobian of the LLG equation in spherical coordinates.\"\"\"\n        # has order theta0, phi0, theta1, phi1, ...\n        if isinstance(H, VectorObj):\n            H = sym.ImmutableMatrix(H.get_cartesian())\n\n        symbols, fns = [], []\n        for i, layer in enumerate(self.layers):\n            symbols.extend((layer.theta, layer.phi))\n            top_layer, bottom_layer, Jtop, Jbottom = self.get_layer_references(\n                i, self.J1)\n            _, _, J2top, J2bottom = self.get_layer_references(i, self.J2)\n            fns.append(\n                layer.rhs_llg(H, Jtop, Jbottom, J2top, J2bottom, top_layer,\n                              bottom_layer))\n        jac = sym.ImmutableMatrix(fns).jacobian(symbols)\n        return jac, symbols\n\n    def create_energy(self,\n                      H: Union[VectorObj, sym.ImmutableMatrix] = None,\n                      volumetric: bool = False):\n        \"\"\"Creates the symbolic energy expression.\n\n        Due to problematic nature of coupling, there is an issue of\n        computing each layer's FMR in the presence of IEC.\n        If volumetric = True then we use the thickness of the layer to multiply the\n        energy and hence avoid having to divide J by the thickness of a layer.\n        If volumetric = False the J constant is divided by weighted thickness\n        and included in every layer's energy, correcting FMR automatically.\n        \"\"\"\n        if H is None:\n            h = self.H.get_cartesian()\n            H = sym.ImmutableMatrix(h)\n        energy = 0\n        if volumetric:\n            # volumetric energy -- DO NOT USE IN GENERAL\n            for i, layer in enumerate(self.layers):\n                top_layer, bottom_layer, Jtop, Jbottom = self.get_layer_references(\n                    i, self.J1)\n                _, _, J2top, J2bottom = self.get_layer_references(i, self.J2)\n                ratio_top, ratio_bottom = 0, 0\n                if top_layer:\n                    ratio_top = top_layer.thickness / (top_layer.thickness +\n                                                       layer.thickness)\n                if bottom_layer:\n                    ratio_bottom = bottom_layer.thickness / (\n                        layer.thickness + bottom_layer.thickness)\n                energy += layer.symbolic_layer_energy(H, Jtop * ratio_top,\n                                                      Jbottom * ratio_bottom,\n                                                      J2top, J2bottom,\n                                                      top_layer, bottom_layer)\n        else:\n            # surface energy for correct angular gradient\n            for layer in self.layers:\n                # to avoid dividing J by thickness\n                energy += layer.no_iec_symbolic_layer_energy(\n                    H) * layer.thickness\n\n            for i in range(len(self.layers) - 1):\n                l1m = self.layers[i].get_m_sym()\n                l2m = self.layers[i + 1].get_m_sym()\n                ldot = (l1m.dot(l2m))\n                energy -= self.J1[i] * ldot\n                energy -= self.J2[i] * (ldot)**2\n\n        return energy\n\n    def create_energy_hessian(self, equilibrium_position: List[float]):\n        \"\"\"Creates the symbolic hessian of the energy expression.\"\"\"\n        energy = self.create_energy(volumetric=False)\n        subs = self.get_subs(equilibrium_position)\n        N = len(self.layers)\n        hessian = [[0 for _ in range(2 * N)] for _ in range(2 * N)]\n        for i in range(N):\n            z = self.layers[i].sb_correction()\n            theta_i, phi_i = self.layers[i].get_coord_sym()\n            for j in range(i, N):\n                # dtheta dtheta\n                theta_j, phi_j = self.layers[j].get_coord_sym()\n\n                expr = sym.diff(sym.diff(energy, theta_i), theta_j)\n                hessian[2 * i][2 * j] = expr\n                hessian[2 * j][2 * i] = expr\n\n                # dphi dphi\n                expr = sym.diff(sym.diff(energy, phi_i), phi_j)\n                hessian[2 * i + 1][2 * j + 1] = expr\n                hessian[2 * j + 1][2 * i + 1] = expr\n\n                expr = sym.diff(sym.diff(energy, theta_i), phi_j)\n                # mixed terms\n                if i == j:\n                    hessian[2 * i + 1][2 * j] = expr + sym.I * z\n                    hessian[2 * i][2 * j + 1] = expr - sym.I * z\n                else:\n                    hessian[2 * i][2 * j + 1] = expr\n                    hessian[2 * j + 1][2 * i] = expr\n\n                    expr = sym.diff(sym.diff(energy, phi_i), theta_j)\n                    hessian[2 * i + 1][2 * j] = expr\n                    hessian[2 * j][2 * i + 1] = expr\n\n        hes = sym.ImmutableMatrix(hessian)\n        _, U, _ = hes.LUdecomposition()\n        return U.det().subs(subs)\n\n    def get_gradient_expr(self, accel=\"math\"):\n        \"\"\"Returns the symbolic gradient of the energy expression.\"\"\"\n        energy = self.create_energy(volumetric=False)\n        grad_vector = []\n        symbols = []\n        for layer in self.layers:\n            (theta, phi) = layer.get_coord_sym()\n            grad_vector.extend((sym.diff(energy, theta), sym.diff(energy,\n                                                                  phi)))\n            symbols.extend((theta, phi))\n        return sym.lambdify(symbols, grad_vector, accel)\n\n    def adam_gradient_descent(self,\n                              init_position: np.ndarray,\n                              max_steps: int,\n                              tol: float = 1e-8,\n                              learning_rate: float = 1e-4,\n                              first_momentum_decay: float = 0.9,\n                              second_momentum_decay: float = 0.999,\n                              perturbation: float = 1e-6):\n        \"\"\"\n        A naive implementation of Adam gradient descent.\n        See: ADAM: A METHOD FOR STOCHASTIC OPTIMIZATION, Kingma et Ba, 2015\n        :param max_steps: maximum number of gradient steps.\n        :param tol: tolerance of the solution.\n        :param learning_rate: the learning rate (descent speed).\n        :param first_momentum_decay: constant for the first momentum.\n        :param second_momentum_decay: constant for the second momentum.\n        \"\"\"\n        step = 0\n        gradfn = self.get_gradient_expr()\n        current_position = init_position\n        if perturbation:\n            current_position = perturb_position(init_position, perturbation)\n        m = np.zeros_like(current_position)  # first momentum\n        v = np.zeros_like(current_position)  # second momentum\n        eps = 1e-12\n\n        while True:\n            step += 1\n            grad = np.asarray(gradfn(*current_position))\n            m = first_momentum_decay * m + (1. - first_momentum_decay) * grad\n            v = second_momentum_decay * v + (1. -\n                                             second_momentum_decay) * grad**2\n            m_hat = m / (1. - first_momentum_decay**step)\n            v_hat = v / (1. - second_momentum_decay**step)\n            new_position = current_position - learning_rate * m_hat / (\n                np.sqrt(v_hat) + eps)\n            if step &gt; max_steps:\n                break\n            # if np.linalg.norm(current_position - new_position) &lt; tol:\n            # break\n            if fast_norm(current_position - new_position) &lt; tol:\n                break\n            current_position = new_position\n        return np.asarray(current_position)\n\n    def single_layer_resonance(self, layer_indx: int, eq_position: np.ndarray):\n        \"\"\"We can compute the equilibrium position of a single layer directly.\n        :param layer_indx: the index of the layer to compute the equilibrium\n        :param eq_position: the equilibrium position vector\"\"\"\n        layer = self.layers[layer_indx]\n        theta_eq = eq_position[2 * layer_indx]\n        theta, phi = self.layers[layer_indx].get_coord_sym()\n        energy = self.create_energy(volumetric=True)\n        subs = self.get_subs(eq_position)\n        d2Edtheta2 = sym.diff(sym.diff(energy, theta), theta).subs(subs)\n        d2Edphi2 = sym.diff(sym.diff(energy, phi), phi).subs(subs)\n        # mixed, assuming symmetry\n        d2Edthetaphi = sym.diff(sym.diff(energy, theta), phi).subs(subs)\n        vareps = 1e-18\n\n        fmr = (d2Edtheta2 * d2Edphi2 - d2Edthetaphi**2) / np.power(\n            np.sin(theta_eq + vareps) * layer.Ms, 2)\n        fmr = np.sqrt(float(fmr)) * gamma_rad / (2 * np.pi)\n        return fmr\n\n    def solve(self,\n              init_position: np.ndarray,\n              max_steps: int = 1e9,\n              learning_rate: float = 1e-4,\n              adam_tol: float = 1e-8,\n              first_momentum_decay: float = 0.9,\n              second_momentum_decay: float = 0.999,\n              perturbation: float = 1e-3,\n              ftol: float = 0.01e9,\n              max_freq: float = 80e9,\n              force_single_layer: bool = False,\n              force_sb: bool = False):\n        \"\"\"Solves the system.\n        1. Computes the energy functional.\n        2. Computes the gradient of the energy functional.\n        3. Performs a gradient descent to find the equilibrium position.\n        Returns the equilibrium position and frequencies in [GHz].\n        If there's only one layer, the frequency is computed analytically.\n        For full analytical solution, see: `analytical_field_scan`\n        :param init_position: initial position for the gradient descent.\n                              Must be a 1D array of size 2 * number of layers (theta, phi)\n        :param max_steps: maximum number of gradient steps.\n        :param learning_rate: the learning rate (descent speed).\n        :param adam_tol: tolerance for the consecutive Adam minima.\n        :param first_momentum_decay: constant for the first momentum.\n        :param second_momentum_decay: constant for the second momentum.\n        :param perturbation: the perturbation to use for the numerical gradient computation.\n        :param ftol: tolerance for the frequency search. [numerical only]\n        :param max_freq: maximum frequency to search for. [numerical only]\n        :param force_single_layer: whether to force the computation of the frequencies\n                                   for each layer individually.\n        :param force_sb: whether to force the computation of the frequencies.\n                        Takes effect only if the layers are LayerDynamic, not LayerSB.\n        :return: equilibrium position and frequencies in [GHz] (and eigenvectors if LayerDynamic instead of LayerSB).\n        \"\"\"\n        if self.H is None:\n            raise ValueError(\n                \"H must be set before solving the system numerically.\")\n        eq = self.adam_gradient_descent(\n            init_position=init_position,\n            max_steps=max_steps,\n            tol=adam_tol,\n            learning_rate=learning_rate,\n            first_momentum_decay=first_momentum_decay,\n            second_momentum_decay=second_momentum_decay,\n            perturbation=perturbation)\n        if not force_sb and isinstance(self.layers[0], LayerDynamic):\n            eigenvalues, eigenvectors = self.dynamic_layer_solve(eq)\n            return eq, eigenvalues / 1e9, eigenvectors\n        N = len(self.layers)\n        if N == 1:\n            return eq, [self.single_layer_resonance(0, eq) / 1e9]\n        if force_single_layer:\n            frequencies = []\n            for indx in range(N):\n                frequency = self.single_layer_resonance(indx, eq) / 1e9\n                frequencies.append(frequency)\n            return eq, frequencies\n        return self.num_solve(eq, ftol=ftol, max_freq=max_freq)\n\n    def dynamic_layer_solve(self, eq: List[float]):\n        \"\"\"Return the FMR frequencies and modes for N layers using the\n        dynamic RHS model\n        :param eq: the equilibrium position of the system.\n        :return: frequencies and eigenmode vectors.\"\"\"\n        jac, symbols = self.compose_llg_jacobian(self.H)\n        subs = {symbols[i]: eq[i] for i in range(len(eq))}\n        jac = jac.subs(subs)\n        jac = np.asarray(jac, dtype=np.float32)\n        eigvals, eigvecs = np.linalg.eig(jac)\n        eigvals_im = np.imag(eigvals) / (2 * np.pi)\n        indx = np.argwhere(eigvals_im &gt; 0).ravel()\n        return eigvals_im[indx], eigvecs[indx]\n\n    def num_solve(self,\n                  eq: List[float],\n                  ftol: float = 0.01e9,\n                  max_freq: float = 80e9):\n        hes = self.create_energy_hessian(eq)\n        omega = sym.Symbol(r\"\\omega\")\n        if len(self.layers) &lt;= 3:\n            y = real_deocrator(njit(sym.lambdify(omega, hes, 'math')))\n        else:\n            y = real_deocrator(sym.lambdify(omega, hes, 'math'))\n        r = RootFinder(0, max_freq, step=ftol, xtol=1e-8, root_dtype=\"float16\")\n        roots = r.find(y)\n        # convert to GHz\n        # reduce unique solutions to 2 decimal places\n        # don't divide by 2pi, we used gamma instead of gamma / 2pi\n        f = np.unique(np.around(roots / 1e9, 2))\n        return eq, f\n\n    def analytical_roots(self):\n        \"\"\"Find &amp; cache the analytical roots of the system.\n        Returns a list of solutions.\n        Ineffecient for more than 2 layers (can try though).\n        \"\"\"\n        Hsym = sym.Matrix([\n            sym.Symbol(r\"H_{x}\"),\n            sym.Symbol(r\"H_{y}\"),\n            sym.Symbol(r\"H_{z}\"),\n        ])\n        N = len(self.layers)\n        if N &gt; 2:\n            warnings.warn(\n                \"Analytical solutions for over 2 layers may be computationally expensive.\"\n            )\n        system_energy = self.create_energy(H=Hsym, volumetric=False)\n        root_expr, energy_functional_expr = find_analytical_roots(N)\n        subs = get_all_second_derivatives(energy_functional_expr,\n                                          energy_expression=system_energy,\n                                          subs={})\n        subs.update(self.get_ms_subs())\n        return [s.subs(subs) for s in root_expr]\n\n    def get_subs(self, equilibrium_position: List[float]):\n        \"\"\"Returns the substitution dictionary for the energy expression.\"\"\"\n        subs = {}\n        for i in range(len(self.layers)):\n            theta, phi = self.layers[i].get_coord_sym()\n            subs[theta] = equilibrium_position[2 * i]\n            subs[phi] = equilibrium_position[(2 * i) + 1]\n        return subs\n\n    def get_ms_subs(self):\n        \"\"\"Returns a dictionary of substitutions for the Ms symbols.\"\"\"\n        a = {r\"M_{\" + str(layer._id) + \"}\": layer.Ms for layer in self.layers}\n        b = {\n            r\"t_{\" + str(layer._id) + r\"}\": layer.thickness\n            for layer in self.layers\n        }\n        return a | b\n\n    def set_H(self, H: VectorObj):\n        \"\"\"Sets the external field.\"\"\"\n        self.H = H\n\n    def analytical_field_scan(\n        self,\n        Hrange: List[VectorObj],\n        init_position: List[float] = None,\n        max_steps: int = 1e9,\n        learning_rate: float = 1e-4,\n        first_momentum_decay: float = 0.9,\n        second_momentum_decay: float = 0.999,\n        disable_tqdm: bool = False\n    ) -&gt; Iterable[Tuple[List[float], List[float], VectorObj]]:\n        \"\"\"Performs a field scan using the analytical solutions.\n        :param Hrange: the range of fields to scan.\n        :param init_position: the initial position for the gradient descent.\n                              If None, the first field in Hrange will be used.\n        :param max_steps: maximum number of gradient steps.\n        :param learning_rate: the learning rate (descent speed).\n        :param first_momentum_decay: constant for the first momentum.\n        :param second_momentum_decay: constant for the second momentum.\n        :param disable_tqdm: disable the progress bar.\n        :return: an iterable of (equilibrium position, frequencies, field)\n        \"\"\"\n        s1 = time.time()\n        global_roots = self.analytical_roots()\n        s2 = time.time()\n        if not disable_tqdm:\n            print(f\"Analytical roots found in {s2 - s1:.2f} seconds.\")\n        if init_position is None:\n            start = Hrange[0]\n            start.mag = 1\n            init_position = []\n            # align with the first field\n            for _ in self.layers:\n                init_position.extend([start.theta, start.phi])\n        Hsym = sym.Matrix([\n            sym.Symbol(r\"H_{x}\"),\n            sym.Symbol(r\"H_{y}\"),\n            sym.Symbol(r\"H_{z}\"),\n        ])\n        current_position = init_position\n        for Hvalue in tqdm(Hrange, disable=disable_tqdm):\n            self.set_H(Hvalue)\n            hx, hy, hz = Hvalue.get_cartesian()\n            eq = self.adam_gradient_descent(\n                init_position=current_position,\n                max_steps=max_steps,\n                tol=1e-9,\n                learning_rate=learning_rate,\n                first_momentum_decay=first_momentum_decay,\n                second_momentum_decay=second_momentum_decay,\n            )\n            step_subs = self.get_subs(eq)\n            step_subs.update(self.get_ms_subs())\n            step_subs.update({Hsym[0]: hx, Hsym[1]: hy, Hsym[2]: hz})\n            roots = [s.subs(step_subs) for s in global_roots]\n            roots = np.asarray(roots, dtype=np.float32) * gamma / 1e9\n            yield eq, roots, Hvalue\n            current_position = eq\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.adam_gradient_descent","title":"<code>adam_gradient_descent(init_position, max_steps, tol=1e-08, learning_rate=0.0001, first_momentum_decay=0.9, second_momentum_decay=0.999, perturbation=1e-06)</code>","text":"<p>A naive implementation of Adam gradient descent. See: ADAM: A METHOD FOR STOCHASTIC OPTIMIZATION, Kingma et Ba, 2015</p> <p>Parameters:</p> Name Type Description Default <code>max_steps</code> <code>int</code> <p>maximum number of gradient steps.</p> required <code>tol</code> <code>float</code> <p>tolerance of the solution.</p> <code>1e-08</code> <code>learning_rate</code> <code>float</code> <p>the learning rate (descent speed).</p> <code>0.0001</code> <code>first_momentum_decay</code> <code>float</code> <p>constant for the first momentum.</p> <code>0.9</code> <code>second_momentum_decay</code> <code>float</code> <p>constant for the second momentum.</p> <code>0.999</code> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def adam_gradient_descent(self,\n                          init_position: np.ndarray,\n                          max_steps: int,\n                          tol: float = 1e-8,\n                          learning_rate: float = 1e-4,\n                          first_momentum_decay: float = 0.9,\n                          second_momentum_decay: float = 0.999,\n                          perturbation: float = 1e-6):\n    \"\"\"\n    A naive implementation of Adam gradient descent.\n    See: ADAM: A METHOD FOR STOCHASTIC OPTIMIZATION, Kingma et Ba, 2015\n    :param max_steps: maximum number of gradient steps.\n    :param tol: tolerance of the solution.\n    :param learning_rate: the learning rate (descent speed).\n    :param first_momentum_decay: constant for the first momentum.\n    :param second_momentum_decay: constant for the second momentum.\n    \"\"\"\n    step = 0\n    gradfn = self.get_gradient_expr()\n    current_position = init_position\n    if perturbation:\n        current_position = perturb_position(init_position, perturbation)\n    m = np.zeros_like(current_position)  # first momentum\n    v = np.zeros_like(current_position)  # second momentum\n    eps = 1e-12\n\n    while True:\n        step += 1\n        grad = np.asarray(gradfn(*current_position))\n        m = first_momentum_decay * m + (1. - first_momentum_decay) * grad\n        v = second_momentum_decay * v + (1. -\n                                         second_momentum_decay) * grad**2\n        m_hat = m / (1. - first_momentum_decay**step)\n        v_hat = v / (1. - second_momentum_decay**step)\n        new_position = current_position - learning_rate * m_hat / (\n            np.sqrt(v_hat) + eps)\n        if step &gt; max_steps:\n            break\n        # if np.linalg.norm(current_position - new_position) &lt; tol:\n        # break\n        if fast_norm(current_position - new_position) &lt; tol:\n            break\n        current_position = new_position\n    return np.asarray(current_position)\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.analytical_field_scan","title":"<code>analytical_field_scan(Hrange, init_position=None, max_steps=1000000000.0, learning_rate=0.0001, first_momentum_decay=0.9, second_momentum_decay=0.999, disable_tqdm=False)</code>","text":"<p>Performs a field scan using the analytical solutions.</p> <p>Parameters:</p> Name Type Description Default <code>Hrange</code> <code>List[VectorObj]</code> <p>the range of fields to scan.</p> required <code>init_position</code> <code>List[float]</code> <p>the initial position for the gradient descent. If None, the first field in Hrange will be used.</p> <code>None</code> <code>max_steps</code> <code>int</code> <p>maximum number of gradient steps.</p> <code>1000000000.0</code> <code>learning_rate</code> <code>float</code> <p>the learning rate (descent speed).</p> <code>0.0001</code> <code>first_momentum_decay</code> <code>float</code> <p>constant for the first momentum.</p> <code>0.9</code> <code>second_momentum_decay</code> <code>float</code> <p>constant for the second momentum.</p> <code>0.999</code> <code>disable_tqdm</code> <code>bool</code> <p>disable the progress bar.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Tuple[List[float], List[float], VectorObj]]</code> <p>an iterable of (equilibrium position, frequencies, field)</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def analytical_field_scan(\n    self,\n    Hrange: List[VectorObj],\n    init_position: List[float] = None,\n    max_steps: int = 1e9,\n    learning_rate: float = 1e-4,\n    first_momentum_decay: float = 0.9,\n    second_momentum_decay: float = 0.999,\n    disable_tqdm: bool = False\n) -&gt; Iterable[Tuple[List[float], List[float], VectorObj]]:\n    \"\"\"Performs a field scan using the analytical solutions.\n    :param Hrange: the range of fields to scan.\n    :param init_position: the initial position for the gradient descent.\n                          If None, the first field in Hrange will be used.\n    :param max_steps: maximum number of gradient steps.\n    :param learning_rate: the learning rate (descent speed).\n    :param first_momentum_decay: constant for the first momentum.\n    :param second_momentum_decay: constant for the second momentum.\n    :param disable_tqdm: disable the progress bar.\n    :return: an iterable of (equilibrium position, frequencies, field)\n    \"\"\"\n    s1 = time.time()\n    global_roots = self.analytical_roots()\n    s2 = time.time()\n    if not disable_tqdm:\n        print(f\"Analytical roots found in {s2 - s1:.2f} seconds.\")\n    if init_position is None:\n        start = Hrange[0]\n        start.mag = 1\n        init_position = []\n        # align with the first field\n        for _ in self.layers:\n            init_position.extend([start.theta, start.phi])\n    Hsym = sym.Matrix([\n        sym.Symbol(r\"H_{x}\"),\n        sym.Symbol(r\"H_{y}\"),\n        sym.Symbol(r\"H_{z}\"),\n    ])\n    current_position = init_position\n    for Hvalue in tqdm(Hrange, disable=disable_tqdm):\n        self.set_H(Hvalue)\n        hx, hy, hz = Hvalue.get_cartesian()\n        eq = self.adam_gradient_descent(\n            init_position=current_position,\n            max_steps=max_steps,\n            tol=1e-9,\n            learning_rate=learning_rate,\n            first_momentum_decay=first_momentum_decay,\n            second_momentum_decay=second_momentum_decay,\n        )\n        step_subs = self.get_subs(eq)\n        step_subs.update(self.get_ms_subs())\n        step_subs.update({Hsym[0]: hx, Hsym[1]: hy, Hsym[2]: hz})\n        roots = [s.subs(step_subs) for s in global_roots]\n        roots = np.asarray(roots, dtype=np.float32) * gamma / 1e9\n        yield eq, roots, Hvalue\n        current_position = eq\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.analytical_roots","title":"<code>analytical_roots()</code>","text":"<p>Find &amp; cache the analytical roots of the system. Returns a list of solutions. Ineffecient for more than 2 layers (can try though).</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def analytical_roots(self):\n    \"\"\"Find &amp; cache the analytical roots of the system.\n    Returns a list of solutions.\n    Ineffecient for more than 2 layers (can try though).\n    \"\"\"\n    Hsym = sym.Matrix([\n        sym.Symbol(r\"H_{x}\"),\n        sym.Symbol(r\"H_{y}\"),\n        sym.Symbol(r\"H_{z}\"),\n    ])\n    N = len(self.layers)\n    if N &gt; 2:\n        warnings.warn(\n            \"Analytical solutions for over 2 layers may be computationally expensive.\"\n        )\n    system_energy = self.create_energy(H=Hsym, volumetric=False)\n    root_expr, energy_functional_expr = find_analytical_roots(N)\n    subs = get_all_second_derivatives(energy_functional_expr,\n                                      energy_expression=system_energy,\n                                      subs={})\n    subs.update(self.get_ms_subs())\n    return [s.subs(subs) for s in root_expr]\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.compose_llg_jacobian","title":"<code>compose_llg_jacobian(H)</code>","text":"<p>Create a symbolic jacobian of the LLG equation in spherical coordinates.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def compose_llg_jacobian(self, H: VectorObj):\n    \"\"\"Create a symbolic jacobian of the LLG equation in spherical coordinates.\"\"\"\n    # has order theta0, phi0, theta1, phi1, ...\n    if isinstance(H, VectorObj):\n        H = sym.ImmutableMatrix(H.get_cartesian())\n\n    symbols, fns = [], []\n    for i, layer in enumerate(self.layers):\n        symbols.extend((layer.theta, layer.phi))\n        top_layer, bottom_layer, Jtop, Jbottom = self.get_layer_references(\n            i, self.J1)\n        _, _, J2top, J2bottom = self.get_layer_references(i, self.J2)\n        fns.append(\n            layer.rhs_llg(H, Jtop, Jbottom, J2top, J2bottom, top_layer,\n                          bottom_layer))\n    jac = sym.ImmutableMatrix(fns).jacobian(symbols)\n    return jac, symbols\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.create_energy","title":"<code>create_energy(H=None, volumetric=False)</code>","text":"<p>Creates the symbolic energy expression.</p> <p>Due to problematic nature of coupling, there is an issue of computing each layer's FMR in the presence of IEC. If volumetric = True then we use the thickness of the layer to multiply the energy and hence avoid having to divide J by the thickness of a layer. If volumetric = False the J constant is divided by weighted thickness and included in every layer's energy, correcting FMR automatically.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def create_energy(self,\n                  H: Union[VectorObj, sym.ImmutableMatrix] = None,\n                  volumetric: bool = False):\n    \"\"\"Creates the symbolic energy expression.\n\n    Due to problematic nature of coupling, there is an issue of\n    computing each layer's FMR in the presence of IEC.\n    If volumetric = True then we use the thickness of the layer to multiply the\n    energy and hence avoid having to divide J by the thickness of a layer.\n    If volumetric = False the J constant is divided by weighted thickness\n    and included in every layer's energy, correcting FMR automatically.\n    \"\"\"\n    if H is None:\n        h = self.H.get_cartesian()\n        H = sym.ImmutableMatrix(h)\n    energy = 0\n    if volumetric:\n        # volumetric energy -- DO NOT USE IN GENERAL\n        for i, layer in enumerate(self.layers):\n            top_layer, bottom_layer, Jtop, Jbottom = self.get_layer_references(\n                i, self.J1)\n            _, _, J2top, J2bottom = self.get_layer_references(i, self.J2)\n            ratio_top, ratio_bottom = 0, 0\n            if top_layer:\n                ratio_top = top_layer.thickness / (top_layer.thickness +\n                                                   layer.thickness)\n            if bottom_layer:\n                ratio_bottom = bottom_layer.thickness / (\n                    layer.thickness + bottom_layer.thickness)\n            energy += layer.symbolic_layer_energy(H, Jtop * ratio_top,\n                                                  Jbottom * ratio_bottom,\n                                                  J2top, J2bottom,\n                                                  top_layer, bottom_layer)\n    else:\n        # surface energy for correct angular gradient\n        for layer in self.layers:\n            # to avoid dividing J by thickness\n            energy += layer.no_iec_symbolic_layer_energy(\n                H) * layer.thickness\n\n        for i in range(len(self.layers) - 1):\n            l1m = self.layers[i].get_m_sym()\n            l2m = self.layers[i + 1].get_m_sym()\n            ldot = (l1m.dot(l2m))\n            energy -= self.J1[i] * ldot\n            energy -= self.J2[i] * (ldot)**2\n\n    return energy\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.create_energy_hessian","title":"<code>create_energy_hessian(equilibrium_position)</code>","text":"<p>Creates the symbolic hessian of the energy expression.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def create_energy_hessian(self, equilibrium_position: List[float]):\n    \"\"\"Creates the symbolic hessian of the energy expression.\"\"\"\n    energy = self.create_energy(volumetric=False)\n    subs = self.get_subs(equilibrium_position)\n    N = len(self.layers)\n    hessian = [[0 for _ in range(2 * N)] for _ in range(2 * N)]\n    for i in range(N):\n        z = self.layers[i].sb_correction()\n        theta_i, phi_i = self.layers[i].get_coord_sym()\n        for j in range(i, N):\n            # dtheta dtheta\n            theta_j, phi_j = self.layers[j].get_coord_sym()\n\n            expr = sym.diff(sym.diff(energy, theta_i), theta_j)\n            hessian[2 * i][2 * j] = expr\n            hessian[2 * j][2 * i] = expr\n\n            # dphi dphi\n            expr = sym.diff(sym.diff(energy, phi_i), phi_j)\n            hessian[2 * i + 1][2 * j + 1] = expr\n            hessian[2 * j + 1][2 * i + 1] = expr\n\n            expr = sym.diff(sym.diff(energy, theta_i), phi_j)\n            # mixed terms\n            if i == j:\n                hessian[2 * i + 1][2 * j] = expr + sym.I * z\n                hessian[2 * i][2 * j + 1] = expr - sym.I * z\n            else:\n                hessian[2 * i][2 * j + 1] = expr\n                hessian[2 * j + 1][2 * i] = expr\n\n                expr = sym.diff(sym.diff(energy, phi_i), theta_j)\n                hessian[2 * i + 1][2 * j] = expr\n                hessian[2 * j][2 * i + 1] = expr\n\n    hes = sym.ImmutableMatrix(hessian)\n    _, U, _ = hes.LUdecomposition()\n    return U.det().subs(subs)\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.dynamic_layer_solve","title":"<code>dynamic_layer_solve(eq)</code>","text":"<p>Return the FMR frequencies and modes for N layers using the dynamic RHS model</p> <p>Parameters:</p> Name Type Description Default <code>eq</code> <code>List[float]</code> <p>the equilibrium position of the system.</p> required <p>Returns:</p> Type Description <p>frequencies and eigenmode vectors.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def dynamic_layer_solve(self, eq: List[float]):\n    \"\"\"Return the FMR frequencies and modes for N layers using the\n    dynamic RHS model\n    :param eq: the equilibrium position of the system.\n    :return: frequencies and eigenmode vectors.\"\"\"\n    jac, symbols = self.compose_llg_jacobian(self.H)\n    subs = {symbols[i]: eq[i] for i in range(len(eq))}\n    jac = jac.subs(subs)\n    jac = np.asarray(jac, dtype=np.float32)\n    eigvals, eigvecs = np.linalg.eig(jac)\n    eigvals_im = np.imag(eigvals) / (2 * np.pi)\n    indx = np.argwhere(eigvals_im &gt; 0).ravel()\n    return eigvals_im[indx], eigvecs[indx]\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.get_gradient_expr","title":"<code>get_gradient_expr(accel='math')</code>","text":"<p>Returns the symbolic gradient of the energy expression.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def get_gradient_expr(self, accel=\"math\"):\n    \"\"\"Returns the symbolic gradient of the energy expression.\"\"\"\n    energy = self.create_energy(volumetric=False)\n    grad_vector = []\n    symbols = []\n    for layer in self.layers:\n        (theta, phi) = layer.get_coord_sym()\n        grad_vector.extend((sym.diff(energy, theta), sym.diff(energy,\n                                                              phi)))\n        symbols.extend((theta, phi))\n    return sym.lambdify(symbols, grad_vector, accel)\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.get_layer_references","title":"<code>get_layer_references(layer_indx, interaction_constant)</code>","text":"<p>Returns the references to the layers above and below the layer with index layer_indx.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def get_layer_references(self, layer_indx, interaction_constant):\n    \"\"\"Returns the references to the layers above and below the layer\n    with index layer_indx.\"\"\"\n    if len(self.layers) == 1:\n        return None, None, 0, 0\n    if layer_indx == 0:\n        return None, self.layers[layer_indx +\n                                 1], 0, interaction_constant[0]\n    elif layer_indx == len(self.layers) - 1:\n        return self.layers[layer_indx -\n                           1], None, interaction_constant[-1], 0\n    return self.layers[layer_indx - 1], self.layers[\n        layer_indx +\n        1], interaction_constant[layer_indx -\n                                 1], interaction_constant[layer_indx]\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.get_ms_subs","title":"<code>get_ms_subs()</code>","text":"<p>Returns a dictionary of substitutions for the Ms symbols.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def get_ms_subs(self):\n    \"\"\"Returns a dictionary of substitutions for the Ms symbols.\"\"\"\n    a = {r\"M_{\" + str(layer._id) + \"}\": layer.Ms for layer in self.layers}\n    b = {\n        r\"t_{\" + str(layer._id) + r\"}\": layer.thickness\n        for layer in self.layers\n    }\n    return a | b\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.get_subs","title":"<code>get_subs(equilibrium_position)</code>","text":"<p>Returns the substitution dictionary for the energy expression.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def get_subs(self, equilibrium_position: List[float]):\n    \"\"\"Returns the substitution dictionary for the energy expression.\"\"\"\n    subs = {}\n    for i in range(len(self.layers)):\n        theta, phi = self.layers[i].get_coord_sym()\n        subs[theta] = equilibrium_position[2 * i]\n        subs[phi] = equilibrium_position[(2 * i) + 1]\n    return subs\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.set_H","title":"<code>set_H(H)</code>","text":"<p>Sets the external field.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def set_H(self, H: VectorObj):\n    \"\"\"Sets the external field.\"\"\"\n    self.H = H\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.single_layer_resonance","title":"<code>single_layer_resonance(layer_indx, eq_position)</code>","text":"<p>We can compute the equilibrium position of a single layer directly.</p> <p>Parameters:</p> Name Type Description Default <code>layer_indx</code> <code>int</code> <p>the index of the layer to compute the equilibrium</p> required <code>eq_position</code> <code>np.ndarray</code> <p>the equilibrium position vector</p> required Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def single_layer_resonance(self, layer_indx: int, eq_position: np.ndarray):\n    \"\"\"We can compute the equilibrium position of a single layer directly.\n    :param layer_indx: the index of the layer to compute the equilibrium\n    :param eq_position: the equilibrium position vector\"\"\"\n    layer = self.layers[layer_indx]\n    theta_eq = eq_position[2 * layer_indx]\n    theta, phi = self.layers[layer_indx].get_coord_sym()\n    energy = self.create_energy(volumetric=True)\n    subs = self.get_subs(eq_position)\n    d2Edtheta2 = sym.diff(sym.diff(energy, theta), theta).subs(subs)\n    d2Edphi2 = sym.diff(sym.diff(energy, phi), phi).subs(subs)\n    # mixed, assuming symmetry\n    d2Edthetaphi = sym.diff(sym.diff(energy, theta), phi).subs(subs)\n    vareps = 1e-18\n\n    fmr = (d2Edtheta2 * d2Edphi2 - d2Edthetaphi**2) / np.power(\n        np.sin(theta_eq + vareps) * layer.Ms, 2)\n    fmr = np.sqrt(float(fmr)) * gamma_rad / (2 * np.pi)\n    return fmr\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.solve","title":"<code>solve(init_position, max_steps=1000000000.0, learning_rate=0.0001, adam_tol=1e-08, first_momentum_decay=0.9, second_momentum_decay=0.999, perturbation=0.001, ftol=10000000.0, max_freq=80000000000.0, force_single_layer=False, force_sb=False)</code>","text":"<p>Solves the system. 1. Computes the energy functional. 2. Computes the gradient of the energy functional. 3. Performs a gradient descent to find the equilibrium position. Returns the equilibrium position and frequencies in [GHz]. If there's only one layer, the frequency is computed analytically. For full analytical solution, see: <code>analytical_field_scan</code></p> <p>Parameters:</p> Name Type Description Default <code>init_position</code> <code>np.ndarray</code> <p>initial position for the gradient descent. Must be a 1D array of size 2 * number of layers (theta, phi)</p> required <code>max_steps</code> <code>int</code> <p>maximum number of gradient steps.</p> <code>1000000000.0</code> <code>learning_rate</code> <code>float</code> <p>the learning rate (descent speed).</p> <code>0.0001</code> <code>adam_tol</code> <code>float</code> <p>tolerance for the consecutive Adam minima.</p> <code>1e-08</code> <code>first_momentum_decay</code> <code>float</code> <p>constant for the first momentum.</p> <code>0.9</code> <code>second_momentum_decay</code> <code>float</code> <p>constant for the second momentum.</p> <code>0.999</code> <code>perturbation</code> <code>float</code> <p>the perturbation to use for the numerical gradient computation.</p> <code>0.001</code> <code>ftol</code> <code>float</code> <p>tolerance for the frequency search. [numerical only]</p> <code>10000000.0</code> <code>max_freq</code> <code>float</code> <p>maximum frequency to search for. [numerical only]</p> <code>80000000000.0</code> <code>force_single_layer</code> <code>bool</code> <p>whether to force the computation of the frequencies for each layer individually.</p> <code>False</code> <code>force_sb</code> <code>bool</code> <p>whether to force the computation of the frequencies. Takes effect only if the layers are LayerDynamic, not LayerSB.</p> <code>False</code> <p>Returns:</p> Type Description <p>equilibrium position and frequencies in [GHz] (and eigenvectors if LayerDynamic instead of LayerSB).</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def solve(self,\n          init_position: np.ndarray,\n          max_steps: int = 1e9,\n          learning_rate: float = 1e-4,\n          adam_tol: float = 1e-8,\n          first_momentum_decay: float = 0.9,\n          second_momentum_decay: float = 0.999,\n          perturbation: float = 1e-3,\n          ftol: float = 0.01e9,\n          max_freq: float = 80e9,\n          force_single_layer: bool = False,\n          force_sb: bool = False):\n    \"\"\"Solves the system.\n    1. Computes the energy functional.\n    2. Computes the gradient of the energy functional.\n    3. Performs a gradient descent to find the equilibrium position.\n    Returns the equilibrium position and frequencies in [GHz].\n    If there's only one layer, the frequency is computed analytically.\n    For full analytical solution, see: `analytical_field_scan`\n    :param init_position: initial position for the gradient descent.\n                          Must be a 1D array of size 2 * number of layers (theta, phi)\n    :param max_steps: maximum number of gradient steps.\n    :param learning_rate: the learning rate (descent speed).\n    :param adam_tol: tolerance for the consecutive Adam minima.\n    :param first_momentum_decay: constant for the first momentum.\n    :param second_momentum_decay: constant for the second momentum.\n    :param perturbation: the perturbation to use for the numerical gradient computation.\n    :param ftol: tolerance for the frequency search. [numerical only]\n    :param max_freq: maximum frequency to search for. [numerical only]\n    :param force_single_layer: whether to force the computation of the frequencies\n                               for each layer individually.\n    :param force_sb: whether to force the computation of the frequencies.\n                    Takes effect only if the layers are LayerDynamic, not LayerSB.\n    :return: equilibrium position and frequencies in [GHz] (and eigenvectors if LayerDynamic instead of LayerSB).\n    \"\"\"\n    if self.H is None:\n        raise ValueError(\n            \"H must be set before solving the system numerically.\")\n    eq = self.adam_gradient_descent(\n        init_position=init_position,\n        max_steps=max_steps,\n        tol=adam_tol,\n        learning_rate=learning_rate,\n        first_momentum_decay=first_momentum_decay,\n        second_momentum_decay=second_momentum_decay,\n        perturbation=perturbation)\n    if not force_sb and isinstance(self.layers[0], LayerDynamic):\n        eigenvalues, eigenvectors = self.dynamic_layer_solve(eq)\n        return eq, eigenvalues / 1e9, eigenvectors\n    N = len(self.layers)\n    if N == 1:\n        return eq, [self.single_layer_resonance(0, eq) / 1e9]\n    if force_single_layer:\n        frequencies = []\n        for indx in range(N):\n            frequency = self.single_layer_resonance(indx, eq) / 1e9\n            frequencies.append(frequency)\n        return eq, frequencies\n    return self.num_solve(eq, ftol=ftol, max_freq=max_freq)\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.fast_norm","title":"<code>fast_norm(x)</code>","text":"<p>Fast norm function for 1D arrays.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>@njit\ndef fast_norm(x):  # sourcery skip: for-index-underscore, sum-comprehension\n    \"\"\"Fast norm function for 1D arrays.\"\"\"\n    sum_ = 0\n    for x_ in x:\n        sum_ += x_**2\n    return math.sqrt(sum_)\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.general_hessian_functional","title":"<code>general_hessian_functional(N)</code>  <code>cached</code>","text":"<p>Create a generalised hessian functional for N layers.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>number of layers. ! WARNING: remember Ms Symbols must match!!!</p> required Source code in <code>cmtj/models/general_sb.py</code> <pre><code>@lru_cache\ndef general_hessian_functional(N: int):\n    \"\"\"Create a generalised hessian functional for N layers.\n    :param N: number of layers.\n    ! WARNING: remember Ms Symbols must match!!!\n    \"\"\"\n    all_symbols = []\n    for i in range(N):\n        # indx_i = str(i + 1) # for display purposes\n        indx_i = str(i)\n        all_symbols.extend(\n            (sym.Symbol(r\"\\theta_\" + indx_i), sym.Symbol(r\"\\phi_\" + indx_i)))\n    energy_functional_expr = sym.Function(\"E\")(*all_symbols)\n    return get_hessian_from_energy_expr(\n        N, energy_functional_expr), energy_functional_expr\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.get_all_second_derivatives","title":"<code>get_all_second_derivatives(energy_functional_expr, energy_expression, subs={})</code>","text":"<p>Get all second derivatives of the energy expression.</p> <p>Parameters:</p> Name Type Description Default <code>energy_functional_expr</code> <p>symbolic energy_functional expression</p> required <code>energy_expression</code> <p>symbolic energy expression (from solver)</p> required <code>subs</code> <p>substitutions to be made.</p> <code>{}</code> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def get_all_second_derivatives(energy_functional_expr,\n                               energy_expression,\n                               subs={}):\n    \"\"\"Get all second derivatives of the energy expression.\n    :param energy_functional_expr: symbolic energy_functional expression\n    :param energy_expression: symbolic energy expression (from solver)\n    :param subs: substitutions to be made.\"\"\"\n    second_derivatives = subs\n    symbols = energy_expression.free_symbols\n    for i, s1 in enumerate(symbols):\n        for j, s2 in enumerate(symbols):\n            if i &lt;= j:\n                org_diff = sym.diff(energy_functional_expr, s1, s2)\n                if subs is not None:\n                    second_derivatives[org_diff] = sym.diff(\n                        energy_expression, s1, s2).subs(subs)\n                else:\n                    second_derivatives[org_diff] = sym.diff(\n                        energy_expression, s1, s2)\n    return second_derivatives\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.get_hessian_from_energy_expr","title":"<code>get_hessian_from_energy_expr(N, energy_functional_expr)</code>  <code>cached</code>","text":"<p>Computes the Hessian matrix of the energy functional expression with respect to the spin angles and phases.</p> <p>Parameters:</p> Name Type Description Default <code>(int)</code> <code>N</code> <p>The number of spins.</p> required <code>(sympy.Expr)</code> <code>energy_functional_expr</code> <p>The energy functional expression.  returns: sympy.Matrix: The Hessian matrix of the energy functional expression.</p> required Source code in <code>cmtj/models/general_sb.py</code> <pre><code>@lru_cache\ndef get_hessian_from_energy_expr(N: int, energy_functional_expr: sym.Expr):\n    \"\"\"\n    Computes the Hessian matrix of the energy functional expression with respect to the spin angles and phases.\n\n    :param N (int): The number of spins.\n    :param energy_functional_expr (sympy.Expr): The energy functional expression.\n\n    returns: sympy.Matrix: The Hessian matrix of the energy functional expression.\n    \"\"\"\n    hessian = [[0 for _ in range(2 * N)] for _ in range(2 * N)]\n    for i in range(N):\n        # indx_i = str(i + 1) # for display purposes\n        indx_i = str(i)\n        # z = sym.Symbol(\"Z\")\n        # these here must match the Ms symbols!\n        z = sym.Symbol(\n            r\"\\omega\") * sym.Symbol(r\"M_{\" + indx_i + \"}\") * sym.sin(\n                sym.Symbol(r\"\\theta_\" + indx_i)) * sym.Symbol(r\"t_{\" + indx_i +\n                                                              \"}\")\n        for j in range(i, N):\n            # indx_j = str(j + 1) # for display purposes\n            indx_j = str(j)\n            s1 = sym.Symbol(r\"\\theta_\" + indx_i)\n            s2 = sym.Symbol(r\"\\theta_\" + indx_j)\n\n            expr = sym.diff(energy_functional_expr, s1, s2)\n            hessian[2 * i][2 * j] = expr\n            hessian[2 * j][2 * i] = expr\n            s1 = sym.Symbol(r\"\\phi_\" + indx_i)\n            s2 = sym.Symbol(r\"\\phi_\" + indx_j)\n            expr = sym.diff(energy_functional_expr, s1, s2)\n            hessian[2 * i + 1][2 * j + 1] = expr\n            hessian[2 * j + 1][2 * i + 1] = expr\n\n            s1 = sym.Symbol(r\"\\theta_\" + indx_i)\n            s2 = sym.Symbol(r\"\\phi_\" + indx_j)\n            expr = sym.diff(energy_functional_expr, s1, s2)\n            if i == j:\n                hessian[2 * i + 1][2 * j] = expr + sym.I * z\n                hessian[2 * i][2 * j + 1] = expr - sym.I * z\n            else:\n                hessian[2 * i][2 * j + 1] = expr\n                hessian[2 * j + 1][2 * i] = expr\n\n                s1 = sym.Symbol(r\"\\phi_\" + indx_i)\n                s2 = sym.Symbol(r\"\\theta_\" + indx_j)\n                expr = sym.diff(energy_functional_expr, s1, s2)\n                hessian[2 * i + 1][2 * j] = expr\n                hessian[2 * j][2 * i + 1] = expr\n    return sym.Matrix(hessian)\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.real_deocrator","title":"<code>real_deocrator(fn)</code>","text":"<p>Using numpy real cast is way faster than sympy.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def real_deocrator(fn):\n    \"\"\"Using numpy real cast is way faster than sympy.\"\"\"\n\n    def wrap_fn(*args):\n        return np.real(fn(*args))\n\n    return wrap_fn\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.solve_for_determinant","title":"<code>solve_for_determinant(N)</code>  <code>cached</code>","text":"<p>Solve for the determinant of the hessian functional.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>number of layers.</p> required Source code in <code>cmtj/models/general_sb.py</code> <pre><code>@lru_cache()\ndef solve_for_determinant(N: int):\n    \"\"\"Solve for the determinant of the hessian functional.\n    :param N: number of layers.\n    \"\"\"\n    hessian, energy_functional_expr = general_hessian_functional(N)\n    if N == 1:\n        return hessian.det(), energy_functional_expr\n\n    # LU decomposition\n    _, U, _ = hessian.LUdecomposition()\n    return U.det(), energy_functional_expr\n</code></pre>"},{"location":"gen-docs/cmtj/","title":"Core","text":""},{"location":"gen-docs/cmtj/#axialdriver","title":"<code>AxialDriver</code>","text":""},{"location":"gen-docs/cmtj/#axis","title":"<code>Axis</code>","text":""},{"location":"gen-docs/cmtj/#cvector","title":"<code>CVector</code>","text":""},{"location":"gen-docs/cmtj/#junction","title":"<code>Junction</code>","text":""},{"location":"gen-docs/cmtj/#__init__self-layers-listlayer-filename-str-none-overloaddef-__init__self-layers-listlayer-filename-str-rp-float-rap-float-none-overloaddef-__init__selflayers-listlayerfilename-strrx0-listfloatry0-listfloatamr_x-listfloatamr_y-listfloatsmr_x-listfloatsmr_y-listfloatahe-listfloat","title":"<code>__init__(self, layers: List[Layer], filename: str = ...) -&gt; None: ...@overloaddef __init__(self, layers: List[Layer], filename: str, Rp: float = ..., Rap: float = ...) -&gt; None: ...@overloaddef __init__(self,layers: List[Layer],filename: str,Rx0: List[float],Ry0: List[float],AMR_X: List[float],AMR_Y: List[float],SMR_X: List[float],SMR_Y: List[float],AHE: List[float],)</code>","text":"<p>Creates a junction with a STRIP magnetoresistance. Each of the Rx0, Ry, AMR, AMR and SMR is list matching the length of the layers passed (they directly correspond to each layer). Calculates the magnetoresistance as per: see reference: Spin Hall magnetoresistance in metallic bilayers by Kim, J. et al.</p>"},{"location":"gen-docs/cmtj/#__init__args-kwargs-any-def-clearlogself","title":"<code>__init__(*args, **kwargs) -&gt; Any: ...def clearLog(self)</code>","text":"<p>Reset current simulation state`</p>"},{"location":"gen-docs/cmtj/#getlayermagnetisationself-layer_id-str-cvector-def-getlogself","title":"<code>getLayerMagnetisation(self, layer_id: str) -&gt; CVector: ...def getLog(self)</code>","text":"<p>Retrieve the simulation log [data].</p>"},{"location":"gen-docs/cmtj/#getmagnetoresistanceself-listfloat-def-runsimulationselftotaltime-floattimestep-float-writefrequency-float-persist-bool-log-bool-calculateenergies-bool","title":"<code>getMagnetoresistance(self) -&gt; List[float]: ...def runSimulation(self,totalTime: float,timeStep: float = ...,writeFrequency: float = ...,persist: bool = ...,log: bool = ...,calculateEnergies: bool = ...,)</code>","text":"<p>Main run simulation function. Use it to run the simulation.</p>"},{"location":"gen-docs/cmtj/#parameters","title":"Parameters","text":"Name Type Description Default <code>totalTime</code> <code>-</code> total time of a simulation, give it in seconds. Typical length is in ~couple ns. <code>-</code> <code>timeStep</code> <code>-</code> the integration step of the RK45 method. Default is 1e-13 <code>-</code> <code>writeFrequency</code> <code>-</code> how often is the log saved to? Must be no smaller than <code>timeStep</code>. Default is 1e-11. <code>-</code> <code>persist</code> <code>-</code> whether to save to the filename specified in the Junction constructor. Default is true <code>-</code> <code>log</code> <code>-</code> if you want some verbosity like timing the simulation. Default is false <code>-</code>"},{"location":"gen-docs/cmtj/#setiecdriverself-bottom_layer-str-top_layer-str-driver-scalardriver","title":"<code>setIECDriver(self, bottom_layer: str, top_layer: str, driver: ScalarDriver)</code>","text":"<p>Set IEC interaction between two layers. The names of the params are only for convention. The IEC will be set between bottomLyaer or topLayer, order is irrelevant.</p>"},{"location":"gen-docs/cmtj/#parameters_1","title":"Parameters","text":"Name Type Description Default <code>bottomLayer</code> <code>-</code> the first layer id <code>-</code>"},{"location":"gen-docs/cmtj/#layer","title":"<code>Layer</code>","text":""},{"location":"gen-docs/cmtj/#__init__selfid-strmag-cvectoranis-cvectorms-floatthickness-floatcellsurface-floatdemagtensor-listcvectortemperature-float-damping-float","title":"<code>__init__(self,id: str,mag: CVector,anis: CVector,Ms: float,thickness: float,cellSurface: float,demagTensor: List[CVector],temperature: float = ...,damping: float = ...,)</code>","text":"<p>The basic structure is a magnetic layer. Its parameters are defined by the constructor and may be altered by the drivers during the simulation time. If you want STT, remember to set the reference vector for the polarisation of the layer. Use <code>setReferenceLayer</code> function to do that.</p>"},{"location":"gen-docs/cmtj/#parameters_2","title":"Parameters","text":"Name Type Description Default <code>id</code> <code>str</code> identifiable name for a layer -- e.g. \"bottom\" or \"free\". <code>-</code> <code>mag</code> <code>CVector</code> initial magnetisation. Must be normalised (norm of 1). Used for quicker convergence. <code>-</code> <code>anis</code> <code>CVector</code> anisotropy of the layer. A normalised vector <code>-</code> <code>Ms</code> <code>float</code> magnetisation saturation. Unit: Tesla [T]. <code>-</code> <code>thickness</code> <code>float</code> thickness of the layer. Unit: meter [m]. <code>-</code> <code>cellSurface</code> <code>float</code> surface of the layer, for volume calculation. Unit: meter^2 [m^2]. <code>-</code> <code>dipoleTensor</code> <code>-</code> dipole tensor of the layer. <code>-</code>"},{"location":"gen-docs/cmtj/#nulldriverscalardriver","title":"<code>NullDriver(ScalarDriver)</code>","text":""},{"location":"gen-docs/cmtj/#__init__self","title":"<code>__init__(self)</code>","text":"<p>An empty driver that does nothing. Use in Axial Driver when the axis is to be id.</p>"},{"location":"gen-docs/cmtj/#scalardriver","title":"<code>ScalarDriver</code>","text":""},{"location":"gen-docs/cmtj/#getconstantdriverconstantvalue-float","title":"<code>getConstantDriver(constantValue: float)</code>","text":"<p>Constant driver produces a constant signal of a fixed amplitude.:param constantValue: constant value of the driver (constant offset/amplitude)</p>"},{"location":"gen-docs/cmtj/#getpulsedriverconstantvalue-float-amplitude-float-period-float-cycle-float","title":"<code>getPulseDriver(constantValue: float, amplitude: float, period: float, cycle: float)</code>","text":"<p>Produces a square pulse of certain period and cycle</p>"},{"location":"gen-docs/cmtj/#parameters_3","title":"Parameters","text":"Name Type Description Default <code>constantValue</code> <code>-</code> offset (vertical) of the pulse. The pulse amplitude will be added to this. <code>-</code> <code>amplitude</code> <code>-</code> amplitude of the pulse signal <code>-</code> <code>period</code> <code>-</code> period of the signal in seconds <code>-</code>"},{"location":"gen-docs/cmtj/#getsinedriverconstantvalue-float-amplitude-float-frequency-float-phase-float","title":"<code>getSineDriver(constantValue: float, amplitude: float, frequency: float, phase: float)</code>","text":"<p>Produces a sinusoidal signal with some offset (constantValue), amplitude frequency and phase offset.</p>"},{"location":"gen-docs/cmtj/#parameters_4","title":"Parameters","text":"Name Type Description Default <code>constantValue</code> <code>float</code> vertical offset. The sine will oscillate around this value. <code>-</code> <code>amplitude</code> <code>float</code> amplitude of the sine wave <code>-</code> <code>frequency</code> <code>float</code> frequency of the sine <code>-</code>"},{"location":"gen-docs/drivers/","title":"Drivers","text":""},{"location":"gen-docs/drivers/#axis","title":"<code>Axis</code>","text":""},{"location":"gen-docs/drivers/#nulldriverscalardriver","title":"<code>NullDriver(ScalarDriver)</code>","text":""},{"location":"gen-docs/drivers/#__init__self","title":"<code>__init__(self)</code>","text":"<p>An empty driver that does nothing. Use in Axial Driver when the axis is to be id.</p>"},{"location":"gen-docs/drivers/#scalardriver","title":"<code>ScalarDriver</code>","text":""},{"location":"gen-docs/drivers/#__init__self-args-kwargs-nonestaticmethoddef-getconstantdriverconstantvalue-float","title":"<code>__init__(self, *args, **kwargs) -&gt; None:...@staticmethoddef getConstantDriver(constantValue: float)</code>","text":"<p>Constant driver produces a constant signal of a fixed amplitude.</p>"},{"location":"gen-docs/drivers/#getpulsedriverconstantvalue-float-amplitude-scalardriver-period-float-cycle-float","title":"<code>getPulseDriver(constantValue: float, amplitude: 'ScalarDriver', period: float, cycle: float)</code>","text":"<p>Produces a square pulse of certain period and cycle</p>"},{"location":"gen-docs/drivers/#parameters","title":"Parameters","text":"Name Type Description Default <code>constantValue</code> <code>float</code> offset (vertical) of the pulse. The pulse amplitude will be added to this. <code>-</code> <code>amplitude</code> <code>'ScalarDriver'</code> amplitude of the pulse signal <code>-</code> <code>period</code> <code>float</code> period of the signal in seconds <code>-</code>"},{"location":"gen-docs/drivers/#getsinedriverconstantvalue-float-amplitude-scalardriver-frequency-float-phase-float","title":"<code>getSineDriver(constantValue: float, amplitude: 'ScalarDriver', frequency: float, phase: float)</code>","text":"<p>Produces a sinusoidal signal with some offset (constantValue), amplitude frequency and phase offset.</p>"},{"location":"gen-docs/drivers/#parameters_1","title":"Parameters","text":"Name Type Description Default <code>constantValue</code> <code>float</code> vertical offset. The sine will oscillate around this value. <code>-</code> <code>amplitude</code> <code>'ScalarDriver'</code> amplitude of the sine wave <code>-</code> <code>frequency</code> <code>float</code> frequency of the sine <code>-</code>"},{"location":"gen-docs/drivers/#getstepdriverconstantvalue-float-amplitude-float-timestart-float-timestop-float","title":"<code>getStepDriver(constantValue: float, amplitude: float, timeStart: float, timeStop: float)</code>","text":"<p>Get a step driver. It has amplitude between timeStart and timeStop and 0 elsewhere</p>"},{"location":"gen-docs/drivers/#parameters_2","title":"Parameters","text":"Name Type Description Default <code>constantValue</code> <code>float</code> offset of the pulse (vertical) <code>-</code> <code>amplitude</code> <code>float</code> amplitude that is added on top of the constantValue <code>-</code> <code>timeStart</code> <code>float</code> start of the pulse <code>-</code>"},{"location":"gen-docs/drivers/#axialdriver","title":"<code>AxialDriver</code>","text":"<p>Requires three scalar drivers, one for each axis.</p>"},{"location":"gen-docs/drivers/#__init__self-x-scalardriver-y-scalardriver-z-scalardriver","title":"<code>__init__(self, x: 'ScalarDriver', y: 'ScalarDriver', z: 'ScalarDriver')</code>","text":""},{"location":"gen-docs/stack/","title":"Stack","text":""},{"location":"gen-docs/stack/#parallelstack","title":"<code>ParallelStack</code>","text":""},{"location":"gen-docs/stack/#__init__self-junctionlist-listcmtjjunction","title":"<code>__init__(self, junctionList: List[cmtj.Junction])</code>","text":"<p>Initialises a parallel connection of junctions.</p>"},{"location":"gen-docs/stack/#clearlogsself","title":"<code>clearLogs(self)</code>","text":"<p>Clear all the logs, both of the stack and the junctions that constitute the stack.</p>"},{"location":"gen-docs/stack/#getlogself-junctionid-int","title":"<code>getLog(self, junctionId: int)</code>","text":"<p>Get the logs of a specific junction -- integer id from the <code>junctionList</code>.</p>"},{"location":"gen-docs/stack/#getlogself","title":"<code>getLog(self)</code>","text":"<p>Get the logs of the stack</p>"},{"location":"gen-docs/stack/#runsimulationself-totaltime-float-timestep-float-writefrequency-float","title":"<code>runSimulation(self, totalTime: float, timeStep: float = ..., writeFrequency: float = ...)</code>","text":"<p>Run the simulation of the stack.</p>"},{"location":"gen-docs/stack/#parameters","title":"Parameters","text":"Name Type Description Default <code>totalTime</code> <code>float</code> total time of a simulation, give it in seconds. Typical length is in ~couple ns. <code>-</code> <code>timeStep</code> <code>float</code> the integration step of the RK45 method. Default is 1e-13 <code>...</code>"},{"location":"gen-docs/stack/#setcoupledcurrentdriverself-driver-cmtjscalardriver","title":"<code>setCoupledCurrentDriver(self, driver: cmtj.ScalarDriver)</code>","text":"<p>Sets a global current driver for all junctions inside the stack. Keep in mind the current passed down the stack will be modified by the coupling constant.</p>"},{"location":"gen-docs/stack/#setcouplingstrengthself-coupling-float","title":"<code>setCouplingStrength(self, coupling: float)</code>","text":"<p>Coupling constant that represents the energy losses as the current passes through the stack.</p>"},{"location":"gen-docs/stack/#setexternalfielddriverself-driver-cmtjaxialdriver","title":"<code>setExternalFieldDriver(self, driver: cmtj.AxialDriver)</code>","text":"<p>Sets a external field current driver for all junctions inside the stack.</p>"},{"location":"gen-docs/stack/#setmagnetistationself-juncionid-int-layerid-str-mag-cmtjcvector","title":"<code>setMagnetistation(self, juncionId: int, layerId: str, mag: cmtj.CVector)</code>","text":"<p>Set magnetisation on a specific layer in a specific junction.</p>"},{"location":"gen-docs/stack/#parameters_1","title":"Parameters","text":"Name Type Description Default <code>junctionId</code> <code>-</code> the id of the junction (int) as passed in the init. <code>-</code> <code>layerId</code> <code>str</code> the string id of the layer in the junction. <code>-</code>"},{"location":"gen-docs/stack/#seriesstack","title":"<code>SeriesStack</code>","text":""},{"location":"gen-docs/stack/#__init__self-junctionlist-listcmtjjunction_1","title":"<code>__init__(self, junctionList: List[cmtj.Junction])</code>","text":"<p>Initialises a series connection of junctions.</p>"},{"location":"gen-docs/stack/#clearlogsself_1","title":"<code>clearLogs(self)</code>","text":"<p>Clear all the logs, both of the stack and the junctions that constitute the stack.</p>"},{"location":"gen-docs/stack/#getlogself-junctionid-int_1","title":"<code>getLog(self, junctionId: int)</code>","text":"<p>Get the logs of a specific junction -- integer id from the <code>junctionList</code>.</p>"},{"location":"gen-docs/stack/#getlogself_1","title":"<code>getLog(self)</code>","text":"<p>Get the logs of the stack</p>"},{"location":"gen-docs/stack/#runsimulationself-totaltime-float-timestep-float-writefrequency-float_1","title":"<code>runSimulation(self, totalTime: float, timeStep: float = ..., writeFrequency: float = ...)</code>","text":"<p>Run the simulation of the stack.</p>"},{"location":"gen-docs/stack/#parameters_2","title":"Parameters","text":"Name Type Description Default <code>totalTime</code> <code>float</code> total time of a simulation, give it in seconds. Typical length is in ~couple ns. <code>-</code> <code>timeStep</code> <code>float</code> the integration step of the RK45 method. Default is 1e-13 <code>...</code>"},{"location":"gen-docs/stack/#setcoupledcurrentdriverself-driver-cmtjscalardriver_1","title":"<code>setCoupledCurrentDriver(self, driver: cmtj.ScalarDriver)</code>","text":"<p>Sets a global current driver for all junctions inside the stack. Keep in mind the current passed down the stack will be modified by the coupling constant.</p>"},{"location":"gen-docs/stack/#setcouplingstrengthself-coupling-float_1","title":"<code>setCouplingStrength(self, coupling: float)</code>","text":"<p>Coupling constant that represents the energy losses as the current passes through the stack.</p>"},{"location":"gen-docs/stack/#setexternalfielddriverself-driver-cmtjaxialdriver_1","title":"<code>setExternalFieldDriver(self, driver: cmtj.AxialDriver)</code>","text":"<p>Sets a external field current driver for all junctions inside the stack.</p>"},{"location":"gen-docs/stack/#setmagnetistationself-juncionid-int-layerid-str-mag-cmtjcvector_1","title":"<code>setMagnetistation(self, juncionId: int, layerId: str, mag: cmtj.CVector)</code>","text":"<p>Set magnetisation on a specific layer in a specific junction.</p>"},{"location":"gen-docs/stack/#parameters_3","title":"Parameters","text":"Name Type Description Default <code>junctionId</code> <code>-</code> the id of the junction (int) as passed in the init. <code>-</code> <code>layerId</code> <code>str</code> the string id of the layer in the junction. <code>-</code>"},{"location":"physics/contributions/","title":"Introduction","text":"<p>In the macromagnetic simulations we distinguish between the following contributions that constitute the \\(\\mathbf{H}_\\textrm{eff}\\):</p> \\[     \\mathbf{H}_\\textrm{eff} = \\mathbf{H}_\\textrm{ext} + \\mathbf{H}_\\textrm{IEC} +     \\mathbf{H}_\\textrm{Oe} +     \\mathbf{H}_\\textrm{K} +     \\mathbf{H}_\\textrm{demag} +     \\mathbf{H}_\\textrm{dipole} +     \\mathbf{H}_\\textrm{th}^* +     \\mathbf{H}_\\textrm{1/f}^* \\] <p>where each component corresponds, respectively, to the applied external field, interlayer exchange coupling (IEC), Oersted field, anisotropy field, demagnetising, dipole, thermal, and \\(1/f\\) noise field. The \\(^*\\) superscripts denote the stochastic contributions (those require a stochastic solver, more on that in the Macromagnetic models section).</p>"},{"location":"physics/contributions/#in-api-classification","title":"In-API classification","text":"<p>We will go through the contributions step by step. However, before we do that, it is useful to mention that the contributions can be divided into 3 categories with respect to their relationship with a <code>Driver</code> system:</p> <ol> <li><code>ScalarDriver</code> driven contributions: \\(\\mathbf{H}_\\textrm{K}\\), \\(\\mathbf{H}_\\textrm{th}\\), and \\(\\mathbf{H}_\\textrm{IEC}\\)    Those contributions have their magnitude changed only. The exception is \\(\\mathbf{H}_\\textrm{K}\\) which has a constant axis passed in the constructor of a <code>Layer</code> object. Other than that, only the magnitude of those effect may be controlled, their direction is computed internally, as it depends on the \\(\\mathbf{m}\\) vectors.</li> <li><code>AxialDriver</code> driven contributions: \\(\\mathbf{H}_\\textrm{ext}\\), \\(\\mathbf{H}_\\textrm{Oe}\\).    Axial contributions can have magntidue controllers in any of the 3 directions, along x, y and z axis. Since <code>AxialDriver</code> consists of 3 <code>ScalarDrivers</code> (one for each axis), it is easy to manipulate each axis independently, magnitudewise.</li> <li>static contributions \\({H}_\\textrm{dipole}\\), and \\(\\mathbf{H}_\\textrm{demag}\\).    Static contributions are not driven by any <code>Driver</code> system, they are simply added to the \\(\\mathbf{H}_\\textrm{eff}\\) field. This may be subject to change in future API versions.</li> </ol> <p>Note</p> <p>Almost every contribution may be set either using <code>Layer</code> api or <code>Junction</code> api. They both have the same set of arguments, and the naming convention is such that if e.g. <code>Layer</code> has a method <code>setContribution</code>, then <code>Junction</code> has a method <code>setLayerContribution</code> and requires one additional argument specyfing the layer id (or <code>all</code> if it is to be set for all layers in the <code>Junction</code>). There are some exceptions to this, e.g. <code>setLayerIEC</code>, which is only defined for two or more layers, therefore it cannot be set from a <code>Layer</code> object.</p>"},{"location":"physics/contributions/#external-field","title":"External field","text":"<p>The external field is the simplest contribution to the effective field. It is the sum of the applied fields.</p> Name Unit Description \\(H_\\textrm{x}\\) A/m Value of field in x direction \\(H_\\textrm{y}\\) A/m Value of field in y direction \\(H_\\textrm{z}\\) A/m Value of field in y direction <pre><code>layer.setExternalFieldDriver(\n    AxialDriver(\n        ScalarDriver.getConstantDriver(100),\n        ScalarDriver.getConstantDriver(0),\n        ScalarDriver.getSineDriver(0, 300, 20e39, 0)\n    )\n)\n</code></pre> <p>or for the <code>Junctions</code> api:</p> <pre><code>device.setLayerExternalFieldDriver(\n    \"free\", # this value of course depends on the layer id\n    AxialDriver(\n        ScalarDriver.getConstantDriver(100),\n        ScalarDriver.getConstantDriver(0),\n        ScalarDriver.getSineDriver(0, 300, 20e39, 0)\n    )\n)\n</code></pre>"},{"location":"physics/contributions/#oersted-field","title":"Oersted field","text":"<p>The Oersted field is the field generated by the flow of current. Currently it is separated from the external field, but it is set the same way, irrespective of the actual current setting in the API. This may be subject to change.</p> Name Unit Description \\(H_\\textrm{x}\\) A/m Value of field in x direction \\(H_\\textrm{y}\\) A/m Value of field in y direction \\(H_\\textrm{z}\\) A/m Value of field in y direction <pre><code>layer.setOerstedFieldDriver(\n    AxialDriver(\n        ScalarDriver.getConstantDriver(100),\n        ScalarDriver.getConstantDriver(0),\n        ScalarDriver.getSineDriver(0, 300, 20e39, 0)\n    )\n)\n</code></pre> <p>or for the <code>Junctions</code> api:</p> <pre><code>device.setLayerOerstedFieldDriver(\n    \"free\", # this value of course depends on the layer id\n    AxialDriver(\n        ScalarDriver.getConstantDriver(100),\n        ScalarDriver.getConstantDriver(0),\n        ScalarDriver.getSineDriver(0, 300, 20e39, 0)\n    )\n)\n</code></pre>"},{"location":"physics/contributions/#exchange-field-iec","title":"Exchange field -- IEC","text":"<p>Interlayer exchange coupling is a scalar driven field contribution. It governs the RKKY-like interaction between magnetic layers.</p> Name Unit Description \\(J_\\textrm{linear}\\) \\(J/m^2\\) Linear value of the IEC contribution \\(J_\\textrm{quad}\\) \\(J/m^2\\) Linear value of the IEC contribution layerA <code>str</code> Layer id of a participating layer layerB <code>str</code> Layer id of other participating layer <p>Linear layer is being set with:</p> <pre><code>device.setIECDriver(\n    \"free\" # this value of course depends on the layer id\n    \"bottom\", # this value of course depends on the layer id\n    ScalarDriver.getConstantDriver(1e-4)\n)\n</code></pre> <p>and quadratic:</p> <pre><code>device.setQuadIECDriver(\n    \"free\" # this value of course depends on the layer id\n    \"bottom\", # this value of course depends on the layer id\n    ScalarDriver.getConstantDriver(1e-6)\n)\n</code></pre> <p>The resulting interaction field for layer 1 \\(\\mathbf{m}_1\\) is computed as:</p> \\[  \\mathbf{H}_{IEC,1} = -\\frac{1}{t_{FM} M_s}\\frac{\\partial E_{d, int}}{\\partial \\mathbf{m}_1} =     \\frac{1}{t_{FM} M_s}[J_\\textrm{linear}\\mathbf{m}_2 + 2J_\\textrm{quad} (\\mathbf{m}_1 \\cdot \\mathbf{m}_1)\\mathbf{m}_2] \\]"},{"location":"physics/contributions/#dipole-and-demag","title":"Dipole and demag","text":"<p>Those two contributions have different origins, but in <code>CMTJ</code> they share a similar api and way of computation. Both are given by tensors, and may be computed externally.</p> \\[     \\mathbf{H}_\\textrm{dipole} = -\\frac{M_\\textrm{s}}{\\mu_0}\\mathbf{N}_\\textrm{dipole}\\mathbf{m} \\] <p>where \\(\\mathbf{N}_\\textrm{dipole}\\) is the dipole tensor of the layer. The demag field is the same way, but with the tensor \\(\\mathbf{N}_\\textrm{demag}\\) of the layer. Since <code>demag</code> tensor is inherent to the geometry (shape) of the system, it is passed in the <code>Layer</code> object.</p> Name Unit Description \\(\\mathbf{N}_{inter}\\) - Tensor of the interaction for dipole or demag <p>The <code>dipole</code> depends on the external interaction and may be due any magnetic interaction a device or layer has with any other magnetic object. Therefore, it is passed in the <code>Layer</code> API as:</p> <pre><code>layer.setTopDipoleTensor(\n    [\n        CVector(0, 5e-8, 1e-24),\n        CVector(5e-8, -2e-6, 0),\n        CVector(1e-23, 0, 1e-23),\n    ]\n)\nlayer.setBottomDipoleTensor(\n    [\n        CVector(0, 5e-8, 1e-24),\n        CVector(5e-8, -2e-6, 0),\n        CVector(1e-23, 0, 1e-23),\n    ]\n)\n</code></pre> <p>Under the hood we simply sum the contributions from both:</p> \\[     \\mathbf{H}_\\textrm{dipole} = \\mathbf{H}_\\textrm{dipole, top} + \\mathbf{H}_\\textrm{dipole, bottom} \\] <p>We set for <code>top</code> and <code>bottom</code> separately since it may come for instance from top and bottom layer and thus top or bottom may be different. Effectively, you can just pass either, where you sum the dipole tensors and it'll have the same effect. However, API makes this convenient separation to logically separate those contributions.</p> <p>Note</p> <p>Dipole tensor for now is only set from the Layer API. We may add a function for adding it in the Junction API as well in near future.</p>"},{"location":"physics/contributions/#anisotropy","title":"Anisotropy","text":"<p>Anisotropy computation has two components -- axis \\(\\mathbf{a}\\) which is in CMTJ a vector, and value \\(K_\\textrm{u}\\) which is a scalar. The axis is passed in the <code>Layer</code> constructor under <code>anis</code> parameter. The scalar value, however, is driven with a <code>ScalarDriver</code> object and can be dynamically operated from either <code>Layer</code> or <code>Junction</code> API.</p> Name Unit Description \\(\\mathbf{K}_\\textrm{u}\\) \\(J/m^3\\) Value of the anisotropy constant <pre><code>layer.setAnisotropyDriver(\n    ScalarDriver.getConstantDriver(1e6)\n)\n</code></pre> <p>or <code>Junction</code> API:</p> <pre><code>device.setLayerAnisotropyDriver(\n    \"free\", # this value of course depends on the layer id\n    ScalarDriver.getConstantDriver(1e6)\n)\n</code></pre> <p>The resulting anisotropy field is computed as:</p> \\[     \\mathbf{H}_{\\textrm{anis}} = \\frac{2K_\\textrm{u}}{M_s}(\\mathbf{m}\\cdot\\mathbf{a})\\mathbf{a} \\]"},{"location":"physics/macromagnetic_models/","title":"Introduction","text":"<p>In this section we will walk through the basics of the LLG equation and the transformation to the LL-form of the LLG equation. The LLG equation is a proper equation in physical sense (derived from actual mechanics), whereas LL is simply a transformed approximation of the LLG equation that allows us to solve it numerically (no implicit term on \\(\\frac{dm}{dt}\\)).</p>"},{"location":"physics/macromagnetic_models/#landau-lifshitz-form-of-landau-lifshitz-gilbert-equation","title":"Landau Lifshitz form of Landau Lifshitz-Gilbert equation","text":"<p>Standard form of the LLG-SOT equation:</p> \\[\\frac{d\\textbf{m}}{dt} = -\\gamma \\textbf{m} \\times \\textbf{H}_{\\mathrm{eff}} + \\alpha \\textbf{m}\\times \\frac{d\\textbf{m}}{dt} -\\gamma|\\tau_{fl}|\\textbf{m} \\times \\phi-\\gamma|\\tau_{dl}|\\textbf{m}\\times\\textbf{m}\\times \\phi\\] <p>Multiply that equation \\(\\times m\\):</p> \\[ \\begin{gathered}        \\textbf{m} \\times \\frac{d\\textbf{m}}{dt} = -\\gamma  \\textbf{m} \\times\\textbf{m} \\times \\textbf{H}_{\\mathrm{eff}} + \\alpha \\textbf{m} \\times \\textbf{m}\\times \\frac{d\\textbf{m}}{dt}  -   \\gamma|\\tau_{fl}| \\textbf{m} \\times \\textbf{m} \\times \\phi-   \\gamma|\\tau_{dl}|\\textbf{m} \\times \\textbf{m}\\times\\textbf{m}\\times \\phi \\\\    \\textbf{m} \\times \\frac{d\\textbf{m}}{dt} = -\\gamma  \\textbf{m} \\times\\textbf{m} \\times \\textbf{H}_{\\mathrm{eff}} - \\alpha \\frac{d\\textbf{m}}{dt}  -  \\gamma|\\tau_{fl}| (\\textbf{m}(\\textbf{m}\\cdot\\phi) - \\phi) +   \\gamma|\\tau_{dl}|\\textbf{m}\\times \\phi\\end{gathered} \\] <p>Substitute RHS of the derived equation above into \\(\\textbf{m}\\times \\frac{d\\textbf{m}}{dt}\\):</p> \\[ \\begin{gathered}   \\frac{d\\textbf{m}}{dt} = -\\gamma \\textbf{m} \\times \\textbf{H}_{\\mathrm{eff}} + \\alpha [-\\gamma  \\textbf{m} \\times\\textbf{m} \\times \\textbf{H}_{\\mathrm{eff}} - \\alpha \\frac{d\\textbf{m}}{dt}  -  \\gamma|\\tau_{fl}| (\\textbf{m}(\\textbf{m}\\cdot\\phi) - \\phi) +   \\gamma|\\tau_{dl}|\\textbf{m}\\times \\phi] \\\\ -    \\gamma|\\tau_{fl}|\\textbf{m} \\times \\phi \\\\ -     \\gamma|\\tau_{dl}|\\textbf{m}\\times\\textbf{m}\\times \\phi \\\\      \\frac{d\\textbf{m}}{dt}(1 + \\alpha^2)  = -\\gamma \\textbf{m} \\times \\textbf{H}_{\\mathrm{eff}} - \\alpha\\gamma\\textbf{m}\\times\\textbf{m}\\times\\textbf{H}_{\\mathrm{eff}} \\\\      - \\gamma|\\tau_{fl}|[\\textbf{m} \\times \\phi  + \\alpha (\\textbf{m}(\\textbf{m}\\cdot\\phi) - \\phi) ] \\\\      -  \\gamma|\\tau_{dl}|[\\textbf{m}\\times\\textbf{m}\\times \\phi - \\alpha\\textbf{m}\\times \\phi]\\end{gathered} \\] <p>Rearranging the terms gives:</p> \\[ \\begin{aligned}     \\frac{d\\textbf{m}}{dt} = \\frac{-\\gamma}{1 + \\alpha^2}[\\textbf{m} \\times \\textbf{H}_{\\mathrm{eff}} + \\alpha\\textbf{m}\\times\\textbf{m}\\times\\textbf{H}_{\\mathrm{eff}} &amp;\\\\      + |\\tau_{fl}|[\\textbf{m} \\times \\phi  + \\alpha (\\textbf{m}(\\textbf{m}\\cdot\\phi) - \\phi) ] &amp;\\\\      +  |\\tau_{dl}|[\\textbf{m}\\times\\textbf{m}\\times \\phi - \\alpha\\textbf{m}\\times \\phi]]\\end{aligned} \\] <p>In this form, \\(\\gamma\\) is the gyromagnetic ratio and is equal to \\(\\gamma \\approx 2.2e5 \\frac{m}{As}\\). The last part can be re-arranged to:</p> \\[ \\begin{aligned} (...) + |\\tau_{fl}|[\\textbf{m} \\times \\phi  + \\alpha (\\textbf{m}(\\textbf{m}\\cdot\\phi) - \\phi) ] + |\\tau_{dl}|[\\textbf{m}\\times\\textbf{m}\\times\\phi - \\alpha\\textbf{m}\\times \\phi]]&amp;\\\\ = \\textbf{m} \\times \\phi(|\\tau_{fl}| - \\alpha|\\tau_{dl}|) + \\textbf{m}\\times\\textbf{m}\\times\\phi(|\\tau_{dl}| + \\alpha|\\tau_{fl}|)\\end{aligned} \\] <p>What is evident in this form of LL form of the LLG equation is the mixing of the torques with damping as the scaling factor (the field-like term for instance now becomes \\(|\\tau_{fl}| - \\alpha|\\tau_{dl}|\\)). Proper LL-form of the LLGS equation is:</p> \\[ (...)+ \\frac{-\\gamma}{1 + \\alpha^2}[     \\tau'_1 \\textbf{m}\\times(\\textbf{m}\\times \\phi)     + \\tau'_2 \\textbf{m}\\times \\phi] \\]"},{"location":"physics/macromagnetic_models/#stt-interaction","title":"STT interaction","text":"<p>The origin of STT is different, thus, we use a different set of quantities:</p> \\[ \\begin{gathered}     |H_{dl}| = \\beta |H_{fl}|, \\quad \\beta \\in [0, 1] \\\\     a_j = \\frac{\\hbar j_e}{eM_s t_{FM}} \\\\     \\eta = \\frac{\\sigma \\Lambda^2}{\\Lambda^2 + 1 + (\\Lambda^2 -1)\\textbf{m}\\cdot\\sigma}\\end{gathered} \\] <p>Given those two terms above, the non-torque part remains the same:</p> \\[... +  a_j\\eta\\beta\\textbf{m} \\times \\sigma + a_j\\eta\\textbf{m}\\times\\textbf{m}\\times \\sigma\\] <p>Then, equation only changes the coefficients scaling the damping-like and field-like torques.</p> <p>The LL form of the STT equation is:</p> \\[ \\begin{aligned} \\frac{d\\textbf{m}}{dt} = \\frac{-\\gamma}{1 + \\alpha^2}[\\textbf{m} \\times \\textbf{H}_{\\mathrm{eff}} + \\alpha\\textbf{m}\\times\\textbf{m}\\times\\textbf{H}_{\\mathrm{eff}} &amp;\\\\ + (-a_j (\\mathbf{m}\\times\\mathbf{p})  + a_j\\beta (\\mathbf{m}\\times\\mathbf{m}\\times\\mathbf{p})] \\end{aligned} \\] <p>where \\(\\(a_j =  \\gamma_0 \\eta \\frac{\\hbar j}{e M_\\mathrm{s} t_\\mathrm{FM}}\\)\\)</p>"},{"location":"physics/macromagnetic_models/#stochastic-llgs","title":"Stochastic LLGS","text":""},{"location":"physics/macromagnetic_models/#stratonovich-formulation-of-the-s-llgs-sde","title":"Stratonovich formulation of the s-LLGS SDE","text":"<p>A stochastic formulation of LLGS will take the form of a Stratonovich SDE:</p> \\[\\mathrm{d}X_t = f(X_t, t)dt + g(X_t, t)\\circ \\mathrm{d}W_t\\sqrt{\\Delta t}\\] <p>where \\(f(X_t, t)\\) is the deterministic part of the equation and \\(g(X_t, t)\\) is the stochastic part of the equation. \\(\\mathrm{d}W\\) is \\\"derivative-like\\\" of the Brownian motion. The symbol \\(\\circ\\) denotes the Stratonovich product which distinguishes it from Ito's SDE. By assuming that the effective field contains thermal fluctuations \\(\\mathbf{H}_{\\mathrm{eff}} \\rightarrow \\mathbf{H}_{\\mathrm{eff}} + \\mathbf{H}_{\\mathrm{T}}\\) we transform the standard LLGS equation into the form that fits Stratonovich SDE. The thermal fluctuations have zero mean and a preset standard deviation:</p> \\[\\sigma(t) = \\sqrt{\\frac{4\\alpha k_bT(t)}{M_sV\\gamma_0}}\\] <p>where \\(V\\) is the volume of the cell (layer), and \\(k_bT(t)\\) is the thermal energy of the system. As a result, \\(\\sigma(t)\\) should be dimensionless. Finally, we set \\(\\mathbf{f}(\\mathbf{m}_t, t)\\) to LL form where \\(\\mathbf{H}_{\\mathrm{eff}}\\) contains no stochastic (thermal) parts and the \\(g\\), the stochastic part, to the following:</p> \\[ \\mathbf{g}(\\mathbf{m}_t, t)\\circ\\mathrm{d}W  =     - \\frac{\\sigma\\gamma}{1+\\alpha^2}[\\mathbf{m}\\times\\mathrm{d}W + \\alpha\\mathbf{m}\\times(\\mathbf{m}\\times\\mathrm{d}W)] \\] <p>with \\(\\mathrm{d}W \\in \\mathbf{R}^3 \\sim \\sqrt{t}\\mathcal{N}(0, 1)\\), a multinomial Gaussian distributed random vector (here we make a transition from \\(W\\) being a generalised Brownian process to a Wiener process). For numerical solutions, we have have \\(\\Delta W\\) instead of \\(\\mathrm{d}W\\). \\(\\Delta W(t) = W(t + \\Delta t) - W(t)\\), where the stochastic vector is being drrawn from a normal distriubtion, with zero mean and unit variance: \\(\\xi_t \\in \\mathbf{R}^3 \\sim \\mathcal{N}(0, 1)\\). The form above follows from the distributive properties of cross-product over addition. Furthermore, there is some evidence that the second term in that equation should be skipped if the noise is sufficiently small which seems to be the case for up to room temperature experiments.</p>"},{"location":"physics/macromagnetic_models/#numerical-solutions","title":"Numerical solutions","text":"<p>We generally solve the stochastic model by either with Euler-Heun or Heun method.</p>"},{"location":"physics/macromagnetic_models/#euler-heun-method","title":"Euler-Heun method","text":"<p>This is in fact first order-method in the limit of 0 K. Euler-Heun method is suitable for Stratonovich SDEs as Euler-Maruyama can only be applied to Ito's SDEs. The update of the step is:</p> \\[Y_{n+1} = Y_n + f_n \\Delta t + \\frac{1}{2}[g_n + g_n(\\hat{Y}_n)]\\Delta W_n\\sqrt{\\Delta t}\\] <p>where \\(\\hat{Y}_n = Y_n + g_n\\Delta W_n\\). Contrary to the Milstein method, it is easier to the user the Euler-Heun due to the lack of quadratic terms of \\(\\Delta W_n\\). The cost is in the convergence order which is 0.5 for strong convergence and 1 for weak convergence. For the solution, we substitute \\(Y_n = \\mathbf{m_t}\\), \\(f_n = \\mathbf{f}_n(\\mathbf{m_t}, t)\\), \\(g_n= \\mathbf{g}_n(\\mathbf{m_t}, t)\\).</p>"},{"location":"physics/macromagnetic_models/#heun-method","title":"Heun method","text":"<p>Now preferred method to solve stochastic form of the LLG equation is the Heun method. It introduces second order correction to the non-stochastic part as well and therefore is deemed a better method.</p> \\[Y_{n+1} = Y_n + \\frac{1}{2}\\left[f_n(\\hat{Y}_{n+1}, t_{n+1}) + f_n(Y_n, t_n)\\right] + \\frac{1}{2}\\left[g_n(\\hat{Y}_{n+1}, g_{n+1}) + g_n(Y_n, t_n)\\right]\\Delta W_n\\] <p>where \\(\\hat{Y}_{n+1} = Y_n + f_n(Y_n, t_n)\\Delta t + g_n(Y_n, t_n)\\Delta W_n\\sqrt{\\Delta t}\\).</p>"},{"location":"physics/macromagnetic_models/#references","title":"References","text":"<p>Numerical Integration of SDEs: A Short Tutorial, Thomas Schaffter, January 19, 2010</p>"},{"location":"physics/paralellism/","title":"Parallelism in CMTJ","text":""},{"location":"physics/paralellism/#overview","title":"Overview","text":"<p><code>cmtj</code> provides a simple way to parallelise simulation sweeps. For instance, while performing the Voltage Spin Diode (VSD) experiments, we need to sweep the frequency and for each frequency value we further need to sweep with the field. For each field and frequency pair we need to compute the VSD DC resistance. Normally, this scales as \\(O(NK)\\) where \\(N\\) is the number of field values and \\(K\\) is the number of frequency values. However, with parallelism, we can reduce this to \\(O(K)\\) if we would be able to process each frequency value in parallel.</p> <p>In practice, we use worker pools which are approximately equal to the number of threads in the CPU. Each worker is assigned a frequency value and it computes the VSD DC resistance for all the field values. Whenever the worker is finished, it is assigned another frequency value.</p>"},{"location":"physics/paralellism/#general-caveats","title":"General caveats","text":"<p>Note</p> <p>Keep in mind that these issues are not specific to CMTJ, but are a general problem of any parallelisation.</p> <p>Before we move on to a specific example, let's discuss when we should be careful with simulating in parallel. When we sweep with an external field, which in the experiment is usually continously swept, we need to realise that if we were to compute the experiment for each separate field in a separate process, we would not carry the relaxed state of magnetisation computed in the previous field step to the next. This is of course a natural consequence of putting things in parallel and can be easily remedided by the following precautions:</p> <ul> <li>relax the magnetisation the magentisation in each parallel process by calling <code>runSimulation</code> for a short time, say between 1-5ns (depending on the complexity of the system),</li> <li>increase the simulation time, since reaching the stable state may take a little longer,</li> <li>decrease the time step (integration step) -- this is more costly computationally, but it is also ensuring absolute convergence.</li> </ul> <p>We generally recommend to use the <code>runSimulation</code> function to relax the magnetisation in each parallel process, and then to use the <code>runSimulation</code> function to compute the experiment in parallel. This is the most efficient way to do it, since short relaxation period does not incur a large computational cost, and because we paralellise the experiment anyway, that cost is offset by running on multiple threads.</p> <p>With this in mind, let's move on to a specific example.</p>"},{"location":"physics/paralellism/#problem-description","title":"Problem description","text":"<p>Suppose we want to compute the VSD DC resistance for a given frequency and field value, but also check how the VSD spectra differ for different values of the interlayer exchange coupling (IEC) constant <code>J</code>. What we want to effectively do is we want to fun a VSD experiment for each of the <code>J</code> values, wherein each experiment is a function of the frequency and field. Below, we outline the steps to parallelise such a problem.</p>"},{"location":"physics/paralellism/#parallelising-the-vsd-experiment","title":"Parallelising the VSD experiment","text":"<p>Here's what we need:</p> <ul> <li>A function that computes the VSD DC resistance for a given frequency and field value.</li> <li>A range of frequencies and fields.</li> <li>A distributing function that assigns the frequency and field values to the workers.</li> </ul> <p>The last point is taken care of by importing the <code>distribute</code> function from <code>cmtj.utils.parallel</code>. The <code>distribute</code> function takes a function and a list of arguments and distributes the arguments to the workers.</p> <p>An example function that computes the VSD DC resistance for a given system with a IEC constant <code>J</code> and for a specific frequency and field value:</p> <pre><code>def simulate_vsd(J, H, frequency):\n    \"\"\"\n    This function computes the VSD DC resistance for a\n    given frequency f and field value H.\n    It also takes the current coupling value J as an argument.\n    \"\"\"\n    int_step = 5e-13\n    demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)]\n\n    Ku = 0.8e3\n    alpha = 0.024  # 0.024\n    l1 = Layer(\n        \"free\",\n        mag=CVector(1, 0.1, 0.1),\n        anis=CVector(0, 1., 0.),  # direction of the anisotropy\n        Ms=1.03,\n        thickness=2.1e-9,\n        cellSurface=surf,\n        demagTensor=demag,\n        damping=alpha)\n\n    l2 = Layer(\n        \"bottom\",\n        mag=CVector(1, 0.1, 0.1),\n        anis=CVector(1, 0, 0),  # direction of the anisotropy\n        Ms=1.65,\n        thickness=6e-9,\n        cellSurface=surf,\n        demagTensor=demag,\n        damping=alpha)\n    j1 = Junction([l1, l2], 163.5, 176)\n    j1.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(Ku))\n    j1.setLayerAnisotropyDriver(\"bottom\", ScalarDriver.getConstantDriver(1e12))\n    j1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J))\n    hangle = FieldScan.angle2vector(90, 90, H)\n    j1.clearLog()\n    j1.setLayerExternalFieldDriver(\n        \"all\",\n        AxialDriver(ScalarDriver.getConstantDriver(hangle.x),\n                    ScalarDriver.getConstantDriver(hangle.y),\n                    ScalarDriver.getConstantDriver(hangle.z)))\n    j1.setLayerOerstedFieldDriver(\n        \"free\",\n        AxialDriver(\n            NullDriver(),\n            ScalarDriver.getSineDriver(0, 5, frequency, 0),\n            NullDriver(),\n        ))\n    j1.runSimulation(60e-9, int_step, int_step, solverMode=SolverMode.RK4)\n    log = j1.getLog()\n    dynamicR = log['R_free_bottom']\n\n    dynamicI = np.sin(2 * math.pi * frequency * np.asarray(log['time']))\n    vmix = compute_sd(dynamicR, dynamicI, int_step)\n    return vmix\n</code></pre> <p>Writing such functions is a good idea in general, since they can be also used in the normal serial processing as well. So a good practice is to write such a function first, test it in serial/iterative sweep and then use <code>distribute</code> to parallelise it easily. Here's how we would use the <code>distribute</code> function to parallelise the VSD experiment:</p> <pre><code>from cmtj.utils.parallel import distribute\n\nJs = np.linspace(1e-4, 1e-3, 10)\nHrange = np.linspace(-15e3, 15e3, 100, endpoint=True)\nfscan = np.arange(1e9, 6.2e9, 0.2e9)\nVSD = np.zeros((len(Js), len(fscan), len(Hrange)), dtype=np.float32)\nJs = np.around(Js, decimals=7)\nfor res in distribute(simulate_vsd, [Js, Hrange, fscan]):\n    (k, i, j), out = res\n    VSD[k, j, i] = out\n</code></pre> <p>The <code>distribute</code> function returns a generator, which we can iterate over to get the results. The results are returned as a tuple of two elements: the first element is a tuple of the indices of the result, and the second element is the result itself. In our case, the result is the VSD DC resistance, and the indices are the indices of the <code>J</code>, <code>H</code> and <code>f</code> values (in that order specifically, we need to match the function signature of <code>simulate_vsd</code> with the second argument to <code>distribute</code> function). We can use these indices to assign the result to the correct place in the <code>VSD</code> array.</p> <p>Very simple! Now we can plot the VSD spectra for different values of the IEC constant <code>J</code>:</p> <pre><code>fig, axs = plt.subplots(len(Js), 1, figsize=(8, 6), dpi=300)\nfor k in range(len(Js)):\n    axs[k].pcolor( Hrange/1e3, fscan / 1e9, VSD[k], shading='auto')\n    axs[k].set_xlabel(\"H (kA/m)\")\n    axs[k].set_ylabel(\"Frequency (GHz)\")\n    axs[k].set_title(\"J = {}\".format(Js[k]))\n</code></pre>"},{"location":"physics/sb-model/","title":"Smit-Beljers model","text":""},{"location":"physics/sb-model/#introduction","title":"Introduction","text":"<p>The basic model was introduced by Smit and Beljers 1955. However, there were nice extensions of the model, notably, by L. Baselgia, M. Warden, and F. Waldner in the Derivation of the resonance frequency from the free energy of ferromagnets, 1988. One of more recent ones by R. L. Rodr\u00edguez-Su\u00e1rez, S. M. Rezende, and A. Azevedo from Ferromagnetic resonance investigation of the residual coupling in spin-valve systems, PRB 2005 is the one I prefer to use for explanation.</p>"},{"location":"physics/sb-model/#the-model","title":"The model","text":"<p>The model is capable of simulating the magnetisation in equilibrium and the resonance frequency mode (fmr = ferromagnetic resonance). The former basically allows us to reproduce the hysteresis M(H) or R(H) loops etc. The latter gives use the frequency of the oscillations of the magnetisation in the presence of an external magnetic field.</p> <p>For the full model we need:</p> <ol> <li>Create energy expression of the system.</li> <li>Obtain equilibirum magnetisation position of the system.</li> <li>Compute the hessian matrix \\(H\\) of the energy expression.</li> <li>Find the roots of the \\(\\det H\\).</li> </ol> <p>Each layer is described by the following parameters:</p>"},{"location":"physics/sb-model/#parameter-table","title":"Parameter table","text":"Parameter Description Units \\(\\theta\\) Polar angle of magnetisation vector rad \\(\\phi\\) Azimuthal angle of magnetisation vector rad \\(t_\\textrm{FM}\\) Thickness of the FM layer m \\(M_s\\) Magnetisation saturation \\(\\frac{A}{m}\\) \\(K_s\\) Shape anisotropy (perpendicular, out of plane) \\(\\frac{J}{m^3}\\) \\(K_v\\) Volume anisotropy (in-plane) \\(\\frac{J}{m^3}\\) \\(\\alpha\\) Azimuthal angle of in-plane anisotropy rad \\(J_1\\) Interlayer exchange coupling value (linear) \\(\\frac{J}{m^2}\\) \\(J_2\\) Interlayer exchange coupling value (quadratic) \\(\\frac{J}{m^2}\\) <p>And the external field is also given by it's own (\\(\\theta\\), \\(\\phi\\), \\(H\\)) where \\(H\\) is the magnitude of the field.</p> <p>Note</p> <p>This assumes physical, not mathematical spherical coordinates! Here, polar angle \\(\\theta\\) is measured from the positive \\(z\\) axis, and azimuthal angle \\(\\phi\\) is measured from the positive \\(x\\) axis.</p> <p>The energy expression per layer is given by the following:</p> \\[     \\varepsilon_i = - \\mu_0 M_s \\vec{m}_i \\cdot \\vec{H} +         (- K_s + \\frac{1}{2}\\mu_0 M_s^2) m_z^2         - K_v (\\vec{m} \\cdot \\vec{K}_{dir})^2         - J_1 \\vec{m}_i \\cdot \\vec{m}_{i+1}         - J_2 (\\vec{m}_i \\cdot \\vec{m}_{i+1})^2 \\] <p>where \\(\\vec{m}\\) is in the spherical coordinates, and \\(\\vec{K}_{dir}\\) is the direction of the in-plane anisotropy.</p> \\[     \\vec{m} = \\begin{bmatrix}         \\sin\\theta\\cos\\phi \\\\         \\sin\\theta\\sin\\phi \\\\         \\cos\\theta          \\\\     \\end{bmatrix} \\] <p>Similarly, \\(H\\) for its respective coordinates. Finally, \\(\\vec{K}_{dir}\\) is given by:</p> \\[ \\vec{K}_{dir} = \\begin{bmatrix}     \\cos\\alpha \\\\     \\sin\\alpha \\\\     0          \\\\ \\end{bmatrix} \\]"},{"location":"physics/sb-model/#solution","title":"Solution","text":""},{"location":"physics/sb-model/#equilibrium-magnetisation","title":"Equilibrium magnetisation","text":"<p>The solution for equilibrium magnetisation is solved using the Adam gradient descent. It is a quick and reliable algorithm for finding energy minima. It operates on the first derivative of the \\(\\varepsilon_i\\) expression, i.e. \\(\\frac{\\partial\\varepsilon}{\\partial\\theta}\\) and \\(\\frac{\\partial\\varepsilon}{\\partial\\phi}\\). If the gradient is found within a certain tolerance, the algorithm stops. Otherwise, it continues to iterate until the maximum number of iterations is reached.</p>"},{"location":"physics/sb-model/#resonance-frequency","title":"Resonance frequency","text":"<p>The equilibrium magnetisation, \\((\\theta^*, \\phi^*)\\), is then used to compute the hessian matrix of the energy expression. The hessian matrix is a matrix of second derivatives of the energy expression. We use it to find the roots of the \\(\\det H\\)(hessian) expression. Those roots designate the frequencies of the resonance mode.</p>"},{"location":"physics/sb-model/#root-finding","title":"Root finding","text":"<p>Root finding algorithm is a naive greedy search, but for GHz or MHz frequencies it's pretty fast and precise enough (you can set the tolerance in the parameters).</p>"},{"location":"physics/sb-model/#runnning-the-model","title":"Runnning the model","text":"<p>Below is an example of how the model can be used, based on a system with 2 ferromagnetic layers:</p> <pre><code>import numpy as np\n\nfrom collections import defaultdict\nfrom cmtj.models.general_sb import LayerSB, VectorObj, SolverSB\nfrom cmtj.utils import mu0\nfrom tqdm import tqdm\n\nMs1 = 1. / mu0 # here we pass the saturation magnetisation in A/m, but in the dynamic model we use T!\nMs2 = 1.2 / mu0\nlayerA = LayerSB(\n    _id=0,\n    thickness=1e-9,\n    Kv=VectorObj(np.deg2rad(0.), np.deg2rad(0), 1e1), # for the Kv only phi angle counts !\n    Ks=3e4,\n    Ms=Ms1,\n)\nlayerB = LayerSB(\n    _id=1,\n    thickness=1.3e-9,\n    Kv=VectorObj(np.deg2rad(0.), np.deg2rad(0), 1e4),\n    Ks=1e1,\n    Ms=Ms2,\n)\n\n# we indicate the \"guess\" of the initial position\n# it's generally good to align it with the field, but it's not necessary\ncurrent_position = [\n    np.deg2rad(89),\n    np.deg2rad(0.1),\n    np.deg2rad(180),\n    np.deg2rad(0.1)\n]\nHspace = np.linspace(-400e3, 400e3, 100)\nresult_dictionary = defaultdict(list)\n# we perform a sweep over the field magnitude\nfor Hmag in tqdm(Hspace):\n    solver = SolverSB(\n        layers=[layerA, layerB],\n        J1=[1e-4],\n        J2=[0.],\n        H=VectorObj(np.deg2rad(89), np.deg2rad(0.1), Hmag)\n    )\n    # check for additional parameters in the solver\n    # such as gradient convergence tolerance, max iterations, etc.\n    # also in the solver there are root finding parameters\n    (t1, p1, t2, p2), frequencies = solver.solve(init_position=current_position)\n    # frequencies are already in GHz\n    for frequency in frequencies:\n        result_dictionary[\"frequency\"].append(frequency)\n        result_dictionary[\"Hmag\"].append(Hmag)\n\n    # we note the final position of the magnetisation in spherical coordinates\n    result_dictionary[\"theta_1\"].append(t1)\n    result_dictionary[\"phi_1\"].append(p1)\n    result_dictionary[\"theta_2\"].append(t2)\n    result_dictionary[\"phi_2\"].append(p2)\n    # we reuse the previous solution as the initial guess for the next iteration\n    current_position = [t1, p1, t2, p2]\n</code></pre>"},{"location":"physics/sb-model/#references","title":"References","text":"<ol> <li>Rodr\u00edguez-Su\u00e1rez, R. L., Rezende, S. M. &amp; Azevedo, A. Ferromagnetic resonance investigation of the residual coupling in spin-valve systems. Phys. Rev. B 71, 224406 (2005).</li> <li>Baselgia, L. et al. Derivation of the resonance frequency from the free energy of ferromagnets. Phys. Rev. B 38, 2237\u20132242 (1988).</li> </ol>"},{"location":"tutorials/CMTJBindingsTutorial/","title":"Library introduction","text":"<p>We start with the definition of our Junction, which in turn is composed from two layers. Here are some key parameters:</p> <ul> <li>mag - magnetisation vector</li> <li>anis - the vector (axis) of the magnetic anisotoropy </li> <li>K - magnetic anisotropy $[J/m^3]$</li> <li>Ms - magnetisation saturation $[T]$</li> <li>thickness - thickness of the layer $[m]$</li> <li>J - the IEC coupling with the other layers $[J/m^2]$</li> </ul> In\u00a0[1]: Copied! <pre>import numpy as np\nimport time\nfrom cmtj import Junction, Layer, CVector, ScalarDriver, AxialDriver, NullDriver\n</pre> import numpy as np import time from cmtj import Junction, Layer, CVector, ScalarDriver, AxialDriver, NullDriver In\u00a0[2]: Copied! <pre>N = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)]\ndamping = 0.01\ncl1 = Layer(id=\"free\",\n            mag=CVector(0, 0, 1),\n            anis=CVector(0, -0.0871557, 0.996195),\n            Ms=1.07,\n            thickness=1e-9,\n            cellSurface=0,\n            demagTensor=N,\n            damping=damping)\n\ncl2 = Layer(id=\"bottom\",\n            mag=CVector(0, 0, 1),\n            anis=CVector(0.34071865, -0.08715574, 0.936116),\n            Ms=1.07,\n            thickness=1e-9,\n            cellSurface=0,\n            demagTensor=N,\n            damping=damping)\n</pre> N = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)] damping = 0.01 cl1 = Layer(id=\"free\",             mag=CVector(0, 0, 1),             anis=CVector(0, -0.0871557, 0.996195),             Ms=1.07,             thickness=1e-9,             cellSurface=0,             demagTensor=N,             damping=damping)  cl2 = Layer(id=\"bottom\",             mag=CVector(0, 0, 1),             anis=CVector(0.34071865, -0.08715574, 0.936116),             Ms=1.07,             thickness=1e-9,             cellSurface=0,             demagTensor=N,             damping=damping) In\u00a0[3]: Copied! <pre>from collections import defaultdict\nfrom cmtj.utils import compute_sd\nfrom tqdm import tqdm\nimport math\n\ndata = defaultdict(list)\n\n\ndef compute_vsd(simulation_log, frequency, offset=0, tstart=1e-9):\n    stime = np.asarray(simulation_log['time'])\n    indx = np.argwhere(stime &gt;= tstart).ravel()\n    Rx = np.asarray(simulation_log['Rx'])[indx]\n    avg_res = np.mean(Rx)\n    current = np.sqrt(\n        10e-6 / avg_res) * np.sin(2 * np.pi * frequency * stime[indx] + offset)\n    return np.mean(current * Rx)\n\n\nstart = time.time()\njunction = Junction(layers=[cl1, cl2],\n                    Rx0=[100, 100],\n                    Ry0=[0, 0],\n                    AMR_X=[10, 10],\n                    AMR_Y=[30 / 2, 30 / 2],\n                    SMR_X=[0, 0],\n                    SMR_Y=[0, 0],\n                    AHE=[0, 0])\n\njunction.setLayerAnisotropyDriver(\"free\",\n                                  ScalarDriver.getConstantDriver((305e3)))\njunction.setLayerAnisotropyDriver(\"bottom\",\n                                  ScalarDriver.getConstantDriver((728e3)))\njunction.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(4e-5))\n\nHoeAmpl = 5e2  # A/m\nHspace = np.linspace(-800e3, 800e3, 100)\nfrequencies = [1e9 * i for i in range(48)]\nmag_free = CVector(1, 1, 0)\nmag_bottom = CVector(1, 1, 0)\nVSD = []\nIampl = 1e-3\nint_step = 1e-12\n\nfor frequency in tqdm(frequencies):\n    H_sweep = []\n    for H in Hspace:\n        junction.clearLog()\n        junction.setLayerMagnetisation(\"free\", mag_free)\n        junction.setLayerMagnetisation(\"bottom\", mag_bottom)\n\n        HDriver = AxialDriver(\n            ScalarDriver.getConstantDriver(H * np.sqrt(2) / 2),\n            ScalarDriver.getConstantDriver(H * np.sqrt(2) / 2), NullDriver())\n\n        HoeDriver = AxialDriver(\n            NullDriver(), ScalarDriver.getSineDriver(0, HoeAmpl, frequency, 0),\n            NullDriver())\n        junction.setLayerExternalFieldDriver(\"all\", HDriver)\n        junction.setLayerOerstedFieldDriver(\"all\", HoeDriver)\n        junction.runSimulation(10e-9, int_step, int_step)\n\n        mag_free = junction.getLayerMagnetisation(\"free\")\n        mag_bottom = junction.getLayerMagnetisation(\"bottom\")\n        log = junction.getLog()\n        dynamicI = Iampl * np.sin(\n            2 * math.pi * frequency * np.asarray(log['time']))\n        vmix = compute_sd(log[\"Rx\"], dynamicI, int_step)\n\n        H_sweep.append(vmix)\n    VSD.append(H_sweep)\n\nend = time.time()\nprint(f\"Simulation time: {end-start:.2f}\")\n</pre> from collections import defaultdict from cmtj.utils import compute_sd from tqdm import tqdm import math  data = defaultdict(list)   def compute_vsd(simulation_log, frequency, offset=0, tstart=1e-9):     stime = np.asarray(simulation_log['time'])     indx = np.argwhere(stime &gt;= tstart).ravel()     Rx = np.asarray(simulation_log['Rx'])[indx]     avg_res = np.mean(Rx)     current = np.sqrt(         10e-6 / avg_res) * np.sin(2 * np.pi * frequency * stime[indx] + offset)     return np.mean(current * Rx)   start = time.time() junction = Junction(layers=[cl1, cl2],                     Rx0=[100, 100],                     Ry0=[0, 0],                     AMR_X=[10, 10],                     AMR_Y=[30 / 2, 30 / 2],                     SMR_X=[0, 0],                     SMR_Y=[0, 0],                     AHE=[0, 0])  junction.setLayerAnisotropyDriver(\"free\",                                   ScalarDriver.getConstantDriver((305e3))) junction.setLayerAnisotropyDriver(\"bottom\",                                   ScalarDriver.getConstantDriver((728e3))) junction.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(4e-5))  HoeAmpl = 5e2  # A/m Hspace = np.linspace(-800e3, 800e3, 100) frequencies = [1e9 * i for i in range(48)] mag_free = CVector(1, 1, 0) mag_bottom = CVector(1, 1, 0) VSD = [] Iampl = 1e-3 int_step = 1e-12  for frequency in tqdm(frequencies):     H_sweep = []     for H in Hspace:         junction.clearLog()         junction.setLayerMagnetisation(\"free\", mag_free)         junction.setLayerMagnetisation(\"bottom\", mag_bottom)          HDriver = AxialDriver(             ScalarDriver.getConstantDriver(H * np.sqrt(2) / 2),             ScalarDriver.getConstantDriver(H * np.sqrt(2) / 2), NullDriver())          HoeDriver = AxialDriver(             NullDriver(), ScalarDriver.getSineDriver(0, HoeAmpl, frequency, 0),             NullDriver())         junction.setLayerExternalFieldDriver(\"all\", HDriver)         junction.setLayerOerstedFieldDriver(\"all\", HoeDriver)         junction.runSimulation(10e-9, int_step, int_step)          mag_free = junction.getLayerMagnetisation(\"free\")         mag_bottom = junction.getLayerMagnetisation(\"bottom\")         log = junction.getLog()         dynamicI = Iampl * np.sin(             2 * math.pi * frequency * np.asarray(log['time']))         vmix = compute_sd(log[\"Rx\"], dynamicI, int_step)          H_sweep.append(vmix)     VSD.append(H_sweep)  end = time.time() print(f\"Simulation time: {end-start:.2f}\") <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 48/48 [00:48&lt;00:00,  1.00s/it]</pre> <pre>Simulation time: 48.16\n</pre> <pre>\n</pre> <p>Now, we may plot our Voltage Spin Diode curve, which is a ferromagnetic resonance curve -- the FMR (fitting the antisymmetric Lorentz curve), being a Vmix function of the field applied to the junction.</p> In\u00a0[4]: Copied! <pre>from mpl_toolkits.axes_grid1 import make_axes_locatable\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom cmtj.utils import Filters\n\nVSD = np.asarray(VSD, dtype=np.float32)\n\nwith plt.style.context(['science', 'nature']):\n    fig, ax = plt.subplots(dpi=300)\n    im = ax.pcolor(\n        Hspace / 1e3,\n        frequencies,\n        Filters.detrend_axis(VSD, axis=1),\n        shading='auto',\n        cmap='inferno',\n    )\n    divider = make_axes_locatable(ax)\n    cax = divider.append_axes('right', size='5%', pad=0.05)\n    fig.colorbar(im, cax=cax, orientation='vertical')\n    ax.set_xlabel(\"Field [A/m]\")\n    ax.set_ylabel(\"Vmix [mV]\")\n    ax.set_title(\"FMR curve for the Voltage Spin Diode Effect\")\nplt.show()\n</pre> from mpl_toolkits.axes_grid1 import make_axes_locatable import matplotlib.pyplot as plt import numpy as np from cmtj.utils import Filters  VSD = np.asarray(VSD, dtype=np.float32)  with plt.style.context(['science', 'nature']):     fig, ax = plt.subplots(dpi=300)     im = ax.pcolor(         Hspace / 1e3,         frequencies,         Filters.detrend_axis(VSD, axis=1),         shading='auto',         cmap='inferno',     )     divider = make_axes_locatable(ax)     cax = divider.append_axes('right', size='5%', pad=0.05)     fig.colorbar(im, cax=cax, orientation='vertical')     ax.set_xlabel(\"Field [A/m]\")     ax.set_ylabel(\"Vmix [mV]\")     ax.set_title(\"FMR curve for the Voltage Spin Diode Effect\") plt.show() In\u00a0[5]: Copied! <pre>import matplotlib.pyplot as plt\nfrom cmtj.utils.linear import FieldScan\nfrom cmtj.utils.procedures import ResistanceParameters, PIMM_procedure\n\nrp = ResistanceParameters(Rxx0=100,\n                          Rxy0=1,\n                          Rsmr=-0.46,\n                          Rahe=-2.7,\n                          Ramr=-0.24,\n                          l=30,\n                          w=20)\n\n# approximate demagnetisation tensor\ndemag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)]\nalpha = 0.005\nKdir = CVector(1, 0, 0)\nMs = 1.65\nl1 = Layer(\"free\",\n           mag=CVector(0, 0, 1),\n           anis=Kdir,\n           Ms=Ms,\n           thickness=3.99e-9,\n           cellSurface=0,\n           demagTensor=demag,\n           damping=alpha)\n\nl2 = Layer(\"bottom\",\n           mag=CVector(0, 0, 1),\n           anis=Kdir,\n           Ms=Ms,\n           thickness=4e-9,\n           cellSurface=0,\n           demagTensor=demag,\n           damping=alpha)\nJ1 = -1.78e-3\nJ2 = -1.69e-4\n\nK1 = K2 = 1.05e3\nint_step = 4e-14\n\nj1 = Junction([l1, l2], 100, 102)\n\nj1.setLayerAnisotropyDriver(\"all\", ScalarDriver.getConstantDriver(K1))\nj1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J1))\nj1.setQuadIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J2))\nHscan, Hvecs = FieldScan.amplitude_scan(-1200e3, 1200e3, 200, 89, 90)\n\nspectrum, freqs, output = PIMM_procedure(j1,\n                                         Hvecs=Hvecs,\n                                         int_step=int_step,\n                                         resistance_params=[rp, rp],\n                                         max_frequency=60e9)\nwith plt.style.context(['science', 'nature']):\n    fig, ax = plt.subplots(dpi=300)\n    ax.pcolor(Hscan / 1e3,\n              freqs / 1e9,\n              np.log10(np.squeeze(spectrum.T)),\n              shading='auto',\n              cmap='viridis')\n    ax.set_xlabel(\"Field [A/m]\")\n    ax.set_ylabel(\"Frequency [GHz]\")\n</pre> import matplotlib.pyplot as plt from cmtj.utils.linear import FieldScan from cmtj.utils.procedures import ResistanceParameters, PIMM_procedure  rp = ResistanceParameters(Rxx0=100,                           Rxy0=1,                           Rsmr=-0.46,                           Rahe=-2.7,                           Ramr=-0.24,                           l=30,                           w=20)  # approximate demagnetisation tensor demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)] alpha = 0.005 Kdir = CVector(1, 0, 0) Ms = 1.65 l1 = Layer(\"free\",            mag=CVector(0, 0, 1),            anis=Kdir,            Ms=Ms,            thickness=3.99e-9,            cellSurface=0,            demagTensor=demag,            damping=alpha)  l2 = Layer(\"bottom\",            mag=CVector(0, 0, 1),            anis=Kdir,            Ms=Ms,            thickness=4e-9,            cellSurface=0,            demagTensor=demag,            damping=alpha) J1 = -1.78e-3 J2 = -1.69e-4  K1 = K2 = 1.05e3 int_step = 4e-14  j1 = Junction([l1, l2], 100, 102)  j1.setLayerAnisotropyDriver(\"all\", ScalarDriver.getConstantDriver(K1)) j1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J1)) j1.setQuadIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J2)) Hscan, Hvecs = FieldScan.amplitude_scan(-1200e3, 1200e3, 200, 89, 90)  spectrum, freqs, output = PIMM_procedure(j1,                                          Hvecs=Hvecs,                                          int_step=int_step,                                          resistance_params=[rp, rp],                                          max_frequency=60e9) with plt.style.context(['science', 'nature']):     fig, ax = plt.subplots(dpi=300)     ax.pcolor(Hscan / 1e3,               freqs / 1e9,               np.log10(np.squeeze(spectrum.T)),               shading='auto',               cmap='viridis')     ax.set_xlabel(\"Field [A/m]\")     ax.set_ylabel(\"Frequency [GHz]\") <pre>Computing PIMM: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 200/200 [00:27&lt;00:00,  7.38it/s]\n</pre> In\u00a0[6]: Copied! <pre>from typing import List, Dict\nfrom cmtj.utils.plotting import get_sphere\nx, y, z = get_sphere()\n\ndef plot_trajectories(log: Dict[str, List[float]], title: str):\n    with plt.style.context(['science', 'nature']):\n        fig = plt.figure(figsize=(4, 3), dpi=250)\n        ax = fig.add_subplot(1, 2, 1, projection='3d')\n        m = np.asarray([log[f'free_mx'], log[f'free_my'], log[f'free_mz']])\n        ax.plot3D(m[0], m[1], m[2], color='blue')\n        ax.set_axis_off()\n        ax.plot_surface(x,\n                        y,\n                        z,\n                        rstride=2,\n                        cstride=2,\n                        color='c',\n                        alpha=0.3,\n                        linewidth=0.1)\n        ax.scatter([0], [0], [1], color='crimson', alpha=1.0, s=50)\n        ax2 = fig.add_subplot(1, 2, 2)\n        ax2.plot(log['time'], log['R_free_bottom'])\n        ax2.set_xlabel(\"Time [s]\")\n        ax2.set_ylabel(\"Resistance [Ohm]\")\n        fig.suptitle(title)\n        fig.tight_layout()\n</pre> from typing import List, Dict from cmtj.utils.plotting import get_sphere x, y, z = get_sphere()  def plot_trajectories(log: Dict[str, List[float]], title: str):     with plt.style.context(['science', 'nature']):         fig = plt.figure(figsize=(4, 3), dpi=250)         ax = fig.add_subplot(1, 2, 1, projection='3d')         m = np.asarray([log[f'free_mx'], log[f'free_my'], log[f'free_mz']])         ax.plot3D(m[0], m[1], m[2], color='blue')         ax.set_axis_off()         ax.plot_surface(x,                         y,                         z,                         rstride=2,                         cstride=2,                         color='c',                         alpha=0.3,                         linewidth=0.1)         ax.scatter([0], [0], [1], color='crimson', alpha=1.0, s=50)         ax2 = fig.add_subplot(1, 2, 2)         ax2.plot(log['time'], log['R_free_bottom'])         ax2.set_xlabel(\"Time [s]\")         ax2.set_ylabel(\"Resistance [Ohm]\")         fig.suptitle(title)         fig.tight_layout() In\u00a0[7]: Copied! <pre>demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.0)]\n\ndamping = 0.3\ncurrentDensity = 5e10\nbeta = 1\nspinPolarisation = 1.0\n\nl1 = Layer.createSTTLayer(id=\"free\",\n                          mag=CVector(0., 0., 1.),\n                          anis=CVector(0, 0., 1.),\n                          Ms=1.,\n                          thickness=1.4e-9,\n                          cellSurface=7e-10 * 7e-10,\n                          demagTensor=demagTensor,\n                          damping=damping,\n                          SlonczewskiSpacerLayerParameter=1.0,\n                          spinPolarisation=spinPolarisation,\n                          beta=beta)\nl2 = Layer(id=\"bottom\",\n           mag=CVector(0., 1., 1.),\n           anis=CVector(0, 1., 1.),\n           Ms=1.2,\n           thickness=3e-9,\n           cellSurface=7e-10 * 7e-10,\n           demagTensor=demagTensor)\n\nl1.setReferenceLayer(CVector(0, 1., 1.))\njunction = Junction([l1, l2], 100, 200)\n\njunction.setLayerAnisotropyDriver(\"free\",\n                                  ScalarDriver.getConstantDriver(300e3))\njunction.setLayerAnisotropyDriver(\"bottom\",\n                                  ScalarDriver.getConstantDriver(1500e3))\njunction.setIECDriver(\"free\", \"bottom\",\n                      ScalarDriver.getConstantDriver(-2.5e-6))\n# current driver\njunction.setLayerCurrentDriver(\"free\",\n                               ScalarDriver.getConstantDriver(currentDensity))\n\njunction.runSimulation(20e-9, 1e-12, 1e-12, True, False)\nlog = junction.getLog()\nplot_trajectories(log, title=\"STO with STT on\")\n</pre> demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.0)]  damping = 0.3 currentDensity = 5e10 beta = 1 spinPolarisation = 1.0  l1 = Layer.createSTTLayer(id=\"free\",                           mag=CVector(0., 0., 1.),                           anis=CVector(0, 0., 1.),                           Ms=1.,                           thickness=1.4e-9,                           cellSurface=7e-10 * 7e-10,                           demagTensor=demagTensor,                           damping=damping,                           SlonczewskiSpacerLayerParameter=1.0,                           spinPolarisation=spinPolarisation,                           beta=beta) l2 = Layer(id=\"bottom\",            mag=CVector(0., 1., 1.),            anis=CVector(0, 1., 1.),            Ms=1.2,            thickness=3e-9,            cellSurface=7e-10 * 7e-10,            demagTensor=demagTensor)  l1.setReferenceLayer(CVector(0, 1., 1.)) junction = Junction([l1, l2], 100, 200)  junction.setLayerAnisotropyDriver(\"free\",                                   ScalarDriver.getConstantDriver(300e3)) junction.setLayerAnisotropyDriver(\"bottom\",                                   ScalarDriver.getConstantDriver(1500e3)) junction.setIECDriver(\"free\", \"bottom\",                       ScalarDriver.getConstantDriver(-2.5e-6)) # current driver junction.setLayerCurrentDriver(\"free\",                                ScalarDriver.getConstantDriver(currentDensity))  junction.runSimulation(20e-9, 1e-12, 1e-12, True, False) log = junction.getLog() plot_trajectories(log, title=\"STO with STT on\") <pre>Steps in simulation: 20000\nWrite every: 1\nSimulation time = 0[s]\n</pre> <p>We will also run the same simulation but with the STT turned off, to see if the spin polarised current flow actually helps to sustain the oscillations. We see that the magnetisation stays still -- as becomes evident in the 3D plot -- we can only see a single dot.</p> In\u00a0[8]: Copied! <pre>l1 = Layer(id=\"free\",\n           mag=CVector(0., 0., -1.),\n           anis=CVector(0, 0., 1.),\n           Ms=1.2,\n           thickness=1.4e-9,\n           cellSurface=7e-10 * 7e-10,\n           demagTensor=demagTensor)\nl2 = Layer(id=\"bottom\",\n           mag=CVector(0., 1., 1.),\n           anis=CVector(0, 1., 1.),\n           Ms=1.2,\n           thickness=3e-9,\n           cellSurface=7e-10 * 7e-10,\n           demagTensor=demagTensor)\n\njunction = Junction([l1, l2], 100, 200)\njunction.setLayerAnisotropyDriver(\"free\",\n                                  ScalarDriver.getConstantDriver(800e3))\njunction.setLayerAnisotropyDriver(\"bottom\",\n                                  ScalarDriver.getConstantDriver(1500e3))\njunction.setIECDriver(\"free\", \"bottom\",\n                      ScalarDriver.getConstantDriver(-2.5e-6))\n# current driver\njunction.setLayerCurrentDriver(\"free\",\n                               ScalarDriver.getConstantDriver(currentDensity))\njunction.runSimulation(20e-9, 1e-12, 1e-12, True, False)\nlog = junction.getLog()\nplot_trajectories(log, title=\"Setup with STT off\")\n</pre> l1 = Layer(id=\"free\",            mag=CVector(0., 0., -1.),            anis=CVector(0, 0., 1.),            Ms=1.2,            thickness=1.4e-9,            cellSurface=7e-10 * 7e-10,            demagTensor=demagTensor) l2 = Layer(id=\"bottom\",            mag=CVector(0., 1., 1.),            anis=CVector(0, 1., 1.),            Ms=1.2,            thickness=3e-9,            cellSurface=7e-10 * 7e-10,            demagTensor=demagTensor)  junction = Junction([l1, l2], 100, 200) junction.setLayerAnisotropyDriver(\"free\",                                   ScalarDriver.getConstantDriver(800e3)) junction.setLayerAnisotropyDriver(\"bottom\",                                   ScalarDriver.getConstantDriver(1500e3)) junction.setIECDriver(\"free\", \"bottom\",                       ScalarDriver.getConstantDriver(-2.5e-6)) # current driver junction.setLayerCurrentDriver(\"free\",                                ScalarDriver.getConstantDriver(currentDensity)) junction.runSimulation(20e-9, 1e-12, 1e-12, True, False) log = junction.getLog() plot_trajectories(log, title=\"Setup with STT off\") <pre>Steps in simulation: 20000\nWrite every: 1\nSimulation time = 0[s]\n</pre>"},{"location":"tutorials/CMTJBindingsTutorial/#library-introduction","title":"Library introduction\u00b6","text":"<p>This notebook is a walkthorugh the basic concepts in the PyMTJ library and covers the basics of using the C++ bindings in Python. In the first section, we will run the basic voltage spin diode experiment using the IEC (Interlayer Exchange Coupling) excitation. In the second section, we are going to construct the Spin Torque Oscillator (STO) using the STT (Slonczewski Spin Torque) addition to our LLG equations. STO is able to sustain the magnetisation precession for a prolonged period of time, since the spin-polarised current flowing through the junction compensates the energy losses from the Gilbert's damping contribution.</p>"},{"location":"tutorials/CMTJBindingsTutorial/#voltage-spin-diode-effect","title":"Voltage Spin Diode effect\u00b6","text":"<p>As we have defined the Junction, we now proceed to running the Voltage Spin Diode experiment.</p> <p>To perform the VSD the external magnetic field is swept in some range, in this case we picked 30 points in range from 0 to 600 mT. For each field point we solve the LLG under the specific excitation and frequency.</p> <p>In this example we will be exciting the system with its resonant frequency which is given a priori but you may find it with the FFT analysis included in the PyMTJ package as well. We skipped that part for clarity. For each of the points we will calculate the constant voltage (Vmix, the diode voltage) arising from the interaction between the sinusoidal current flowing throught the MTJ (of 0 phase and frequency equal to that of the resonant frequency) and also oscillating magnetoresistance, which in turn is invoked by the oscillating magnetisation in response to the effective field contributions.</p> <p>Other parameters were fixed so that we get a nice result, but feel free to tinker with the options and see what happens.</p>"},{"location":"tutorials/CMTJBindingsTutorial/#convenience-procedure","title":"Convenience procedure\u00b6","text":"<p>You can also use the functions provided in the <code>cmtj.utils.procedures</code> package to perform the VSD experiment. The function <code>VSD_procedure</code> takes the junction, the field range, the frequency and the number of points in the field range as arguments. It returns the field and the Vmix values. Another procedure -- PIMM, illustrated below -- is the one that performs the PIMM experiment. It takes the junction, the field range, and resistance parameter object as an input.</p> <p>In that way, you don't have to write PIMM or VSD procedures each time yourself.</p>"},{"location":"tutorials/CMTJBindingsTutorial/#stt","title":"STT\u00b6","text":"<p>We may now transition to simulating Spin Torque Oscillators. As mentioned before, these are called the oscillators because they can sustain the oscillating magnetisation.</p> <p>This experiment is much simpler than the previous one. Like before, we will set up our layers, but this time, we will enable the STT contributions and we will invoke the critical current densities.</p> <p>Note, we turn the STT in the free layer, which has now the magnetisation in the -z direction. Additionally, we lower the free layer anisotropy and we turn off the coupling (for simplicity).</p> <p>We also slightly tilt the bottom layer's magnetisation in order to invoke the torque on the spin torque.</p>"},{"location":"tutorials/examples/","title":"Advanced examples","text":"In\u00a0[1]: Copied! <pre>import math\nfrom collections import defaultdict\n\nimport matplotlib as mpl\nimport matplotlib.cm as cm\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as mtransforms\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom matplotlib.lines import Line2D\nfrom mpl_toolkits.axes_grid1.inset_locator import inset_axes\nfrom scipy.fft import fft, fftfreq\nfrom scipy.ndimage import uniform_filter, uniform_filter1d\nfrom scipy.optimize import curve_fit\nfrom tqdm import tqdm\n\nfrom cmtj import *\nfrom cmtj import SolverMode\nfrom cmtj.models.ensemble import meinert_model\nfrom cmtj.stack import ParallelStack, SeriesStack\nfrom cmtj.utils import (FieldScan, Filters, OetoAm, TtoAm,\n                        calculate_resistance_parallel,\n                        calculate_resistance_series, compute_sd, echarge, hbar,\n                        mu0)\nfrom cmtj.utils.parallel import distribute\n\ngyromagnetic_ratio = 2.211e5\n</pre> import math from collections import defaultdict  import matplotlib as mpl import matplotlib.cm as cm import matplotlib.pyplot as plt import matplotlib.transforms as mtransforms import numpy as np import pandas as pd import seaborn as sns from matplotlib.lines import Line2D from mpl_toolkits.axes_grid1.inset_locator import inset_axes from scipy.fft import fft, fftfreq from scipy.ndimage import uniform_filter, uniform_filter1d from scipy.optimize import curve_fit from tqdm import tqdm  from cmtj import * from cmtj import SolverMode from cmtj.models.ensemble import meinert_model from cmtj.stack import ParallelStack, SeriesStack from cmtj.utils import (FieldScan, Filters, OetoAm, TtoAm,                         calculate_resistance_parallel,                         calculate_resistance_series, compute_sd, echarge, hbar,                         mu0) from cmtj.utils.parallel import distribute  gyromagnetic_ratio = 2.211e5  In\u00a0[2]: Copied! <pre>loops0 = {}\nloops90 = {}\n\nloop_Hrange = np.linspace(-500 * OetoAm, 500 * OetoAm, 100)\nloop_Hrange = np.concatenate((loop_Hrange, loop_Hrange[:-1][::-1]))\nlabels = ('2.37', '2.14', '1.90')\nHJs = (30, 10, -40)\n# a way of recomputing the Js from the data\nJs = [HJ * OetoAm * 6e-9 * 1.05 for HJ in HJs]\n# approximate demagnetisation tensor\ndemag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)]\nsurf = 15e-9 * 15e-9 * np.pi\nfor angle in (90, 0):\n    for th, J in zip(labels, tqdm(Js)):\n        Ku = 0.8e3\n        alpha = 0.024\n        l1 = Layer(\n            \"free\",\n            mag=CVector(1, 0.1, 0.1),\n            anis=CVector(1, 0., 0.),  # direction of the anisotropy\n            Ms=1.03,\n            thickness=2.1e-9,\n            cellSurface=surf,\n            demagTensor=demag,\n            damping=alpha)\n\n        l2 = Layer(\n            \"bottom\",\n            mag=CVector(1, 0.1, 0.1),\n            anis=CVector(1, 0, 0),  # direction of the anisotropy\n            Ms=1.65,\n            thickness=6e-9,\n            cellSurface=surf,\n            demagTensor=demag,\n            damping=alpha)\n\n        j1 = Junction([l1, l2], 163.5, 176)\n        j1.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(Ku))\n        j1.setLayerAnisotropyDriver(\"bottom\",\n                                    ScalarDriver.getConstantDriver(1e12))\n        j1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J))\n\n        Rs = []\n        for H in loop_Hrange:\n            j1.clearLog()\n            hangle = FieldScan.angle2vector(90, angle, H)\n            j1.setLayerExternalFieldDriver(\n                \"all\",\n                AxialDriver(ScalarDriver.getConstantDriver(hangle.x),\n                            ScalarDriver.getConstantDriver(hangle.y),\n                            ScalarDriver.getConstantDriver(hangle.z)))\n\n            j1.runSimulation(20e-9, 1e-12, 1e-12)\n            log = j1.getLog()\n            R = np.mean(log['R_free_bottom'][-100:])\n            Rs.append(R)\n        if angle == 0:\n            loops0[th] = Rs\n        if angle == 90:\n            loops90[th] = Rs\n</pre> loops0 = {} loops90 = {}  loop_Hrange = np.linspace(-500 * OetoAm, 500 * OetoAm, 100) loop_Hrange = np.concatenate((loop_Hrange, loop_Hrange[:-1][::-1])) labels = ('2.37', '2.14', '1.90') HJs = (30, 10, -40) # a way of recomputing the Js from the data Js = [HJ * OetoAm * 6e-9 * 1.05 for HJ in HJs] # approximate demagnetisation tensor demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)] surf = 15e-9 * 15e-9 * np.pi for angle in (90, 0):     for th, J in zip(labels, tqdm(Js)):         Ku = 0.8e3         alpha = 0.024         l1 = Layer(             \"free\",             mag=CVector(1, 0.1, 0.1),             anis=CVector(1, 0., 0.),  # direction of the anisotropy             Ms=1.03,             thickness=2.1e-9,             cellSurface=surf,             demagTensor=demag,             damping=alpha)          l2 = Layer(             \"bottom\",             mag=CVector(1, 0.1, 0.1),             anis=CVector(1, 0, 0),  # direction of the anisotropy             Ms=1.65,             thickness=6e-9,             cellSurface=surf,             demagTensor=demag,             damping=alpha)          j1 = Junction([l1, l2], 163.5, 176)         j1.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(Ku))         j1.setLayerAnisotropyDriver(\"bottom\",                                     ScalarDriver.getConstantDriver(1e12))         j1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J))          Rs = []         for H in loop_Hrange:             j1.clearLog()             hangle = FieldScan.angle2vector(90, angle, H)             j1.setLayerExternalFieldDriver(                 \"all\",                 AxialDriver(ScalarDriver.getConstantDriver(hangle.x),                             ScalarDriver.getConstantDriver(hangle.y),                             ScalarDriver.getConstantDriver(hangle.z)))              j1.runSimulation(20e-9, 1e-12, 1e-12)             log = j1.getLog()             R = np.mean(log['R_free_bottom'][-100:])             Rs.append(R)         if angle == 0:             loops0[th] = Rs         if angle == 90:             loops90[th] = Rs <pre> 67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 2/3 [00:07&lt;00:03,  3.97s/it]\n 67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 2/3 [00:08&lt;00:04,  4.01s/it]\n</pre> In\u00a0[3]: Copied! <pre>def simulate_vsd(J, H, frequency):\n    int_step = 5e-13\n    demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)]\n\n    Ku = 0.8e3\n    alpha = 0.024  # 0.024\n    l1 = Layer(\n        \"free\",\n        mag=CVector(1, 0.1, 0.1),\n        anis=CVector(0, 1., 0.),  # direction of the anisotropy\n        Ms=1.03,\n        thickness=2.1e-9,\n        cellSurface=surf,\n        demagTensor=demag,\n        damping=alpha)\n\n    l2 = Layer(\n        \"bottom\",\n        mag=CVector(1, 0.1, 0.1),\n        anis=CVector(1, 0, 0),  # direction of the anisotropy\n        Ms=1.65,\n        thickness=6e-9,\n        cellSurface=surf,\n        demagTensor=demag,\n        damping=alpha)\n    j1 = Junction([l1, l2], 163.5, 176)\n    j1.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(Ku))\n    j1.setLayerAnisotropyDriver(\"bottom\", ScalarDriver.getConstantDriver(1e12))\n    j1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J))\n    hangle = FieldScan.angle2vector(90, 90, H)\n    j1.clearLog()\n    j1.setLayerExternalFieldDriver(\n        \"all\",\n        AxialDriver(ScalarDriver.getConstantDriver(hangle.x),\n                    ScalarDriver.getConstantDriver(hangle.y),\n                    ScalarDriver.getConstantDriver(hangle.z)))\n    j1.setLayerOerstedFieldDriver(\n        \"free\",\n        AxialDriver(\n            NullDriver(),\n            ScalarDriver.getSineDriver(0, 5, frequency, 0),\n            NullDriver(),\n        ))\n    j1.runSimulation(60e-9, int_step, int_step, solverMode=SolverMode.RK4)\n    log = j1.getLog()\n    dynamicR = log['R_free_bottom']\n\n    dynamicI = np.sin(2 * math.pi * frequency * np.asarray(log['time']))\n    vmix = compute_sd(dynamicR, dynamicI, int_step)\n    return vmix\n\n\nHJs = (25, 15, -29)\nJs = [HJ * OetoAm * 6e-9 * 1.05 for HJ in HJs]\nHrange = np.linspace(-15e3, 15e3, 50, endpoint=True)\nfscan = np.arange(1e9, 6.2e9, 0.2e9)\nVSD = np.zeros((len(Js), len(fscan), len(Hrange)), dtype=np.float32)\nJs = np.around(Js, decimals=7)\nfor res in distribute(simulate_vsd, [Js, Hrange, fscan]):\n    (k, i, j), out = res\n    VSD[k, j, i] = out\n\n# uncomment for serial\n# import time\n\n# start = time.time()\n# for k, J in enumerate(tqdm(Js)):\n#     for i, H in enumerate(Hrange):\n#         for j, f in enumerate(fscan):\n#             VSD[k, j, i] = simulate_vsd(J, H, f)\n# end = time.time()\n# print(f\"Time elapsed: {end - start:.3f}s\")\n</pre> def simulate_vsd(J, H, frequency):     int_step = 5e-13     demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)]      Ku = 0.8e3     alpha = 0.024  # 0.024     l1 = Layer(         \"free\",         mag=CVector(1, 0.1, 0.1),         anis=CVector(0, 1., 0.),  # direction of the anisotropy         Ms=1.03,         thickness=2.1e-9,         cellSurface=surf,         demagTensor=demag,         damping=alpha)      l2 = Layer(         \"bottom\",         mag=CVector(1, 0.1, 0.1),         anis=CVector(1, 0, 0),  # direction of the anisotropy         Ms=1.65,         thickness=6e-9,         cellSurface=surf,         demagTensor=demag,         damping=alpha)     j1 = Junction([l1, l2], 163.5, 176)     j1.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(Ku))     j1.setLayerAnisotropyDriver(\"bottom\", ScalarDriver.getConstantDriver(1e12))     j1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J))     hangle = FieldScan.angle2vector(90, 90, H)     j1.clearLog()     j1.setLayerExternalFieldDriver(         \"all\",         AxialDriver(ScalarDriver.getConstantDriver(hangle.x),                     ScalarDriver.getConstantDriver(hangle.y),                     ScalarDriver.getConstantDriver(hangle.z)))     j1.setLayerOerstedFieldDriver(         \"free\",         AxialDriver(             NullDriver(),             ScalarDriver.getSineDriver(0, 5, frequency, 0),             NullDriver(),         ))     j1.runSimulation(60e-9, int_step, int_step, solverMode=SolverMode.RK4)     log = j1.getLog()     dynamicR = log['R_free_bottom']      dynamicI = np.sin(2 * math.pi * frequency * np.asarray(log['time']))     vmix = compute_sd(dynamicR, dynamicI, int_step)     return vmix   HJs = (25, 15, -29) Js = [HJ * OetoAm * 6e-9 * 1.05 for HJ in HJs] Hrange = np.linspace(-15e3, 15e3, 50, endpoint=True) fscan = np.arange(1e9, 6.2e9, 0.2e9) VSD = np.zeros((len(Js), len(fscan), len(Hrange)), dtype=np.float32) Js = np.around(Js, decimals=7) for res in distribute(simulate_vsd, [Js, Hrange, fscan]):     (k, i, j), out = res     VSD[k, j, i] = out  # uncomment for serial # import time  # start = time.time() # for k, J in enumerate(tqdm(Js)): #     for i, H in enumerate(Hrange): #         for j, f in enumerate(fscan): #             VSD[k, j, i] = simulate_vsd(J, H, f) # end = time.time() # print(f\"Time elapsed: {end - start:.3f}s\") <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3900/3900 [01:37&lt;00:00, 39.94it/s]\n</pre> In\u00a0[4]: Copied! <pre>def kittel_relation(H_iec, H_ext, H_ku, Ms):\n    B_ = (abs(H_iec) + H_ext + H_ku) * mu0\n    f = 28024e6 * np.sqrt(B_ * (B_ + Ms))\n    return f\n\n\ndf = pd.read_csv('./data/dispersion_relation.csv', skiprows=[0], sep=',')\ndf_magen_237 = pd.read_csv('./data/J237.dat', sep='\\t', header=None)\ndf_magen_214 = pd.read_csv('./data/J214.dat', sep='\\t', header=None)\ndf_magen_190 = pd.read_csv('./data/magen3190.dat', sep='\\t', header=None)\ncmap = sns.color_palette('inferno', len(loops0))\nHJs = (25, 15, -29)\nfreq_indx = (4, 8, 14)\nmagens = [df_magen_237, df_magen_214, df_magen_190]\nwith plt.style.context(['science', 'nature']):\n    fig = plt.figure(constrained_layout=True, figsize=(3.4, 8), dpi=300)\n    gs = plt.GridSpec(4, 6)\n    ax1 = fig.add_subplot(gs[0, :2])\n    ax2 = fig.add_subplot(gs[0, 2:4])\n    ax3 = fig.add_subplot(gs[0, 4:])\n    axs = [ax1, ax2, ax3]\n    ax4 = fig.add_subplot(gs[1, :3])\n    ax5 = fig.add_subplot(gs[1, 3:])\n\n    for i, th in enumerate(loops0):\n        ax4.plot(loop_Hrange / 1e3,\n                 loops0[th],\n                 label=f\"{th} nm\",\n                 color=cmap[i])\n        ax5.plot(loop_Hrange / 1e3,\n                 loops90[th],\n                 label=f\"{th} nm\",\n                 color=cmap[i])\n\n    ax4.set_xlabel(\"H [kA/m]\")\n    ax5.set_xlabel(\"H [kA/m]\")\n    ax4.set_ylabel(r\"Resistance [$\\Omega$]\")\n    ax5.legend(frameon=True, loc=5)\n\n    Ms = 1.03\n    H_ku = 2 * 0.8e3 / (Ms)\n    HJsAm = [H_  * OetoAm for H_ in HJs]\n    Hpos_mask = np.argwhere(Hrange &gt;= -10e3).flatten()\n    for i, J in enumerate(Js):\n        VSD2 = Filters.detrend_axis(VSD[i], 1)\n        axs[i].pcolor(\n            Hrange / 1e3,\n            fscan / 1e9,\n            VSD2,\n            shading='auto',\n            cmap=cm.get_cmap(\"magma\"),\n        )\n        krel = kittel_relation(HJsAm[i], Hrange[Hpos_mask], H_ku, Ms) / 1e9\n        axs[i].plot(Hrange[~Hpos_mask] / 1e3, krel, color='turquoise', lw=2.)\n        col = 'ivory'\n        mult = 1\n        if i == 2:\n            colid = 11\n            mult = -1.\n        else:\n            colid = 13\n        axs[i].plot(mult * magens[i][0] / 1e3,\n                    magens[i][colid] / 1e9,\n                    label='Smit-Beljers',\n                    lw=1.5,\n                    linestyle='--',\n                    color=col)\n\n        if labels[i] + \"nm\" in df.columns:\n            axs[i].plot(df[labels[i] + \"nmH\"] * OetoAm / 1e3,\n                        df[labels[i] + \"nm\"],\n                        '.',\n                        markeredgecolor='lime',\n                        markerfacecolor='none',\n                        markersize=6,\n                        mew=1)\n        if J &gt; 0:\n            jlabel = r'$J &gt; 0$'\n        elif J &lt; 0:\n            jlabel = r'$J &lt; 0$'\n        if labels[i] == '2.14':\n            jlabel = r'$J \\approx 0$'\n        axs[i].set_title(labels[i] + \" nm, \" + jlabel)\n        axs[i].set_xlabel(\"$\\mathregular{H}_\\mathrm{y}$ [kA/m]\", usetex=False)\n        axs[i].set_ylim([1, 5.5])\n        axs[i].set_xlim([-15, 15])\n        if i &gt; 0:\n            continue\n\n    axs[0].set_ylabel(r\"f [GHz]\")\n    for label, ax in zip(('(a)', '(b)', '(c)', '(d)', '(e)'),\n                         (ax1, ax2, ax3, ax4, ax5)):\n        # label physical distance in and down:\n        trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,\n                                              fig.dpi_scale_trans)\n        ax.text(0.0,\n                1.0,\n                label,\n                transform=ax.transAxes + trans,\n                fontsize='medium',\n                verticalalignment='top',\n                bbox=dict(facecolor='none', edgecolor='none', pad=3.0))\n    fig.subplots_adjust(wspace=0, hspace=0.4)\n\n    for ax in (ax2, ax3, ax5):\n        ax.set_yticklabels([])\n    fig.align_ylabels()\n</pre> def kittel_relation(H_iec, H_ext, H_ku, Ms):     B_ = (abs(H_iec) + H_ext + H_ku) * mu0     f = 28024e6 * np.sqrt(B_ * (B_ + Ms))     return f   df = pd.read_csv('./data/dispersion_relation.csv', skiprows=[0], sep=',') df_magen_237 = pd.read_csv('./data/J237.dat', sep='\\t', header=None) df_magen_214 = pd.read_csv('./data/J214.dat', sep='\\t', header=None) df_magen_190 = pd.read_csv('./data/magen3190.dat', sep='\\t', header=None) cmap = sns.color_palette('inferno', len(loops0)) HJs = (25, 15, -29) freq_indx = (4, 8, 14) magens = [df_magen_237, df_magen_214, df_magen_190] with plt.style.context(['science', 'nature']):     fig = plt.figure(constrained_layout=True, figsize=(3.4, 8), dpi=300)     gs = plt.GridSpec(4, 6)     ax1 = fig.add_subplot(gs[0, :2])     ax2 = fig.add_subplot(gs[0, 2:4])     ax3 = fig.add_subplot(gs[0, 4:])     axs = [ax1, ax2, ax3]     ax4 = fig.add_subplot(gs[1, :3])     ax5 = fig.add_subplot(gs[1, 3:])      for i, th in enumerate(loops0):         ax4.plot(loop_Hrange / 1e3,                  loops0[th],                  label=f\"{th} nm\",                  color=cmap[i])         ax5.plot(loop_Hrange / 1e3,                  loops90[th],                  label=f\"{th} nm\",                  color=cmap[i])      ax4.set_xlabel(\"H [kA/m]\")     ax5.set_xlabel(\"H [kA/m]\")     ax4.set_ylabel(r\"Resistance [$\\Omega$]\")     ax5.legend(frameon=True, loc=5)      Ms = 1.03     H_ku = 2 * 0.8e3 / (Ms)     HJsAm = [H_  * OetoAm for H_ in HJs]     Hpos_mask = np.argwhere(Hrange &gt;= -10e3).flatten()     for i, J in enumerate(Js):         VSD2 = Filters.detrend_axis(VSD[i], 1)         axs[i].pcolor(             Hrange / 1e3,             fscan / 1e9,             VSD2,             shading='auto',             cmap=cm.get_cmap(\"magma\"),         )         krel = kittel_relation(HJsAm[i], Hrange[Hpos_mask], H_ku, Ms) / 1e9         axs[i].plot(Hrange[~Hpos_mask] / 1e3, krel, color='turquoise', lw=2.)         col = 'ivory'         mult = 1         if i == 2:             colid = 11             mult = -1.         else:             colid = 13         axs[i].plot(mult * magens[i][0] / 1e3,                     magens[i][colid] / 1e9,                     label='Smit-Beljers',                     lw=1.5,                     linestyle='--',                     color=col)          if labels[i] + \"nm\" in df.columns:             axs[i].plot(df[labels[i] + \"nmH\"] * OetoAm / 1e3,                         df[labels[i] + \"nm\"],                         '.',                         markeredgecolor='lime',                         markerfacecolor='none',                         markersize=6,                         mew=1)         if J &gt; 0:             jlabel = r'$J &gt; 0$'         elif J &lt; 0:             jlabel = r'$J &lt; 0$'         if labels[i] == '2.14':             jlabel = r'$J \\approx 0$'         axs[i].set_title(labels[i] + \" nm, \" + jlabel)         axs[i].set_xlabel(\"$\\mathregular{H}_\\mathrm{y}$ [kA/m]\", usetex=False)         axs[i].set_ylim([1, 5.5])         axs[i].set_xlim([-15, 15])         if i &gt; 0:             continue      axs[0].set_ylabel(r\"f [GHz]\")     for label, ax in zip(('(a)', '(b)', '(c)', '(d)', '(e)'),                          (ax1, ax2, ax3, ax4, ax5)):         # label physical distance in and down:         trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,                                               fig.dpi_scale_trans)         ax.text(0.0,                 1.0,                 label,                 transform=ax.transAxes + trans,                 fontsize='medium',                 verticalalignment='top',                 bbox=dict(facecolor='none', edgecolor='none', pad=3.0))     fig.subplots_adjust(wspace=0, hspace=0.4)      for ax in (ax2, ax3, ax5):         ax.set_yticklabels([])     fig.align_ylabels() <pre>/var/folders/wq/0q9brtfs5rq65q1t_mtgshb00000gn/T/ipykernel_81600/632190011.py:3: RuntimeWarning: invalid value encountered in sqrt\n  f = 28024e6 * np.sqrt(B_ * (B_ + Ms))\n/var/folders/wq/0q9brtfs5rq65q1t_mtgshb00000gn/T/ipykernel_81600/632190011.py:3: RuntimeWarning: invalid value encountered in sqrt\n  f = 28024e6 * np.sqrt(B_ * (B_ + Ms))\n/var/folders/wq/0q9brtfs5rq65q1t_mtgshb00000gn/T/ipykernel_81600/632190011.py:3: RuntimeWarning: invalid value encountered in sqrt\n  f = 28024e6 * np.sqrt(B_ * (B_ + Ms))\n/var/folders/wq/0q9brtfs5rq65q1t_mtgshb00000gn/T/ipykernel_81600/632190011.py:103: UserWarning: This figure was using constrained_layout, but that is incompatible with subplots_adjust and/or tight_layout; disabling constrained_layout.\n  fig.subplots_adjust(wspace=0, hspace=0.4)\n</pre> In\u00a0[5]: Copied! <pre>def simulate_pimm(J: float, stepsH: int = 100):\n    int_step = 5e-13\n    demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)]\n\n    Ku = 0.8e3\n    alpha = 0.024  # 0.024\n    Ms1 = 1.03\n    Ms2 = 1.65\n    surf = 0.1\n    l1 = Layer(\n        \"free\",\n        mag=CVector(1, 0.1, 0.1),\n        anis=CVector(0, 1., 0.),  # direction of the anisotropy\n        Ms=Ms1,\n        thickness=2e-9,\n        cellSurface=surf,\n        demagTensor=demag,\n        damping=alpha)\n\n    l2 = Layer(\n        \"bottom\",\n        mag=CVector(1, 0.1, 0.1),\n        anis=CVector(1, 0, 0),  # direction of the anisotropy\n        Ms=Ms2,\n        thickness=6e-9,\n        cellSurface=surf,\n        demagTensor=demag,\n        damping=alpha)\n    j1 = Junction([l1, l2], 163.5, 176)\n    j1.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(Ku))\n    j1.setLayerAnisotropyDriver(\"bottom\", ScalarDriver.getConstantDriver(1e12))\n    j1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J))\n    spectrum = []\n    Hscan, Hvecs = FieldScan.amplitude_scan(-800e3, 800e3, stepsH, 90, 45)\n    div = 10\n    j1.setLayerExternalFieldDriver(\n        \"all\",\n        AxialDriver(ScalarDriver.getConstantDriver(Hvecs[0][0]),\n                    ScalarDriver.getConstantDriver(Hvecs[0][1]),\n                    ScalarDriver.getConstantDriver(Hvecs[0][2])))\n    j1.runSimulation(5e-9, int_step, int_step, solverMode=SolverMode.RK4)\n    for hangle in Hvecs:\n        j1.clearLog()\n        j1.setLayerExternalFieldDriver(\n            \"all\",\n            AxialDriver(ScalarDriver.getConstantDriver(hangle[0]),\n                        ScalarDriver.getConstantDriver(hangle[1]),\n                        ScalarDriver.getConstantDriver(hangle[2])))\n        HoeDriver = AxialDriver(\n            NullDriver(), NullDriver(),\n            ScalarDriver.getStepDriver(0, 50, 0.0, int_step * 5))\n        j1.setLayerOerstedFieldDriver(\"all\", HoeDriver)\n        j1.runSimulation(15e-9, int_step, int_step, solverMode=SolverMode.RK4)\n        log = j1.getLog()\n\n        mixed = np.mean([\n            np.asarray(log[f\"{layer}_mz\"]) * Ms\n            for layer, Ms in zip(('free', 'bottom'), (Ms1, Ms2))\n        ],\n                        axis=0)\n        mixed = np.squeeze(mixed)\n        yf = np.abs(fft(mixed))\n        frequencies = fftfreq(len(yf), int_step)\n        frequencies = frequencies[:len(yf) // div]\n        yf = yf[1:len(yf) // div]\n        spectrum.append(yf)\n\n    return np.asarray(spectrum), frequencies, Hscan\n\n\nJrange = np.linspace(-1e-3, 1e-3, 30)\n\ndata = defaultdict(list)\nfor J in tqdm(Jrange, desc=\"simulating J\"):\n    spectrum, frequencies, Hvecs = simulate_pimm(J)\n    data['J'].append(J)\n    data['spec'].append(spectrum)\n    data['f'].append(frequencies)\n    data['H'].append(Hvecs)\n</pre> def simulate_pimm(J: float, stepsH: int = 100):     int_step = 5e-13     demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)]      Ku = 0.8e3     alpha = 0.024  # 0.024     Ms1 = 1.03     Ms2 = 1.65     surf = 0.1     l1 = Layer(         \"free\",         mag=CVector(1, 0.1, 0.1),         anis=CVector(0, 1., 0.),  # direction of the anisotropy         Ms=Ms1,         thickness=2e-9,         cellSurface=surf,         demagTensor=demag,         damping=alpha)      l2 = Layer(         \"bottom\",         mag=CVector(1, 0.1, 0.1),         anis=CVector(1, 0, 0),  # direction of the anisotropy         Ms=Ms2,         thickness=6e-9,         cellSurface=surf,         demagTensor=demag,         damping=alpha)     j1 = Junction([l1, l2], 163.5, 176)     j1.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(Ku))     j1.setLayerAnisotropyDriver(\"bottom\", ScalarDriver.getConstantDriver(1e12))     j1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J))     spectrum = []     Hscan, Hvecs = FieldScan.amplitude_scan(-800e3, 800e3, stepsH, 90, 45)     div = 10     j1.setLayerExternalFieldDriver(         \"all\",         AxialDriver(ScalarDriver.getConstantDriver(Hvecs[0][0]),                     ScalarDriver.getConstantDriver(Hvecs[0][1]),                     ScalarDriver.getConstantDriver(Hvecs[0][2])))     j1.runSimulation(5e-9, int_step, int_step, solverMode=SolverMode.RK4)     for hangle in Hvecs:         j1.clearLog()         j1.setLayerExternalFieldDriver(             \"all\",             AxialDriver(ScalarDriver.getConstantDriver(hangle[0]),                         ScalarDriver.getConstantDriver(hangle[1]),                         ScalarDriver.getConstantDriver(hangle[2])))         HoeDriver = AxialDriver(             NullDriver(), NullDriver(),             ScalarDriver.getStepDriver(0, 50, 0.0, int_step * 5))         j1.setLayerOerstedFieldDriver(\"all\", HoeDriver)         j1.runSimulation(15e-9, int_step, int_step, solverMode=SolverMode.RK4)         log = j1.getLog()          mixed = np.mean([             np.asarray(log[f\"{layer}_mz\"]) * Ms             for layer, Ms in zip(('free', 'bottom'), (Ms1, Ms2))         ],                         axis=0)         mixed = np.squeeze(mixed)         yf = np.abs(fft(mixed))         frequencies = fftfreq(len(yf), int_step)         frequencies = frequencies[:len(yf) // div]         yf = yf[1:len(yf) // div]         spectrum.append(yf)      return np.asarray(spectrum), frequencies, Hscan   Jrange = np.linspace(-1e-3, 1e-3, 30)  data = defaultdict(list) for J in tqdm(Jrange, desc=\"simulating J\"):     spectrum, frequencies, Hvecs = simulate_pimm(J)     data['J'].append(J)     data['spec'].append(spectrum)     data['f'].append(frequencies)     data['H'].append(Hvecs) <pre>simulating J: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [01:11&lt;00:00,  2.38s/it]\n</pre> In\u00a0[6]: Copied! <pre>with plt.style.context(['science', 'nature']):\n    fig, (ax1, ax2) = plt.subplots(1,\n                                   2,\n                                   figsize=(4.5, 2.5),\n                                   sharey=True,\n                                   dpi=300)\n    ax2.set_ylim([0, 30.5])\n    vmax = max(spectrum.max(), spectrum.min())\n    # argmaxline\n    lw = 1.5\n    palette = sns.color_palette(\"inferno\", len(Jrange))\n    spectrum = np.zeros_like(data['spec'][0])\n    for i in range(Jrange.shape[0]):\n        max_freqs = np.argmax(data['spec'][i], axis=1)\n        ax2.plot(data['H'][0] / 1e3,\n                 data['f'][0][max_freqs] / 1e9,\n                 linewidth=lw,\n                 color=palette[i],\n                 alpha=.9)\n        spectrum += data['spec'][i]\n    ax2.pcolor(Hvecs / 1e3,\n               frequencies / 1e9,\n               spectrum.T,\n               shading='auto',\n               cmap='inferno')\n    ax2.set_xlabel(\"H [kA/m]\")\n\n    ax1.set_xlabel(\"H [kA/m]\")\n    ax1.set_ylabel(\"f [GHz]\")\n    ax1.set_ylim([0, 30.5])\n    ax1.pcolor(Hvecs / 1e3,\n               frequencies / 1e9,\n               spectrum.T,\n               shading='auto',\n               cmap='inferno')\n\n    cmap = sns.color_palette(\"inferno\", as_cmap=True)\n    cmap = sns.color_palette(\"inferno\", as_cmap=True)\n    norm = mpl.colors.Normalize(vmin=spectrum.min(), vmax=spectrum.max())\n    cbar = fig.colorbar(mpl.cm.ScalarMappable(norm=norm, cmap=cmap),\n                        ax=ax1,\n                        orientation='vertical')\n    cbar.ax.set_ylabel(r\"Ampl. [a.u.]\", rotation=270, usetex=False)\n    cbar.ax.get_yaxis().labelpad = 9.5\n    cmap = sns.color_palette(\"inferno\", as_cmap=True)\n    norm = mpl.colors.Normalize(vmin=Jrange.min() * 1e3,\n                                vmax=Jrange.max() * 1e3)\n    cbar = fig.colorbar(mpl.cm.ScalarMappable(norm=norm, cmap=cmap),\n                        ax=ax2,\n                        orientation='vertical')\n    cbar.ax.set_ylabel(r\"J [$\\mathregular{mJ/m^2}$]\",\n                       rotation=270,\n                       usetex=False)\n    cbar.ax.get_yaxis().labelpad = 9.5\n\n    fig.subplots_adjust(wspace=0.15)\n    for label, ax in zip(('(a)', '(b)'), (ax1, ax2)):\n        trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,\n                                              fig.dpi_scale_trans)\n\n        fc = 'none'\n        ec = 'none'\n        ax.text(0,\n                1,\n                label,\n                color='azure',\n                transform=ax.transAxes + trans,\n                verticalalignment='top',\n                bbox=dict(facecolor=fc, edgecolor=ec, pad=3.0))\n</pre> with plt.style.context(['science', 'nature']):     fig, (ax1, ax2) = plt.subplots(1,                                    2,                                    figsize=(4.5, 2.5),                                    sharey=True,                                    dpi=300)     ax2.set_ylim([0, 30.5])     vmax = max(spectrum.max(), spectrum.min())     # argmaxline     lw = 1.5     palette = sns.color_palette(\"inferno\", len(Jrange))     spectrum = np.zeros_like(data['spec'][0])     for i in range(Jrange.shape[0]):         max_freqs = np.argmax(data['spec'][i], axis=1)         ax2.plot(data['H'][0] / 1e3,                  data['f'][0][max_freqs] / 1e9,                  linewidth=lw,                  color=palette[i],                  alpha=.9)         spectrum += data['spec'][i]     ax2.pcolor(Hvecs / 1e3,                frequencies / 1e9,                spectrum.T,                shading='auto',                cmap='inferno')     ax2.set_xlabel(\"H [kA/m]\")      ax1.set_xlabel(\"H [kA/m]\")     ax1.set_ylabel(\"f [GHz]\")     ax1.set_ylim([0, 30.5])     ax1.pcolor(Hvecs / 1e3,                frequencies / 1e9,                spectrum.T,                shading='auto',                cmap='inferno')      cmap = sns.color_palette(\"inferno\", as_cmap=True)     cmap = sns.color_palette(\"inferno\", as_cmap=True)     norm = mpl.colors.Normalize(vmin=spectrum.min(), vmax=spectrum.max())     cbar = fig.colorbar(mpl.cm.ScalarMappable(norm=norm, cmap=cmap),                         ax=ax1,                         orientation='vertical')     cbar.ax.set_ylabel(r\"Ampl. [a.u.]\", rotation=270, usetex=False)     cbar.ax.get_yaxis().labelpad = 9.5     cmap = sns.color_palette(\"inferno\", as_cmap=True)     norm = mpl.colors.Normalize(vmin=Jrange.min() * 1e3,                                 vmax=Jrange.max() * 1e3)     cbar = fig.colorbar(mpl.cm.ScalarMappable(norm=norm, cmap=cmap),                         ax=ax2,                         orientation='vertical')     cbar.ax.set_ylabel(r\"J [$\\mathregular{mJ/m^2}$]\",                        rotation=270,                        usetex=False)     cbar.ax.get_yaxis().labelpad = 9.5      fig.subplots_adjust(wspace=0.15)     for label, ax in zip(('(a)', '(b)'), (ax1, ax2)):         trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,                                               fig.dpi_scale_trans)          fc = 'none'         ec = 'none'         ax.text(0,                 1,                 label,                 color='azure',                 transform=ax.transAxes + trans,                 verticalalignment='top',                 bbox=dict(facecolor=fc, edgecolor=ec, pad=3.0)) <pre>/var/folders/wq/0q9brtfs5rq65q1t_mtgshb00000gn/T/ipykernel_81600/218232615.py:21: MatplotlibDeprecationWarning: shading='flat' when X and Y have the same dimensions as C is deprecated since 3.3.  Either specify the corners of the quadrilaterals with X and Y, or pass shading='auto', 'nearest' or 'gouraud', or set rcParams['pcolor.shading'].  This will become an error two minor releases later.\n  ax2.pcolor(Hvecs / 1e3,\n/var/folders/wq/0q9brtfs5rq65q1t_mtgshb00000gn/T/ipykernel_81600/218232615.py:31: MatplotlibDeprecationWarning: shading='flat' when X and Y have the same dimensions as C is deprecated since 3.3.  Either specify the corners of the quadrilaterals with X and Y, or pass shading='auto', 'nearest' or 'gouraud', or set rcParams['pcolor.shading'].  This will become an error two minor releases later.\n  ax1.pcolor(Hvecs / 1e3,\n</pre> In\u00a0[7]: Copied! <pre>def simulate_cims(H_ext: float, impulses: np.ndarray):\n    w = 10e-6\n    l = 75e-6\n\n    Ms = 0.5\n    Hk = 2508 * OetoAm\n    K = Ms * Hk / 2\n    jden = 6.94e10\n    Hdl = 6.23e2 / jden * 1.35\n    Hfl = 1.43e2 / jden * 1.35\n    # surface is required for temperature calculation\n    surf = w * l\n    # approximate demagnetisation tensor\n    demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 0)]\n    ### Create MTJ ###\n    # we use the .createSTTLayer to indicate the STT contributions\n    # we can also create SOT layers for other experiments.\n    alpha = 0.03\n    l1 = Layer.createSOTLayer(\n        \"free\",\n        mag=CVector(0.1, 0.1, 1.),\n        anis=CVector(0, 0., 1.),  # direction of the anisotropy\n        Ms=Ms,\n        thickness=4e-9,\n        cellSurface=surf,\n        demagTensor=demag,\n        damping=alpha,\n        dampingLikeTorque=Hdl,\n        fieldLikeTorque=Hfl)\n\n    j = Junction([l1])\n    j.setLayerAnisotropyDriver(\"all\", ScalarDriver.getConstantDriver(K))\n    j.setLayerReferenceLayer(\"all\", CVector(0, 1, 0))\n\n    tstep = 1e-13\n\n    hysteresis = []\n    data = {}\n\n    hangle = FieldScan.angle2vector(90, 0, H_ext)\n    j.setLayerExternalFieldDriver(\n        \"free\",\n        AxialDriver(ScalarDriver.getConstantDriver(hangle.x),\n                    ScalarDriver.getConstantDriver(hangle.y),\n                    ScalarDriver.getConstantDriver(hangle.z)))\n    for current in impulses:\n        j.clearLog()\n        j.setLayerMagnetisation(\"free\", CVector(0, 0, -1))\n        pulse = ScalarDriver.getTrapezoidDriver(0, current, 0, 1e-9, 3e-9)\n        j.setLayerCurrentDriver(\"all\", pulse)\n        j.runSimulation(15e-9, tstep, tstep)\n\n        log = j.getLog()\n        str_ = \"free\"\n        m = np.asarray(\n            [[log[f'{str_}_mx'], log[f'{str_}_my'], log[f'{str_}_mz']]])\n        Rx0 = [100]\n        Ry0 = [1]\n        SMR = [1.11]\n        AMR = [0.41]\n        AHE = [2.23]\n        _, Rxy = calculate_resistance_series(Rx0,\n                                             Ry0,\n                                             AMR=AMR,\n                                             AHE=AHE,\n                                             SMR=SMR,\n                                             m=m,\n                                             l=[l],\n                                             w=[w])\n\n        Rstable = Rxy[-100:].mean()\n        hysteresis.append(Rstable)\n\n    data['hysteresis'] = hysteresis\n    critical_current = 0\n    for i in range(1, len(hysteresis)):\n        if abs(hysteresis[i] - hysteresis[i - 1]) &gt; 0.1:\n            critical_current = impulses[i]\n    data['critical_current'] = critical_current\n    return data\n\n\nHspace = np.linspace(-1200, 1200, 50, endpoint=True) * OetoAm\nImax = 1.4e13\nimpulses = np.linspace(-Imax, Imax, num=250)\n\n\ndef sim_warp(H_ext):\n    return simulate_cims(H_ext, impulses)\n\n\ncritical_currents = np.zeros(len(Hspace))\n\nfor res in distribute(sim_warp, [Hspace]):\n    indx, output = res\n    critical_currents[indx] = output['critical_current']\n\n# uncomment for serial\n# import time\n# start = time.time()\n# for i, H_ext in enumerate(tqdm(Hspace)):\n#     output = sim_warp(H_ext)\n#     critical_currents[i] = output['critical_current']\n#     # print(f'{i} / {len(Hspace)}')\n# end = time.time()\n# print(f'Elapsed time: {end - start}')\n</pre> def simulate_cims(H_ext: float, impulses: np.ndarray):     w = 10e-6     l = 75e-6      Ms = 0.5     Hk = 2508 * OetoAm     K = Ms * Hk / 2     jden = 6.94e10     Hdl = 6.23e2 / jden * 1.35     Hfl = 1.43e2 / jden * 1.35     # surface is required for temperature calculation     surf = w * l     # approximate demagnetisation tensor     demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 0)]     ### Create MTJ ###     # we use the .createSTTLayer to indicate the STT contributions     # we can also create SOT layers for other experiments.     alpha = 0.03     l1 = Layer.createSOTLayer(         \"free\",         mag=CVector(0.1, 0.1, 1.),         anis=CVector(0, 0., 1.),  # direction of the anisotropy         Ms=Ms,         thickness=4e-9,         cellSurface=surf,         demagTensor=demag,         damping=alpha,         dampingLikeTorque=Hdl,         fieldLikeTorque=Hfl)      j = Junction([l1])     j.setLayerAnisotropyDriver(\"all\", ScalarDriver.getConstantDriver(K))     j.setLayerReferenceLayer(\"all\", CVector(0, 1, 0))      tstep = 1e-13      hysteresis = []     data = {}      hangle = FieldScan.angle2vector(90, 0, H_ext)     j.setLayerExternalFieldDriver(         \"free\",         AxialDriver(ScalarDriver.getConstantDriver(hangle.x),                     ScalarDriver.getConstantDriver(hangle.y),                     ScalarDriver.getConstantDriver(hangle.z)))     for current in impulses:         j.clearLog()         j.setLayerMagnetisation(\"free\", CVector(0, 0, -1))         pulse = ScalarDriver.getTrapezoidDriver(0, current, 0, 1e-9, 3e-9)         j.setLayerCurrentDriver(\"all\", pulse)         j.runSimulation(15e-9, tstep, tstep)          log = j.getLog()         str_ = \"free\"         m = np.asarray(             [[log[f'{str_}_mx'], log[f'{str_}_my'], log[f'{str_}_mz']]])         Rx0 = [100]         Ry0 = [1]         SMR = [1.11]         AMR = [0.41]         AHE = [2.23]         _, Rxy = calculate_resistance_series(Rx0,                                              Ry0,                                              AMR=AMR,                                              AHE=AHE,                                              SMR=SMR,                                              m=m,                                              l=[l],                                              w=[w])          Rstable = Rxy[-100:].mean()         hysteresis.append(Rstable)      data['hysteresis'] = hysteresis     critical_current = 0     for i in range(1, len(hysteresis)):         if abs(hysteresis[i] - hysteresis[i - 1]) &gt; 0.1:             critical_current = impulses[i]     data['critical_current'] = critical_current     return data   Hspace = np.linspace(-1200, 1200, 50, endpoint=True) * OetoAm Imax = 1.4e13 impulses = np.linspace(-Imax, Imax, num=250)   def sim_warp(H_ext):     return simulate_cims(H_ext, impulses)   critical_currents = np.zeros(len(Hspace))  for res in distribute(sim_warp, [Hspace]):     indx, output = res     critical_currents[indx] = output['critical_current']  # uncomment for serial # import time # start = time.time() # for i, H_ext in enumerate(tqdm(Hspace)): #     output = sim_warp(H_ext) #     critical_currents[i] = output['critical_current'] #     # print(f'{i} / {len(Hspace)}') # end = time.time() # print(f'Elapsed time: {end - start}') <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 50/50 [03:21&lt;00:00,  4.03s/it]\n</pre> In\u00a0[13]: Copied! <pre>def compute_j(Hx):\n    Hk = 2508 * OetoAm\n    Ms = 0.5\n    thetaSH = 13.5\n    tfm = 4e-9\n    jc = -(2 * echarge * Ms * tfm / hbar * thetaSH) * (Hk / 2 -\n                                                      Hx / math.sqrt(2))\n    return jc\n\n\ncric_c = compute_j(Hx=np.abs(Hspace))\n\nwith plt.style.context(['science', 'nature']):\n    fig, ax = plt.subplots(dpi=300)\n    ax.set_ylim([4.4, 8.5])\n    #     ax.set_xlim([-75, 75])\n    ax.plot(Hspace / 1e3,\n            np.abs(critical_currents) / 1e12,\n            'o',\n            markersize=5,\n            label='Simulation',\n            color='crimson',\n            markeredgecolor='k')\n    ax.plot(Hspace / 1e3,\n            cric_c / 1e12,\n            lw=2,\n            label='Analytical',\n            color='royalblue')\n    ax.set_xlabel(r\"$\\mathregular{H}_\\mathrm{x}$ [$\\mathdefault{kA/m}$]\",\n                  usetex=False)\n    ax.set_ylabel(r\"$j_\\mathrm{crit}$ [$\\mathdefault{TA/m^2}$]\", usetex=False)\n\n    ax.legend()\n</pre> def compute_j(Hx):     Hk = 2508 * OetoAm     Ms = 0.5     thetaSH = 13.5     tfm = 4e-9     jc = -(2 * echarge * Ms * tfm / hbar * thetaSH) * (Hk / 2 -                                                       Hx / math.sqrt(2))     return jc   cric_c = compute_j(Hx=np.abs(Hspace))  with plt.style.context(['science', 'nature']):     fig, ax = plt.subplots(dpi=300)     ax.set_ylim([4.4, 8.5])     #     ax.set_xlim([-75, 75])     ax.plot(Hspace / 1e3,             np.abs(critical_currents) / 1e12,             'o',             markersize=5,             label='Simulation',             color='crimson',             markeredgecolor='k')     ax.plot(Hspace / 1e3,             cric_c / 1e12,             lw=2,             label='Analytical',             color='royalblue')     ax.set_xlabel(r\"$\\mathregular{H}_\\mathrm{x}$ [$\\mathdefault{kA/m}$]\",                   usetex=False)     ax.set_ylabel(r\"$j_\\mathrm{crit}$ [$\\mathdefault{TA/m^2}$]\", usetex=False)      ax.legend() In\u00a0[9]: Copied! <pre># approximate demagnetisation tensor\ndemag = [\n    CVector(0.00116298, 0, 0),\n    CVector(0, 0.000227086, 0),\n    CVector(0, 0, 0.99861)\n]\nalpha = 0.005\nKdir = CVector(1, 0, 0)\nMs = 1.65\n# Ms = 1.8\nl1 = Layer(\"free\",\n           mag=CVector(0, 0, 1),\n           anis=Kdir,\n           Ms=Ms,\n           thickness=3.99e-9,\n           cellSurface=0,\n           demagTensor=demag,\n           damping=alpha)\n\nl2 = Layer(\"bottom\",\n           mag=CVector(0, 0, 1),\n           anis=Kdir,\n           Ms=Ms,\n           thickness=4e-9,\n           cellSurface=0,\n           demagTensor=demag,\n           damping=alpha)\n# J1 = -1.78e-3\n# J2 = -1.69e-4\nJ1 = -1.8e-3\nJ2 = -1.74e-4\n\nK1 = K2 = 1.05e3\n# K1 = K2 = 0.55e3\nint_step = 4e-14\n\nj1 = Junction([l1, l2], 100, 102)\n\nj1.setLayerAnisotropyDriver(\"all\", ScalarDriver.getConstantDriver(K1))\nj1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J1))\nj1.setQuadIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J2))\nHscan, Hvecs = FieldScan.amplitude_scan(-1200e3, 1200e3, 200, 89, 90)\nmagnetisations = defaultdict(list)\nspectrum = []\nsim_time = 4e-9\nfor indx, H in enumerate(tqdm(Hvecs)):\n    j1.clearLog()\n    j1.setLayerExternalFieldDriver(\n        \"all\",\n        AxialDriver(ScalarDriver.getConstantDriver(H[0]),\n                    ScalarDriver.getConstantDriver(H[1]),\n                    ScalarDriver.getConstantDriver(H[2])))\n    j1.setLayerOerstedFieldDriver(\n        \"all\",\n        AxialDriver(NullDriver(), NullDriver(),\n                    ScalarDriver.getStepDriver(0, 50, 0, int_step * 3)))\n    # if (H)\n    j1.runSimulation(sim_time, int_step, int_step)\n    log = j1.getLog()\n\n    org_layer_strs = ('free', 'bottom')\n    m_traj = np.asarray([[\n        log[f'{org_layer_strs[i]}_mx'], log[f'{org_layer_strs[i]}_my'],\n        log[f'{org_layer_strs[i]}_mz']\n    ] for i in range(2)])\n\n    m = m_traj[:, :, -100:]  # all layers, all x, y, z, last timestamp\n    m_avg = np.mean(m_traj[:, :, -1], 0)\n\n    mixed = [np.asarray(log[f\"{org_layer_strs[i]}_mz\"]) for i in range(2)]\n    # mixed = np.mean(np.squeeze(mixed), axis=0)\n    yf = np.abs(\n        fft(log[f\"{org_layer_strs[0]}_mz\"]) +\n        fft(log[f\"{org_layer_strs[1]}_mz\"]))\n    freqs = fftfreq(len(yf), int_step)\n    freqs = freqs[:len(freqs) // 2]\n    yf = yf[:len(yf) // 2]\n\n    findx = np.argwhere(freqs &lt;= 65e9)\n    freqs = freqs[findx]\n    yf = yf[findx]\n\n    spectrum.append(yf)\n    Rx, Ry = calculate_resistance_series([100, 100], [1, 1], [-0.046, -0.046],\n                                         [-2.7, -2.7], [-0.24, -0.24],\n                                         m,\n                                         l=[30, 30],\n                                         w=[20, 20])\n    magnetisations['H'].append(Hscan[indx])\n    magnetisations['m1'].append(m[0].mean(axis=1))\n    magnetisations['m2'].append(m[1].mean(axis=1))\n    magnetisations['m'].append(m_avg)\n    magnetisations['Rxx'].append(Rx.mean())\n    magnetisations['Rxy'].append(Ry.mean())\n    magnetisations['Rz'].append(log['R_free_bottom'][-1])\n    magnetisations['traj'].append(m_traj)\n\nspectrum = np.asarray(spectrum).squeeze()\n\n# phase computation\ntraj = np.asarray(magnetisations['traj'])\ntime = np.asarray(log['time']) * 1e9\nstart = 3.5  # pick a time\nstop = 4.5\nphases = defaultdict(list)\nindx = 1\nfor traj_h in traj:\n    eps = np.deg2rad(0.01)  # we allow 5 deg variation\n    rtime = np.argwhere((time &lt;= stop) &amp; (time &gt;= start))\n    for label, indx in zip('xyz', range(3)):\n        a = traj_h[0, indx, rtime].squeeze()\n        b = traj_h[1, indx, rtime].squeeze()\n        af = fft(a)\n        bf = fft(b)\n        freqs2 = fftfreq(len(af), int_step)\n        freqs2 = freqs2[:len(freqs2) // 2]\n        af = af[:len(af) // 2]\n        bf = bf[:len(bf) // 2]\n\n        findx = np.argwhere(freqs2 &lt;= 65e9)\n        af = af[findx]\n        bf = bf[findx]\n\n        angle_af = np.angle(af)\n        angle_bf = np.angle(bf)\n        max_freq = np.argmax(np.abs(af[1:]))\n        phase = np.abs(angle_af[1:][max_freq] - angle_bf[1:][max_freq])\n        phases[label].append(phase)\n</pre> # approximate demagnetisation tensor demag = [     CVector(0.00116298, 0, 0),     CVector(0, 0.000227086, 0),     CVector(0, 0, 0.99861) ] alpha = 0.005 Kdir = CVector(1, 0, 0) Ms = 1.65 # Ms = 1.8 l1 = Layer(\"free\",            mag=CVector(0, 0, 1),            anis=Kdir,            Ms=Ms,            thickness=3.99e-9,            cellSurface=0,            demagTensor=demag,            damping=alpha)  l2 = Layer(\"bottom\",            mag=CVector(0, 0, 1),            anis=Kdir,            Ms=Ms,            thickness=4e-9,            cellSurface=0,            demagTensor=demag,            damping=alpha) # J1 = -1.78e-3 # J2 = -1.69e-4 J1 = -1.8e-3 J2 = -1.74e-4  K1 = K2 = 1.05e3 # K1 = K2 = 0.55e3 int_step = 4e-14  j1 = Junction([l1, l2], 100, 102)  j1.setLayerAnisotropyDriver(\"all\", ScalarDriver.getConstantDriver(K1)) j1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J1)) j1.setQuadIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J2)) Hscan, Hvecs = FieldScan.amplitude_scan(-1200e3, 1200e3, 200, 89, 90) magnetisations = defaultdict(list) spectrum = [] sim_time = 4e-9 for indx, H in enumerate(tqdm(Hvecs)):     j1.clearLog()     j1.setLayerExternalFieldDriver(         \"all\",         AxialDriver(ScalarDriver.getConstantDriver(H[0]),                     ScalarDriver.getConstantDriver(H[1]),                     ScalarDriver.getConstantDriver(H[2])))     j1.setLayerOerstedFieldDriver(         \"all\",         AxialDriver(NullDriver(), NullDriver(),                     ScalarDriver.getStepDriver(0, 50, 0, int_step * 3)))     # if (H)     j1.runSimulation(sim_time, int_step, int_step)     log = j1.getLog()      org_layer_strs = ('free', 'bottom')     m_traj = np.asarray([[         log[f'{org_layer_strs[i]}_mx'], log[f'{org_layer_strs[i]}_my'],         log[f'{org_layer_strs[i]}_mz']     ] for i in range(2)])      m = m_traj[:, :, -100:]  # all layers, all x, y, z, last timestamp     m_avg = np.mean(m_traj[:, :, -1], 0)      mixed = [np.asarray(log[f\"{org_layer_strs[i]}_mz\"]) for i in range(2)]     # mixed = np.mean(np.squeeze(mixed), axis=0)     yf = np.abs(         fft(log[f\"{org_layer_strs[0]}_mz\"]) +         fft(log[f\"{org_layer_strs[1]}_mz\"]))     freqs = fftfreq(len(yf), int_step)     freqs = freqs[:len(freqs) // 2]     yf = yf[:len(yf) // 2]      findx = np.argwhere(freqs &lt;= 65e9)     freqs = freqs[findx]     yf = yf[findx]      spectrum.append(yf)     Rx, Ry = calculate_resistance_series([100, 100], [1, 1], [-0.046, -0.046],                                          [-2.7, -2.7], [-0.24, -0.24],                                          m,                                          l=[30, 30],                                          w=[20, 20])     magnetisations['H'].append(Hscan[indx])     magnetisations['m1'].append(m[0].mean(axis=1))     magnetisations['m2'].append(m[1].mean(axis=1))     magnetisations['m'].append(m_avg)     magnetisations['Rxx'].append(Rx.mean())     magnetisations['Rxy'].append(Ry.mean())     magnetisations['Rz'].append(log['R_free_bottom'][-1])     magnetisations['traj'].append(m_traj)  spectrum = np.asarray(spectrum).squeeze()  # phase computation traj = np.asarray(magnetisations['traj']) time = np.asarray(log['time']) * 1e9 start = 3.5  # pick a time stop = 4.5 phases = defaultdict(list) indx = 1 for traj_h in traj:     eps = np.deg2rad(0.01)  # we allow 5 deg variation     rtime = np.argwhere((time &lt;= stop) &amp; (time &gt;= start))     for label, indx in zip('xyz', range(3)):         a = traj_h[0, indx, rtime].squeeze()         b = traj_h[1, indx, rtime].squeeze()         af = fft(a)         bf = fft(b)         freqs2 = fftfreq(len(af), int_step)         freqs2 = freqs2[:len(freqs2) // 2]         af = af[:len(af) // 2]         bf = bf[:len(bf) // 2]          findx = np.argwhere(freqs2 &lt;= 65e9)         af = af[findx]         bf = bf[findx]          angle_af = np.angle(af)         angle_bf = np.angle(bf)         max_freq = np.argmax(np.abs(af[1:]))         phase = np.abs(angle_af[1:][max_freq] - angle_bf[1:][max_freq])         phases[label].append(phase) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 200/200 [00:21&lt;00:00,  9.49it/s]\n</pre> In\u00a0[10]: Copied! <pre>pimm_data = pd.read_csv('./data/4804_35.csv', sep=';')\npimm_data['f'] = pd.to_numeric(pimm_data['f'].str.replace(',', '.')).astype(float)\npimm_data['H'] = pd.to_numeric(pimm_data['H'].str.replace(',', '.')).astype(float)\npimm_data = pimm_data.loc[pimm_data['H'].between(-550e3/OetoAm, 550e3/OetoAm)]\nwith plt.style.context(['science', 'nature']):\n    fig, axs = plt.subplots(3, 2, figsize=(5, 2), dpi=300, sharex=True)\n    # hindx = 55\n    hindx = 57\n    traj = np.asarray(magnetisations['traj'])[hindx]\n    time = np.asarray(log['time']) * 1e9\n    start = 3.5\n    stop = 4.5\n    rtime = np.argwhere((time &lt;= stop) &amp; (time &gt;= start))\n    for i, label in enumerate('xyz'):\n        axs[i, 0].plot(time[rtime],\n                       traj[0, i, rtime],\n                       color='royalblue',\n                       label=rf\"$m_1$\")\n        axs[i, 0].plot(time[rtime],\n                       traj[1, i, rtime],\n                       color='crimson',\n                       label=rf\"$m_2$\")\n        axs[i, 0].set_ylabel(rf'$m_{label}$')\n    fig.subplots_adjust(hspace=0, wspace=0.25)\n    fig.align_labels()\n\n    gs = axs[1, -1].get_gridspec()\n    axs[0, 0].legend()\n    axbig = fig.add_subplot(gs[:, -1])\n    axbig.pcolor(Hscan[1:] / 1e3,\n                 freqs / 1e9,\n                 np.log10(spectrum[1:].T),\n                 shading='auto',\n                 cmap='magma')\n    axbig.axvline(x=Hscan[hindx] / 1e3,\n                  color='lavender',\n                  linestyle='--',\n                  label=f\"{Hscan[hindx] / 1e3:.0f} kA/m\")\n    axbig.set_xlabel(\"$\\mathrm{H}_\\mathrm{y}$ [kA/m]\", usetex=False)\n    axbig.set_ylabel(\"f [GHz]\")\n    axbig2 = axbig.twinx()\n    axbig.plot(pimm_data['H'] * OetoAm / 1e3,\n               pimm_data['f'],\n               'o',\n               markerfacecolor='royalblue',\n               markeredgecolor='black')\n    p = uniform_filter1d(phases['z'][1:], 5)\n\n    axbig2.plot(Hscan[1:] / 1e3, p, color='azure', label=rf'$\\phi_{label}$')\n    axbig2.set_ylabel(r'$\\Delta\\phi_z$ [rad]', rotation=270, labelpad=15)\n\n    for ax in axs[:, -1]:\n        # ax.remove()\n        ax.set_axis_off()\n    axs[-1, 0].set_xlabel(\"Time [ns]\")\n    axbig.legend(frameon=False, labelcolor='lavender', loc=10)\n    # axbig.legend(frameon=False, labelcolor='lavender', loc=1, fontsize='x-small')\n    for label, ax in zip(('(a)', '(b)', '(c)', '(d)'), [*axs[:, 0], axbig]):\n        trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,\n                                              fig.dpi_scale_trans)\n        if label == '(d)':\n            fc = 'none'\n            ec = 'none'\n        else:\n            fc = 'white'\n            ec = 'lavender'\n        ax.text(0,\n                1,\n                label,\n                color='black',\n                transform=ax.transAxes + trans,\n                verticalalignment='top',\n                bbox=dict(facecolor=fc, edgecolor=ec, pad=3.0))\n</pre> pimm_data = pd.read_csv('./data/4804_35.csv', sep=';') pimm_data['f'] = pd.to_numeric(pimm_data['f'].str.replace(',', '.')).astype(float) pimm_data['H'] = pd.to_numeric(pimm_data['H'].str.replace(',', '.')).astype(float) pimm_data = pimm_data.loc[pimm_data['H'].between(-550e3/OetoAm, 550e3/OetoAm)] with plt.style.context(['science', 'nature']):     fig, axs = plt.subplots(3, 2, figsize=(5, 2), dpi=300, sharex=True)     # hindx = 55     hindx = 57     traj = np.asarray(magnetisations['traj'])[hindx]     time = np.asarray(log['time']) * 1e9     start = 3.5     stop = 4.5     rtime = np.argwhere((time &lt;= stop) &amp; (time &gt;= start))     for i, label in enumerate('xyz'):         axs[i, 0].plot(time[rtime],                        traj[0, i, rtime],                        color='royalblue',                        label=rf\"$m_1$\")         axs[i, 0].plot(time[rtime],                        traj[1, i, rtime],                        color='crimson',                        label=rf\"$m_2$\")         axs[i, 0].set_ylabel(rf'$m_{label}$')     fig.subplots_adjust(hspace=0, wspace=0.25)     fig.align_labels()      gs = axs[1, -1].get_gridspec()     axs[0, 0].legend()     axbig = fig.add_subplot(gs[:, -1])     axbig.pcolor(Hscan[1:] / 1e3,                  freqs / 1e9,                  np.log10(spectrum[1:].T),                  shading='auto',                  cmap='magma')     axbig.axvline(x=Hscan[hindx] / 1e3,                   color='lavender',                   linestyle='--',                   label=f\"{Hscan[hindx] / 1e3:.0f} kA/m\")     axbig.set_xlabel(\"$\\mathrm{H}_\\mathrm{y}$ [kA/m]\", usetex=False)     axbig.set_ylabel(\"f [GHz]\")     axbig2 = axbig.twinx()     axbig.plot(pimm_data['H'] * OetoAm / 1e3,                pimm_data['f'],                'o',                markerfacecolor='royalblue',                markeredgecolor='black')     p = uniform_filter1d(phases['z'][1:], 5)      axbig2.plot(Hscan[1:] / 1e3, p, color='azure', label=rf'$\\phi_{label}$')     axbig2.set_ylabel(r'$\\Delta\\phi_z$ [rad]', rotation=270, labelpad=15)      for ax in axs[:, -1]:         # ax.remove()         ax.set_axis_off()     axs[-1, 0].set_xlabel(\"Time [ns]\")     axbig.legend(frameon=False, labelcolor='lavender', loc=10)     # axbig.legend(frameon=False, labelcolor='lavender', loc=1, fontsize='x-small')     for label, ax in zip(('(a)', '(b)', '(c)', '(d)'), [*axs[:, 0], axbig]):         trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,                                               fig.dpi_scale_trans)         if label == '(d)':             fc = 'none'             ec = 'none'         else:             fc = 'white'             ec = 'lavender'         ax.text(0,                 1,                 label,                 color='black',                 transform=ax.transAxes + trans,                 verticalalignment='top',                 bbox=dict(facecolor=fc, edgecolor=ec, pad=3.0))  In\u00a0[11]: Copied! <pre>with plt.style.context(['science', 'nature']):\n    fig, ax = plt.subplots(3, 2, dpi=300, sharex=True)\n    m1 = np.asarray(magnetisations['m1'])\n    m2 = np.asarray(magnetisations['m2'])\n    Rx = np.asarray(magnetisations['Rxx'])\n    Ry = np.asarray(magnetisations['Rxy'])\n    Rz = np.asarray(magnetisations['Rz'])\n    m = np.asarray(magnetisations['m'])\n    H = np.asarray(magnetisations['H']) / 1e3\n    w = 3\n    for label, i in zip('xyz', range(3)):\n        ax[i, 0].plot(H[1:], m[1:, i], lw=2, color='k', alpha=1)\n        ax[i, 0].set_ylabel(rf\"$m_{label}$\")\n\n    ax[0, 0].legend()\n    for i, (label, R) in enumerate(zip(('xx', 'xy', 'zz'), (Rx, Ry, Rz))):\n        ax[i, 1].plot(H[1:], R[1:], lw=2, color='k')\n        ax[i, 1].set_ylabel(r\"$R_{\" f\"{label}\" r\"}$\")\n    fig.subplots_adjust(wspace=0.6, hspace=0)\n    fig.align_ylabels()\n    ax[-1, 0].set_xlabel(\"$\\mathrm{H}_\\mathrm{y}$ [kA/m]\", usetex=False)\n    ax[-1, 1].set_xlabel(\"$\\mathrm{H}_\\mathrm{y}$ [kA/m]\", usetex=False)\n    for label, ax in zip(('(a)', '(d)', '(b)', '(e)', '(c)', '(f)'),\n                         ax.flatten()):\n        # label physical distance in and down:\n        trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,\n                                              fig.dpi_scale_trans)\n        ax.text(0.0,\n                1.0,\n                label,\n                transform=ax.transAxes + trans,\n                fontsize='medium',\n                verticalalignment='top',\n                bbox=dict(facecolor='none', edgecolor='none', pad=3.0))\n</pre> with plt.style.context(['science', 'nature']):     fig, ax = plt.subplots(3, 2, dpi=300, sharex=True)     m1 = np.asarray(magnetisations['m1'])     m2 = np.asarray(magnetisations['m2'])     Rx = np.asarray(magnetisations['Rxx'])     Ry = np.asarray(magnetisations['Rxy'])     Rz = np.asarray(magnetisations['Rz'])     m = np.asarray(magnetisations['m'])     H = np.asarray(magnetisations['H']) / 1e3     w = 3     for label, i in zip('xyz', range(3)):         ax[i, 0].plot(H[1:], m[1:, i], lw=2, color='k', alpha=1)         ax[i, 0].set_ylabel(rf\"$m_{label}$\")      ax[0, 0].legend()     for i, (label, R) in enumerate(zip(('xx', 'xy', 'zz'), (Rx, Ry, Rz))):         ax[i, 1].plot(H[1:], R[1:], lw=2, color='k')         ax[i, 1].set_ylabel(r\"$R_{\" f\"{label}\" r\"}$\")     fig.subplots_adjust(wspace=0.6, hspace=0)     fig.align_ylabels()     ax[-1, 0].set_xlabel(\"$\\mathrm{H}_\\mathrm{y}$ [kA/m]\", usetex=False)     ax[-1, 1].set_xlabel(\"$\\mathrm{H}_\\mathrm{y}$ [kA/m]\", usetex=False)     for label, ax in zip(('(a)', '(d)', '(b)', '(e)', '(c)', '(f)'),                          ax.flatten()):         # label physical distance in and down:         trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,                                               fig.dpi_scale_trans)         ax.text(0.0,                 1.0,                 label,                 transform=ax.transAxes + trans,                 fontsize='medium',                 verticalalignment='top',                 bbox=dict(facecolor='none', edgecolor='none', pad=3.0)) <pre>No handles with labels found to put in legend.\n</pre> In\u00a0[15]: Copied! <pre>data = pd.read_csv('./data/V10325_Ptb_85_thin_cross.txt',\n                   sep='\\t',\n                   skiprows=[1, 2])\nHrange = np.arange(100, 5000, 100)\nHrange_red = [4000., 100.]\njhm = 1.33e11\nl = 3e-5\nw = 1e-5\nrhohm = 2.5e-7\nrhofm = 2.5e-7\nthm = 9.9e-9\ntfm = 2e-9\nahm = thm * w\nafm = tfm * w\nRhm = rhohm * l / ahm\nRfm = rhofm * l / afm\nIrf = jhm * ahm\n\nR0 = 1\nRx0 = [0]\nRy0 = [3]\nSMR = [-0.125 * R0]\nAMR = [-1e-4 * R0]\nAHE = [1.36]\nw = [w]\nl = [l]\n\n\ndef compute_vsd(dynamic_r, integration_step, dynamic_i):\n    SD = dynamic_i * dynamic_r\n    y = fft(SD) * (2 / len(SD))\n    amp = np.abs(y)\n    phase = np.angle(y)\n    freqs = fftfreq(len(y), integration_step)\n    y = y[:len(y) // 2]\n    freqs = freqs[:len(freqs) // 2]\n    return amp, phase, freqs\n\n\ndef find_max_f_frequency(freqs: np.ndarray, values: np.ndarray,\n                         frequency: float):\n    # take between 0 and max\n    freq_indx = np.abs(freqs - frequency).argmin()\n    max_value = values[freq_indx]\n    max_freq = freqs[freq_indx]\n    return max_value, max_freq\n\n\ndef compute_harmonics(theta, Hampl, Ms, Ku, Hdl, Hfl, steps):\n\n    demagTensor = [\n        CVector(0., 0., 0.),\n        CVector(0., 0., 0.),\n        CVector(0., 0., 1.)\n    ]\n\n    thickness = 2e-9\n    s_time = 200e-9\n    int_step = 1e-12\n\n    l1_params = {\n        \"Ms\": Ms,\n        \"thickness\": thickness,\n        \"anis\": CVector(0.1, 0.1, 1.),\n        \"mag\": CVector(0, 0, 1.),\n        \"cellSurface\": 1.0,\n        \"demagTensor\": demagTensor,\n        \"damping\": 0.003,\n    }\n    l1 = Layer(id=\"free\", **l1_params)\n    l1.setReferenceLayer(CVector(0., 1., 0.))\n    layer_str = [\"free\"]\n    layers = [l1]\n    junction = Junction(layers=layers)\n    junction.setLayerAnisotropyDriver(\"all\",\n                                      ScalarDriver.getConstantDriver(Ku))\n\n    frequency = 0.01e9\n    Hscan, Hvecs = FieldScan.phi_scan(-190, 190, steps, Hampl, theta=theta)\n    amp_diag1f = np.zeros((len(Hscan), ))\n    phase_diag2f = np.zeros((len(Hscan), ))\n    junction.setLayerDampingLikeTorqueDriver(\n        \"all\", ScalarDriver.getSineDriver(0, Hdl, frequency, 0))\n    junction.setLayerFieldLikeTorqueDriver(\n        \"all\", ScalarDriver.getSineDriver(0, Hfl, frequency, 0))\n\n    Hval = Hvecs[0]\n\n    HDriver = AxialDriver(ScalarDriver.getConstantDriver(Hval[0]),\n                          ScalarDriver.getConstantDriver(Hval[1]),\n                          ScalarDriver.getConstantDriver(Hval[2]))\n    junction.runSimulation(s_time, int_step, int_step)\n    mags = [junction.getLayerMagnetisation(\"free\")]\n    for hi, Hval in enumerate(Hvecs):\n        junction.clearLog()\n        HDriver = AxialDriver(ScalarDriver.getConstantDriver(Hval[0]),\n                              ScalarDriver.getConstantDriver(Hval[1]),\n                              ScalarDriver.getConstantDriver(Hval[2]))\n        junction.setLayerExternalFieldDriver(\"all\", HDriver)\n        # set mags for better convergence\n        for i, l_str in enumerate(layer_str):\n            junction.setLayerMagnetisation(l_str, mags[i])\n\n        junction.runSimulation(s_time, int_step, int_step)\n        # set new mags\n        for str_ in layer_str:\n            mags[i] = junction.getLayerMagnetisation(str_)\n\n        log = junction.getLog()\n        m = np.asarray(\n            [[log[f'{str_}_mx'], log[f'{str_}_my'], log[f'{str_}_mz']]\n             for str_ in layer_str])\n\n        _, dynamic_ry = calculate_resistance_parallel(Rx0, Ry0, AMR, AHE, SMR,\n                                                      m, l, w)\n\n        lt = np.asarray(log['time'])\n        dynamic_i = Irf * np.sin(2 * np.pi * frequency * lt)\n        org_amp, org_phase, freqs_org = compute_vsd(dynamic_r=dynamic_ry,\n                                                    integration_step=int_step,\n                                                    dynamic_i=dynamic_i)\n\n        max_phase2f, _ = find_max_f_frequency(freqs_org, org_phase,\n                                              2 * frequency)\n        max_amp1f, _ = find_max_f_frequency(freqs_org, org_amp, frequency)\n        max_amp2f, _ = find_max_f_frequency(freqs_org, org_amp, 2 * frequency)\n        amp_diag1f[hi] = max_amp1f\n        phase_diag2f[hi] = np.cos(max_phase2f) * max_amp2f\n    return amp_diag1f, phase_diag2f, Hscan\n\n\ndef compute_harmonics_distributed(H):\n    \"\"\"Insert layer parameters here\"\"\"\n    theta = 92\n    Ms = 1.2\n    Ku = 0.00313 * TtoAm * Ms / 2\n    Hdl = 1.325e-3 * TtoAm\n    Hfl = -2.06e-04 * TtoAm\n    _, phase_diag2f, phi_scan = compute_harmonics(theta=theta,\n                                                  steps=50,\n                                                  Ms=Ms,\n                                                  Ku=Ku,\n                                                  Hampl=H * OetoAm,\n                                                  Hdl=Hdl,\n                                                  Hfl=Hfl)\n    return phase_diag2f, phi_scan\n\n\n# we distribute over all fields\nresult = distribute(compute_harmonics_distributed, [Hrange_red], n_cores=2)\n\nres = []\nfor r in result:\n    (i), out = r\n    phase_diag2f, scan = out\n    res.append(phase_diag2f)\n    phi_scan = scan\n\nres_max = np.max(res)\nwith plt.style.context(['science', 'nature']):\n    fig, ax = plt.subplots(dpi=300)\n    ms = 8\n    cmap = sns.color_palette(\"crest\", as_cmap=True)\n    cmap_disc = sns.color_palette(\"crest\", len(Hrange))\n    norm = mpl.colors.Normalize(vmin=min(Hrange / 1e3), vmax=max(Hrange / 1e3))\n    indx = (2, 10)\n    patches = []\n    labels = []\n    for i in range(len(res)):\n        r = np.asarray(res[i])\n        R = (r - r.min()) / (r.max() - r.min())\n        ax.plot(phi_scan,\n                R,\n                lw=2,\n                color=cmap(norm(Hrange_red[i] / 1e3)),\n                label=\"Sim.\")\n        labels.append(f\"Sim. - {np.round(Hrange_red[i]*OetoAm/1e3):.0f} kAm/m\")\n        line_exp = Line2D(range(1),\n                          range(1),\n                          color=cmap(norm(Hrange_red[i] / 1e3)))\n\n        patches.append(line_exp)\n        patches.append(\n            Line2D([], [],\n                   linestyle='none',\n                   color=cmap(norm(Hrange_red[i] / 1e3)),\n                   marker='o',\n                   markerfacecolor='none',\n                   markersize=ms // 2))\n        labels.append(f\"Exp. - {np.round(Hrange_red[i]*OetoAm/1e3):.0f} kA/m\")\n    patches.append(\n        Line2D(range(1), range(1), linestyle='dashed', color=\"crimson\"))\n    labels.append(\"Fit\")\n\n    for i in indx:\n        V = (data[f'Phase.{i}'] /\n             data[f'Phase.{i}'].max()).rolling(window=5).mean()\n        V = (V - V.min()) / (V.max() - V.min())\n        # remove NaNs\n        x = data[f'F. Angle Azim..{i}'] - 12\n        mask = pd.isna(V)\n        x = x.loc[~mask]\n        V = V.loc[~mask]\n        ax.plot(x,\n                V,\n                '.',\n                markersize=ms,\n                markerfacecolor='none',\n                markeredgecolor=cmap(norm(data[f'Field.{i}'][0] / 1e3)),\n                label='Exp.')\n\n        popt, _ = curve_fit(\n            f=meinert_model,\n            xdata=x,\n            ydata=V,\n        )\n        ax.plot(x, meinert_model(x, *popt), '--', color='crimson', label='Fit')\n\n    ax.set_xlim([-180, 180])\n\n    ax.legend(handles=patches, labels=labels)\n    ax.set_xlabel(r\"$\\phi$ [deg]\")\n    ax.set_ylabel(r\"$V_{2\\omega} [norm.]$\")\n</pre> data = pd.read_csv('./data/V10325_Ptb_85_thin_cross.txt',                    sep='\\t',                    skiprows=[1, 2]) Hrange = np.arange(100, 5000, 100) Hrange_red = [4000., 100.] jhm = 1.33e11 l = 3e-5 w = 1e-5 rhohm = 2.5e-7 rhofm = 2.5e-7 thm = 9.9e-9 tfm = 2e-9 ahm = thm * w afm = tfm * w Rhm = rhohm * l / ahm Rfm = rhofm * l / afm Irf = jhm * ahm  R0 = 1 Rx0 = [0] Ry0 = [3] SMR = [-0.125 * R0] AMR = [-1e-4 * R0] AHE = [1.36] w = [w] l = [l]   def compute_vsd(dynamic_r, integration_step, dynamic_i):     SD = dynamic_i * dynamic_r     y = fft(SD) * (2 / len(SD))     amp = np.abs(y)     phase = np.angle(y)     freqs = fftfreq(len(y), integration_step)     y = y[:len(y) // 2]     freqs = freqs[:len(freqs) // 2]     return amp, phase, freqs   def find_max_f_frequency(freqs: np.ndarray, values: np.ndarray,                          frequency: float):     # take between 0 and max     freq_indx = np.abs(freqs - frequency).argmin()     max_value = values[freq_indx]     max_freq = freqs[freq_indx]     return max_value, max_freq   def compute_harmonics(theta, Hampl, Ms, Ku, Hdl, Hfl, steps):      demagTensor = [         CVector(0., 0., 0.),         CVector(0., 0., 0.),         CVector(0., 0., 1.)     ]      thickness = 2e-9     s_time = 200e-9     int_step = 1e-12      l1_params = {         \"Ms\": Ms,         \"thickness\": thickness,         \"anis\": CVector(0.1, 0.1, 1.),         \"mag\": CVector(0, 0, 1.),         \"cellSurface\": 1.0,         \"demagTensor\": demagTensor,         \"damping\": 0.003,     }     l1 = Layer(id=\"free\", **l1_params)     l1.setReferenceLayer(CVector(0., 1., 0.))     layer_str = [\"free\"]     layers = [l1]     junction = Junction(layers=layers)     junction.setLayerAnisotropyDriver(\"all\",                                       ScalarDriver.getConstantDriver(Ku))      frequency = 0.01e9     Hscan, Hvecs = FieldScan.phi_scan(-190, 190, steps, Hampl, theta=theta)     amp_diag1f = np.zeros((len(Hscan), ))     phase_diag2f = np.zeros((len(Hscan), ))     junction.setLayerDampingLikeTorqueDriver(         \"all\", ScalarDriver.getSineDriver(0, Hdl, frequency, 0))     junction.setLayerFieldLikeTorqueDriver(         \"all\", ScalarDriver.getSineDriver(0, Hfl, frequency, 0))      Hval = Hvecs[0]      HDriver = AxialDriver(ScalarDriver.getConstantDriver(Hval[0]),                           ScalarDriver.getConstantDriver(Hval[1]),                           ScalarDriver.getConstantDriver(Hval[2]))     junction.runSimulation(s_time, int_step, int_step)     mags = [junction.getLayerMagnetisation(\"free\")]     for hi, Hval in enumerate(Hvecs):         junction.clearLog()         HDriver = AxialDriver(ScalarDriver.getConstantDriver(Hval[0]),                               ScalarDriver.getConstantDriver(Hval[1]),                               ScalarDriver.getConstantDriver(Hval[2]))         junction.setLayerExternalFieldDriver(\"all\", HDriver)         # set mags for better convergence         for i, l_str in enumerate(layer_str):             junction.setLayerMagnetisation(l_str, mags[i])          junction.runSimulation(s_time, int_step, int_step)         # set new mags         for str_ in layer_str:             mags[i] = junction.getLayerMagnetisation(str_)          log = junction.getLog()         m = np.asarray(             [[log[f'{str_}_mx'], log[f'{str_}_my'], log[f'{str_}_mz']]              for str_ in layer_str])          _, dynamic_ry = calculate_resistance_parallel(Rx0, Ry0, AMR, AHE, SMR,                                                       m, l, w)          lt = np.asarray(log['time'])         dynamic_i = Irf * np.sin(2 * np.pi * frequency * lt)         org_amp, org_phase, freqs_org = compute_vsd(dynamic_r=dynamic_ry,                                                     integration_step=int_step,                                                     dynamic_i=dynamic_i)          max_phase2f, _ = find_max_f_frequency(freqs_org, org_phase,                                               2 * frequency)         max_amp1f, _ = find_max_f_frequency(freqs_org, org_amp, frequency)         max_amp2f, _ = find_max_f_frequency(freqs_org, org_amp, 2 * frequency)         amp_diag1f[hi] = max_amp1f         phase_diag2f[hi] = np.cos(max_phase2f) * max_amp2f     return amp_diag1f, phase_diag2f, Hscan   def compute_harmonics_distributed(H):     \"\"\"Insert layer parameters here\"\"\"     theta = 92     Ms = 1.2     Ku = 0.00313 * TtoAm * Ms / 2     Hdl = 1.325e-3 * TtoAm     Hfl = -2.06e-04 * TtoAm     _, phase_diag2f, phi_scan = compute_harmonics(theta=theta,                                                   steps=50,                                                   Ms=Ms,                                                   Ku=Ku,                                                   Hampl=H * OetoAm,                                                   Hdl=Hdl,                                                   Hfl=Hfl)     return phase_diag2f, phi_scan   # we distribute over all fields result = distribute(compute_harmonics_distributed, [Hrange_red], n_cores=2)  res = [] for r in result:     (i), out = r     phase_diag2f, scan = out     res.append(phase_diag2f)     phi_scan = scan  res_max = np.max(res) with plt.style.context(['science', 'nature']):     fig, ax = plt.subplots(dpi=300)     ms = 8     cmap = sns.color_palette(\"crest\", as_cmap=True)     cmap_disc = sns.color_palette(\"crest\", len(Hrange))     norm = mpl.colors.Normalize(vmin=min(Hrange / 1e3), vmax=max(Hrange / 1e3))     indx = (2, 10)     patches = []     labels = []     for i in range(len(res)):         r = np.asarray(res[i])         R = (r - r.min()) / (r.max() - r.min())         ax.plot(phi_scan,                 R,                 lw=2,                 color=cmap(norm(Hrange_red[i] / 1e3)),                 label=\"Sim.\")         labels.append(f\"Sim. - {np.round(Hrange_red[i]*OetoAm/1e3):.0f} kAm/m\")         line_exp = Line2D(range(1),                           range(1),                           color=cmap(norm(Hrange_red[i] / 1e3)))          patches.append(line_exp)         patches.append(             Line2D([], [],                    linestyle='none',                    color=cmap(norm(Hrange_red[i] / 1e3)),                    marker='o',                    markerfacecolor='none',                    markersize=ms // 2))         labels.append(f\"Exp. - {np.round(Hrange_red[i]*OetoAm/1e3):.0f} kA/m\")     patches.append(         Line2D(range(1), range(1), linestyle='dashed', color=\"crimson\"))     labels.append(\"Fit\")      for i in indx:         V = (data[f'Phase.{i}'] /              data[f'Phase.{i}'].max()).rolling(window=5).mean()         V = (V - V.min()) / (V.max() - V.min())         # remove NaNs         x = data[f'F. Angle Azim..{i}'] - 12         mask = pd.isna(V)         x = x.loc[~mask]         V = V.loc[~mask]         ax.plot(x,                 V,                 '.',                 markersize=ms,                 markerfacecolor='none',                 markeredgecolor=cmap(norm(data[f'Field.{i}'][0] / 1e3)),                 label='Exp.')          popt, _ = curve_fit(             f=meinert_model,             xdata=x,             ydata=V,         )         ax.plot(x, meinert_model(x, *popt), '--', color='crimson', label='Fit')      ax.set_xlim([-180, 180])      ax.legend(handles=patches, labels=labels)     ax.set_xlabel(r\"$\\phi$ [deg]\")     ax.set_ylabel(r\"$V_{2\\omega} [norm.]$\") <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:05&lt;00:00,  2.90s/it]\n</pre> In\u00a0[16]: Copied! <pre>damping = 0.005\nMs = 1.6\nthickness = 1.8e-9\nSLP = 0.69\nbeta = 1\nspin_polarisation = 1.\nsurf = 70e-9 * 70e-9 * np.pi\ndemag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)]\n### Create MTJ ###\n# we use the .createSTTLayer to indicate the STT contributions\n# we can also create SOT layers for other experiments.\nl1 = Layer.createSTTLayer(\"free\",\n                          mag=CVector(0, 0, .9),\n                          anis=CVector(0, 0, 1),\n                          Ms=Ms,\n                          thickness=thickness,\n                          cellSurface=surf,\n                          demagTensor=demag,\n                          damping=damping,\n                          SlonczewskiSpacerLayerParameter=SLP,\n                          beta=beta,\n                          spinPolarisation=spin_polarisation)\nl2 = Layer.createSTTLayer(\"free\",\n                          mag=CVector(0, 0, 1),\n                          anis=CVector(0., 0., 1),\n                          Ms=Ms * 1.11,\n                          thickness=thickness,\n                          cellSurface=surf,\n                          demagTensor=demag,\n                          damping=damping,\n                          SlonczewskiSpacerLayerParameter=SLP,\n                          beta=beta,\n                          spinPolarisation=spin_polarisation)\n\n# we use pinning layers for the bottom layer\nl1.setReferenceLayer(CVector(1, 0, 0))\nl2.setReferenceLayer(CVector(1, 0, 0))\n\nj1 = Junction([l1], 100, 200)\nj2 = Junction([l2], 110, 220)\nj1.setLayerAlternativeSTT(\"all\", True)\nj2.setLayerAlternativeSTT(\"all\", True)\nj1.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(7e4))\nj2.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(10e4))\nstack = ParallelStack([j1, j2])\n\nint_time = 1e-12\nsim_time = 100e-9\nstack.setCoupledCurrentDriver(ScalarDriver.getConstantDriver(6e10))\n\nk = 20\nHspan, Hrange = FieldScan.amplitude_scan(-100e3, 400e3, 100, 5, 0)\ncouplings = defaultdict(list)\nfor label, coupling in zip(('pos', 'zero', 'neg'), (0.1, 0, -0.12)):\n    stack.setCouplingStrength(coupling)\n    spectrum = []\n    for Hvector in tqdm(Hrange):\n        stack.clearLogs()\n        stack.setExternalFieldDriver(\n            AxialDriver(ScalarDriver.getConstantDriver(Hvector[0]),\n                        ScalarDriver.getConstantDriver(Hvector[1]),\n                        ScalarDriver.getConstantDriver(Hvector[2])))\n        stack.runSimulation(sim_time, int_time, int_time)\n\n        log = stack.getLog()\n        y = fft(log['Resistance'])\n        yk = np.abs(y[:len(y) // k])\n        spectrum.append(yk)\n\n        if label == 'neg':\n            log0 = stack.getLog(0)\n            log1 = stack.getLog(1)\n            fft1 = fft(log0['R'])\n            freqs = fftfreq(len(fft1), d=int_time)\n            freqs = freqs[1:len(freqs) // k]\n            fft1 = fft1[1:len(fft1) // k]\n            fft2 = fft(log1['R'])\n            fft2 = fft2[1:len(fft2) // k]\n            amp1 = np.abs(fft1)\n            amp2 = np.abs(fft2)\n            fmax1 = np.argmax(amp1)\n            fmax2 = np.argmax(amp2)\n            phase1 = np.angle(fft1)[fmax1]\n            phase2 = np.angle(fft2)[fmax2]\n\n            couplings['resonance1'].append(freqs[fmax1])\n            couplings['resonance2'].append(freqs[fmax2])\n\n    spectrum = np.asarray(spectrum)\n    spectrum = uniform_filter(spectrum, size=7)\n    freqs = fftfreq(len(y), d=int_time)\n    freqs = freqs[:len(freqs) // k]\n    couplings[f'{label}_freqs'] = freqs\n    couplings[f'{label}_spectrum'] = spectrum\n</pre> damping = 0.005 Ms = 1.6 thickness = 1.8e-9 SLP = 0.69 beta = 1 spin_polarisation = 1. surf = 70e-9 * 70e-9 * np.pi demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)] ### Create MTJ ### # we use the .createSTTLayer to indicate the STT contributions # we can also create SOT layers for other experiments. l1 = Layer.createSTTLayer(\"free\",                           mag=CVector(0, 0, .9),                           anis=CVector(0, 0, 1),                           Ms=Ms,                           thickness=thickness,                           cellSurface=surf,                           demagTensor=demag,                           damping=damping,                           SlonczewskiSpacerLayerParameter=SLP,                           beta=beta,                           spinPolarisation=spin_polarisation) l2 = Layer.createSTTLayer(\"free\",                           mag=CVector(0, 0, 1),                           anis=CVector(0., 0., 1),                           Ms=Ms * 1.11,                           thickness=thickness,                           cellSurface=surf,                           demagTensor=demag,                           damping=damping,                           SlonczewskiSpacerLayerParameter=SLP,                           beta=beta,                           spinPolarisation=spin_polarisation)  # we use pinning layers for the bottom layer l1.setReferenceLayer(CVector(1, 0, 0)) l2.setReferenceLayer(CVector(1, 0, 0))  j1 = Junction([l1], 100, 200) j2 = Junction([l2], 110, 220) j1.setLayerAlternativeSTT(\"all\", True) j2.setLayerAlternativeSTT(\"all\", True) j1.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(7e4)) j2.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(10e4)) stack = ParallelStack([j1, j2])  int_time = 1e-12 sim_time = 100e-9 stack.setCoupledCurrentDriver(ScalarDriver.getConstantDriver(6e10))  k = 20 Hspan, Hrange = FieldScan.amplitude_scan(-100e3, 400e3, 100, 5, 0) couplings = defaultdict(list) for label, coupling in zip(('pos', 'zero', 'neg'), (0.1, 0, -0.12)):     stack.setCouplingStrength(coupling)     spectrum = []     for Hvector in tqdm(Hrange):         stack.clearLogs()         stack.setExternalFieldDriver(             AxialDriver(ScalarDriver.getConstantDriver(Hvector[0]),                         ScalarDriver.getConstantDriver(Hvector[1]),                         ScalarDriver.getConstantDriver(Hvector[2])))         stack.runSimulation(sim_time, int_time, int_time)          log = stack.getLog()         y = fft(log['Resistance'])         yk = np.abs(y[:len(y) // k])         spectrum.append(yk)          if label == 'neg':             log0 = stack.getLog(0)             log1 = stack.getLog(1)             fft1 = fft(log0['R'])             freqs = fftfreq(len(fft1), d=int_time)             freqs = freqs[1:len(freqs) // k]             fft1 = fft1[1:len(fft1) // k]             fft2 = fft(log1['R'])             fft2 = fft2[1:len(fft2) // k]             amp1 = np.abs(fft1)             amp2 = np.abs(fft2)             fmax1 = np.argmax(amp1)             fmax2 = np.argmax(amp2)             phase1 = np.angle(fft1)[fmax1]             phase2 = np.angle(fft2)[fmax2]              couplings['resonance1'].append(freqs[fmax1])             couplings['resonance2'].append(freqs[fmax2])      spectrum = np.asarray(spectrum)     spectrum = uniform_filter(spectrum, size=7)     freqs = fftfreq(len(y), d=int_time)     freqs = freqs[:len(freqs) // k]     couplings[f'{label}_freqs'] = freqs     couplings[f'{label}_spectrum'] = spectrum <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:09&lt;00:00, 11.06it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:09&lt;00:00, 10.93it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:11&lt;00:00,  8.98it/s]\n</pre> In\u00a0[\u00a0]: Copied! <pre>cmap = sns.color_palette(\"magma\", as_cmap=True)\nwith plt.style.context(['science', 'nature']):\n    fig, axs = plt.subplots(1, 3, dpi=300, sharey=True)\n    for i, (ax, label, chval) in enumerate(\n            zip(axs, (\n                'neg',\n                'pos',\n                'zero',\n            ), (-0.12, 0.1, 0))):\n        ax.set_ylim([10, 40])\n        ax.pcolor(Hspan / 1e3,\n                  freqs / 1e9,\n                  np.log10(couplings[f\"{label}_spectrum\"].T),\n                  cmap=cmap,\n                  shading='auto')\n        if label == 'neg':\n            ax.plot(Hspan / 1e3,\n                    np.asarray(couplings['resonance1']) / 1e9,\n                    color='royalblue',\n                    alpha=1)\n            ax.plot(Hspan / 1e3,\n                    np.asarray(couplings['resonance2']) / 1e9,\n                    color='crimson',\n                    alpha=1)\n        ax.set_xlabel(\"H [$\\mathrm{kA/m}$]\", usetex=False)\n        ax.set_title(rf\"$\\chi = {chval}$\")\n    axs[0].set_ylabel(\"Frequency [GHz]\")\n    fig.subplots_adjust(wspace=0.05)\n    for label, ax in zip(['(a)', '(b)', '(c)'], axs):\n        # label physical distance in and down:\n        trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,\n                                              fig.dpi_scale_trans)\n        ax.text(0.0,\n                1.0,\n                label,\n                color='w',\n                transform=ax.transAxes + trans,\n                fontsize='medium',\n                verticalalignment='top',\n                bbox=dict(facecolor='none', edgecolor='none', pad=3.0))\n</pre> cmap = sns.color_palette(\"magma\", as_cmap=True) with plt.style.context(['science', 'nature']):     fig, axs = plt.subplots(1, 3, dpi=300, sharey=True)     for i, (ax, label, chval) in enumerate(             zip(axs, (                 'neg',                 'pos',                 'zero',             ), (-0.12, 0.1, 0))):         ax.set_ylim([10, 40])         ax.pcolor(Hspan / 1e3,                   freqs / 1e9,                   np.log10(couplings[f\"{label}_spectrum\"].T),                   cmap=cmap,                   shading='auto')         if label == 'neg':             ax.plot(Hspan / 1e3,                     np.asarray(couplings['resonance1']) / 1e9,                     color='royalblue',                     alpha=1)             ax.plot(Hspan / 1e3,                     np.asarray(couplings['resonance2']) / 1e9,                     color='crimson',                     alpha=1)         ax.set_xlabel(\"H [$\\mathrm{kA/m}$]\", usetex=False)         ax.set_title(rf\"$\\chi = {chval}$\")     axs[0].set_ylabel(\"Frequency [GHz]\")     fig.subplots_adjust(wspace=0.05)     for label, ax in zip(['(a)', '(b)', '(c)'], axs):         # label physical distance in and down:         trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,                                               fig.dpi_scale_trans)         ax.text(0.0,                 1.0,                 label,                 color='w',                 transform=ax.transAxes + trans,                 fontsize='medium',                 verticalalignment='top',                 bbox=dict(facecolor='none', edgecolor='none', pad=3.0)) In\u00a0[17]: Copied! <pre>from cmtj.utils import calculate_resistance_series\nimport matplotlib.pyplot as plt\nfrom cmtj.utils.linear import FieldScan\nfrom cmtj.utils.procedures import ResistanceParameters, PIMM_procedure\n\nrp = ResistanceParameters(Rxx0=100,\n                          Rxy0=1,\n                          Rsmr=-0.46,\n                          Rahe=-2.7,\n                          Ramr=-0.24,\n                          l=30,\n                          w=20)\n\n# approximate demagnetisation tensor\ndemag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)]\nalpha = 0.005\nKdir = CVector(1, 0, 0)\nMs = 1.65\nl1 = Layer(\"free\",\n           mag=CVector(0, 0, 1),\n           anis=Kdir,\n           Ms=Ms,\n           thickness=3.99e-9,\n           cellSurface=0,\n           demagTensor=demag,\n           damping=alpha)\n\nl2 = Layer(\"bottom\",\n           mag=CVector(0, 0, 1),\n           anis=Kdir,\n           Ms=Ms,\n           thickness=4e-9,\n           cellSurface=0,\n           demagTensor=demag,\n           damping=alpha)\nJ1 = -1.78e-3\nJ2 = -1.69e-4\n\nK1 = K2 = 1.05e3\nint_step = 4e-14\n\nj1 = Junction([l1, l2], 100, 102)\n\nj1.setLayerAnisotropyDriver(\"all\", ScalarDriver.getConstantDriver(K1))\nj1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J1))\nj1.setQuadIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J2))\n# j1.runSimulation(5e-9, 1e-13, 1e-12)\nHscan, Hvecs = FieldScan.amplitude_scan(-1200e3, 1200e3, 200, 89, 90)\n\nspectrum, freqs, output = PIMM_procedure(j1,\n                                         Hvecs=Hvecs,\n                                         int_step=int_step,\n                                         resistance_params=[rp, rp],\n                                         max_frequency=60e9)\nwith plt.style.context(['science', 'nature']):\n    fig, ax = plt.subplots(dpi=300)\n    ax.pcolor(Hscan / 1e3,\n              freqs / 1e9,\n              np.log10(np.squeeze(spectrum.T)),\n              cmap='viridis')\n    ax.set_xlabel(\"H [$\\mathrm{kA/m}$]\", usetex=False)\n    ax.set_ylabel(\"Frequency [GHz]\")\n</pre> from cmtj.utils import calculate_resistance_series import matplotlib.pyplot as plt from cmtj.utils.linear import FieldScan from cmtj.utils.procedures import ResistanceParameters, PIMM_procedure  rp = ResistanceParameters(Rxx0=100,                           Rxy0=1,                           Rsmr=-0.46,                           Rahe=-2.7,                           Ramr=-0.24,                           l=30,                           w=20)  # approximate demagnetisation tensor demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)] alpha = 0.005 Kdir = CVector(1, 0, 0) Ms = 1.65 l1 = Layer(\"free\",            mag=CVector(0, 0, 1),            anis=Kdir,            Ms=Ms,            thickness=3.99e-9,            cellSurface=0,            demagTensor=demag,            damping=alpha)  l2 = Layer(\"bottom\",            mag=CVector(0, 0, 1),            anis=Kdir,            Ms=Ms,            thickness=4e-9,            cellSurface=0,            demagTensor=demag,            damping=alpha) J1 = -1.78e-3 J2 = -1.69e-4  K1 = K2 = 1.05e3 int_step = 4e-14  j1 = Junction([l1, l2], 100, 102)  j1.setLayerAnisotropyDriver(\"all\", ScalarDriver.getConstantDriver(K1)) j1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J1)) j1.setQuadIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J2)) # j1.runSimulation(5e-9, 1e-13, 1e-12) Hscan, Hvecs = FieldScan.amplitude_scan(-1200e3, 1200e3, 200, 89, 90)  spectrum, freqs, output = PIMM_procedure(j1,                                          Hvecs=Hvecs,                                          int_step=int_step,                                          resistance_params=[rp, rp],                                          max_frequency=60e9) with plt.style.context(['science', 'nature']):     fig, ax = plt.subplots(dpi=300)     ax.pcolor(Hscan / 1e3,               freqs / 1e9,               np.log10(np.squeeze(spectrum.T)),               cmap='viridis')     ax.set_xlabel(\"H [$\\mathrm{kA/m}$]\", usetex=False)     ax.set_ylabel(\"Frequency [GHz]\") <pre>Computing PIMM: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 200/200 [00:24&lt;00:00,  8.24it/s]\n/var/folders/wq/0q9brtfs5rq65q1t_mtgshb00000gn/T/ipykernel_81600/2057453406.py:57: MatplotlibDeprecationWarning: shading='flat' when X and Y have the same dimensions as C is deprecated since 3.3.  Either specify the corners of the quadrilaterals with X and Y, or pass shading='auto', 'nearest' or 'gouraud', or set rcParams['pcolor.shading'].  This will become an error two minor releases later.\n  ax.pcolor(Hscan / 1e3,\n</pre>"},{"location":"tutorials/examples/#advanced-examples","title":"Advanced examples\u00b6","text":"<p>This is a set of more advanced examples along with some explanations of how they work. The examples are accompanied by a dataset in the <code>examples/data</code> folder.</p>"},{"location":"tutorials/examples/#spin-valve-system","title":"Spin valve system\u00b6","text":"<p>For the GMR system we will take a look at the Spin-Diode maps as well as on the PIMM maps in function of variable IEC. First, we are going to compute Voltage Spin Diode effect. See the function <code>simulate_vsd</code> and note how the DC mixing voltage is computed for each value of the field, frequency and a scanning parameter, in this case J -- the IEC constant. At the same time, we will note the resistance at two different field arrangements -- one where the field is applied 0 phi in plane angle, and then rotated at 90 degrees in plane. Having those two values of the field will result in drastically different R(H) loops.</p>"},{"location":"tutorials/examples/#spin-diode-fmr","title":"Spin-Diode FMR\u00b6","text":""},{"location":"tutorials/examples/#pimm","title":"PIMM\u00b6","text":"<p>In this experiment we will excite the system with a slight pulse of Oersted field in z direction. This simulates the experimental excitement by a current pulse along the y axis of the sample. The pulse should be very short and also rather weak, so that the system is not driven out of the harmonic regime. The pulse is applied at the beginning of the simulation and the system is allowed to relax to a steady state. The steady state is then used as initial condition for the next simulation. This is repeated for different pulse strengths. The resulting PIMM maps are shown below.</p>"},{"location":"tutorials/examples/#cims","title":"CIMS\u00b6","text":"<p>In this section we focus on generating switching currents. We are going to excite the system with a range of different pulse strengths. In this case, unlike in the PIMM, we excite the system directly with the current density pulse (which takes on the form of trapezoidal impulse) in order to evoke the torque response. After each simulation the system is allowed to relax to a steady state. We then pick up the steady state to see in which state (up/down) the magnetisation has settled. Based on the change of the hysteresis change, we can infer the critical current for a given value of the external field.</p>"},{"location":"tutorials/examples/#mh-and-rh-loops","title":"M(H) and R(H) loops\u00b6","text":"<p>Here we will generate the M(H) and R(H) loops for the system. We will use the same method as in the PIMM section. We will then apply a range of different external fields and record the magnetisation and the resistance at a steady state. This shows that the PIMM, M(H) and R(H) may be collected from the same range of simulations!</p>"},{"location":"tutorials/examples/#angular-harmonics","title":"Angular harmonics\u00b6","text":"<p>Here, we can simulate a system where we can analyse the influence of damping like and field like torques. The sweep is now with the angle of the field (in-plane angle) and not its magnitude.</p>"},{"location":"tutorials/examples/#stack-system","title":"Stack system\u00b6","text":"<p>In this section we will simulate a simple parallel structure of two MTJs. We are interested in how the two magnetic tunnel junctions will synchronised if we couple them electrically. Here, we use some example electrical coupling (via the current) values and we scan over the external field values, at a constant current density value. You could easily try to scan with the current density instead of the external field and see how the system behaves then.</p>"},{"location":"tutorials/examples/#convenice-procedures","title":"Convenice procedures\u00b6","text":"<p>Certain procedures such as PIMM or VSD are provided in their basic form via <code>cmtj.utils.procedures</code> submodule. See below for an example usage.</p>"},{"location":"tutorials/trajectory/","title":"Generating trajectories","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nfrom cmtj import Junction, Layer, CVector, ScalarDriver, AxialDriver, NullDriver\nimport numpy as np\nfrom typing import List, Dict\n# sphere points\nr = 1\npi = np.pi\ncos = np.cos\nsin = np.sin\nphi, theta = np.mgrid[0.0:pi:100j, 0.0:2.0 * pi:100j]\nx = r * sin(phi) * cos(theta)\ny = r * sin(phi) * sin(theta)\nz = r * cos(phi)\n\n\ndef plot_trajectory(log: Dict[str, List[float]], title: str):\n    with plt.style.context(['science', 'no-latex']):\n        fig = plt.figure(figsize=(12, 12))\n        ax = fig.add_subplot(1, 2, 1, projection='3d')\n        m = np.asarray([log[f'free_mx'], log[f'free_my'], log[f'free_mz']])\n        ax.plot3D(m[0], m[1], m[2], color='blue')\n        ax.set_axis_off()\n        ax.plot_surface(x,\n                        y,\n                        z,\n                        rstride=2,\n                        cstride=2,\n                        color='c',\n                        alpha=0.3,\n                        linewidth=0.1)\n        ax.scatter([0], [0], [1], color='crimson', alpha=1.0, s=50)\n        fig.savefig(f\"{title}.png\")\n</pre> import matplotlib.pyplot as plt from cmtj import Junction, Layer, CVector, ScalarDriver, AxialDriver, NullDriver import numpy as np from typing import List, Dict # sphere points r = 1 pi = np.pi cos = np.cos sin = np.sin phi, theta = np.mgrid[0.0:pi:100j, 0.0:2.0 * pi:100j] x = r * sin(phi) * cos(theta) y = r * sin(phi) * sin(theta) z = r * cos(phi)   def plot_trajectory(log: Dict[str, List[float]], title: str):     with plt.style.context(['science', 'no-latex']):         fig = plt.figure(figsize=(12, 12))         ax = fig.add_subplot(1, 2, 1, projection='3d')         m = np.asarray([log[f'free_mx'], log[f'free_my'], log[f'free_mz']])         ax.plot3D(m[0], m[1], m[2], color='blue')         ax.set_axis_off()         ax.plot_surface(x,                         y,                         z,                         rstride=2,                         cstride=2,                         color='c',                         alpha=0.3,                         linewidth=0.1)         ax.scatter([0], [0], [1], color='crimson', alpha=1.0, s=50)         fig.savefig(f\"{title}.png\")  In\u00a0[2]: Copied! <pre>demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.0)]\n\ndamping = 0.03\ncurrentDensity = 1e9\nbeta = 1\nspinPolarisation = 1.0\n\nl1 = Layer.createSTTLayer(id=\"free\",\n                          mag=CVector(0., 0., 1.),\n                          anis=CVector(0, 0., 1.),\n                          Ms=1.,\n                          thickness=1.4e-9,\n                          cellSurface=7e-10 * 7e-10,\n                          demagTensor=demagTensor,\n                          damping=damping,\n                          SlonczewskiSpacerLayerParameter=1.0,\n                          spinPolarisation=spinPolarisation,\n                          beta=beta)\n\nl1.setReferenceLayer(CVector(0, 1., 1.))\njunction = Junction([l1])\n\njunction.setLayerAnisotropyDriver(\"free\",\n                                  ScalarDriver.getConstantDriver(300e3))\njunction.setLayerCurrentDriver(\"free\",\n                               ScalarDriver.getConstantDriver(currentDensity))\n\njunction.runSimulation(150e-9, 1e-12, 1e-12, False, False)\nlog = junction.getLog()\nplot_trajectory(log, \"STT\")\n</pre> demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.0)]  damping = 0.03 currentDensity = 1e9 beta = 1 spinPolarisation = 1.0  l1 = Layer.createSTTLayer(id=\"free\",                           mag=CVector(0., 0., 1.),                           anis=CVector(0, 0., 1.),                           Ms=1.,                           thickness=1.4e-9,                           cellSurface=7e-10 * 7e-10,                           demagTensor=demagTensor,                           damping=damping,                           SlonczewskiSpacerLayerParameter=1.0,                           spinPolarisation=spinPolarisation,                           beta=beta)  l1.setReferenceLayer(CVector(0, 1., 1.)) junction = Junction([l1])  junction.setLayerAnisotropyDriver(\"free\",                                   ScalarDriver.getConstantDriver(300e3)) junction.setLayerCurrentDriver(\"free\",                                ScalarDriver.getConstantDriver(currentDensity))  junction.runSimulation(150e-9, 1e-12, 1e-12, False, False) log = junction.getLog() plot_trajectory(log, \"STT\")  <p>Now, let's try to narrow down the radius of the oscillation by increasing the current density 100 fold.</p> In\u00a0[3]: Copied! <pre>demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.0)]\n\ndamping = 0.03\ncurrentDensity = 1e9\nbeta = 1\nspinPolarisation = 1.0\n\nl1 = Layer.createSTTLayer(id=\"free\",\n                          mag=CVector(-1., -1., 0.),\n                          anis=CVector(-1., -1., 0.),\n                          Ms=1.,\n                          thickness=1.4e-9,\n                          cellSurface=7e-10 * 7e-10,\n                          demagTensor=demagTensor,\n                          damping=damping,\n                          SlonczewskiSpacerLayerParameter=1.0,\n                          spinPolarisation=spinPolarisation,\n                          beta=beta)\n\nl1.setReferenceLayer(CVector(1, 1., 0.))\njunction = Junction([l1])\n\njunction.setLayerAnisotropyDriver(\"free\",\n                                  ScalarDriver.getConstantDriver(300e3))\njunction.setLayerCurrentDriver(\n    \"free\", ScalarDriver.getConstantDriver(currentDensity))\n\njunction.runSimulation(1500e-9, 1e-12, 1e-12, False, False)\nlog = junction.getLog()\nplot_trajectory(log, \"STT\")\n</pre> demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.0)]  damping = 0.03 currentDensity = 1e9 beta = 1 spinPolarisation = 1.0  l1 = Layer.createSTTLayer(id=\"free\",                           mag=CVector(-1., -1., 0.),                           anis=CVector(-1., -1., 0.),                           Ms=1.,                           thickness=1.4e-9,                           cellSurface=7e-10 * 7e-10,                           demagTensor=demagTensor,                           damping=damping,                           SlonczewskiSpacerLayerParameter=1.0,                           spinPolarisation=spinPolarisation,                           beta=beta)  l1.setReferenceLayer(CVector(1, 1., 0.)) junction = Junction([l1])  junction.setLayerAnisotropyDriver(\"free\",                                   ScalarDriver.getConstantDriver(300e3)) junction.setLayerCurrentDriver(     \"free\", ScalarDriver.getConstantDriver(currentDensity))  junction.runSimulation(1500e-9, 1e-12, 1e-12, False, False) log = junction.getLog() plot_trajectory(log, \"STT\") In\u00a0[4]: Copied! <pre>demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.0)]\ndamping = 0.03\n\nl1 = Layer(id=\"free\",\n           mag=CVector(0., 0., 1.),\n           anis=CVector(0, 0., 1.),\n           Ms=1.2,\n           thickness=1.4e-9,\n           cellSurface=7e-10 * 7e-10,\n           demagTensor=demagTensor,\n           damping=damping)\njunction = Junction([l1])\n\njunction.setLayerExternalFieldDriver(\n    \"free\",\n    AxialDriver(NullDriver(), ScalarDriver.getConstantDriver(-250e3),\n                NullDriver()))\njunction.setLayerAnisotropyDriver(\n    \"free\", ScalarDriver.getSineDriver(900e3, 10e3, 7e9, 0))\n\njunction.runSimulation(2e-9, 1e-12, 1e-12, False, False)\nlog = junction.getLog()\nplot_trajectory(log, \"VCMA\")\n</pre> demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.0)] damping = 0.03  l1 = Layer(id=\"free\",            mag=CVector(0., 0., 1.),            anis=CVector(0, 0., 1.),            Ms=1.2,            thickness=1.4e-9,            cellSurface=7e-10 * 7e-10,            demagTensor=demagTensor,            damping=damping) junction = Junction([l1])  junction.setLayerExternalFieldDriver(     \"free\",     AxialDriver(NullDriver(), ScalarDriver.getConstantDriver(-250e3),                 NullDriver())) junction.setLayerAnisotropyDriver(     \"free\", ScalarDriver.getSineDriver(900e3, 10e3, 7e9, 0))  junction.runSimulation(2e-9, 1e-12, 1e-12, False, False) log = junction.getLog() plot_trajectory(log, \"VCMA\") In\u00a0[5]: Copied! <pre>demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.0)]\n\ndamping = 0.3\n\nl1 = Layer(id=\"free\",\n           mag=CVector(0., 0., 1.),\n           anis=CVector(0, 0., 1.),\n           Ms=1.6,\n           thickness=1.4e-9,\n           cellSurface=7e-10 * 7e-10,\n           demagTensor=demagTensor,\n           damping=damping)\n\njunction = Junction([l1])\n\njunction.setLayerExternalFieldDriver(\n    \"free\",\n    AxialDriver(ScalarDriver.getConstantDriver(200e3),\n                ScalarDriver.getStepDriver(300e3, 100e3, 0.01e-9, 0.1e-9),\n                NullDriver()))\njunction.setLayerAnisotropyDriver(\"free\",\n                                  ScalarDriver.getConstantDriver(800e3))\n\njunction.runSimulation(2e-9, 1e-12, 1e-12, False, False)\nlog = junction.getLog()\nplot_trajectory(log, \"Hoepulse\")\n</pre> demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.0)]  damping = 0.3  l1 = Layer(id=\"free\",            mag=CVector(0., 0., 1.),            anis=CVector(0, 0., 1.),            Ms=1.6,            thickness=1.4e-9,            cellSurface=7e-10 * 7e-10,            demagTensor=demagTensor,            damping=damping)  junction = Junction([l1])  junction.setLayerExternalFieldDriver(     \"free\",     AxialDriver(ScalarDriver.getConstantDriver(200e3),                 ScalarDriver.getStepDriver(300e3, 100e3, 0.01e-9, 0.1e-9),                 NullDriver())) junction.setLayerAnisotropyDriver(\"free\",                                   ScalarDriver.getConstantDriver(800e3))  junction.runSimulation(2e-9, 1e-12, 1e-12, False, False) log = junction.getLog() plot_trajectory(log, \"Hoepulse\") In\u00a0[6]: Copied! <pre>demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.)]\n\ndamping = 0.011\n\nl1 = Layer.createSTTLayer(id=\"free\",\n                          mag=CVector(1., 0., 0.),\n                          anis=CVector(1, 0., 0.),\n                          Ms=1,\n                          thickness=1.4e-9,\n                          cellSurface=7e-10 * 7e-10,\n                          demagTensor=demagTensor,\n                          damping=damping,\n                          SlonczewskiSpacerLayerParameter=1.0,\n                          spinPolarisation=spinPolarisation,\n                          beta=beta)\nl2 = Layer.createSTTLayer(id=\"bottom\",\n                          mag=CVector(1., 0., 0.),\n                          anis=CVector(1, 0., 0.),\n                          Ms=1.2,\n                          thickness=3e-9,\n                          cellSurface=7e-10 * 7e-10,\n                          demagTensor=demagTensor,\n                          SlonczewskiSpacerLayerParameter=1.0,\n                          spinPolarisation=spinPolarisation,\n                          beta=beta)\n\nl1.setReferenceLayer(CVector(0, 0, 1))\nl2.setReferenceLayer(CVector(0, 0, 1))\njunction = Junction([l1, l2])\njunction.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(-4e-5))\njunction.setLayerAnisotropyDriver(\"free\",\n                                  ScalarDriver.getConstantDriver(300e3))\njunction.setLayerAnisotropyDriver(\"bottom\",\n                                  ScalarDriver.getConstantDriver(800e3))\njunction.setLayerCurrentDriver(\"all\", ScalarDriver.getConstantDriver(1e12))\n\njunction.setLayerExternalFieldDriver(\n    \"free\",\n    AxialDriver(NullDriver(), ScalarDriver.getConstantDriver(100e3),\n                NullDriver()))\n\njunction.runSimulation(2e-9, 1e-12, 1e-12, False, False)\nlog = junction.getLog()\nplot_trajectory(log, \"Switching\")\n</pre> demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.)]  damping = 0.011  l1 = Layer.createSTTLayer(id=\"free\",                           mag=CVector(1., 0., 0.),                           anis=CVector(1, 0., 0.),                           Ms=1,                           thickness=1.4e-9,                           cellSurface=7e-10 * 7e-10,                           demagTensor=demagTensor,                           damping=damping,                           SlonczewskiSpacerLayerParameter=1.0,                           spinPolarisation=spinPolarisation,                           beta=beta) l2 = Layer.createSTTLayer(id=\"bottom\",                           mag=CVector(1., 0., 0.),                           anis=CVector(1, 0., 0.),                           Ms=1.2,                           thickness=3e-9,                           cellSurface=7e-10 * 7e-10,                           demagTensor=demagTensor,                           SlonczewskiSpacerLayerParameter=1.0,                           spinPolarisation=spinPolarisation,                           beta=beta)  l1.setReferenceLayer(CVector(0, 0, 1)) l2.setReferenceLayer(CVector(0, 0, 1)) junction = Junction([l1, l2]) junction.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(-4e-5)) junction.setLayerAnisotropyDriver(\"free\",                                   ScalarDriver.getConstantDriver(300e3)) junction.setLayerAnisotropyDriver(\"bottom\",                                   ScalarDriver.getConstantDriver(800e3)) junction.setLayerCurrentDriver(\"all\", ScalarDriver.getConstantDriver(1e12))  junction.setLayerExternalFieldDriver(     \"free\",     AxialDriver(NullDriver(), ScalarDriver.getConstantDriver(100e3),                 NullDriver()))  junction.runSimulation(2e-9, 1e-12, 1e-12, False, False) log = junction.getLog() plot_trajectory(log, \"Switching\")"},{"location":"tutorials/trajectory/#generating-trajectories","title":"Generating trajectories\u00b6","text":"<p>In this notebook we will generate a couple of interesting trajectories using the core <code>cmtj</code> library.</p>"},{"location":"tutorials/trajectory/#first-steps","title":"First steps\u00b6","text":"<p>Firstly, we import all the necessary stuff from <code>cmtj</code> library and we define a sphere on which we will be plotting our simulated magnetisation dyamics</p>"},{"location":"tutorials/trajectory/#stt-trajectory","title":"STT trajectory\u00b6","text":"<p>Our first trajectory will be the STO (Spin-Transfer Oscillator) trajectory. We will use the STT modelling to induce oscillations of the magnetisation. This is achieved by pumping spin current into our layer. The constant current density supplied to the system sustains the oscillations.</p>"},{"location":"tutorials/trajectory/#vcma-trajectory","title":"VCMA trajectory\u00b6","text":"<p>VCMA (Voltage Controlled Magnetic Anistoropy) allows us to control the perpendicular anisotropy of the system. Here, we excite the perpendicular anisotropy of our layer with a small sinusoidal anisotropy change in the z direction. Since we applied a strong magentic field in the y direction, the magnetisation will eventually settle there after being \"popped\" from a steady starting state in the z direction.</p>"},{"location":"tutorials/trajectory/#oerstedexternalfield-excitation","title":"Oersted/ExternalField excitation\u00b6","text":"<p>The idea is very similar to the VCMA, but here the excitation comes through the $H_{OE}$ (which in this case is modelled as an external field). You may use <code>setLayerOerstedFieldDriver</code> instead of <code>setLayerExternalFieldDriver</code> to help readability, but keep in mind that for the computational engine these two are identical.</p>"},{"location":"tutorials/trajectory/#bilayer-switching","title":"Bilayer switching\u00b6","text":"<p>Finally, we will demonstrate the bilayer switching. Unlike in the other examples, we will use two layers since we need a pinning anisotropy in the bottom layer which is coupled to the top layer via the IEC interaction. The switching from parallel (initial) state to anti-parallel is achieved with STT, by supplying a sufficient spin current to the system.</p>"}]}