{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#cmtj","title":"CMTJ","text":""},{"location":"#table-of-contents","title":"Table of contents","text":"<ul> <li>CMTJ</li> <li>Table of contents</li> <li>Short description<ul> <li>What can you simulate?</li> </ul> </li> <li>Web GUI</li> <li>Quickstart<ul> <li>Installation :rocket:</li> <li>Extra dependencies</li> </ul> </li> <li>Documentation and examples</li> <li>Extensions</li> <li>Citing</li> <li>Development</li> <li>Acknowledgements</li> <li>Contributions</li> <li>Docker</li> <li>Precommit</li> <li>Documentation builds</li> </ul>"},{"location":"#short-description","title":"Short description","text":"<p>The <code>cmtj</code> name may be misleading -- the MTJ (Magnetic Tunnel Junctions) are not the only structures that may be simulated. The library allows for macromagnetic simulation of various multilayer spintronic structures. The package uses C++ implementation of (s)LLGS (stochastic Landau-Lifschitz-Gilbert-Slonczewski) equation with various field contributions included for instance: anisotropy, interlayer exchange coupling, demagnetisation, dipole fields etc. It is also possible to connect devices in parallel or in series to have electrically coupled arrays.</p>"},{"location":"#what-can-you-simulate","title":"What can you simulate?","text":"<p>Below is a brief list of examples (it's not exhaustive! Check the docs for more).</p> <p>Magnetic devices:</p> <ul> <li>Magnetic Tunnel Junctions</li> <li>Voltage-Driven Magnetic Tunnel Junctions</li> <li>Spin-Torque Oscillators</li> <li>VCMA sensors and devices</li> <li>Magnetic Tunnel Junction Arrays</li> <li>SOT devices</li> <li>Current-Driven SOT</li> <li>Advanced device coupling</li> <li>Reservoirs (dipole coupling)</li> <li>Electrically coupled MTJs</li> <li>Base equations</li> <li>Landau-Lifshitz-Gilbert-Slonczewski equation</li> <li>Stochastic Landau-Lifshitz-Gilbert-Slonczewski equation</li> <li>Landau-Lifshitz-Gilbert-Bloch equation</li> <li>Domain wall motion</li> </ul> <p>Experimental methods:</p> <p>Some of the experimental methods available:</p> <ul> <li>PIMM</li> <li>Spin-Diode</li> <li>CIMS</li> <li>R(H), M(H)</li> </ul>"},{"location":"#web-gui","title":"Web GUI","text":"<p>Check out the streamlit hosted demo here.  You can simulate:</p> <ul> <li>PIMM spectra and Spin-Diode spectra</li> <li>Try some optimization fitting</li> <li>Fit multi-domain or multi-level M(H) or R(H) loops in Domain mode</li> </ul> <p>Let us know if you have any issues with the demo.</p>"},{"location":"#quickstart","title":"Quickstart","text":""},{"location":"#installation-rocket","title":"Installation :rocket:","text":"<p>The recommended way is to use the <code>pip</code> package manager and virtualenv (or conda). Installation is as easy as doing:</p> <ol> <li>With <code>virtualenv</code> (recommended):</li> </ol> <pre><code>$(bash) python -m venv .my-venv\n$(bash) source .my-venv/bin/activate\n$(.my-venv) python -m pip install cmtj\n</code></pre> <ol> <li>Straight from <code>pip</code>:</li> </ol> <pre><code>python3 -m pip install cmtj\n</code></pre> <ol> <li>Straight from source:</li> </ol> <pre><code>python3 -m pip install git+https://github.com/LemurPwned/cmtj.git\n</code></pre> <ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/LemurPwned/cmtj.git\npython3 -m pip install .\n</code></pre>"},{"location":"#extra-dependencies","title":"Extra dependencies","text":"<p>The package requires (if <code>utils</code> subpackage is used):</p> <pre><code>- numpy\n- scipy\n- matplotlib\n</code></pre>"},{"location":"#documentation-and-examples","title":"Documentation and examples","text":"<p>Documentation: https://lemurpwned.github.io/cmtj. There are many examples available, check out the examples section in the docs</p>"},{"location":"#extensions","title":"Extensions","text":"<p>There's a GUI version available! If you wish to conduct a subset of simulations, mainly for experimental modelling, please see the PyMag project. It uses CMTJ as a backend for fast computation.</p>"},{"location":"#citing","title":"Citing","text":"<p>We would appreciate citing either of the listed work if you decide to use the project or using the cite button on the right hand side panel of the repository:</p> <p>cmtj: Simulation package for analysis of multilayer spintronic devices</p> <pre><code>@article{mojsiejuk_cmtj_2023,\n    title = {cmtj: Simulation package for analysis of multilayer spintronic devices},\n    volume = {9},\n    issn = {2057-3960},\n    url = {https://www.nature.com/articles/s41524-023-01002-x},\n    doi = {10.1038/s41524-023-01002-x},\n    pages = {54},\n    number = {1},\n    journaltitle = {npj Comput Mater},\n    author = {Mojsiejuk, Jakub and Zi\u0119tek, S\u0142awomir and Grochot, Krzysztof and Skowro\u0144ski, Witold and Stobiecki, Tomasz},\n    date = {2023-04-06},\n}\n</code></pre>"},{"location":"#development","title":"Development","text":""},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Many thanks to professor Jack Sankey for his help with the development of thermal contributions, with inspiration from the macrospinmob project.</p>"},{"location":"#contributions","title":"Contributions","text":"<p>All contributions are welcome, please leave an issue if you've encountered any trouble with setup or running the library.</p>"},{"location":"#docker","title":"Docker","text":"<p>In the <code>docker</code> directory there's a <code>Dockerfile</code> that can be used to build a docker image with the library installed. <code>Dockerfile.app</code> is used for streamlit development.</p>"},{"location":"#precommit","title":"Precommit","text":"<p>There's a <code>.pre-commit-config.yaml</code> that does some basic python and cpp lints and checks. More static analysis to come in the future. This may be run with:</p> <pre><code>pre-commit run -v\n</code></pre> <p>or</p> <pre><code>pre-commit run -a (or --files core/* cmtj/*)\n</code></pre>"},{"location":"#documentation-builds","title":"Documentation builds","text":"<p>Note For stub generation add <code>__init__.py</code> to the <code>cmtj</code> directory.</p> <p>There are a couple of stages to building the documentation</p> <ol> <li>Build Doxygen documentation    <pre><code>doxygen Doxyfile\n</code></pre>    This is mostly for the C++ documentation. Future changes may couple C++ and Python docs.</li> <li>Build stubs    The stubgen is <code>pybind11-stubgen</code> or <code>mypy stubgen</code> with the latter being preferred now.    Before running the stubgen, make sure to install the package with:    <pre><code>python3 -m pip install .\n</code></pre>    avoid using <code>-e</code> flag as it may cause issues with the stubgen.    Then to generate, for instance, <code>Stack</code> module stubs we can do:    <pre><code>stubgen -m cmtj.stack -o target-stub-dir/\n</code></pre>    or    <pre><code>python3 -c \"import mypy.stubgen; mypy.stubgen.main(['-p', 'cmtj.stack', '-o', 'target-stub-dir/'])\"\n</code></pre>    More info here: https://mypy.readthedocs.io/en/stable/stubgen.html.</li> <li>Parse stubs to Markdown.    This stage is done by running: <code>python3 docs/docgen.py</code>    The deployment of the documentation is done via:    <pre><code>mkdocs gh-deploy\n</code></pre>    But first, worth a check:    <pre><code>mkdocs serve\n</code></pre></li> </ol>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#190","title":"1.9.0","text":"<ul> <li>Added generalised linearisation options for frequency computing in linear models</li> <li>Revamped SB modelling for better processing and analytical roots + code cleanup</li> </ul>"},{"location":"changelog/#180","title":"1.8.0","text":"<ul> <li>Fixing bugs in electrical coupling</li> <li>You can now have useKCL = True Stacks which will implicitly preserve Kirchoff's current law, and will simulate perfect voltage sources</li> </ul>"},{"location":"changelog/#170","title":"1.7.0","text":"<ul> <li>Adaptive simulation is now available again with Dormand-Price method</li> <li>Adding curated simulation examples</li> <li>Memory cells are now supported (you can specify two polarisation vectors per Layer now)</li> <li>Import fixes and other minor bugfixes</li> </ul>"},{"location":"changelog/#162-166","title":"1.6.2-1.6.6","text":"<ul> <li>Fixed a bug in the <code>ScalarDriver</code> class which prevented the use of custom drivers with no arguments.</li> </ul>"},{"location":"changelog/#161","title":"1.6.1","text":"<ul> <li>Small fixes to the noise interfaces and resistance functions.</li> <li>Documentation updates: added a tutorial on custom dipole interactions + interface fixes and typing.</li> </ul>"},{"location":"changelog/#160","title":"1.6.0","text":"<ul> <li>Extended the <code>Stack</code> models allowing for non-symmetric coupling between devices.   <code>Stack</code> current drivers can now be of any type and are adequately scaled.</li> <li>Custom definition of the <code>ScalarDriver</code> is now possible and documented.</li> <li>Fixed a bug in the <code>Stack</code> class which inverted the connection order of in-series connections.</li> <li>Exposed IDMI interaction to Layer and Junction classes.</li> <li>Added <code>getLayer</code> method to the <code>Junction</code> class and <code>getJunction</code> method to the <code>Stack</code> class that return a reference to the object.</li> <li>Fixed and expanded the <code>reservoir</code> module. Now, <code>GroupInteraction</code> can use any dipole interaction function, with 3 provided as default: <code>computeDipoleInteraction</code>, <code>computeDipoleInteractionNoumra</code> and <code>nullDipoleInteraction</code> (0 dipole tensor).</li> </ul>"},{"location":"changelog/#150-154","title":"1.5.0-1.5.4","text":"<ul> <li>Dipole interaction added to the <code>SB Model</code></li> <li>Kasdin 1/f noise generator added to the <code>noise</code> module and to the solvers</li> <li>Reworking the solvers for better performance and stability</li> <li>Added a simple noise model to the <code>utils</code> class. It exists outside standard simulation procedures.</li> <li>Added LLGB bindings and code. The solver is still WIP and doesn't integrate with more advanced features yet.</li> <li>Added aliases for <code>ScalarDriver</code> -- for example, instead of calling <code>ScalarDriver.getConstantDriver</code>, you can now call <code>constantDriver</code> directly to create a constant driver.</li> <li>Improve stub detection across editors and IDEs</li> </ul>"},{"location":"changelog/#141","title":"1.4.1","text":"<ul> <li>Adding a basic optimisation script in the <code>optimization</code> module.</li> <li>Streamlit optimization updates.</li> </ul>"},{"location":"changelog/#140","title":"1.4.0","text":"<ul> <li>Adding new, dynamic symbolic model compatible with <code>Solver</code> class. It is now possible to use the <code>Solver</code> class with <code>LayerDynamic</code> to solve the LLG equation.</li> <li>Added tests for procedures and operators.</li> <li>Added missing operators for <code>CVector</code> class in Python.</li> <li><code>CVector</code> is now subscriptable.</li> <li>Added new <code>CVector</code> and <code>AxialDriver</code> initialisations.</li> <li><code>VSD</code> and <code>PIMM</code> procedures accept additional new parameters.</li> <li>Added some optimization utilities like <code>coordinate_descent</code>.</li> <li>Added a <code>streamlit</code> service for an example PIMM simulation.</li> </ul>"},{"location":"changelog/#132","title":"1.3.2","text":"<ul> <li>Added new <code>ScalarDrivers</code> -- Gaussian impulse and Gaussian step.</li> </ul>"},{"location":"changelog/#131","title":"1.3.1","text":"<ul> <li><code>CVector</code> got extra functionality in Python bindings. Operators are now supported.</li> <li>Domain Wall dynamics is now also for 2 layer systems. Added edge potential.</li> <li>SB model generalised for N layers.</li> </ul>"},{"location":"changelog/#130","title":"1.3.0","text":"<ul> <li>Adding DW dynamics 1D model with dynamic drivers. (Numba optimised)</li> <li>Adding SB model for energy-based FMR computation. Gradient computed using Adam optimiser.</li> <li>Moving resistance functions from <code>utils</code> to <code>resistance</code></li> <li>Introducing docs updates for tutorial notebook (dark/light toggle works now).</li> <li>Reservoir computing is now exposed in Python in the <code>reservoir</code> computing module.</li> </ul>"},{"location":"changelog/#120","title":"1.2.0","text":"<ul> <li>Oersted field computation helper class in cmtj/models/oersted.py. Basic functionality is there, but needs to be further tested and documented. Next release potentially will move the computation to C++ for speed.</li> <li>Added Heun (2nd order) solver and made it default for thermal computation. This is a more stable solver than the Euler solver, but is slower. The Euler solver is still available as an option.</li> <li>Stack class now supports arbitrary layer ids to be coupled.</li> <li>Extended the plotting capabilities of the Stack class. Now supports plotting of the magnetic field and the current density.</li> <li>Added alternative STT formulation which in some cases may be useful.</li> <li>Fixed some minor bugs in the thermal solver.</li> <li>Fixed some minor bugs in the Stack class.</li> <li>Updating tutorials on the docs page.</li> <li>Bunch of extra documentation and examples.</li> </ul>"},{"location":"docgen/","title":"Docgen","text":"In\u00a0[\u00a0]: Copied! <pre>import glob\nimport logging\nimport os\nimport re\nfrom dataclasses import dataclass\n</pre> import glob import logging import os import re from dataclasses import dataclass In\u00a0[\u00a0]: Copied! <pre>log = logging.getLogger(\"mkdocs\")\n</pre> log = logging.getLogger(\"mkdocs\") In\u00a0[\u00a0]: Copied! <pre>py_signature = r\"(def (.+?) -&gt; ([\\'\\[\\]\\,\\sA-z]+)\\:)\"\nc_py_signature = re.compile(py_signature)\n</pre> py_signature = r\"(def (.+?) -&gt; ([\\'\\[\\]\\,\\sA-z]+)\\:)\" c_py_signature = re.compile(py_signature) In\u00a0[\u00a0]: Copied! <pre># old regex that does not allow for optional docstrings and quoted rtype\n# joint_py = r\"(?s)(def (.+?) -&gt; ([\\\"\\'\\[\\]\\,\\sA-z]+)\\:)\\n{0,}\\s{8}(\\\"{3}(.+?)\\\"{3})\"\njoint_py = r\"(?s)(def (.+?) -&gt; ([\\\"\\'\\[\\]\\,\\sA-z]+)\\:)(?:\\n\\s*(\\\"{3}(.+?)\\\"{3}))?\"\nc_joint_py = re.compile(joint_py)\n</pre> # old regex that does not allow for optional docstrings and quoted rtype # joint_py = r\"(?s)(def (.+?) -&gt; ([\\\"\\'\\[\\]\\,\\sA-z]+)\\:)\\n{0,}\\s{8}(\\\"{3}(.+?)\\\"{3})\" joint_py = r\"(?s)(def (.+?) -&gt; ([\\\"\\'\\[\\]\\,\\sA-z]+)\\:)(?:\\n\\s*(\\\"{3}(.+?)\\\"{3}))?\" c_joint_py = re.compile(joint_py) In\u00a0[\u00a0]: Copied! <pre>pydoc_regex = r\"(?s)(\\\"{3}(.+?)\\\"{3})\"\nc_pydoc_rgx = re.compile(pydoc_regex)\narg_pydoc = r\"(\\:param ([A-z0-9]+)\\:(.+)\\n)\"\npy_arg_rgx = re.compile(arg_pydoc)\n</pre> pydoc_regex = r\"(?s)(\\\"{3}(.+?)\\\"{3})\" c_pydoc_rgx = re.compile(pydoc_regex) arg_pydoc = r\"(\\:param ([A-z0-9]+)\\:(.+)\\n)\" py_arg_rgx = re.compile(arg_pydoc) In\u00a0[\u00a0]: Copied! <pre>cdoc_regex = r\"(?s)(\\/\\*{2}(.+?)\\*\\/{1})\"  # ?s is an inline DOTALL flag\narg_cdoc = r\"(\\@param ([A-z0-9]+)\\:(.+)\\n)\"\nc_cdoc_rgx = re.compile(cdoc_regex)\nc_arg_rgx = re.compile(arg_cdoc)\n</pre> cdoc_regex = r\"(?s)(\\/\\*{2}(.+?)\\*\\/{1})\"  # ?s is an inline DOTALL flag arg_cdoc = r\"(\\@param ([A-z0-9]+)\\:(.+)\\n)\" c_cdoc_rgx = re.compile(cdoc_regex) c_arg_rgx = re.compile(arg_cdoc) In\u00a0[\u00a0]: Copied! <pre>GEN_FOLDER = \"gen-docs\"\n</pre> GEN_FOLDER = \"gen-docs\" In\u00a0[\u00a0]: Copied! <pre>@dataclass\nclass PythonDocstring:\n    signature: str\n    rtype: str\n    docstring: str\n\n    def extract_signature_types(self):\n        type_map = {}\n        rtype_map = {}\n        first_bracket = self.signature.index(\"(\")\n        second_bracket = self.signature.index(\")\")\n        args = self.signature[first_bracket + 1 : second_bracket].split(\",\")\n        args = [arg.strip() for arg in args if arg != \"self\"]\n        for arg in args:\n            if \":\" in arg:\n                key_, type_ = arg.split(\":\")\n                key_ = key_.strip()\n                type_ = type_.strip()\n                default_ = \"-\"\n                if \"=\" in type_:\n                    type_, default_ = type_.split(\"=\")\n                    type_ = type_.strip()\n                    default_ = default_.strip()\n                type_map[key_] = type_\n                rtype_map[key_] = default_\n        return type_map, rtype_map\n\n    def py_signature_to_markdown(self):\n        # form type map first\n        type_map, rtype_map = self.extract_signature_types()\n\n        arg_template = \"**`{}`** | `{}` | {} | `{}`\"\n        table = (\n            \"\"\"Name | Type | Description | Default\\n\"\"\"\n            \"\"\"------ | ---- | ----------- | -------\"\"\"\n        )\n        table = \"#### **Parameters** \\n\" + table\n        arg_count = 0\n        for arg in py_arg_rgx.findall(self.docstring):\n            if arg:\n                arg_count += 1\n                real_arg = arg[1].replace(\"\\n\", \"\")\n                arg_desc = arg[2].replace(\"\\n\", \"\")\n\n                table += \"\\n\" + arg_template.format(\n                    real_arg,\n                    type_map.get(real_arg, \"-\"),\n                    arg_desc,\n                    rtype_map.get(real_arg, \"-\"),\n                )\n        fnsignature = self.docstring.split(\":param\")[0].strip()\n        sig = self.signature.replace(\"\\n\", \"\").replace(\"\\t\", \"\").replace(\"    \", \"\")\n        if arg_count:\n            return f\"### `{sig}`\\n\\n{fnsignature}\\n{table}\\n\\n\"\n        return f\"### `{sig}`\\n\\n{fnsignature}\\n\\n\\n\"\n</pre> @dataclass class PythonDocstring:     signature: str     rtype: str     docstring: str      def extract_signature_types(self):         type_map = {}         rtype_map = {}         first_bracket = self.signature.index(\"(\")         second_bracket = self.signature.index(\")\")         args = self.signature[first_bracket + 1 : second_bracket].split(\",\")         args = [arg.strip() for arg in args if arg != \"self\"]         for arg in args:             if \":\" in arg:                 key_, type_ = arg.split(\":\")                 key_ = key_.strip()                 type_ = type_.strip()                 default_ = \"-\"                 if \"=\" in type_:                     type_, default_ = type_.split(\"=\")                     type_ = type_.strip()                     default_ = default_.strip()                 type_map[key_] = type_                 rtype_map[key_] = default_         return type_map, rtype_map      def py_signature_to_markdown(self):         # form type map first         type_map, rtype_map = self.extract_signature_types()          arg_template = \"**`{}`** | `{}` | {} | `{}`\"         table = (             \"\"\"Name | Type | Description | Default\\n\"\"\"             \"\"\"------ | ---- | ----------- | -------\"\"\"         )         table = \"#### **Parameters** \\n\" + table         arg_count = 0         for arg in py_arg_rgx.findall(self.docstring):             if arg:                 arg_count += 1                 real_arg = arg[1].replace(\"\\n\", \"\")                 arg_desc = arg[2].replace(\"\\n\", \"\")                  table += \"\\n\" + arg_template.format(                     real_arg,                     type_map.get(real_arg, \"-\"),                     arg_desc,                     rtype_map.get(real_arg, \"-\"),                 )         fnsignature = self.docstring.split(\":param\")[0].strip()         sig = self.signature.replace(\"\\n\", \"\").replace(\"\\t\", \"\").replace(\"    \", \"\")         if arg_count:             return f\"### `{sig}`\\n\\n{fnsignature}\\n{table}\\n\\n\"         return f\"### `{sig}`\\n\\n{fnsignature}\\n\\n\\n\" In\u00a0[\u00a0]: Copied! <pre>def extract_python_docs(file_text):\n    for captured in c_joint_py.findall(file_text):\n        print(captured)\n        if captured:\n            yield PythonDocstring(\n                signature=captured[1].strip().replace(\"\\n\", \"\"),\n                rtype=captured[2].strip().replace(\"\\n\", \"\"),\n                docstring=captured[-1].strip(),\n            )\n</pre> def extract_python_docs(file_text):     for captured in c_joint_py.findall(file_text):         print(captured)         if captured:             yield PythonDocstring(                 signature=captured[1].strip().replace(\"\\n\", \"\"),                 rtype=captured[2].strip().replace(\"\\n\", \"\"),                 docstring=captured[-1].strip(),             ) In\u00a0[\u00a0]: Copied! <pre>def extract_cpp_docs(file_text):\n    for captured in c_cdoc_rgx.findall(file_text):\n        if captured:\n            yield captured[1].strip()\n</pre> def extract_cpp_docs(file_text):     for captured in c_cdoc_rgx.findall(file_text):         if captured:             yield captured[1].strip() In\u00a0[\u00a0]: Copied! <pre>def create_api_markdown_file(src_filename):\n    _, file_extension = os.path.splitext(src_filename)\n    target_filename = os.path.basename(os.path.dirname(src_filename)).replace(\n        file_extension, \".md\"\n    )\n    if not target_filename.endswith(\".md\"):\n        target_filename += \".md\"\n\n    md_fn = \"\"\n    with open(src_filename, \"r\") as f:\n        ftext = f.read()\n\n        class_docs = ftext.split(\"class\")[1:]\n        for i, doc_ in enumerate(class_docs):\n            doc_ = (\n                doc_.strip()\n                .replace(\"@staticmethod\", \"\")\n                .replace(\"@classmethod\", \"\")\n                .replace(\"@overload\", \"\")\n            )\n            class_name = doc_.partition(\"\\n\")[0].replace(\":\", \"\").strip()\n            md_fn += f\"## `{class_name}`\"\n            for g in extract_python_docs(doc_.replace(\"...\", \"...\\n\")):\n                sig = g.py_signature_to_markdown()\n                md_fn += f\"\\n{sig}\\n\"\n            md_fn += \"  \\n\"\n\n    with open(\n        os.path.join(os.path.dirname(__file__), GEN_FOLDER, target_filename), \"w\"\n    ) as f:\n        f.write(md_fn)\n</pre> def create_api_markdown_file(src_filename):     _, file_extension = os.path.splitext(src_filename)     target_filename = os.path.basename(os.path.dirname(src_filename)).replace(         file_extension, \".md\"     )     if not target_filename.endswith(\".md\"):         target_filename += \".md\"      md_fn = \"\"     with open(src_filename, \"r\") as f:         ftext = f.read()          class_docs = ftext.split(\"class\")[1:]         for i, doc_ in enumerate(class_docs):             doc_ = (                 doc_.strip()                 .replace(\"@staticmethod\", \"\")                 .replace(\"@classmethod\", \"\")                 .replace(\"@overload\", \"\")             )             class_name = doc_.partition(\"\\n\")[0].replace(\":\", \"\").strip()             md_fn += f\"## `{class_name}`\"             for g in extract_python_docs(doc_.replace(\"...\", \"...\\n\")):                 sig = g.py_signature_to_markdown()                 md_fn += f\"\\n{sig}\\n\"             md_fn += \"  \\n\"      with open(         os.path.join(os.path.dirname(__file__), GEN_FOLDER, target_filename), \"w\"     ) as f:         f.write(md_fn) In\u00a0[\u00a0]: Copied! <pre>def on_startup(command, dirty, **kwargs):\n    fn_lists = [\n        *glob.glob(os.path.join(os.path.dirname(__file__), \"..\", \"cmtj/*/*.pyi\")),\n        *glob.glob(os.path.join(os.path.dirname(__file__), \"..\", \"cmtj/*.pyi\")),\n    ]\n    for fn in fn_lists:\n        create_api_markdown_file(fn)\n</pre> def on_startup(command, dirty, **kwargs):     fn_lists = [         *glob.glob(os.path.join(os.path.dirname(__file__), \"..\", \"cmtj/*/*.pyi\")),         *glob.glob(os.path.join(os.path.dirname(__file__), \"..\", \"cmtj/*.pyi\")),     ]     for fn in fn_lists:         create_api_markdown_file(fn) In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    on_startup()\n</pre> if __name__ == \"__main__\":     on_startup()"},{"location":"overview/","title":"Overview","text":"<p>The <code>cmtj</code> library is a macrospin library. That means that it is efficient and easy to use. It is also a collection of utilities that are useful for macrospin analysis, such as selected procedures, energy calculations, and parallelization. </p>"},{"location":"overview/#installation","title":"Installation","text":"<p>Installation is as easy as doing:</p> <pre><code>python3 -m pip install cmtj\n</code></pre>"},{"location":"overview/#how-do-i-get-started","title":"How do I get started?","text":"<p>The best way to get started is to modify one of the examples in the Examples section. If you're looking for a more in-depth look at the library, please see the API section.</p> <p>There are also some examples in the repository under curated-examples folder. These are less described</p> <p>Remember to check out #tips-and-trics section for some tips on how to improve your simulations. </p>"},{"location":"overview/#functionalities","title":"Functionalities","text":""},{"location":"overview/#junction-system","title":"Junction system","text":"<p>Primarily you will be using the <code>Junction</code> class to create a multilayer device. This need not to be an MTJ, it can be of any ferromagnetic (FM) type. Remember, that the FM type is solely dependent on the parameters you pass to the constructor of the <code>Layer</code> class, such as \\(M_\\textrm{s}\\) or \\(K_\\textrm{s}\\) (magnetisation saturation and anisotropy respectively).</p>"},{"location":"overview/#how-do-i-model-the-spaceroxide","title":"How do I model the spacer/oxide?","text":"<p>The funny thing is you don't do that directly. The effects of the spacer are effectively modeled by the <code>Junction</code> class in the following ways:</p> <ul> <li>the STT/SOT parameters, depending on the oxide type or thickness parameters such as \\(H_\\textrm{DL}\\) of \\(H_\\textrm{FL}\\) may get smaller or larger.</li> <li>the effective anisotropy in either of layers creating the junction may be dependent on the interface mixing or interface assymetry, so you can model that, for instance, by modifying one layer's anisotropy adequately.</li> <li>various modifications to magnetoresistance computation may be necessary, depending on the type of junction and the type of the oxide.</li> <li>addition of the <code>dipole</code> or <code>IEC</code> interaction is also a part of the junction model. Sometimes the coupling is so small, it may be neglected. See more in the Core section to see how to enable those (<code>setLayerIEC</code> and <code>setLayerTopDipole</code>).</li> </ul>"},{"location":"overview/#stack-system","title":"Stack system","text":"<p>The junctions can be further stacked to create a stack of junctions. The stacking is done by creating a <code>Stack</code> object which can either be <code>Parallel</code> stack or <code>Series</code> stack. The type depends on the electrical connection between the junctions.</p> <p>Find more in the examples. </p>"},{"location":"overview/#group-interaction-system","title":"Group interaction system","text":"<p>Another way to define 1-1 interaction matrix, also based on distance is <code>GroupInteraction</code> system. For example you can use it to define dipolar interaction in an array of devices. The interaction can also be custom, as long as it matches the signature -- for more, check out the <code>interactions</code> tutorial</p>"},{"location":"overview/#symbolic-models","title":"Symbolic models","text":"<p>There is a plethora of symbolic computation that can solve energy-based systems of FM layers, SAFs and so on. </p> <p>For theory on how those models work visit Smit-Beljers and linearisation sections. The corresponding API is given in Symbolic models section.</p> <p>Things they allow for:</p> <ul> <li>linearised frequency computation</li> <li>native Smit-Beljers model</li> <li>linearised Voltage Spin Diode </li> </ul> <p>Check out the examples in SBModel tutorial and there are other examples scattered here and there.</p>"},{"location":"tipsandtricks/","title":"Tips and tricks","text":"<p>This is a loose collection of observations and tips that may help you in your work with the library.</p> <ul> <li>While scanning with a parameter use the previous value as the starting point. This will speed up the scan. However, remember to perturb the parameter by a small amount, otherwise the simulation may converge to a local minimum. Usually, for obtaining spectra this has no effect, but for obtaining the magnetisation profile it is important.</li> <li>Use <code>utils.Filters</code> for postprocessing the data. Not only logarithm, but detrending the spectra may help in obtaining a clearer picture. Using a <code>uniform_filter</code> from scipy may also help in smoothing the data.</li> <li>Try out integration times no lower than \\(10^{-12}\\). For large IEC coupling values (in the ballpark of \\(10^{-4}\\) or larger than that) you may need to go even much lower. You can always start up higher and then reduce step size to confirm that it has no effect on the results and convergence.</li> <li>Use <code>junction.clearLog()</code> and <code>stack.clearLogs()</code> to clear the log of the junction and stack. This will save you a lot of memory if you're doing a lot of scans and will vastly speed up the processing.</li> <li>You can define your own drivers! See the API documentation for more information.</li> <li>In models from <code>cmtj.models</code>, in the <code>Solver</code> class you can pass <code>prefer_numerical_roots=False</code> to the solver can speed up your computation, depending on the complexity of your model!</li> </ul>"},{"location":"api/core/","title":"Core","text":""},{"location":"api/core/#cmtj.core.AxialDriver","title":"<code>AxialDriver</code>","text":"<p>Axial driver class.</p> Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>class AxialDriver:\n    \"\"\"Axial driver class.\"\"\"\n\n    @overload\n    def __init__(self, x: ScalarDriver, y: ScalarDriver, z: ScalarDriver) -&gt; None:\n        \"\"\"Create an axial driver with three scalar drivers for each axis.\n        :param x: driver for the x axis\n        :param y: driver for the y axis\n        :param z: driver for the z axis\n        \"\"\"\n        ...\n\n    @overload\n    def __init__(self, axialDrivers: list[ScalarDriver]) -&gt; None:\n        \"\"\"Create an axial driver with a list of scalar drivers.\n        :param axialDrivers: list of scalar drivers\n        \"\"\"\n        ...\n\n    @overload\n    def __init__(self, x: float, y: float, z: float) -&gt; None:\n        \"\"\"Create an axial driver with a list of floats.\n        :param x: constant float for the x axis\n        :param y: constant float for the y axis\n        :param z: constant float for the z axis\n        \"\"\"\n        ...\n\n    @overload\n    def __init__(self, xyz: CVector) -&gt; None:\n        \"\"\"Create an axial driver with a vector.\n        :param xyz: CVector object with x, y, z components\n        \"\"\"\n        ...\n\n    @overload\n    def __init__(*args, **kwargs) -&gt; Any: ...\n    @overload\n    def applyMask(self, mask: CVector) -&gt; None:\n        \"\"\"Apply mask to the driver.\n        :param mask: mask to be applied\"\"\"\n        ...\n\n    @overload\n    def applyMask(self, mask: list[int]) -&gt; None:\n        \"\"\"Apply mask to the driver.\n        :param mask: mask to be applied\"\"\"\n        ...\n\n    @overload\n    def applyMask(*args, **kwargs) -&gt; Any: ...\n    def getCurrentAxialDrivers(self, arg0: float) -&gt; CVector: ...\n    def getVectorAxialDriver(self, arg0: float, arg1: float) -&gt; AxialDriver: ...\n</code></pre>"},{"location":"api/core/#cmtj.core.CVector","title":"<code>CVector</code>","text":"<p>CVector class. Represents a 3D vector.</p> Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>class CVector:\n    \"\"\"CVector class. Represents a 3D vector.\"\"\"\n\n    def __init__(self, x: float, y: float, z: float) -&gt; None:\n        \"\"\"Initialises a 3D vector.\n        :param x: x component of the vector\n        :param y: y component of the vector\n        :param z: z component of the vector\"\"\"\n        ...\n\n    def length(self) -&gt; float:\n        \"\"\"Returns the length of the vector.\"\"\"\n        ...\n\n    def normalize(self) -&gt; None:\n        \"\"\"Normalizes the vector.\"\"\"\n        ...\n\n    def tolist(self) -&gt; list[float]:\n        \"\"\"Converts the vector to a list.\"\"\"\n        ...\n\n    @staticmethod\n    def fromSpherical(theta: float, phi: float, r: float = 1.0) -&gt; CVector:\n        \"\"\"Create a vector from spherical coordinates.\n        :param theta: polar angle in radians\n        :param phi: azimuthal angle in radians\n        :param r: radius of the vector\n        \"\"\"\n        ...\n\n    def __add__(self, arg0: CVector) -&gt; CVector: ...\n    def __eq__(self, arg0: CVector) -&gt; bool: ...\n    def __getitem__(self, arg0: int) -&gt; float: ...\n    def __iter__(self) -&gt; typing.Iterator[float]: ...\n    def __iadd__(self, arg0: CVector) -&gt; CVector: ...\n    def __imul__(self, arg0: float) -&gt; CVector: ...\n    def __isub__(self, arg0: CVector) -&gt; CVector: ...\n    def __len__(self) -&gt; int: ...\n    def __mul__(self, arg0: float) -&gt; CVector: ...\n    def __ne__(self, arg0: CVector) -&gt; bool: ...\n    def __rmul__(self, arg0: float) -&gt; CVector: ...\n    def __sub__(self, arg0: CVector) -&gt; CVector: ...\n    @property\n    def x(self) -&gt; float: ...\n    @x.setter\n    def x(self, val: float) -&gt; None: ...\n    @property\n    def y(self) -&gt; float: ...\n    @y.setter\n    def y(self, val: float) -&gt; None: ...\n    @property\n    def z(self) -&gt; float: ...\n    @z.setter\n    def z(self, val: float) -&gt; None: ...\n</code></pre>"},{"location":"api/core/#cmtj.core.CVector.__init__","title":"<code>__init__(x, y, z)</code>","text":"<p>Initialises a 3D vector.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>x component of the vector</p> required <code>y</code> <code>float</code> <p>y component of the vector</p> required <code>z</code> <code>float</code> <p>z component of the vector</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def __init__(self, x: float, y: float, z: float) -&gt; None:\n    \"\"\"Initialises a 3D vector.\n    :param x: x component of the vector\n    :param y: y component of the vector\n    :param z: z component of the vector\"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.CVector.fromSpherical","title":"<code>fromSpherical(theta, phi, r=1.0)</code>  <code>staticmethod</code>","text":"<p>Create a vector from spherical coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>polar angle in radians</p> required <code>phi</code> <code>float</code> <p>azimuthal angle in radians</p> required <code>r</code> <code>float</code> <p>radius of the vector</p> <code>1.0</code> Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>@staticmethod\ndef fromSpherical(theta: float, phi: float, r: float = 1.0) -&gt; CVector:\n    \"\"\"Create a vector from spherical coordinates.\n    :param theta: polar angle in radians\n    :param phi: azimuthal angle in radians\n    :param r: radius of the vector\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.CVector.length","title":"<code>length()</code>","text":"<p>Returns the length of the vector.</p> Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def length(self) -&gt; float:\n    \"\"\"Returns the length of the vector.\"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.CVector.normalize","title":"<code>normalize()</code>","text":"<p>Normalizes the vector.</p> Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def normalize(self) -&gt; None:\n    \"\"\"Normalizes the vector.\"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.CVector.tolist","title":"<code>tolist()</code>","text":"<p>Converts the vector to a list.</p> Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def tolist(self) -&gt; list[float]:\n    \"\"\"Converts the vector to a list.\"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Junction","title":"<code>Junction</code>","text":"Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>class Junction:\n    @overload\n    def __init__(self, layers: list[Layer]) -&gt; None:\n        \"\"\"\"\"\"\n        ...\n\n    @overload\n    def __init__(self, layers: list[Layer], Rp: float = ..., Rap: float = ...) -&gt; None:\n        \"\"\"Creates a junction with a magnetoresistance.\n        :param layers: list of layers\n\n        :param Rp: Parallel magnetoresistance\n        :param Rap: Magnetoresistance anti-parallel state\n        \"\"\"\n        ...\n\n    @overload\n    def __init__(\n        self,\n        layers: list[Layer],\n        Rx0: list[float],\n        Ry0: list[float],\n        AMR_X: list[float],\n        AMR_Y: list[float],\n        SMR_X: list[float],\n        SMR_Y: list[float],\n        AHE: list[float],\n    ) -&gt; None:\n        \"\"\"Creates a junction with a STRIP magnetoresistance.\n        Each of the Rx0, Ry, AMR, AMR and SMR is list matching the\n        length of the layers passed (they directly correspond to each layer).\n        Calculates the magnetoresistance as per: __see reference__:\n        Spin Hall magnetoresistance in metallic bilayers by Kim, J. et al.\n        :param Rx0: Magnetoresistance offset longitudinal\n        :param Ry0: Magnetoresistance offset transverse\n        :param AMR_X: Anisotropic magnetoresistance longitudinal\n        :param AMR_Y: Anisotropic magnetoresistance transverse\n        :param SMR_X: Spin magnetoresistance longitudinal\n        :param SMR_Y: Spin magnetoresistance transverse\n        :param AHE: Anomalous Hall effect resistance offset (transverse only)\n        \"\"\"\n        ...\n\n    @overload\n    def __init__(*args, **kwargs) -&gt; Any: ...\n    def clearLog(self) -&gt; dict[str, Any]:\n        \"\"\"Reset current simulation state.\"\"\"\n        ...\n\n    def getLayerMagnetisation(self, layerId: str) -&gt; CVector:\n        \"\"\"Get the magnetisation of a layer.\n        :param layerId: the layer id\"\"\"\n        ...\n\n    def getLog(self) -&gt; dict[str, list[float]]:\n        \"\"\"Retrieve the simulation log [data].\"\"\"\n        ...\n\n    def getMagnetoresistance(self) -&gt; list[float]: ...\n    def runSimulation(\n        self,\n        totalTime: float,\n        timeStep: float = ...,\n        writeFrequency: float = ...,\n        persist: bool = ...,\n        log: bool = ...,\n        calculateEnergies: bool = ...,\n    ) -&gt; None:\n        \"\"\"Main run simulation function.\n        Use it to run the simulation.\n        :param totalTime: total time of a simulation, give it in seconds. Typical length is in ~couple ns.\n        :param timeStep: the integration step of the RK45 method. Default is 1e-13\n        :param writeFrequency: how often is the log saved to? Must be no smaller than `timeStep`. Default is 1e-11.\n        :param persist: whether to save to the filename specified in the Junction constructor. Default is true\n        :param log: if you want some verbosity like timing the simulation. Default is false\n        :param calculateEnergies: [WORK IN PROGRESS] log energy values to the log. Default is false.\n        \"\"\"\n        ...\n\n    def setIECDriver(self, bottomLayer: str, topLayer: str, driver: ScalarDriver) -&gt; None:\n        \"\"\"Set IEC interaction between two layers.\n        The names of the params are only for convention. The IEC will be set\n        between bottomLyaer or topLayer, order is irrelevant.\n        :param bottomLayer: the first layer id\n        :param topLayer: the second layer id\n        \"\"\"\n        ...\n\n    def setQuadIECDriver(self, bottomLayer: str, topLayer: str, driver: ScalarDriver) -&gt; None:\n        \"\"\"Set secondary (biquadratic term) IEC interaction between two layers.\n        The names of the params are only for convention. The IEC will be set\n        between bottomLyaer or topLayer, order is irrelevant.\n        :param bottomLayer: the first layer id\n        :param topLayer: the second layer id\n        \"\"\"\n        ...\n\n    def setLayerTemperatureDriver(self, layerId: str, driver: ScalarDriver) -&gt; None:\n        \"\"\"Set a temperature driver for a layer.\n        :param layerId: the id of the layer.\n        :param driver: the temperature driver to be set.\n        \"\"\"\n        ...\n\n    def setLayerAnisotropyDriver(self, layerId: str, driver: ScalarDriver) -&gt; None:\n        \"\"\"Set anisotropy driver for a layer.\n        :param layerId: the id of the layer.\n        :param driver: the anisotropy driver to be set.\n        \"\"\"\n        ...\n\n    def setLayerCurrentDriver(self, layerId: str, driver: ScalarDriver) -&gt; None:\n        \"\"\"Set a current driver for a layer.\n        :param layerId: the layer id\n        :param driver: the driver\n        \"\"\"\n        ...\n\n    def setLayerExternalFieldDriver(self, layerId: str, driver: AxialDriver) -&gt; None:\n        \"\"\"Set an external field driver for a layer.\n        :param layerId: the id of the layer.\n        :param driver: the field driver to be set.\n        \"\"\"\n        ...\n\n    def setLayerMagnetisation(self, layerId: str, mag: CVector) -&gt; None:\n        \"\"\"Set the magnetisation of a layer.\n        :param layerId: the layer id\n        :param mag: the magnetisation\n        \"\"\"\n        ...\n\n    @overload\n    def setLayerOerstedFieldDriver(self, layerId: str, driver: AxialDriver) -&gt; None:\n        \"\"\"Set an Oersted field driver for a layer.\n        :param layerId: the id of the layer.\n        :param driver: the field driver to be set.\n        \"\"\"\n        ...\n\n    def setLayerDampingLikeTorqueDriver(self, layerId: str, driver: ScalarDriver) -&gt; None:\n        \"\"\"Set the damping like torque driver for a layer.\n        :param layerId: the layer id\n        :param driver: the driver\n        \"\"\"\n        ...\n\n    def setLayerFieldLikeTorqueDriver(self, layerId: str, driver: ScalarDriver) -&gt; None:\n        \"\"\"Set the field like torque driver for a layer.\n        :param layerId: the layer id\n        :param driver: the driver\n        \"\"\"\n        ...\n\n    def setLayerOneFNoise(self, layerId: str, sources: int, bias: float, scale: float) -&gt; None:\n        \"\"\"Set 1/f noise for a layer.\n        :param layerId: the layer id\n        :param sources: the number of generation sources (the more the slower, but more acc.)\n        :param bias: the bias of the noise (p in the Multinomial distribution)\n        :param scale: the scale of the noise, additional scaling factor\n        \"\"\"\n        ...\n\n    def getLayer(self, layerId: str) -&gt; Layer:\n        \"\"\"Get a specific layer from the junction. Returns a reference.\n        :param layerId: the id of the layer (string) as passed in the init.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Junction.clearLog","title":"<code>clearLog()</code>","text":"<p>Reset current simulation state.</p> Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def clearLog(self) -&gt; dict[str, Any]:\n    \"\"\"Reset current simulation state.\"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Junction.getLayer","title":"<code>getLayer(layerId)</code>","text":"<p>Get a specific layer from the junction. Returns a reference.</p> <p>Parameters:</p> Name Type Description Default <code>layerId</code> <code>str</code> <p>the id of the layer (string) as passed in the init.</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def getLayer(self, layerId: str) -&gt; Layer:\n    \"\"\"Get a specific layer from the junction. Returns a reference.\n    :param layerId: the id of the layer (string) as passed in the init.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Junction.getLayerMagnetisation","title":"<code>getLayerMagnetisation(layerId)</code>","text":"<p>Get the magnetisation of a layer.</p> <p>Parameters:</p> Name Type Description Default <code>layerId</code> <code>str</code> <p>the layer id</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def getLayerMagnetisation(self, layerId: str) -&gt; CVector:\n    \"\"\"Get the magnetisation of a layer.\n    :param layerId: the layer id\"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Junction.getLog","title":"<code>getLog()</code>","text":"<p>Retrieve the simulation log [data].</p> Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def getLog(self) -&gt; dict[str, list[float]]:\n    \"\"\"Retrieve the simulation log [data].\"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Junction.runSimulation","title":"<code>runSimulation(totalTime, timeStep=Ellipsis, writeFrequency=Ellipsis, persist=Ellipsis, log=Ellipsis, calculateEnergies=Ellipsis)</code>","text":"<p>Main run simulation function. Use it to run the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>totalTime</code> <code>float</code> <p>total time of a simulation, give it in seconds. Typical length is in ~couple ns.</p> required <code>timeStep</code> <code>float</code> <p>the integration step of the RK45 method. Default is 1e-13</p> <code>Ellipsis</code> <code>writeFrequency</code> <code>float</code> <p>how often is the log saved to? Must be no smaller than <code>timeStep</code>. Default is 1e-11.</p> <code>Ellipsis</code> <code>persist</code> <code>bool</code> <p>whether to save to the filename specified in the Junction constructor. Default is true</p> <code>Ellipsis</code> <code>log</code> <code>bool</code> <p>if you want some verbosity like timing the simulation. Default is false</p> <code>Ellipsis</code> <code>calculateEnergies</code> <code>bool</code> <p>[WORK IN PROGRESS] log energy values to the log. Default is false.</p> <code>Ellipsis</code> Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def runSimulation(\n    self,\n    totalTime: float,\n    timeStep: float = ...,\n    writeFrequency: float = ...,\n    persist: bool = ...,\n    log: bool = ...,\n    calculateEnergies: bool = ...,\n) -&gt; None:\n    \"\"\"Main run simulation function.\n    Use it to run the simulation.\n    :param totalTime: total time of a simulation, give it in seconds. Typical length is in ~couple ns.\n    :param timeStep: the integration step of the RK45 method. Default is 1e-13\n    :param writeFrequency: how often is the log saved to? Must be no smaller than `timeStep`. Default is 1e-11.\n    :param persist: whether to save to the filename specified in the Junction constructor. Default is true\n    :param log: if you want some verbosity like timing the simulation. Default is false\n    :param calculateEnergies: [WORK IN PROGRESS] log energy values to the log. Default is false.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Junction.setIECDriver","title":"<code>setIECDriver(bottomLayer, topLayer, driver)</code>","text":"<p>Set IEC interaction between two layers. The names of the params are only for convention. The IEC will be set between bottomLyaer or topLayer, order is irrelevant.</p> <p>Parameters:</p> Name Type Description Default <code>bottomLayer</code> <code>str</code> <p>the first layer id</p> required <code>topLayer</code> <code>str</code> <p>the second layer id</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def setIECDriver(self, bottomLayer: str, topLayer: str, driver: ScalarDriver) -&gt; None:\n    \"\"\"Set IEC interaction between two layers.\n    The names of the params are only for convention. The IEC will be set\n    between bottomLyaer or topLayer, order is irrelevant.\n    :param bottomLayer: the first layer id\n    :param topLayer: the second layer id\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Junction.setLayerAnisotropyDriver","title":"<code>setLayerAnisotropyDriver(layerId, driver)</code>","text":"<p>Set anisotropy driver for a layer.</p> <p>Parameters:</p> Name Type Description Default <code>layerId</code> <code>str</code> <p>the id of the layer.</p> required <code>driver</code> <code>ScalarDriver</code> <p>the anisotropy driver to be set.</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def setLayerAnisotropyDriver(self, layerId: str, driver: ScalarDriver) -&gt; None:\n    \"\"\"Set anisotropy driver for a layer.\n    :param layerId: the id of the layer.\n    :param driver: the anisotropy driver to be set.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Junction.setLayerCurrentDriver","title":"<code>setLayerCurrentDriver(layerId, driver)</code>","text":"<p>Set a current driver for a layer.</p> <p>Parameters:</p> Name Type Description Default <code>layerId</code> <code>str</code> <p>the layer id</p> required <code>driver</code> <code>ScalarDriver</code> <p>the driver</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def setLayerCurrentDriver(self, layerId: str, driver: ScalarDriver) -&gt; None:\n    \"\"\"Set a current driver for a layer.\n    :param layerId: the layer id\n    :param driver: the driver\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Junction.setLayerDampingLikeTorqueDriver","title":"<code>setLayerDampingLikeTorqueDriver(layerId, driver)</code>","text":"<p>Set the damping like torque driver for a layer.</p> <p>Parameters:</p> Name Type Description Default <code>layerId</code> <code>str</code> <p>the layer id</p> required <code>driver</code> <code>ScalarDriver</code> <p>the driver</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def setLayerDampingLikeTorqueDriver(self, layerId: str, driver: ScalarDriver) -&gt; None:\n    \"\"\"Set the damping like torque driver for a layer.\n    :param layerId: the layer id\n    :param driver: the driver\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Junction.setLayerExternalFieldDriver","title":"<code>setLayerExternalFieldDriver(layerId, driver)</code>","text":"<p>Set an external field driver for a layer.</p> <p>Parameters:</p> Name Type Description Default <code>layerId</code> <code>str</code> <p>the id of the layer.</p> required <code>driver</code> <code>AxialDriver</code> <p>the field driver to be set.</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def setLayerExternalFieldDriver(self, layerId: str, driver: AxialDriver) -&gt; None:\n    \"\"\"Set an external field driver for a layer.\n    :param layerId: the id of the layer.\n    :param driver: the field driver to be set.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Junction.setLayerFieldLikeTorqueDriver","title":"<code>setLayerFieldLikeTorqueDriver(layerId, driver)</code>","text":"<p>Set the field like torque driver for a layer.</p> <p>Parameters:</p> Name Type Description Default <code>layerId</code> <code>str</code> <p>the layer id</p> required <code>driver</code> <code>ScalarDriver</code> <p>the driver</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def setLayerFieldLikeTorqueDriver(self, layerId: str, driver: ScalarDriver) -&gt; None:\n    \"\"\"Set the field like torque driver for a layer.\n    :param layerId: the layer id\n    :param driver: the driver\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Junction.setLayerMagnetisation","title":"<code>setLayerMagnetisation(layerId, mag)</code>","text":"<p>Set the magnetisation of a layer.</p> <p>Parameters:</p> Name Type Description Default <code>layerId</code> <code>str</code> <p>the layer id</p> required <code>mag</code> <code>CVector</code> <p>the magnetisation</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def setLayerMagnetisation(self, layerId: str, mag: CVector) -&gt; None:\n    \"\"\"Set the magnetisation of a layer.\n    :param layerId: the layer id\n    :param mag: the magnetisation\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Junction.setLayerOneFNoise","title":"<code>setLayerOneFNoise(layerId, sources, bias, scale)</code>","text":"<p>Set 1/f noise for a layer.</p> <p>Parameters:</p> Name Type Description Default <code>layerId</code> <code>str</code> <p>the layer id</p> required <code>sources</code> <code>int</code> <p>the number of generation sources (the more the slower, but more acc.)</p> required <code>bias</code> <code>float</code> <p>the bias of the noise (p in the Multinomial distribution)</p> required <code>scale</code> <code>float</code> <p>the scale of the noise, additional scaling factor</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def setLayerOneFNoise(self, layerId: str, sources: int, bias: float, scale: float) -&gt; None:\n    \"\"\"Set 1/f noise for a layer.\n    :param layerId: the layer id\n    :param sources: the number of generation sources (the more the slower, but more acc.)\n    :param bias: the bias of the noise (p in the Multinomial distribution)\n    :param scale: the scale of the noise, additional scaling factor\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Junction.setLayerTemperatureDriver","title":"<code>setLayerTemperatureDriver(layerId, driver)</code>","text":"<p>Set a temperature driver for a layer.</p> <p>Parameters:</p> Name Type Description Default <code>layerId</code> <code>str</code> <p>the id of the layer.</p> required <code>driver</code> <code>ScalarDriver</code> <p>the temperature driver to be set.</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def setLayerTemperatureDriver(self, layerId: str, driver: ScalarDriver) -&gt; None:\n    \"\"\"Set a temperature driver for a layer.\n    :param layerId: the id of the layer.\n    :param driver: the temperature driver to be set.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Junction.setQuadIECDriver","title":"<code>setQuadIECDriver(bottomLayer, topLayer, driver)</code>","text":"<p>Set secondary (biquadratic term) IEC interaction between two layers. The names of the params are only for convention. The IEC will be set between bottomLyaer or topLayer, order is irrelevant.</p> <p>Parameters:</p> Name Type Description Default <code>bottomLayer</code> <code>str</code> <p>the first layer id</p> required <code>topLayer</code> <code>str</code> <p>the second layer id</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def setQuadIECDriver(self, bottomLayer: str, topLayer: str, driver: ScalarDriver) -&gt; None:\n    \"\"\"Set secondary (biquadratic term) IEC interaction between two layers.\n    The names of the params are only for convention. The IEC will be set\n    between bottomLyaer or topLayer, order is irrelevant.\n    :param bottomLayer: the first layer id\n    :param topLayer: the second layer id\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Layer","title":"<code>Layer</code>","text":"Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>class Layer:\n    def __init__(\n        self,\n        id: str,\n        mag: CVector,\n        anis: CVector,\n        Ms: float,\n        thickness: float,\n        cellSurface: float,\n        demagTensor: list[CVector],\n        temperature: float = ...,\n        damping: float = ...,\n    ) -&gt; Layer:\n        \"\"\"\n        The basic structure is a magnetic layer.\n        Its parameters are defined by the constructor and may be altered\n        by the drivers during the simulation time.\n        If you want STT, remember to set the reference vector for the polarisation of the layer.\n        Use `setReferenceLayer` function to do that.\n        :param id: identifiable name for a layer -- e.g. \"bottom\" or \"free\".\n        :param mag: initial magnetisation. Must be normalised (norm of 1). Used for quicker convergence.\n        :param anis: anisotropy of the layer. A normalised vector\n        :param Ms: magnetisation saturation. Unit: Tesla [T].\n        :param thickness: thickness of the layer. Unit: meter [m].\n        :param cellSurface: surface of the layer, for volume calculation. Unit: meter^2 [m^2].\n        :param damping: often marked as alpha in the LLG equation. Damping of the layer. Default 0.011. Dimensionless\n        \"\"\"\n        ...\n\n    @staticmethod\n    def createSOTLayer(\n        id: str,\n        mag: CVector,\n        anis: CVector,\n        Ms: float,\n        thickness: float,\n        cellSurface: float,\n        demagTensor: list[CVector],\n        damping: float = 0.11,\n        fieldLikeTorque: float = 0,\n        dampingLikeTorque: float = 0,\n    ) -&gt; Layer:\n        \"\"\"\n        Create SOT layer -- including damping and field-like torques that are\n        calculated based on the effective Spin Hall angles.\n        :param id: identifiable name for a layer -- e.g. \"bottom\" or \"free\".\n        :param mag: initial magnetisation. Must be normalised (norm of 1). Used for quicker convergence.\n        :param anis: anisotropy of the layer. A normalised vector\n        :param Ms: magnetisation saturation. Unit: Tesla [T].\n        :param thickness: thickness of the layer. Unit: meter [m].\n        :param cellSurface: surface of the layer, for volume calculation. Unit: meter^2 [m^2].\n        :param damping: often marked as alpha in the LLG equation. Damping of the layer. Default 0.011. Dimensionless.\n        \"\"\"\n        ...\n\n    @staticmethod\n    def createSTTLayer(\n        id: str,\n        mag: CVector,\n        anis: CVector,\n        Ms: float,\n        thickness: float,\n        cellSurface: float,\n        demagTensor: list[CVector],\n        damping: float = 0.011,\n        SlonczewskiSpacerLayerParameter: float = 1.0,\n        beta: float = 0.0,\n        spinPolarisation: float = 0.0,\n    ) -&gt; Layer:\n        \"\"\"\n        Create STT layer -- with the standard Slomczewski formulation.\n        :param id: identifiable name for a layer -- e.g. \"bottom\" or \"free\".\n        :param mag: initial magnetisation. Must be normalised (norm of 1). Used for quicker convergence.\n        :param anis: anisotropy of the layer. A normalised vector\n        :param Ms: magnetisation saturation. Unit: Tesla [T].\n        :param thickness: thickness of the layer. Unit: meter [m].\n        :param cellSurface: surface of the layer, for volume calculation. Unit: meter^2 [m^2].\n        :param damping: often marked as alpha in the LLG equation. Damping of the layer. Default 0.011. Dimensionless.\n        :param SlonczewskiSpacerLayerParameter: Slomczewski parameter. Often marked as lambda.\n        :param beta: beta parameter that scales FL/DL ratio.\n        :param spinPolarisation: the spin effectiveness.\n        \"\"\"\n        ...\n\n    def createBufferedAlphaNoise(self, bufferSize: int) -&gt; None:\n        \"\"\"Create a buffered alpha noise generator.\"\"\"\n        ...\n\n    def setAlphaNoise(self, alpha: float, std: float, scale: float, axis: Axis = Axis.all) -&gt; None:\n        \"\"\"Set alpha noise for the layer.\n        :param alpha: Alpha parameter\n        :param std: Standard deviation\n        :param scale: Scale\n        :param axis: Axis, by default all axes are used\n        \"\"\"\n        ...\n\n    def setAnisotropyDriver(self, driver: ScalarDriver) -&gt; None:\n        \"\"\"Set anisotropy driver for the layer.\n        It's scalar. The axis is determined in the layer constructor\"\"\"\n        ...\n\n    def setTemperatureDriver(self, driver: ScalarDriver) -&gt; None:\n        \"\"\"Set a driver for the temperature of the layer.\n        Automatically changes the solver to Euler-Heun.\"\"\"\n        ...\n\n    def setExternalFieldDriver(self, driver: AxialDriver) -&gt; None: ...\n    def setMagnetisation(self, mag: CVector) -&gt; None:\n        \"\"\"Set the magnetisation of the layer.\n        :param mag: the magnetisation to be set.\"\"\"\n        ...\n\n    def setOerstedFieldDriver(self, driver: AxialDriver) -&gt; None:\n        \"\"\"Set an Oersted field driver for the layer.\n        :param driver: the field driver to be set.\"\"\"\n        ...\n\n    def setDampingLikeTorqueDriver(self, driver: ScalarDriver) -&gt; None:\n        \"\"\"Set a driver for the damping like torque of the layer.\n        :param driver: the driver to be set.\"\"\"\n        ...\n\n    def setFieldLikeTorqueDriver(self, driver: ScalarDriver) -&gt; None:\n        \"\"\"Set a driver for the field like torque of the layer.\n        :param driver: the driver to be set.\"\"\"\n        ...\n\n    def setReferenceLayer(self, ref: CVector) -&gt; None:\n        \"\"\"Set a reference layer for the STT.\n        :param ref: the reference layer vector.\"\"\"\n        ...\n\n    @overload\n    def setReferenceLayer(self, ref: Reference) -&gt; None:  # noqa: F811\n        \"\"\"Set a reference layer for the STT. The reference can be\n        FIXED, BOTTOM or TOP. YOu can use another layer as reference\n        to this one.\n        :param ref: the reference layer vector.\"\"\"\n        ...\n\n    def setTopDipoleTensor(self, tensor: list[CVector]) -&gt; None:\n        \"\"\"Set a dipole tensor from the top layer.\n        :param tensor: the dipole tensor to be set.\n        \"\"\"\n        ...\n\n    def setBottomDipoleTensor(self, tensor: list[CVector]) -&gt; None:\n        \"\"\"Set a dipole tensor from the bottom layer.\n        :param tensor: the dipole tensor to be set.\n        \"\"\"\n        ...\n\n    def getId(self) -&gt; str:\n        \"\"\"Get Id of the layer\"\"\"\n        ...\n\n    def setAlternativeSTT(self, setAlternative: bool) -&gt; None:\n        \"\"\"Switch to an alternative STT forumulation (Taniguchi et al.)\n        https://iopscience.iop.org/article/10.7567/APEX.11.013005\n        :param setAlternative: whether to set the alternative STT formulation\n        \"\"\"\n        ...\n\n    def setKappa(self, kappa: float) -&gt; None:\n        \"\"\"Set the kappa parameter for the layer -- determines SOT mixing\n            Hdl * kappa + Hfl\n        Allows you to turn off Hdl. Turning Hfl is via beta parameter.\n        :param kappa: the kappa parameter\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Layer.__init__","title":"<code>__init__(id, mag, anis, Ms, thickness, cellSurface, demagTensor, temperature=Ellipsis, damping=Ellipsis)</code>","text":"<p>The basic structure is a magnetic layer. Its parameters are defined by the constructor and may be altered by the drivers during the simulation time. If you want STT, remember to set the reference vector for the polarisation of the layer. Use <code>setReferenceLayer</code> function to do that.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>identifiable name for a layer -- e.g. \"bottom\" or \"free\".</p> required <code>mag</code> <code>CVector</code> <p>initial magnetisation. Must be normalised (norm of 1). Used for quicker convergence.</p> required <code>anis</code> <code>CVector</code> <p>anisotropy of the layer. A normalised vector</p> required <code>Ms</code> <code>float</code> <p>magnetisation saturation. Unit: Tesla [T].</p> required <code>thickness</code> <code>float</code> <p>thickness of the layer. Unit: meter [m].</p> required <code>cellSurface</code> <code>float</code> <p>surface of the layer, for volume calculation. Unit: meter^2 [m^2].</p> required <code>damping</code> <code>float</code> <p>often marked as alpha in the LLG equation. Damping of the layer. Default 0.011. Dimensionless</p> <code>Ellipsis</code> Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def __init__(\n    self,\n    id: str,\n    mag: CVector,\n    anis: CVector,\n    Ms: float,\n    thickness: float,\n    cellSurface: float,\n    demagTensor: list[CVector],\n    temperature: float = ...,\n    damping: float = ...,\n) -&gt; Layer:\n    \"\"\"\n    The basic structure is a magnetic layer.\n    Its parameters are defined by the constructor and may be altered\n    by the drivers during the simulation time.\n    If you want STT, remember to set the reference vector for the polarisation of the layer.\n    Use `setReferenceLayer` function to do that.\n    :param id: identifiable name for a layer -- e.g. \"bottom\" or \"free\".\n    :param mag: initial magnetisation. Must be normalised (norm of 1). Used for quicker convergence.\n    :param anis: anisotropy of the layer. A normalised vector\n    :param Ms: magnetisation saturation. Unit: Tesla [T].\n    :param thickness: thickness of the layer. Unit: meter [m].\n    :param cellSurface: surface of the layer, for volume calculation. Unit: meter^2 [m^2].\n    :param damping: often marked as alpha in the LLG equation. Damping of the layer. Default 0.011. Dimensionless\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Layer.createBufferedAlphaNoise","title":"<code>createBufferedAlphaNoise(bufferSize)</code>","text":"<p>Create a buffered alpha noise generator.</p> Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def createBufferedAlphaNoise(self, bufferSize: int) -&gt; None:\n    \"\"\"Create a buffered alpha noise generator.\"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Layer.createSOTLayer","title":"<code>createSOTLayer(id, mag, anis, Ms, thickness, cellSurface, demagTensor, damping=0.11, fieldLikeTorque=0, dampingLikeTorque=0)</code>  <code>staticmethod</code>","text":"<p>Create SOT layer -- including damping and field-like torques that are calculated based on the effective Spin Hall angles.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>identifiable name for a layer -- e.g. \"bottom\" or \"free\".</p> required <code>mag</code> <code>CVector</code> <p>initial magnetisation. Must be normalised (norm of 1). Used for quicker convergence.</p> required <code>anis</code> <code>CVector</code> <p>anisotropy of the layer. A normalised vector</p> required <code>Ms</code> <code>float</code> <p>magnetisation saturation. Unit: Tesla [T].</p> required <code>thickness</code> <code>float</code> <p>thickness of the layer. Unit: meter [m].</p> required <code>cellSurface</code> <code>float</code> <p>surface of the layer, for volume calculation. Unit: meter^2 [m^2].</p> required <code>damping</code> <code>float</code> <p>often marked as alpha in the LLG equation. Damping of the layer. Default 0.011. Dimensionless.</p> <code>0.11</code> Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>@staticmethod\ndef createSOTLayer(\n    id: str,\n    mag: CVector,\n    anis: CVector,\n    Ms: float,\n    thickness: float,\n    cellSurface: float,\n    demagTensor: list[CVector],\n    damping: float = 0.11,\n    fieldLikeTorque: float = 0,\n    dampingLikeTorque: float = 0,\n) -&gt; Layer:\n    \"\"\"\n    Create SOT layer -- including damping and field-like torques that are\n    calculated based on the effective Spin Hall angles.\n    :param id: identifiable name for a layer -- e.g. \"bottom\" or \"free\".\n    :param mag: initial magnetisation. Must be normalised (norm of 1). Used for quicker convergence.\n    :param anis: anisotropy of the layer. A normalised vector\n    :param Ms: magnetisation saturation. Unit: Tesla [T].\n    :param thickness: thickness of the layer. Unit: meter [m].\n    :param cellSurface: surface of the layer, for volume calculation. Unit: meter^2 [m^2].\n    :param damping: often marked as alpha in the LLG equation. Damping of the layer. Default 0.011. Dimensionless.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Layer.createSTTLayer","title":"<code>createSTTLayer(id, mag, anis, Ms, thickness, cellSurface, demagTensor, damping=0.011, SlonczewskiSpacerLayerParameter=1.0, beta=0.0, spinPolarisation=0.0)</code>  <code>staticmethod</code>","text":"<p>Create STT layer -- with the standard Slomczewski formulation.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>identifiable name for a layer -- e.g. \"bottom\" or \"free\".</p> required <code>mag</code> <code>CVector</code> <p>initial magnetisation. Must be normalised (norm of 1). Used for quicker convergence.</p> required <code>anis</code> <code>CVector</code> <p>anisotropy of the layer. A normalised vector</p> required <code>Ms</code> <code>float</code> <p>magnetisation saturation. Unit: Tesla [T].</p> required <code>thickness</code> <code>float</code> <p>thickness of the layer. Unit: meter [m].</p> required <code>cellSurface</code> <code>float</code> <p>surface of the layer, for volume calculation. Unit: meter^2 [m^2].</p> required <code>damping</code> <code>float</code> <p>often marked as alpha in the LLG equation. Damping of the layer. Default 0.011. Dimensionless.</p> <code>0.011</code> <code>SlonczewskiSpacerLayerParameter</code> <code>float</code> <p>Slomczewski parameter. Often marked as lambda.</p> <code>1.0</code> <code>beta</code> <code>float</code> <p>beta parameter that scales FL/DL ratio.</p> <code>0.0</code> <code>spinPolarisation</code> <code>float</code> <p>the spin effectiveness.</p> <code>0.0</code> Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>@staticmethod\ndef createSTTLayer(\n    id: str,\n    mag: CVector,\n    anis: CVector,\n    Ms: float,\n    thickness: float,\n    cellSurface: float,\n    demagTensor: list[CVector],\n    damping: float = 0.011,\n    SlonczewskiSpacerLayerParameter: float = 1.0,\n    beta: float = 0.0,\n    spinPolarisation: float = 0.0,\n) -&gt; Layer:\n    \"\"\"\n    Create STT layer -- with the standard Slomczewski formulation.\n    :param id: identifiable name for a layer -- e.g. \"bottom\" or \"free\".\n    :param mag: initial magnetisation. Must be normalised (norm of 1). Used for quicker convergence.\n    :param anis: anisotropy of the layer. A normalised vector\n    :param Ms: magnetisation saturation. Unit: Tesla [T].\n    :param thickness: thickness of the layer. Unit: meter [m].\n    :param cellSurface: surface of the layer, for volume calculation. Unit: meter^2 [m^2].\n    :param damping: often marked as alpha in the LLG equation. Damping of the layer. Default 0.011. Dimensionless.\n    :param SlonczewskiSpacerLayerParameter: Slomczewski parameter. Often marked as lambda.\n    :param beta: beta parameter that scales FL/DL ratio.\n    :param spinPolarisation: the spin effectiveness.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Layer.getId","title":"<code>getId()</code>","text":"<p>Get Id of the layer</p> Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def getId(self) -&gt; str:\n    \"\"\"Get Id of the layer\"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Layer.setAlphaNoise","title":"<code>setAlphaNoise(alpha, std, scale, axis=Axis.all)</code>","text":"<p>Set alpha noise for the layer.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Alpha parameter</p> required <code>std</code> <code>float</code> <p>Standard deviation</p> required <code>scale</code> <code>float</code> <p>Scale</p> required <code>axis</code> <code>Axis</code> <p>Axis, by default all axes are used</p> <code>Axis.all</code> Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def setAlphaNoise(self, alpha: float, std: float, scale: float, axis: Axis = Axis.all) -&gt; None:\n    \"\"\"Set alpha noise for the layer.\n    :param alpha: Alpha parameter\n    :param std: Standard deviation\n    :param scale: Scale\n    :param axis: Axis, by default all axes are used\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Layer.setAlternativeSTT","title":"<code>setAlternativeSTT(setAlternative)</code>","text":"<p>Switch to an alternative STT forumulation (Taniguchi et al.) https://iopscience.iop.org/article/10.7567/APEX.11.013005</p> <p>Parameters:</p> Name Type Description Default <code>setAlternative</code> <code>bool</code> <p>whether to set the alternative STT formulation</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def setAlternativeSTT(self, setAlternative: bool) -&gt; None:\n    \"\"\"Switch to an alternative STT forumulation (Taniguchi et al.)\n    https://iopscience.iop.org/article/10.7567/APEX.11.013005\n    :param setAlternative: whether to set the alternative STT formulation\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Layer.setAnisotropyDriver","title":"<code>setAnisotropyDriver(driver)</code>","text":"<p>Set anisotropy driver for the layer. It's scalar. The axis is determined in the layer constructor</p> Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def setAnisotropyDriver(self, driver: ScalarDriver) -&gt; None:\n    \"\"\"Set anisotropy driver for the layer.\n    It's scalar. The axis is determined in the layer constructor\"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Layer.setBottomDipoleTensor","title":"<code>setBottomDipoleTensor(tensor)</code>","text":"<p>Set a dipole tensor from the bottom layer.</p> <p>Parameters:</p> Name Type Description Default <code>tensor</code> <code>list[CVector]</code> <p>the dipole tensor to be set.</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def setBottomDipoleTensor(self, tensor: list[CVector]) -&gt; None:\n    \"\"\"Set a dipole tensor from the bottom layer.\n    :param tensor: the dipole tensor to be set.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Layer.setDampingLikeTorqueDriver","title":"<code>setDampingLikeTorqueDriver(driver)</code>","text":"<p>Set a driver for the damping like torque of the layer.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>ScalarDriver</code> <p>the driver to be set.</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def setDampingLikeTorqueDriver(self, driver: ScalarDriver) -&gt; None:\n    \"\"\"Set a driver for the damping like torque of the layer.\n    :param driver: the driver to be set.\"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Layer.setFieldLikeTorqueDriver","title":"<code>setFieldLikeTorqueDriver(driver)</code>","text":"<p>Set a driver for the field like torque of the layer.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>ScalarDriver</code> <p>the driver to be set.</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def setFieldLikeTorqueDriver(self, driver: ScalarDriver) -&gt; None:\n    \"\"\"Set a driver for the field like torque of the layer.\n    :param driver: the driver to be set.\"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Layer.setKappa","title":"<code>setKappa(kappa)</code>","text":"<p>Set the kappa parameter for the layer -- determines SOT mixing     Hdl * kappa + Hfl Allows you to turn off Hdl. Turning Hfl is via beta parameter.</p> <p>Parameters:</p> Name Type Description Default <code>kappa</code> <code>float</code> <p>the kappa parameter</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def setKappa(self, kappa: float) -&gt; None:\n    \"\"\"Set the kappa parameter for the layer -- determines SOT mixing\n        Hdl * kappa + Hfl\n    Allows you to turn off Hdl. Turning Hfl is via beta parameter.\n    :param kappa: the kappa parameter\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Layer.setMagnetisation","title":"<code>setMagnetisation(mag)</code>","text":"<p>Set the magnetisation of the layer.</p> <p>Parameters:</p> Name Type Description Default <code>mag</code> <code>CVector</code> <p>the magnetisation to be set.</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def setMagnetisation(self, mag: CVector) -&gt; None:\n    \"\"\"Set the magnetisation of the layer.\n    :param mag: the magnetisation to be set.\"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Layer.setOerstedFieldDriver","title":"<code>setOerstedFieldDriver(driver)</code>","text":"<p>Set an Oersted field driver for the layer.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>AxialDriver</code> <p>the field driver to be set.</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def setOerstedFieldDriver(self, driver: AxialDriver) -&gt; None:\n    \"\"\"Set an Oersted field driver for the layer.\n    :param driver: the field driver to be set.\"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Layer.setReferenceLayer","title":"<code>setReferenceLayer(ref)</code>","text":"<p>Set a reference layer for the STT.</p> <p>Parameters:</p> Name Type Description Default <code>ref</code> <code>CVector</code> <p>the reference layer vector.</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def setReferenceLayer(self, ref: CVector) -&gt; None:\n    \"\"\"Set a reference layer for the STT.\n    :param ref: the reference layer vector.\"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Layer.setTemperatureDriver","title":"<code>setTemperatureDriver(driver)</code>","text":"<p>Set a driver for the temperature of the layer. Automatically changes the solver to Euler-Heun.</p> Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def setTemperatureDriver(self, driver: ScalarDriver) -&gt; None:\n    \"\"\"Set a driver for the temperature of the layer.\n    Automatically changes the solver to Euler-Heun.\"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Layer.setTopDipoleTensor","title":"<code>setTopDipoleTensor(tensor)</code>","text":"<p>Set a dipole tensor from the top layer.</p> <p>Parameters:</p> Name Type Description Default <code>tensor</code> <code>list[CVector]</code> <p>the dipole tensor to be set.</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def setTopDipoleTensor(self, tensor: list[CVector]) -&gt; None:\n    \"\"\"Set a dipole tensor from the top layer.\n    :param tensor: the dipole tensor to be set.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.NullDriver","title":"<code>NullDriver</code>","text":"<p>         Bases: <code>ScalarDriver</code></p> Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>class NullDriver(ScalarDriver):\n    def __init__(self) -&gt; None:\n        \"\"\"\n        An empty driver that does nothing. Use in Axial Driver when\n        the axis is to be id.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/core/#cmtj.core.NullDriver.__init__","title":"<code>__init__()</code>","text":"<p>An empty driver that does nothing. Use in Axial Driver when the axis is to be id.</p> Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    An empty driver that does nothing. Use in Axial Driver when\n    the axis is to be id.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.Reference","title":"<code>Reference</code>","text":"<p>Reference layer indicator.</p> Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>class Reference:\n    \"\"\"Reference layer indicator.\"\"\"\n\n    bottom: ClassVar[Reference] = ...\n    fixed: ClassVar[Reference] = ...\n    none: ClassVar[Reference] = ...\n    top: ClassVar[Reference] = ...\n</code></pre>"},{"location":"api/core/#cmtj.core.ScalarDriver","title":"<code>ScalarDriver</code>","text":"Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>class ScalarDriver:\n    def __init__(self, *args, **kwargs) -&gt; None: ...\n    def getCurrentScalarValue(self, time: float) -&gt; float:\n        \"\"\"\n        :param time: time in seconds\n        :return: the scalar value of the driver at time.\n        \"\"\"\n        ...\n\n    @staticmethod\n    def getConstantDriver(constantValue: float) -&gt; ScalarDriver:\n        \"\"\"\n        Constant driver produces a constant signal of a fixed amplitude.\n        :param constantValue: constant value of the driver (constant offset/amplitude)\n        \"\"\"\n        ...\n\n    @staticmethod\n    def getPulseDriver(constantValue: float, amplitude: float, period: float, cycle: float) -&gt; ScalarDriver:\n        \"\"\"\n        Produces a square pulse of certain period and cycle\n        :param constantValue: offset (vertical) of the pulse. The pulse amplitude will be added to this.\n        :param amplitude: amplitude of the pulse signal\n        :param period: period of the signal in seconds\n        :param cycle: duty cycle of the signal -- a fraction between [0 and 1].\n        \"\"\"\n        ...\n\n    @staticmethod\n    def getSineDriver(constantValue: float, amplitude: ScalarDriver, frequency: float, phase: float) -&gt; Any:\n        \"\"\"\n        Produces a sinusoidal signal with some offset (constantValue), amplitude frequency and phase offset.\n        :param constantValue: vertical offset. The sine will oscillate around this value.\n        :param amplitude: amplitude of the sine wave\n        :param frequency: frequency of the sine\n        :param phase: phase of the sine in radians.\n        \"\"\"\n        ...\n\n    @staticmethod\n    def getStepDriver(constantValue: float, amplitude: float, timeStart: float, timeStop: float) -&gt; ScalarDriver:\n        \"\"\"\n        Get a step driver. It has amplitude between timeStart and timeStop and 0 elsewhere\n        :param constantValue: offset of the pulse (vertical)\n        :param amplitude: amplitude that is added on top of the constantValue\n        :param timeStart: start of the pulse\n        :param timeStop: when the pulse ends\n        \"\"\"\n        ...\n\n    @staticmethod\n    def getTrapezoidDriver(\n        constantValue: float,\n        amplitude: float,\n        timeStart,\n        edgeTime: float,\n        steadyTime: float,\n    ) -&gt; ScalarDriver:\n        \"\"\"Create Trapezoid driver. Has a rising and a falling edge.\n        :param constantValue: offset of the pulse (vertical)\n        :param amplitude: amplitude that is added on top of the constantValue\n        :param timeStart: start of the pulse\n        :param edgeTime: time it takes to reach the maximum amplitude\n        :param steadyTime: time it spends in a steady state\n        \"\"\"\n        ...\n\n    @staticmethod\n    def getGaussianImpulseDriver(constantValue: float, amplitude: float, t0: float, sigma: float) -&gt; ScalarDriver:\n        \"\"\"Gaussian impulse driver. It has amplitude starts at t0 and falls off with sigma.\n\n        Formula:\n        A * exp(-((t - t0) ** 2) / (2 * sigma ** 2))\n\n        :param constantValue: offset of the pulse (vertical)\n        :param amplitude: amplitude that is added on top of the constantValue\n        :param t0: start of the pulse\n        :param sigma: fall-off of the Gaussian pulse\n        \"\"\"\n        ...\n\n    @staticmethod\n    def getGaussianStepDriver(constantValue: float, amplitude: float, t0: float, sigma: float) -&gt; ScalarDriver:\n        \"\"\"Gaussian step driver (erf function). It has amplitude starts at t0 and falls off with sigma.\n\n        Formula:\n        f(t) = constantValue + amplitude * (1 + erf((t - t0) / (sigma * sqrt(2))))\n\n        :param constantValue: offset of the pulse (vertical)\n        :param amplitude: amplitude that is added on top of the constantValue\n        :param t0: start of the pulse\n        :param sigma: fall-off of the Gaussian pulse\n        \"\"\"\n        ...\n\n    @staticmethod\n    def getPosSineDriver(constantValue: float, amplitude: float, frequency: float, phase: float) -&gt; ScalarDriver:\n        \"\"\"Produces a positive sinusoidal signal with some offset (constantValue), amplitude frequency and phase offset.\n        :param constantValue: vertical offset. The sine will oscillate around this value.\n        :param amplitude: amplitude of the sine wave\n        :param frequency: frequency of the sine\n        :param phase: phase of the sine in radians.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/core/#cmtj.core.ScalarDriver.getConstantDriver","title":"<code>getConstantDriver(constantValue)</code>  <code>staticmethod</code>","text":"<p>Constant driver produces a constant signal of a fixed amplitude.</p> <p>Parameters:</p> Name Type Description Default <code>constantValue</code> <code>float</code> <p>constant value of the driver (constant offset/amplitude)</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>@staticmethod\ndef getConstantDriver(constantValue: float) -&gt; ScalarDriver:\n    \"\"\"\n    Constant driver produces a constant signal of a fixed amplitude.\n    :param constantValue: constant value of the driver (constant offset/amplitude)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.ScalarDriver.getCurrentScalarValue","title":"<code>getCurrentScalarValue(time)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>time in seconds</p> required <p>Returns:</p> Type Description <code>float</code> <p>the scalar value of the driver at time.</p> Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def getCurrentScalarValue(self, time: float) -&gt; float:\n    \"\"\"\n    :param time: time in seconds\n    :return: the scalar value of the driver at time.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.ScalarDriver.getGaussianImpulseDriver","title":"<code>getGaussianImpulseDriver(constantValue, amplitude, t0, sigma)</code>  <code>staticmethod</code>","text":"<p>Gaussian impulse driver. It has amplitude starts at t0 and falls off with sigma.</p> <p>Formula: A * exp(-((t - t0)  2) / (2 * sigma  2))</p> <p>Parameters:</p> Name Type Description Default <code>constantValue</code> <code>float</code> <p>offset of the pulse (vertical)</p> required <code>amplitude</code> <code>float</code> <p>amplitude that is added on top of the constantValue</p> required <code>t0</code> <code>float</code> <p>start of the pulse</p> required <code>sigma</code> <code>float</code> <p>fall-off of the Gaussian pulse</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>@staticmethod\ndef getGaussianImpulseDriver(constantValue: float, amplitude: float, t0: float, sigma: float) -&gt; ScalarDriver:\n    \"\"\"Gaussian impulse driver. It has amplitude starts at t0 and falls off with sigma.\n\n    Formula:\n    A * exp(-((t - t0) ** 2) / (2 * sigma ** 2))\n\n    :param constantValue: offset of the pulse (vertical)\n    :param amplitude: amplitude that is added on top of the constantValue\n    :param t0: start of the pulse\n    :param sigma: fall-off of the Gaussian pulse\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.ScalarDriver.getGaussianStepDriver","title":"<code>getGaussianStepDriver(constantValue, amplitude, t0, sigma)</code>  <code>staticmethod</code>","text":"<p>Gaussian step driver (erf function). It has amplitude starts at t0 and falls off with sigma.</p> <p>Formula: f(t) = constantValue + amplitude * (1 + erf((t - t0) / (sigma * sqrt(2))))</p> <p>Parameters:</p> Name Type Description Default <code>constantValue</code> <code>float</code> <p>offset of the pulse (vertical)</p> required <code>amplitude</code> <code>float</code> <p>amplitude that is added on top of the constantValue</p> required <code>t0</code> <code>float</code> <p>start of the pulse</p> required <code>sigma</code> <code>float</code> <p>fall-off of the Gaussian pulse</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>@staticmethod\ndef getGaussianStepDriver(constantValue: float, amplitude: float, t0: float, sigma: float) -&gt; ScalarDriver:\n    \"\"\"Gaussian step driver (erf function). It has amplitude starts at t0 and falls off with sigma.\n\n    Formula:\n    f(t) = constantValue + amplitude * (1 + erf((t - t0) / (sigma * sqrt(2))))\n\n    :param constantValue: offset of the pulse (vertical)\n    :param amplitude: amplitude that is added on top of the constantValue\n    :param t0: start of the pulse\n    :param sigma: fall-off of the Gaussian pulse\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.ScalarDriver.getPosSineDriver","title":"<code>getPosSineDriver(constantValue, amplitude, frequency, phase)</code>  <code>staticmethod</code>","text":"<p>Produces a positive sinusoidal signal with some offset (constantValue), amplitude frequency and phase offset.</p> <p>Parameters:</p> Name Type Description Default <code>constantValue</code> <code>float</code> <p>vertical offset. The sine will oscillate around this value.</p> required <code>amplitude</code> <code>float</code> <p>amplitude of the sine wave</p> required <code>frequency</code> <code>float</code> <p>frequency of the sine</p> required <code>phase</code> <code>float</code> <p>phase of the sine in radians.</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>@staticmethod\ndef getPosSineDriver(constantValue: float, amplitude: float, frequency: float, phase: float) -&gt; ScalarDriver:\n    \"\"\"Produces a positive sinusoidal signal with some offset (constantValue), amplitude frequency and phase offset.\n    :param constantValue: vertical offset. The sine will oscillate around this value.\n    :param amplitude: amplitude of the sine wave\n    :param frequency: frequency of the sine\n    :param phase: phase of the sine in radians.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.ScalarDriver.getPulseDriver","title":"<code>getPulseDriver(constantValue, amplitude, period, cycle)</code>  <code>staticmethod</code>","text":"<p>Produces a square pulse of certain period and cycle</p> <p>Parameters:</p> Name Type Description Default <code>constantValue</code> <code>float</code> <p>offset (vertical) of the pulse. The pulse amplitude will be added to this.</p> required <code>amplitude</code> <code>float</code> <p>amplitude of the pulse signal</p> required <code>period</code> <code>float</code> <p>period of the signal in seconds</p> required <code>cycle</code> <code>float</code> <p>duty cycle of the signal -- a fraction between [0 and 1].</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>@staticmethod\ndef getPulseDriver(constantValue: float, amplitude: float, period: float, cycle: float) -&gt; ScalarDriver:\n    \"\"\"\n    Produces a square pulse of certain period and cycle\n    :param constantValue: offset (vertical) of the pulse. The pulse amplitude will be added to this.\n    :param amplitude: amplitude of the pulse signal\n    :param period: period of the signal in seconds\n    :param cycle: duty cycle of the signal -- a fraction between [0 and 1].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.ScalarDriver.getSineDriver","title":"<code>getSineDriver(constantValue, amplitude, frequency, phase)</code>  <code>staticmethod</code>","text":"<p>Produces a sinusoidal signal with some offset (constantValue), amplitude frequency and phase offset.</p> <p>Parameters:</p> Name Type Description Default <code>constantValue</code> <code>float</code> <p>vertical offset. The sine will oscillate around this value.</p> required <code>amplitude</code> <code>ScalarDriver</code> <p>amplitude of the sine wave</p> required <code>frequency</code> <code>float</code> <p>frequency of the sine</p> required <code>phase</code> <code>float</code> <p>phase of the sine in radians.</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>@staticmethod\ndef getSineDriver(constantValue: float, amplitude: ScalarDriver, frequency: float, phase: float) -&gt; Any:\n    \"\"\"\n    Produces a sinusoidal signal with some offset (constantValue), amplitude frequency and phase offset.\n    :param constantValue: vertical offset. The sine will oscillate around this value.\n    :param amplitude: amplitude of the sine wave\n    :param frequency: frequency of the sine\n    :param phase: phase of the sine in radians.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.ScalarDriver.getStepDriver","title":"<code>getStepDriver(constantValue, amplitude, timeStart, timeStop)</code>  <code>staticmethod</code>","text":"<p>Get a step driver. It has amplitude between timeStart and timeStop and 0 elsewhere</p> <p>Parameters:</p> Name Type Description Default <code>constantValue</code> <code>float</code> <p>offset of the pulse (vertical)</p> required <code>amplitude</code> <code>float</code> <p>amplitude that is added on top of the constantValue</p> required <code>timeStart</code> <code>float</code> <p>start of the pulse</p> required <code>timeStop</code> <code>float</code> <p>when the pulse ends</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>@staticmethod\ndef getStepDriver(constantValue: float, amplitude: float, timeStart: float, timeStop: float) -&gt; ScalarDriver:\n    \"\"\"\n    Get a step driver. It has amplitude between timeStart and timeStop and 0 elsewhere\n    :param constantValue: offset of the pulse (vertical)\n    :param amplitude: amplitude that is added on top of the constantValue\n    :param timeStart: start of the pulse\n    :param timeStop: when the pulse ends\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.ScalarDriver.getTrapezoidDriver","title":"<code>getTrapezoidDriver(constantValue, amplitude, timeStart, edgeTime, steadyTime)</code>  <code>staticmethod</code>","text":"<p>Create Trapezoid driver. Has a rising and a falling edge.</p> <p>Parameters:</p> Name Type Description Default <code>constantValue</code> <code>float</code> <p>offset of the pulse (vertical)</p> required <code>amplitude</code> <code>float</code> <p>amplitude that is added on top of the constantValue</p> required <code>timeStart</code> <p>start of the pulse</p> required <code>edgeTime</code> <code>float</code> <p>time it takes to reach the maximum amplitude</p> required <code>steadyTime</code> <code>float</code> <p>time it spends in a steady state</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>@staticmethod\ndef getTrapezoidDriver(\n    constantValue: float,\n    amplitude: float,\n    timeStart,\n    edgeTime: float,\n    steadyTime: float,\n) -&gt; ScalarDriver:\n    \"\"\"Create Trapezoid driver. Has a rising and a falling edge.\n    :param constantValue: offset of the pulse (vertical)\n    :param amplitude: amplitude that is added on top of the constantValue\n    :param timeStart: start of the pulse\n    :param edgeTime: time it takes to reach the maximum amplitude\n    :param steadyTime: time it spends in a steady state\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.SolverMode","title":"<code>SolverMode</code>","text":"<p>SolverMode Indicator</p> Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>class SolverMode:\n    \"\"\"SolverMode Indicator\"\"\"\n\n    DormandPrice: ClassVar[SolverMode] = ...\n    EulerHeun: ClassVar[SolverMode] = ...\n    RK4: ClassVar[SolverMode] = ...\n    Heun: ClassVar[SolverMode] = ...\n</code></pre>"},{"location":"api/core/#cmtj.core.c_dot","title":"<code>c_dot(arg0, arg1)</code>","text":"<p>Compute dot (scalar) product of two CVectors.</p> Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def c_dot(arg0: CVector, arg1: CVector) -&gt; float:\n    \"\"\"Compute dot (scalar) product of two CVectors.\"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.constantDriver","title":"<code>constantDriver(constant)</code>","text":"<p>Constant driver produces a constant signal of a fixed amplitude.</p> <p>Parameters:</p> Name Type Description Default <code>constant</code> <code>float</code> <p>constant value of the driver (constant offset/amplitude)</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def constantDriver(constant: float) -&gt; ScalarDriver:\n    \"\"\"\n    Constant driver produces a constant signal of a fixed amplitude.\n    :param constant: constant value of the driver (constant offset/amplitude)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.gaussianImpulseDriver","title":"<code>gaussianImpulseDriver(constantValue, amplitude, t0, sigma)</code>","text":"<p>Gaussian impulse driver. It starts with an max amplitude at t0 and falls off with sigma.</p> <p>Formula:</p> <p>\\(A \\exp(-(t - t_0)^2 / (2\\sigma^2))\\)</p> <p>Parameters:</p> Name Type Description Default <code>constantValue</code> <code>float</code> <p>offset of the pulse (vertical)</p> required <code>amplitude</code> <code>float</code> <p>amplitude that is added on top of the constantValue</p> required <code>t0</code> <code>float</code> <p>start of the pulse</p> required <code>sigma</code> <code>float</code> <p>fall-off of the Gaussian pulse</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def gaussianImpulseDriver(constantValue: float, amplitude: float, t0: float, sigma: float) -&gt; ScalarDriver:\n    \"\"\"\n    Gaussian impulse driver. It starts with an max amplitude at t0 and falls off with sigma.\n\n    Formula:\n\n    $A \\exp(-(t - t_0)^2 / (2\\sigma^2))$\n\n    :param constantValue: offset of the pulse (vertical)\n    :param amplitude: amplitude that is added on top of the constantValue\n    :param t0: start of the pulse\n    :param sigma: fall-off of the Gaussian pulse\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.gaussianStepDriver","title":"<code>gaussianStepDriver(constantValue, amplitude, t0, sigma)</code>","text":"<p>Gaussian step driver (erf function). It starts at t0 and falls off with sigma.</p> <p>Formula:</p> <p>\\(f(t) = c + A + A\\mathrm{erf}((t - t_0) / (\\sigma \\sqrt(2)))\\)</p> <p>Parameters:</p> Name Type Description Default <code>constantValue</code> <code>float</code> <p>offset of the pulse (vertical)</p> required <code>amplitude</code> <code>float</code> <p>amplitude that is added on top of the constantValue</p> required <code>t0</code> <code>float</code> <p>start of the pulse</p> required <code>sigma</code> <code>float</code> <p>fall-off of the Gaussian pulse</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def gaussianStepDriver(constantValue: float, amplitude: float, t0: float, sigma: float) -&gt; ScalarDriver:\n    \"\"\"Gaussian step driver (erf function). It starts at t0 and falls off with sigma.\n\n    Formula:\n\n    $f(t) = c + A + A\\mathrm{erf}((t - t_0) / (\\sigma \\sqrt(2)))$\n\n    :param constantValue: offset of the pulse (vertical)\n    :param amplitude: amplitude that is added on top of the constantValue\n    :param t0: start of the pulse\n    :param sigma: fall-off of the Gaussian pulse\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.posSineDriver","title":"<code>posSineDriver(constantValue, amplitude, frequency, phase)</code>","text":"<p>Produces a positive sinusoidal signal with some offset (constantValue), amplitude frequency and phase offset.</p> <p>Parameters:</p> Name Type Description Default <code>constantValue</code> <code>float</code> <p>vertical offset. The sine will oscillate around this value.</p> required <code>amplitude</code> <code>float</code> <p>amplitude of the sine wave</p> required <code>frequency</code> <code>float</code> <p>frequency of the sine</p> required <code>phase</code> <code>float</code> <p>phase of the sine in radians.</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def posSineDriver(constantValue: float, amplitude: float, frequency: float, phase: float) -&gt; ScalarDriver:\n    \"\"\"Produces a positive sinusoidal signal with some offset (constantValue), amplitude frequency and phase offset.\n    :param constantValue: vertical offset. The sine will oscillate around this value.\n    :param amplitude: amplitude of the sine wave\n    :param frequency: frequency of the sine\n    :param phase: phase of the sine in radians.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.pulseDriver","title":"<code>pulseDriver(constantValue, amplitude, period, cycle)</code>","text":"<p>Produces a square pulse of certain period and cycle</p> <p>Parameters:</p> Name Type Description Default <code>constantValue</code> <code>float</code> <p>offset (vertical) of the pulse. The pulse amplitude will be added to this.</p> required <code>amplitude</code> <code>float</code> <p>amplitude of the pulse signal</p> required <code>period</code> <code>float</code> <p>period of the signal in seconds</p> required <code>cycle</code> <code>float</code> <p>duty cycle of the signal -- a fraction between [0 and 1].</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def pulseDriver(constantValue: float, amplitude: float, period: float, cycle: float) -&gt; ScalarDriver:\n    \"\"\"\n    Produces a square pulse of certain period and cycle\n    :param constantValue: offset (vertical) of the pulse. The pulse amplitude will be added to this.\n    :param amplitude: amplitude of the pulse signal\n    :param period: period of the signal in seconds\n    :param cycle: duty cycle of the signal -- a fraction between [0 and 1].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.sineDriver","title":"<code>sineDriver(constantValue, amplitude, frequency, phase)</code>","text":"<p>Produces a sinusoidal signal with some offset (constantValue), amplitude frequency and phase offset.</p> <p>Parameters:</p> Name Type Description Default <code>constantValue</code> <code>float</code> <p>vertical offset. The sine will oscillate around this value.</p> required <code>amplitude</code> <code>float</code> <p>amplitude of the sine wave</p> required <code>frequency</code> <code>float</code> <p>frequency of the sine</p> required <code>phase</code> <code>float</code> <p>phase of the sine in radians.</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def sineDriver(constantValue: float, amplitude: float, frequency: float, phase: float) -&gt; ScalarDriver:\n    \"\"\"\n    Produces a sinusoidal signal with some offset (constantValue), amplitude frequency and phase offset.\n    :param constantValue: vertical offset. The sine will oscillate around this value.\n    :param amplitude: amplitude of the sine wave\n    :param frequency: frequency of the sine\n    :param phase: phase of the sine in radians.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.stepDriver","title":"<code>stepDriver(constantValue, amplitude, timeStart, timeStop)</code>","text":"<p>Get a step driver. It has amplitude between timeStart and timeStop and 0 elsewhere</p> <p>Parameters:</p> Name Type Description Default <code>constantValue</code> <code>float</code> <p>offset of the pulse (vertical)</p> required <code>amplitude</code> <code>float</code> <p>amplitude that is added on top of the constantValue</p> required <code>timeStart</code> <code>float</code> <p>start of the pulse</p> required <code>timeStop</code> <code>float</code> <p>when the pulse ends</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def stepDriver(constantValue: float, amplitude: float, timeStart: float, timeStop: float) -&gt; ScalarDriver:\n    \"\"\"\n    Get a step driver. It has amplitude between timeStart and timeStop and 0 elsewhere\n    :param constantValue: offset of the pulse (vertical)\n    :param amplitude: amplitude that is added on top of the constantValue\n    :param timeStart: start of the pulse\n    :param timeStop: when the pulse ends\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#cmtj.core.trapezoidDriver","title":"<code>trapezoidDriver(constantValue, amplitude, timeStart, edgeTime, steadyTime)</code>","text":"<p>Create Trapezoid driver. Has a rising and a falling edge.</p> <p>Parameters:</p> Name Type Description Default <code>constantValue</code> <code>float</code> <p>offset of the pulse (vertical)</p> required <code>amplitude</code> <code>float</code> <p>amplitude that is added on top of the constantValue</p> required <code>timeStart</code> <p>start of the pulse</p> required <code>edgeTime</code> <code>float</code> <p>time it takes to reach the maximum amplitude</p> required <code>steadyTime</code> <code>float</code> <p>time it spends in a steady state</p> required Source code in <code>cmtj/core/__init__.pyi</code> <pre><code>def trapezoidDriver(\n    constantValue: float,\n    amplitude: float,\n    timeStart,\n    edgeTime: float,\n    steadyTime: float,\n) -&gt; ScalarDriver:\n    \"\"\"Create Trapezoid driver. Has a rising and a falling edge.\n    :param constantValue: offset of the pulse (vertical)\n    :param amplitude: amplitude that is added on top of the constantValue\n    :param timeStart: start of the pulse\n    :param edgeTime: time it takes to reach the maximum amplitude\n    :param steadyTime: time it spends in a steady state\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/drivers/","title":"Drivers API","text":"<p>The drivers API allows you to freely control the excitation types in <code>cmtj</code> library. There are two types of drivers:</p> <ul> <li><code>ScalarDriver</code> -- is a function over time that returns a scalar value.</li> <li><code>AxialDriver</code> -- is a driver that returns a 3-vector value. It is a composition of three scalar drivers, one for each component of the vector.</li> </ul> <p>The library provides a few built-in drivers that can be used to define the scalar values. The built-in <code>ScalarDrivers</code> drivers that can also be easily used to define the <code>AxialDrivers</code>. The built-in drivers are:</p> <ul> <li><code>constantDriver</code>: A driver that returns a constant value at each time step.</li> <li><code>sineDriver</code>: A driver that returns a sinusoidal value at each time step.</li> <li><code>gaussianImpulseDriver</code>: A driver that returns a Gaussian impulse at a given time.</li> <li><code>posSineDriver</code>: A driver that returns a positive sinusoidal value at each time step.</li> <li><code>pulseDriver</code>: A driver that returns a pulse at a given time.</li> <li><code>stepDriver</code>: A driver that returns a step function at a given time.</li> <li><code>trapezoidDriver</code>: A driver that returns a trapezoidal function at a given time.</li> <li><code>NullDriver</code>: A driver that returns zero at each time step (no-op driver)</li> </ul> <p>For more details on the driver parameters see the binding file here or the documentation.</p>"},{"location":"api/drivers/#how-to-define-your-own-drivers","title":"How to define your own drivers?","text":"<p>You can define your own drivers by inheriting from the <code>ScalarDriver</code> class. This class has a single method <code>getCurrentScalarValue</code> which you need to implement. This method should return the scalar value of the driver at the given time. The time is given in seconds. The driver can be used in the same way as the built-in drivers. Here is an example of a driver that returns a random value at each time step:</p> <pre><code>from cmtj import (\n    ScalarDriver,\n    Layer,\n    Junction,\n    CVector,\n    constantDriver,\n    AxialDriver,\n    NullDriver,\n)\nimport numpy as np\n\n\ndef my_custom_function(time: float) -&gt; float:\n    return time * np.random.choice([-1, 1])\n\n# Create a driver with this function\ndriver = ScalarDriver.getCustomDriver(my_custom_function)\n\ndemag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)]\nlayer = Layer(\n    \"free\",\n    mag=CVector(0.1, 0.1, 0.9),\n    anis=CVector(0.0, 0.0, 1.0),\n    Ms=1.0,\n    thickness=3e-9,\n    cellSurface=0,\n    demagTensor=demag,\n    damping=3e-3,\n)\nlayer.setReferenceLayer(CVector(0, 0, 1))\njunction = Junction([layer], 100, 200)\njunction.setLayerExternalFieldDriver(\n    \"all\", AxialDriver(driver, NullDriver(), NullDriver())\n)\njunction.setLayerAnisotropyDriver(\"all\", constantDriver(150e3))\njunction.runSimulation(30e-9, 1e-13, 1e-13)\n</code></pre> <p>After you've defined the driver these work just like any other driver.</p>"},{"location":"api/energy-reference/","title":"Energy","text":""},{"location":"api/energy-reference/#cmtj.utils.energy.EnergyCompute","title":"<code>EnergyCompute</code>","text":"<p>Energy density in [J/m^3] computing functions</p> Source code in <code>cmtj/utils/energy.py</code> <pre><code>class EnergyCompute:\n    \"\"\"Energy density in [J/m^3] computing functions\"\"\"\n\n    def __init__(self, cell_surface: float, thickness: float, log: dict[str, list[float]]) -&gt; None:\n        \"\"\"Initialise energy computation class\n        :param cell_surface: surface of the cell in [m^2]\n        :param thickness: thickness of the cell in [m]\n        :param log: log of the simulation (directly from .getLog())\"\"\"\n        self.cell_surface = cell_surface\n        self.thickness = thickness\n        self.cell_volumne = self.cell_surface * thickness\n        self.log = log\n\n    def compute_from_log(self) -&gt; dict[str, list[float]]:\n        \"\"\"\n        Computes a log of energies over time and returns it\n        in the same form of the\n        \"\"\"\n        field_keys = list({k[:-1] for k in self.log if \"_H\" in k})\n        mag_k = (k.replace(\"_mx\", \"\") for k in self.log if \"_mx\" in k)\n        mag_vectors = {k: np.asarray([self.log[f\"{k}_mx\"], self.log[f\"{k}_my\"], self.log[f\"{k}_mz\"]]) for k in mag_k}\n        energy_data = {}\n        for field_key in field_keys:\n            if \"J_\" in field_key:\n                eng_fn = self.calculate_energy_from_field_interfacial\n            else:\n                eng_fn = self.calculate_energy_from_field\n\n            m_key = field_key.split(\"_\")[0]  # get m key\n            m = mag_vectors[m_key]\n            field_series = np.asarray(\n                [\n                    self.log[f\"{field_key}x\"],\n                    self.log[f\"{field_key}y\"],\n                    self.log[f\"{field_key}z\"],\n                ]\n            )\n            energy_data[f\"energy_{field_key}\"] = eng_fn(m, field_series)\n\n        return energy_data\n\n    def calculate_energy_from_field(self, m: np.ndarray, field_vector: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        :param m: magnetisation\n        :param field_vector: magnetic field vector (can be external, Oersted etc.)\n        Compute generic energy density\n        E = H * (mi0 Ms/V)\n        where mi0 Ms is in [T], Ms in [A/m], H in [A/m]\n        \"\"\"\n        return -np.sum(m * field_vector, axis=0) / self.cell_volumne\n\n    def calculate_energy_from_field_interfacial(self, m: np.ndarray, field_vector: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        :param m: magnetisation\n        :param field_vector: magnetic field vector (can be IEC etc.)\n        Compute generic energy density\n        E = H * (mi0 Ms/A)\n        where mi0 Ms is in [T], Ms in [A/m], H in [A/m]\n        \"\"\"\n        return -np.sum(m * field_vector, axis=0) / self.cell_surface\n</code></pre>"},{"location":"api/energy-reference/#cmtj.utils.energy.EnergyCompute.__init__","title":"<code>__init__(cell_surface, thickness, log)</code>","text":"<p>Initialise energy computation class</p> <p>Parameters:</p> Name Type Description Default <code>cell_surface</code> <code>float</code> <p>surface of the cell in [m^2]</p> required <code>thickness</code> <code>float</code> <p>thickness of the cell in [m]</p> required <code>log</code> <code>dict[str, list[float]]</code> <p>log of the simulation (directly from .getLog())</p> required Source code in <code>cmtj/utils/energy.py</code> <pre><code>def __init__(self, cell_surface: float, thickness: float, log: dict[str, list[float]]) -&gt; None:\n    \"\"\"Initialise energy computation class\n    :param cell_surface: surface of the cell in [m^2]\n    :param thickness: thickness of the cell in [m]\n    :param log: log of the simulation (directly from .getLog())\"\"\"\n    self.cell_surface = cell_surface\n    self.thickness = thickness\n    self.cell_volumne = self.cell_surface * thickness\n    self.log = log\n</code></pre>"},{"location":"api/energy-reference/#cmtj.utils.energy.EnergyCompute.calculate_energy_from_field","title":"<code>calculate_energy_from_field(m, field_vector)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>m</code> <code>np.ndarray</code> <p>magnetisation</p> required <code>field_vector</code> <code>np.ndarray</code> <p>magnetic field vector (can be external, Oersted etc.) Compute generic energy density E = H * (mi0 Ms/V) where mi0 Ms is in [T], Ms in [A/m], H in [A/m]</p> required Source code in <code>cmtj/utils/energy.py</code> <pre><code>def calculate_energy_from_field(self, m: np.ndarray, field_vector: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    :param m: magnetisation\n    :param field_vector: magnetic field vector (can be external, Oersted etc.)\n    Compute generic energy density\n    E = H * (mi0 Ms/V)\n    where mi0 Ms is in [T], Ms in [A/m], H in [A/m]\n    \"\"\"\n    return -np.sum(m * field_vector, axis=0) / self.cell_volumne\n</code></pre>"},{"location":"api/energy-reference/#cmtj.utils.energy.EnergyCompute.calculate_energy_from_field_interfacial","title":"<code>calculate_energy_from_field_interfacial(m, field_vector)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>m</code> <code>np.ndarray</code> <p>magnetisation</p> required <code>field_vector</code> <code>np.ndarray</code> <p>magnetic field vector (can be IEC etc.) Compute generic energy density E = H * (mi0 Ms/A) where mi0 Ms is in [T], Ms in [A/m], H in [A/m]</p> required Source code in <code>cmtj/utils/energy.py</code> <pre><code>def calculate_energy_from_field_interfacial(self, m: np.ndarray, field_vector: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    :param m: magnetisation\n    :param field_vector: magnetic field vector (can be IEC etc.)\n    Compute generic energy density\n    E = H * (mi0 Ms/A)\n    where mi0 Ms is in [T], Ms in [A/m], H in [A/m]\n    \"\"\"\n    return -np.sum(m * field_vector, axis=0) / self.cell_surface\n</code></pre>"},{"location":"api/energy-reference/#cmtj.utils.energy.EnergyCompute.compute_from_log","title":"<code>compute_from_log()</code>","text":"<p>Computes a log of energies over time and returns it in the same form of the</p> Source code in <code>cmtj/utils/energy.py</code> <pre><code>def compute_from_log(self) -&gt; dict[str, list[float]]:\n    \"\"\"\n    Computes a log of energies over time and returns it\n    in the same form of the\n    \"\"\"\n    field_keys = list({k[:-1] for k in self.log if \"_H\" in k})\n    mag_k = (k.replace(\"_mx\", \"\") for k in self.log if \"_mx\" in k)\n    mag_vectors = {k: np.asarray([self.log[f\"{k}_mx\"], self.log[f\"{k}_my\"], self.log[f\"{k}_mz\"]]) for k in mag_k}\n    energy_data = {}\n    for field_key in field_keys:\n        if \"J_\" in field_key:\n            eng_fn = self.calculate_energy_from_field_interfacial\n        else:\n            eng_fn = self.calculate_energy_from_field\n\n        m_key = field_key.split(\"_\")[0]  # get m key\n        m = mag_vectors[m_key]\n        field_series = np.asarray(\n            [\n                self.log[f\"{field_key}x\"],\n                self.log[f\"{field_key}y\"],\n                self.log[f\"{field_key}z\"],\n            ]\n        )\n        energy_data[f\"energy_{field_key}\"] = eng_fn(m, field_series)\n\n    return energy_data\n</code></pre>"},{"location":"api/ensemble-reference/","title":"Ensemble functions","text":"<p>This module contains functions for computing simple fits and models.</p>"},{"location":"api/ensemble-reference/#cmtj.models.ensemble.antisymmetric_lorentz","title":"<code>antisymmetric_lorentz(H, dH, Hr, Vas)</code>","text":"<p>Antisymmetric Lorentzian function.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <p>applied field in A/m</p> required <code>dH</code> <p>half width at half maximum in A/m</p> required <code>Hr</code> <p>resonance field in A/m</p> required Source code in <code>cmtj/models/ensemble.py</code> <pre><code>def antisymmetric_lorentz(H, dH, Hr, Vas):\n    \"\"\"\n    Antisymmetric Lorentzian function.\n    :param H: applied field in A/m\n    :param dH: half width at half maximum in A/m\n    :param Hr: resonance field in A/m\n    \"\"\"\n    dH2 = dH**2\n    dHr = H - Hr\n    return Vas * dH * dHr / (np.power(dHr, 2) + dH2)\n</code></pre>"},{"location":"api/ensemble-reference/#cmtj.models.ensemble.meinert_model","title":"<code>meinert_model(phi, V1, V2, phase_offset, offset)</code>","text":"<p>Fits to Meinert model.</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <p>angle in degrees, given parameter</p> required <code>V1</code> <p>(Hfl/Hext), fitting parameter</p> required <code>V2</code> <p>(Va*Hdl/Heff), fitting parameter</p> required <code>phase_offset</code> <p>phase offset in degrees, fitting parameter</p> required <code>offset</code> <p>offset in V, fitting parameter V2omega = (Acos(2(phi - phase_offset)) - B)*cos(phi - phase_offset) + offset</p> required Source code in <code>cmtj/models/ensemble.py</code> <pre><code>def meinert_model(phi, V1, V2, phase_offset, offset):\n    \"\"\"\n    Fits to Meinert model.\n    :param phi: angle in degrees, given parameter\n    :param V1: (Hfl/Hext), fitting parameter\n    :param V2: (Va*Hdl/Heff), fitting parameter\n    :param phase_offset: phase offset in degrees, fitting parameter\n    :param offset: offset in V, fitting parameter\n    V2omega = (Acos(2(phi - phase_offset)) - B)*cos(phi - phase_offset) + offset\n    \"\"\"\n    deg_rad = np.deg2rad(phi - phase_offset)\n    return (V1 * np.cos(2 * (deg_rad)) - V2) * np.cos(deg_rad) + offset\n</code></pre>"},{"location":"api/ensemble-reference/#cmtj.models.ensemble.mixed_lorentz","title":"<code>mixed_lorentz(H, dH, Hr, Va, Vas)</code>","text":"<p>Mixed Lorentzian function.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <p>applied field in A/m</p> required <code>dH</code> <p>half width at half maximum in A/m</p> required <code>Hr</code> <p>resonance field in A/m</p> required <code>Va</code> <p>amplitude of symmetric Lorentzian</p> required <code>Vas</code> <p>amplitude of antisymmetric Lorentzian</p> required Source code in <code>cmtj/models/ensemble.py</code> <pre><code>def mixed_lorentz(H, dH, Hr, Va, Vas):\n    \"\"\"\n    Mixed Lorentzian function.\n    :param H: applied field in A/m\n    :param dH: half width at half maximum in A/m\n    :param Hr: resonance field in A/m\n    :param Va: amplitude of symmetric Lorentzian\n    :param Vas: amplitude of antisymmetric Lorentzian\n    \"\"\"\n    return symmetric_lorentz(H, dH, Hr, Va) + antisymmetric_lorentz(H, dH, Hr, Vas)\n</code></pre>"},{"location":"api/ensemble-reference/#cmtj.models.ensemble.symmetric_lorentz","title":"<code>symmetric_lorentz(H, dH, Hr, Vs)</code>","text":"<p>Symmetric Lorentzian function.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <p>applied field in A/m</p> required <code>dH</code> <p>half width at half maximum in A/m</p> required <code>Hr</code> <p>resonance field in A/m</p> required Source code in <code>cmtj/models/ensemble.py</code> <pre><code>def symmetric_lorentz(H, dH, Hr, Vs):\n    \"\"\"\n    Symmetric Lorentzian function.\n    :param H: applied field in A/m\n    :param dH: half width at half maximum in A/m\n    :param Hr: resonance field in A/m\n    \"\"\"\n    dH2 = dH**2\n    return Vs * dH2 / ((H - Hr) ** 2 + dH2)\n</code></pre>"},{"location":"api/filters-reference/","title":"Filters","text":""},{"location":"api/filters-reference/#cmtj.utils.filters.Filters","title":"<code>Filters</code>","text":"Source code in <code>cmtj/utils/filters.py</code> <pre><code>class Filters:\n    @staticmethod\n    def butter_bandpass_filter(data: np.ndarray, pass_freq: tuple[float, float], fs: float, order: int = 5):\n        \"\"\"Basic bandpass (notch) butterworth filter.\n        :param data: input data.\n        :param pass_freq: the tuple of (low, high) band frequencies.\n        :param fs: sampling frequency.\n        \"\"\"\n        # Nyquist is half of the sampling freq\n        nyq = 0.5 * fs\n        if isinstance(pass_freq, float):\n            if pass_freq == 0:\n                pass_freq = 0.1\n                try:\n                    b, a = butter(\n                        order,\n                        [0.9 * pass_freq / nyq, pass_freq / nyq],\n                        btype=\"bandpass\",\n                        analog=False,\n                    )\n                except ValueError as e:\n                    print(fs, pass_freq, nyq, 0.9 * pass_freq / nyq, pass_freq / nyq)\n                    raise ValueError(\"Error in filtering\") from e\n        elif isinstance(pass_freq, tuple):\n            b, a = butter(order, [pass_freq[0], pass_freq[1]], btype=\"bandpass\", analog=False)\n        return lfilter(b, a, data, zi=None)\n\n    @staticmethod\n    def butter_lowpass_filter(data: np.ndarray, cutoff: float, fs: float, order: int = 5):\n        \"\"\"Low pass digital filter.\n        :param data: data to be filtered.\n        :param cutoff: cutoff frequency of the filter.\n        :param fs: sampling frequency.\n        :param order: order of the filter.\n        \"\"\"\n        nyq = 0.5 * fs\n        normal_cutoff = cutoff / nyq\n        b, a = butter(order, normal_cutoff, btype=\"low\", analog=False)\n        return lfilter(b, a, data, zi=None)\n\n    @staticmethod\n    def detrend_axis(arr, axis):\n        \"\"\"Detrend axis for better spectrum visibility.\n        :param arr: input array (spectrum)\n        :param axis: axis along which to detrend\n        \"\"\"\n        medians = np.median(arr, axis=axis)\n        return (arr.T - medians).T if axis else arr - medians\n</code></pre>"},{"location":"api/filters-reference/#cmtj.utils.filters.Filters.butter_bandpass_filter","title":"<code>butter_bandpass_filter(data, pass_freq, fs, order=5)</code>  <code>staticmethod</code>","text":"<p>Basic bandpass (notch) butterworth filter.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>np.ndarray</code> <p>input data.</p> required <code>pass_freq</code> <code>tuple[float, float]</code> <p>the tuple of (low, high) band frequencies.</p> required <code>fs</code> <code>float</code> <p>sampling frequency.</p> required Source code in <code>cmtj/utils/filters.py</code> <pre><code>@staticmethod\ndef butter_bandpass_filter(data: np.ndarray, pass_freq: tuple[float, float], fs: float, order: int = 5):\n    \"\"\"Basic bandpass (notch) butterworth filter.\n    :param data: input data.\n    :param pass_freq: the tuple of (low, high) band frequencies.\n    :param fs: sampling frequency.\n    \"\"\"\n    # Nyquist is half of the sampling freq\n    nyq = 0.5 * fs\n    if isinstance(pass_freq, float):\n        if pass_freq == 0:\n            pass_freq = 0.1\n            try:\n                b, a = butter(\n                    order,\n                    [0.9 * pass_freq / nyq, pass_freq / nyq],\n                    btype=\"bandpass\",\n                    analog=False,\n                )\n            except ValueError as e:\n                print(fs, pass_freq, nyq, 0.9 * pass_freq / nyq, pass_freq / nyq)\n                raise ValueError(\"Error in filtering\") from e\n    elif isinstance(pass_freq, tuple):\n        b, a = butter(order, [pass_freq[0], pass_freq[1]], btype=\"bandpass\", analog=False)\n    return lfilter(b, a, data, zi=None)\n</code></pre>"},{"location":"api/filters-reference/#cmtj.utils.filters.Filters.butter_lowpass_filter","title":"<code>butter_lowpass_filter(data, cutoff, fs, order=5)</code>  <code>staticmethod</code>","text":"<p>Low pass digital filter.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>np.ndarray</code> <p>data to be filtered.</p> required <code>cutoff</code> <code>float</code> <p>cutoff frequency of the filter.</p> required <code>fs</code> <code>float</code> <p>sampling frequency.</p> required <code>order</code> <code>int</code> <p>order of the filter.</p> <code>5</code> Source code in <code>cmtj/utils/filters.py</code> <pre><code>@staticmethod\ndef butter_lowpass_filter(data: np.ndarray, cutoff: float, fs: float, order: int = 5):\n    \"\"\"Low pass digital filter.\n    :param data: data to be filtered.\n    :param cutoff: cutoff frequency of the filter.\n    :param fs: sampling frequency.\n    :param order: order of the filter.\n    \"\"\"\n    nyq = 0.5 * fs\n    normal_cutoff = cutoff / nyq\n    b, a = butter(order, normal_cutoff, btype=\"low\", analog=False)\n    return lfilter(b, a, data, zi=None)\n</code></pre>"},{"location":"api/filters-reference/#cmtj.utils.filters.Filters.detrend_axis","title":"<code>detrend_axis(arr, axis)</code>  <code>staticmethod</code>","text":"<p>Detrend axis for better spectrum visibility.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <p>input array (spectrum)</p> required <code>axis</code> <p>axis along which to detrend</p> required Source code in <code>cmtj/utils/filters.py</code> <pre><code>@staticmethod\ndef detrend_axis(arr, axis):\n    \"\"\"Detrend axis for better spectrum visibility.\n    :param arr: input array (spectrum)\n    :param axis: axis along which to detrend\n    \"\"\"\n    medians = np.median(arr, axis=axis)\n    return (arr.T - medians).T if axis else arr - medians\n</code></pre>"},{"location":"api/general-reference/","title":"Miscellaneous Utilities","text":"<p>Contains definition of a base vector object used in the models such as Domain Wall Dynamics or Smit-Beljers model.</p>"},{"location":"api/general-reference/#cmtj.utils.general.VectorObj","title":"<code>VectorObj</code>  <code>dataclass</code>","text":"<p>Vector object for standard manipulation. Alternative to CVectors (which are used in the C++ code). Easier to modify and manipulate, but slower.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>positive z-axis angle (in xz plane) in radians.</p> required <code>phi</code> <code>float</code> <p>positive x-axis (in xy plane) angle in radians</p> required <code>mag</code> <code>float</code> <p>magnitude of the vector, if not set defaults to 1 unit vector</p> <code>1</code> Source code in <code>cmtj/utils/general.py</code> <pre><code>@dataclass\nclass VectorObj:\n    \"\"\"Vector object for standard manipulation.\n    Alternative to CVectors (which are used in the C++ code).\n    Easier to modify and manipulate, but slower.\n    :param theta: positive z-axis angle (in xz plane) in radians.\n    :param phi: positive x-axis (in xy plane) angle in radians\n    :param mag: magnitude of the vector, if not set defaults to 1 *unit vector*\n    \"\"\"\n\n    theta: float  # in radians\n    phi: float  # rad\n    mag: float = 1\n\n    def __add__(self, other):\n        \"\"\"Adds two vectors\"\"\"\n        return VectorObj.from_cvector(self.to_cvector() + other.to_cvector())\n\n    def __mul__(self, other: Union[\"VectorObj\", float]):\n        \"\"\"Multiplies a vector by a scalar\"\"\"\n        if isinstance(other, VectorObj):\n            return self._componentwise_mul(other)\n        return VectorObj.from_cvector(self.to_cvector() * other)\n\n    def __rmul__(self, other: Union[\"VectorObj\", float]):\n        \"\"\"Multiplies a vector by a scalar\"\"\"\n        return self.__mul__(other)\n\n    def __repr__(self) -&gt; str:\n        return f\"VectorObj(theta={self.theta}, phi={self.phi}, mag={self.mag})\"\n\n    def __hash__(self) -&gt; int:\n        return hash(str(self))\n\n    def __eq__(self, __value: \"VectorObj\") -&gt; bool:\n        return self.theta == __value.theta and self.phi == __value.phi and self.mag == __value.mag\n\n    def _componentwise_mul(self, other):\n        coors = self.get_cartesian()\n        other_coords = other.get_cartesian()\n        return VectorObj.from_cartesian(\n            coors[0] * other_coords[0],\n            coors[1] * other_coords[1],\n            coors[2] * other_coords[2],\n        )\n\n    def get_cartesian(self):\n        \"\"\"Returns the vector in Cartesian coordinates with (x, y, z) compnents\"\"\"\n        return VectorObj.from_spherical(self.theta, self.phi, self.mag)\n\n    @staticmethod\n    def from_spherical(theta, phi, mag=1):\n        \"\"\"Creates a Cartesian vector from spherical components\"\"\"\n        return [\n            mag * math.sin(theta) * math.cos(phi),\n            mag * math.sin(theta) * math.sin(phi),\n            mag * math.cos(theta),\n        ]\n\n    @staticmethod\n    def from_cartesian(x: float, y: float, z: float):\n        \"\"\"Creates a spherical vector from Cartesian components\"\"\"\n        mag = math.sqrt(x**2 + y**2 + z**2)\n        if mag == 0:\n            return VectorObj(0, 0, 0)\n        theta = math.acos(z / mag)\n        phi = math.atan2(y, x)\n        return VectorObj(theta, phi, mag)\n\n    @staticmethod\n    def from_cvector(cvector: CVector):\n        \"\"\"Creates a spherical vector from Cartesian components\"\"\"\n        mag = cvector.length()\n        if mag == 0:\n            return VectorObj(0, 0, 0)\n        theta = math.acos(cvector.z / mag)\n        phi = math.atan2(cvector.y, cvector.x)\n        return VectorObj(theta, phi, mag)\n\n    def to_cvector(self):\n        \"\"\"Creates a Cartesian vector from spherical components\"\"\"\n        return CVector(*self.get_cartesian())\n</code></pre>"},{"location":"api/general-reference/#cmtj.utils.general.VectorObj.__add__","title":"<code>__add__(other)</code>","text":"<p>Adds two vectors</p> Source code in <code>cmtj/utils/general.py</code> <pre><code>def __add__(self, other):\n    \"\"\"Adds two vectors\"\"\"\n    return VectorObj.from_cvector(self.to_cvector() + other.to_cvector())\n</code></pre>"},{"location":"api/general-reference/#cmtj.utils.general.VectorObj.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiplies a vector by a scalar</p> Source code in <code>cmtj/utils/general.py</code> <pre><code>def __mul__(self, other: Union[\"VectorObj\", float]):\n    \"\"\"Multiplies a vector by a scalar\"\"\"\n    if isinstance(other, VectorObj):\n        return self._componentwise_mul(other)\n    return VectorObj.from_cvector(self.to_cvector() * other)\n</code></pre>"},{"location":"api/general-reference/#cmtj.utils.general.VectorObj.__rmul__","title":"<code>__rmul__(other)</code>","text":"<p>Multiplies a vector by a scalar</p> Source code in <code>cmtj/utils/general.py</code> <pre><code>def __rmul__(self, other: Union[\"VectorObj\", float]):\n    \"\"\"Multiplies a vector by a scalar\"\"\"\n    return self.__mul__(other)\n</code></pre>"},{"location":"api/general-reference/#cmtj.utils.general.VectorObj.from_cartesian","title":"<code>from_cartesian(x, y, z)</code>  <code>staticmethod</code>","text":"<p>Creates a spherical vector from Cartesian components</p> Source code in <code>cmtj/utils/general.py</code> <pre><code>@staticmethod\ndef from_cartesian(x: float, y: float, z: float):\n    \"\"\"Creates a spherical vector from Cartesian components\"\"\"\n    mag = math.sqrt(x**2 + y**2 + z**2)\n    if mag == 0:\n        return VectorObj(0, 0, 0)\n    theta = math.acos(z / mag)\n    phi = math.atan2(y, x)\n    return VectorObj(theta, phi, mag)\n</code></pre>"},{"location":"api/general-reference/#cmtj.utils.general.VectorObj.from_cvector","title":"<code>from_cvector(cvector)</code>  <code>staticmethod</code>","text":"<p>Creates a spherical vector from Cartesian components</p> Source code in <code>cmtj/utils/general.py</code> <pre><code>@staticmethod\ndef from_cvector(cvector: CVector):\n    \"\"\"Creates a spherical vector from Cartesian components\"\"\"\n    mag = cvector.length()\n    if mag == 0:\n        return VectorObj(0, 0, 0)\n    theta = math.acos(cvector.z / mag)\n    phi = math.atan2(cvector.y, cvector.x)\n    return VectorObj(theta, phi, mag)\n</code></pre>"},{"location":"api/general-reference/#cmtj.utils.general.VectorObj.from_spherical","title":"<code>from_spherical(theta, phi, mag=1)</code>  <code>staticmethod</code>","text":"<p>Creates a Cartesian vector from spherical components</p> Source code in <code>cmtj/utils/general.py</code> <pre><code>@staticmethod\ndef from_spherical(theta, phi, mag=1):\n    \"\"\"Creates a Cartesian vector from spherical components\"\"\"\n    return [\n        mag * math.sin(theta) * math.cos(phi),\n        mag * math.sin(theta) * math.sin(phi),\n        mag * math.cos(theta),\n    ]\n</code></pre>"},{"location":"api/general-reference/#cmtj.utils.general.VectorObj.get_cartesian","title":"<code>get_cartesian()</code>","text":"<p>Returns the vector in Cartesian coordinates with (x, y, z) compnents</p> Source code in <code>cmtj/utils/general.py</code> <pre><code>def get_cartesian(self):\n    \"\"\"Returns the vector in Cartesian coordinates with (x, y, z) compnents\"\"\"\n    return VectorObj.from_spherical(self.theta, self.phi, self.mag)\n</code></pre>"},{"location":"api/general-reference/#cmtj.utils.general.VectorObj.to_cvector","title":"<code>to_cvector()</code>","text":"<p>Creates a Cartesian vector from spherical components</p> Source code in <code>cmtj/utils/general.py</code> <pre><code>def to_cvector(self):\n    \"\"\"Creates a Cartesian vector from spherical components\"\"\"\n    return CVector(*self.get_cartesian())\n</code></pre>"},{"location":"api/general-reference/#cmtj.utils.general.box_muller_random","title":"<code>box_muller_random(mean, std)</code>","text":"<p>Generates Gaussian noise with mean and standard deviation using the Box-Muller transform. https://en.wikipedia.org/wiki/Box\u2013Muller_transform</p> <p>Parameters:</p> Name Type Description Default <code>mean</code> <p>mean of the Gaussian.</p> required <code>std</code> <p>standard deviation of the Gaussian.</p> required Source code in <code>cmtj/utils/general.py</code> <pre><code>def box_muller_random(mean, std):\n    \"\"\"\n    Generates Gaussian noise with mean and standard deviation\n    using the Box-Muller transform.\n    https://en.wikipedia.org/wiki/Box\u2013Muller_transform\n    :param mean: mean of the Gaussian.\n    :param std: standard deviation of the Gaussian.\n    \"\"\"\n    u1 = np.random.uniform(0, 1)\n    u2 = np.random.uniform(0, 1)\n    mag = std * math.sqrt(-2.0 * math.log(u1))\n    z0 = mag * math.cos(2 * math.pi * u2) + mean\n    z1 = mag * math.sin(2 * math.pi * u2) + mean\n    return z0, z1\n</code></pre>"},{"location":"api/general-reference/#cmtj.utils.general.perturb_position","title":"<code>perturb_position(eq_point, pmax=0.001)</code>","text":"<p>Perturbs an equilibrium point by a random amount.</p> Source code in <code>cmtj/utils/general.py</code> <pre><code>def perturb_position(eq_point, pmax=1e-3):\n    \"\"\"\n    Perturbs an equilibrium point by a random amount.\n    \"\"\"\n    return np.asarray(eq_point) + np.random.normal(0, pmax, len(eq_point))\n</code></pre>"},{"location":"api/linear-reference/","title":"Linear","text":""},{"location":"api/linear-reference/#cmtj.utils.linear.FieldScan","title":"<code>FieldScan</code>","text":"Source code in <code>cmtj/utils/linear.py</code> <pre><code>class FieldScan:\n    @staticmethod\n    def _trig_compute(theta, phi) -&gt; tuple:\n        \"\"\"Compute trigonometric functions for theta and phi.\n        :param theta: theta angle in [deg].\n        :param phi: phi angle in [deg].\n        :returns: trigonometric functions for theta and phi.\"\"\"\n        st = np.sin(np.deg2rad(theta))\n        ct = np.cos(np.deg2rad(theta))\n        sp = np.sin(np.deg2rad(phi))\n        cp = np.cos(np.deg2rad(phi))\n        return st, ct, sp, cp\n\n    @staticmethod\n    def angle2vector(theta, phi, amplitude=1) -&gt; CVector:\n        \"\"\"Convert spherical coordinates to cartesian coordinates.\n        :param theta: polar angle in degrees.\n        :param phi: azimuthal angle in degrees.\n        :param amplitude: amplitude of target vector.\n        :returns: cartesian vector.\"\"\"\n        st, ct, sp, cp = FieldScan._trig_compute(theta, phi)\n        return CVector(\n            st * cp * amplitude,\n            st * sp * amplitude,\n            ct * amplitude,\n        )\n\n    @staticmethod\n    def vector2angle(x, y, z) -&gt; tuple:\n        \"\"\"Convert cartesian coordinates to spherical coordinates.\n        :param x: x coordinate of the vector.\n        :param y: y coordinate of the vector.\n        :param z: z coordinate of the vector.\n        :returns (theta, phi, r)\n        https://github.com/numpy/numpy/issues/5228\n        \"\"\"\n        r = np.sqrt(x**2 + y**2 + z**2)\n        theta = np.rad2deg(np.arctan2(np.sqrt(x**2 + y**2), z))\n        phi = np.rad2deg(np.arctan2(y, x))\n        return theta, phi, r\n\n    @staticmethod\n    def cvector2angle(vector: CVector) -&gt; tuple:\n        \"\"\"\n        :param vector: cartesian vector.\n        :returns (theta, phi, r)\n        https://github.com/numpy/numpy/issues/5228\n        \"\"\"\n        return FieldScan.vector2angle(vector.x, vector.y, vector.z)\n\n    @staticmethod\n    def amplitude_scan(\n        start: float,\n        stop: float,\n        steps: int,\n        theta: float,\n        phi: float,\n        back: bool = False,\n    ) -&gt; tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Compute a linear magnitude sweep. Angles given in deg.\n        :param start: start of the sweep\n        :param stop: end of the sweep\n        :param steps: number of steps\n        :param theta: polar angle in deg.\n        :param phi: azimuthal angle in deg.\n        :returns: linear amplitude, field vectors\n        \"\"\"\n        Hspan = np.linspace(start, stop, endpoint=True, num=steps)\n        st, ct, sp, cp = FieldScan._trig_compute(theta, phi)\n        Hx = st * cp * Hspan\n        Hy = st * sp * Hspan\n        Hz = ct * Hspan\n        if back:\n            forward = np.vstack((Hx, Hy, Hz)).T\n            return np.concatenate((Hspan[:-1], Hspan[::-1]),\n                                  axis=0), np.concatenate(\n                                      (forward[:-1], forward[::-1]), axis=0)\n        return Hspan, np.vstack((Hx, Hy, Hz)).T\n\n    @staticmethod\n    def theta_scan(\n        start: float, stop: float, steps: int, amplitude: float, phi: float\n    ) -&gt; tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Compute a linear theta angle sweep. Angles given in deg.\n        :param start: polar angle start of the sweep\n        :param stop: polar angle end of the sweep\n        :param steps: number of steps\n        :param amplitude: amplitude of the scanned field.\n        :param phi: azimuthal angle in deg.\n        \"\"\"\n        theta_span = np.linspace(start, stop, endpoint=True, num=steps)\n        st, ct, sp, cp = FieldScan._trig_compute(theta_span, phi)\n        Hx = st * cp * amplitude\n        Hy = st * sp * amplitude\n        Hz = ct * amplitude\n        return theta_span, np.vstack((Hx, Hy, Hz)).T\n\n    @staticmethod\n    def phi_scan(\n        start: float, stop: float, steps: int, amplitude: float, theta: float\n    ) -&gt; tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Compute a linear phi angle sweep. Angles given in deg.\n        :param start: azimuthal angle start of the sweep\n        :param stop: azimuthal angle end of the sweep\n        :param steps: number of steps\n        :param amplitude: amplitude of the scanned field\n        :param theta: polar angle in deg.\n        \"\"\"\n        phi_span = np.linspace(start, stop, endpoint=True, num=steps)\n        st, ct, sp, cp = FieldScan._trig_compute(theta, phi_span)\n        Hx = st * cp * amplitude\n        Hy = st * sp * amplitude\n        Hz = ct * amplitude * np.ones_like(Hy)\n        return phi_span, np.vstack((Hx, Hy, Hz)).T\n</code></pre>"},{"location":"api/linear-reference/#cmtj.utils.linear.FieldScan.amplitude_scan","title":"<code>amplitude_scan(start, stop, steps, theta, phi, back=False)</code>  <code>staticmethod</code>","text":"<p>Compute a linear magnitude sweep. Angles given in deg.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>start of the sweep</p> required <code>stop</code> <code>float</code> <p>end of the sweep</p> required <code>steps</code> <code>int</code> <p>number of steps</p> required <code>theta</code> <code>float</code> <p>polar angle in deg.</p> required <code>phi</code> <code>float</code> <p>azimuthal angle in deg.</p> required <p>Returns:</p> Type Description <code>tuple[np.ndarray, np.ndarray]</code> <p>linear amplitude, field vectors</p> Source code in <code>cmtj/utils/linear.py</code> <pre><code>@staticmethod\ndef amplitude_scan(\n    start: float,\n    stop: float,\n    steps: int,\n    theta: float,\n    phi: float,\n    back: bool = False,\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Compute a linear magnitude sweep. Angles given in deg.\n    :param start: start of the sweep\n    :param stop: end of the sweep\n    :param steps: number of steps\n    :param theta: polar angle in deg.\n    :param phi: azimuthal angle in deg.\n    :returns: linear amplitude, field vectors\n    \"\"\"\n    Hspan = np.linspace(start, stop, endpoint=True, num=steps)\n    st, ct, sp, cp = FieldScan._trig_compute(theta, phi)\n    Hx = st * cp * Hspan\n    Hy = st * sp * Hspan\n    Hz = ct * Hspan\n    if back:\n        forward = np.vstack((Hx, Hy, Hz)).T\n        return np.concatenate((Hspan[:-1], Hspan[::-1]),\n                              axis=0), np.concatenate(\n                                  (forward[:-1], forward[::-1]), axis=0)\n    return Hspan, np.vstack((Hx, Hy, Hz)).T\n</code></pre>"},{"location":"api/linear-reference/#cmtj.utils.linear.FieldScan.angle2vector","title":"<code>angle2vector(theta, phi, amplitude=1)</code>  <code>staticmethod</code>","text":"<p>Convert spherical coordinates to cartesian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <p>polar angle in degrees.</p> required <code>phi</code> <p>azimuthal angle in degrees.</p> required <code>amplitude</code> <p>amplitude of target vector.</p> <code>1</code> <p>Returns:</p> Type Description <code>CVector</code> <p>cartesian vector.</p> Source code in <code>cmtj/utils/linear.py</code> <pre><code>@staticmethod\ndef angle2vector(theta, phi, amplitude=1) -&gt; CVector:\n    \"\"\"Convert spherical coordinates to cartesian coordinates.\n    :param theta: polar angle in degrees.\n    :param phi: azimuthal angle in degrees.\n    :param amplitude: amplitude of target vector.\n    :returns: cartesian vector.\"\"\"\n    st, ct, sp, cp = FieldScan._trig_compute(theta, phi)\n    return CVector(\n        st * cp * amplitude,\n        st * sp * amplitude,\n        ct * amplitude,\n    )\n</code></pre>"},{"location":"api/linear-reference/#cmtj.utils.linear.FieldScan.cvector2angle","title":"<code>cvector2angle(vector)</code>  <code>staticmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>vector</code> <code>CVector</code> <p>cartesian vector.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>//github.com/numpy/numpy/issues/5228</p> Source code in <code>cmtj/utils/linear.py</code> <pre><code>@staticmethod\ndef cvector2angle(vector: CVector) -&gt; tuple:\n    \"\"\"\n    :param vector: cartesian vector.\n    :returns (theta, phi, r)\n    https://github.com/numpy/numpy/issues/5228\n    \"\"\"\n    return FieldScan.vector2angle(vector.x, vector.y, vector.z)\n</code></pre>"},{"location":"api/linear-reference/#cmtj.utils.linear.FieldScan.phi_scan","title":"<code>phi_scan(start, stop, steps, amplitude, theta)</code>  <code>staticmethod</code>","text":"<p>Compute a linear phi angle sweep. Angles given in deg.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>azimuthal angle start of the sweep</p> required <code>stop</code> <code>float</code> <p>azimuthal angle end of the sweep</p> required <code>steps</code> <code>int</code> <p>number of steps</p> required <code>amplitude</code> <code>float</code> <p>amplitude of the scanned field</p> required <code>theta</code> <code>float</code> <p>polar angle in deg.</p> required Source code in <code>cmtj/utils/linear.py</code> <pre><code>@staticmethod\ndef phi_scan(\n    start: float, stop: float, steps: int, amplitude: float, theta: float\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Compute a linear phi angle sweep. Angles given in deg.\n    :param start: azimuthal angle start of the sweep\n    :param stop: azimuthal angle end of the sweep\n    :param steps: number of steps\n    :param amplitude: amplitude of the scanned field\n    :param theta: polar angle in deg.\n    \"\"\"\n    phi_span = np.linspace(start, stop, endpoint=True, num=steps)\n    st, ct, sp, cp = FieldScan._trig_compute(theta, phi_span)\n    Hx = st * cp * amplitude\n    Hy = st * sp * amplitude\n    Hz = ct * amplitude * np.ones_like(Hy)\n    return phi_span, np.vstack((Hx, Hy, Hz)).T\n</code></pre>"},{"location":"api/linear-reference/#cmtj.utils.linear.FieldScan.theta_scan","title":"<code>theta_scan(start, stop, steps, amplitude, phi)</code>  <code>staticmethod</code>","text":"<p>Compute a linear theta angle sweep. Angles given in deg.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>polar angle start of the sweep</p> required <code>stop</code> <code>float</code> <p>polar angle end of the sweep</p> required <code>steps</code> <code>int</code> <p>number of steps</p> required <code>amplitude</code> <code>float</code> <p>amplitude of the scanned field.</p> required <code>phi</code> <code>float</code> <p>azimuthal angle in deg.</p> required Source code in <code>cmtj/utils/linear.py</code> <pre><code>@staticmethod\ndef theta_scan(\n    start: float, stop: float, steps: int, amplitude: float, phi: float\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Compute a linear theta angle sweep. Angles given in deg.\n    :param start: polar angle start of the sweep\n    :param stop: polar angle end of the sweep\n    :param steps: number of steps\n    :param amplitude: amplitude of the scanned field.\n    :param phi: azimuthal angle in deg.\n    \"\"\"\n    theta_span = np.linspace(start, stop, endpoint=True, num=steps)\n    st, ct, sp, cp = FieldScan._trig_compute(theta_span, phi)\n    Hx = st * cp * amplitude\n    Hy = st * sp * amplitude\n    Hz = ct * amplitude\n    return theta_span, np.vstack((Hx, Hy, Hz)).T\n</code></pre>"},{"location":"api/linear-reference/#cmtj.utils.linear.FieldScan.vector2angle","title":"<code>vector2angle(x, y, z)</code>  <code>staticmethod</code>","text":"<p>Convert cartesian coordinates to spherical coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>x coordinate of the vector.</p> required <code>y</code> <p>y coordinate of the vector.</p> required <code>z</code> <p>z coordinate of the vector.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>//github.com/numpy/numpy/issues/5228</p> Source code in <code>cmtj/utils/linear.py</code> <pre><code>@staticmethod\ndef vector2angle(x, y, z) -&gt; tuple:\n    \"\"\"Convert cartesian coordinates to spherical coordinates.\n    :param x: x coordinate of the vector.\n    :param y: y coordinate of the vector.\n    :param z: z coordinate of the vector.\n    :returns (theta, phi, r)\n    https://github.com/numpy/numpy/issues/5228\n    \"\"\"\n    r = np.sqrt(x**2 + y**2 + z**2)\n    theta = np.rad2deg(np.arctan2(np.sqrt(x**2 + y**2), z))\n    phi = np.rad2deg(np.arctan2(y, x))\n    return theta, phi, r\n</code></pre>"},{"location":"api/llgb/","title":"LLGB","text":""},{"location":"api/llgb/#cmtj.llgb.LLGBJunction","title":"<code>LLGBJunction</code>","text":"<p>LLGB Junction class.</p> Source code in <code>cmtj/llgb/__init__.pyi</code> <pre><code>class LLGBJunction:\n    \"\"\"LLGB Junction class.\"\"\"\n\n    def __init__(self, layers: list[LLGBLayer]) -&gt; None:\n        \"\"\"Initialises a LLGB junction with layers.\n        :param layers: list of LLGB layers.\"\"\"\n        ...\n\n    def clearLog(self) -&gt; None:\n        \"\"\"Clears the simulation log of the junction.\"\"\"\n        ...\n\n    def getLog(self) -&gt; dict[str, list[float]]:\n        \"\"\"Returns the simulation log of the junction.\"\"\"\n        ...\n\n    def runSimulation(\n        self,\n        totalTime: float,\n        timeStep: float = ...,\n        writeFrequency: float = ...,\n        log: bool = ...,\n        solverMode: cmtj.SolverMode = ...,\n    ) -&gt; None:\n        \"\"\"Runs the simulation of the junction.\n        :param totalTime: total simulation time.\n        :param timeStep: time step.\n        :param writeFrequency: frequency of writing to the log.\n        :param log: whether to log the simulation.\n        :param solverMode: solver mode.\n        \"\"\"\n        ...\n\n    def saveLogs(self, arg0: str) -&gt; None:\n        \"\"\"Saves the simulation logs to a file.\n        :param arg0: file path.\"\"\"\n        ...\n\n    def setLayerExternalFieldDriver(self, layerId: str, driver: cmtj.AxialDriver) -&gt; None:\n        \"\"\"Set an external field driver for a layer.\n        :param layerId: the id of the layer.\n        :param driver: the field driver to be set.\"\"\"\n        ...\n\n    def setLayerTemperatureDriver(self, layerId: str, driver: cmtj.ScalarDriver) -&gt; None:\n        \"\"\"Set a temperature driver for a layer.\n        :param layerId: the id of the layer.\n        :param driver: the temperature driver to be set.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/llgb/#cmtj.llgb.LLGBJunction.__init__","title":"<code>__init__(layers)</code>","text":"<p>Initialises a LLGB junction with layers.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[LLGBLayer]</code> <p>list of LLGB layers.</p> required Source code in <code>cmtj/llgb/__init__.pyi</code> <pre><code>def __init__(self, layers: list[LLGBLayer]) -&gt; None:\n    \"\"\"Initialises a LLGB junction with layers.\n    :param layers: list of LLGB layers.\"\"\"\n    ...\n</code></pre>"},{"location":"api/llgb/#cmtj.llgb.LLGBJunction.clearLog","title":"<code>clearLog()</code>","text":"<p>Clears the simulation log of the junction.</p> Source code in <code>cmtj/llgb/__init__.pyi</code> <pre><code>def clearLog(self) -&gt; None:\n    \"\"\"Clears the simulation log of the junction.\"\"\"\n    ...\n</code></pre>"},{"location":"api/llgb/#cmtj.llgb.LLGBJunction.getLog","title":"<code>getLog()</code>","text":"<p>Returns the simulation log of the junction.</p> Source code in <code>cmtj/llgb/__init__.pyi</code> <pre><code>def getLog(self) -&gt; dict[str, list[float]]:\n    \"\"\"Returns the simulation log of the junction.\"\"\"\n    ...\n</code></pre>"},{"location":"api/llgb/#cmtj.llgb.LLGBJunction.runSimulation","title":"<code>runSimulation(totalTime, timeStep=Ellipsis, writeFrequency=Ellipsis, log=Ellipsis, solverMode=Ellipsis)</code>","text":"<p>Runs the simulation of the junction.</p> <p>Parameters:</p> Name Type Description Default <code>totalTime</code> <code>float</code> <p>total simulation time.</p> required <code>timeStep</code> <code>float</code> <p>time step.</p> <code>Ellipsis</code> <code>writeFrequency</code> <code>float</code> <p>frequency of writing to the log.</p> <code>Ellipsis</code> <code>log</code> <code>bool</code> <p>whether to log the simulation.</p> <code>Ellipsis</code> <code>solverMode</code> <code>cmtj.SolverMode</code> <p>solver mode.</p> <code>Ellipsis</code> Source code in <code>cmtj/llgb/__init__.pyi</code> <pre><code>def runSimulation(\n    self,\n    totalTime: float,\n    timeStep: float = ...,\n    writeFrequency: float = ...,\n    log: bool = ...,\n    solverMode: cmtj.SolverMode = ...,\n) -&gt; None:\n    \"\"\"Runs the simulation of the junction.\n    :param totalTime: total simulation time.\n    :param timeStep: time step.\n    :param writeFrequency: frequency of writing to the log.\n    :param log: whether to log the simulation.\n    :param solverMode: solver mode.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/llgb/#cmtj.llgb.LLGBJunction.saveLogs","title":"<code>saveLogs(arg0)</code>","text":"<p>Saves the simulation logs to a file.</p> <p>Parameters:</p> Name Type Description Default <code>arg0</code> <code>str</code> <p>file path.</p> required Source code in <code>cmtj/llgb/__init__.pyi</code> <pre><code>def saveLogs(self, arg0: str) -&gt; None:\n    \"\"\"Saves the simulation logs to a file.\n    :param arg0: file path.\"\"\"\n    ...\n</code></pre>"},{"location":"api/llgb/#cmtj.llgb.LLGBJunction.setLayerExternalFieldDriver","title":"<code>setLayerExternalFieldDriver(layerId, driver)</code>","text":"<p>Set an external field driver for a layer.</p> <p>Parameters:</p> Name Type Description Default <code>layerId</code> <code>str</code> <p>the id of the layer.</p> required <code>driver</code> <code>cmtj.AxialDriver</code> <p>the field driver to be set.</p> required Source code in <code>cmtj/llgb/__init__.pyi</code> <pre><code>def setLayerExternalFieldDriver(self, layerId: str, driver: cmtj.AxialDriver) -&gt; None:\n    \"\"\"Set an external field driver for a layer.\n    :param layerId: the id of the layer.\n    :param driver: the field driver to be set.\"\"\"\n    ...\n</code></pre>"},{"location":"api/llgb/#cmtj.llgb.LLGBJunction.setLayerTemperatureDriver","title":"<code>setLayerTemperatureDriver(layerId, driver)</code>","text":"<p>Set a temperature driver for a layer.</p> <p>Parameters:</p> Name Type Description Default <code>layerId</code> <code>str</code> <p>the id of the layer.</p> required <code>driver</code> <code>cmtj.ScalarDriver</code> <p>the temperature driver to be set.</p> required Source code in <code>cmtj/llgb/__init__.pyi</code> <pre><code>def setLayerTemperatureDriver(self, layerId: str, driver: cmtj.ScalarDriver) -&gt; None:\n    \"\"\"Set a temperature driver for a layer.\n    :param layerId: the id of the layer.\n    :param driver: the temperature driver to be set.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/llgb/#cmtj.llgb.LLGBLayer","title":"<code>LLGBLayer</code>","text":"<p>LLGB Layer class.</p> Source code in <code>cmtj/llgb/__init__.pyi</code> <pre><code>class LLGBLayer:\n    \"\"\"LLGB Layer class.\"\"\"\n\n    def __init__(\n        self,\n        id: str,\n        mag: cmtj.CVector,\n        anis: cmtj.CVector,\n        Ms: float,\n        thickness: float,\n        cellSurface: float,\n        demagTensor: list[cmtj.CVector],\n        damping: float,\n        Tc: float,\n        susceptibility: float,\n        me: float,\n    ) -&gt; None:\n        \"\"\"Creates a LLGB layer.\n        :param id: layer id.\n        :param mag: magnetisation.\n        :param anis: anisotropy axis.\n        :param Ms: saturation magnetisation.\n        :param thickness: thickness.\n        :param cellSurface: cell surface.\n        :param demagTensor: demagnetisation tensor.\n        :param damping: damping factor.\n        :param Tc: Curie temperature.\n        :param susceptibility: susceptibility.\n        :param me: equilibrium magnetisation.\n        \"\"\"\n        ...\n\n    def setAnisotropyDriver(self, driver: cmtj.ScalarDriver) -&gt; None:\n        \"\"\"Sets an anisotropy driver.\n        :param driver: the anisotropy driver to be set.\"\"\"\n        ...\n\n    def setExternalFieldDriver(self, driver: cmtj.AxialDriver) -&gt; None:\n        \"\"\"Sets an external field driver.\n        :param driver: the field driver to be set.\"\"\"\n        ...\n\n    def setTemperatureDriver(self, driver: cmtj.ScalarDriver) -&gt; None:\n        \"\"\"Sets a temperature driver.\n        :param driver: the temperature driver to be set.\"\"\"\n        ...\n</code></pre>"},{"location":"api/llgb/#cmtj.llgb.LLGBLayer.__init__","title":"<code>__init__(id, mag, anis, Ms, thickness, cellSurface, demagTensor, damping, Tc, susceptibility, me)</code>","text":"<p>Creates a LLGB layer.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>layer id.</p> required <code>mag</code> <code>cmtj.CVector</code> <p>magnetisation.</p> required <code>anis</code> <code>cmtj.CVector</code> <p>anisotropy axis.</p> required <code>Ms</code> <code>float</code> <p>saturation magnetisation.</p> required <code>thickness</code> <code>float</code> <p>thickness.</p> required <code>cellSurface</code> <code>float</code> <p>cell surface.</p> required <code>demagTensor</code> <code>list[cmtj.CVector]</code> <p>demagnetisation tensor.</p> required <code>damping</code> <code>float</code> <p>damping factor.</p> required <code>Tc</code> <code>float</code> <p>Curie temperature.</p> required <code>susceptibility</code> <code>float</code> <p>susceptibility.</p> required <code>me</code> <code>float</code> <p>equilibrium magnetisation.</p> required Source code in <code>cmtj/llgb/__init__.pyi</code> <pre><code>def __init__(\n    self,\n    id: str,\n    mag: cmtj.CVector,\n    anis: cmtj.CVector,\n    Ms: float,\n    thickness: float,\n    cellSurface: float,\n    demagTensor: list[cmtj.CVector],\n    damping: float,\n    Tc: float,\n    susceptibility: float,\n    me: float,\n) -&gt; None:\n    \"\"\"Creates a LLGB layer.\n    :param id: layer id.\n    :param mag: magnetisation.\n    :param anis: anisotropy axis.\n    :param Ms: saturation magnetisation.\n    :param thickness: thickness.\n    :param cellSurface: cell surface.\n    :param demagTensor: demagnetisation tensor.\n    :param damping: damping factor.\n    :param Tc: Curie temperature.\n    :param susceptibility: susceptibility.\n    :param me: equilibrium magnetisation.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/llgb/#cmtj.llgb.LLGBLayer.setAnisotropyDriver","title":"<code>setAnisotropyDriver(driver)</code>","text":"<p>Sets an anisotropy driver.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>cmtj.ScalarDriver</code> <p>the anisotropy driver to be set.</p> required Source code in <code>cmtj/llgb/__init__.pyi</code> <pre><code>def setAnisotropyDriver(self, driver: cmtj.ScalarDriver) -&gt; None:\n    \"\"\"Sets an anisotropy driver.\n    :param driver: the anisotropy driver to be set.\"\"\"\n    ...\n</code></pre>"},{"location":"api/llgb/#cmtj.llgb.LLGBLayer.setExternalFieldDriver","title":"<code>setExternalFieldDriver(driver)</code>","text":"<p>Sets an external field driver.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>cmtj.AxialDriver</code> <p>the field driver to be set.</p> required Source code in <code>cmtj/llgb/__init__.pyi</code> <pre><code>def setExternalFieldDriver(self, driver: cmtj.AxialDriver) -&gt; None:\n    \"\"\"Sets an external field driver.\n    :param driver: the field driver to be set.\"\"\"\n    ...\n</code></pre>"},{"location":"api/llgb/#cmtj.llgb.LLGBLayer.setTemperatureDriver","title":"<code>setTemperatureDriver(driver)</code>","text":"<p>Sets a temperature driver.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>cmtj.ScalarDriver</code> <p>the temperature driver to be set.</p> required Source code in <code>cmtj/llgb/__init__.pyi</code> <pre><code>def setTemperatureDriver(self, driver: cmtj.ScalarDriver) -&gt; None:\n    \"\"\"Sets a temperature driver.\n    :param driver: the temperature driver to be set.\"\"\"\n    ...\n</code></pre>"},{"location":"api/llgb/#cmtj.llgb.MFAWeissCurie","title":"<code>MFAWeissCurie(me, T, J0, relax=Ellipsis, tolerance=Ellipsis, maxIter=Ellipsis)</code>","text":"<p>Mean Field Approximation for Weiss Curie temperature.</p> <p>Parameters:</p> Name Type Description Default <code>me</code> <code>float</code> <p>equilibrium magnetisation.</p> required <code>T</code> <code>float</code> <p>temperature.</p> required <code>J0</code> <code>float</code> <p>exchange coupling.</p> required <code>relax</code> <code>float</code> <p>relaxation factor.</p> <code>Ellipsis</code> <code>tolerance</code> <code>float</code> <p>tolerance for convergence.</p> <code>Ellipsis</code> <code>maxIter</code> <code>int</code> <p>maximum number of iterations.</p> <code>Ellipsis</code> Source code in <code>cmtj/llgb/__init__.pyi</code> <pre><code>def MFAWeissCurie(\n    me: float,\n    T: float,\n    J0: float,\n    relax: float = ...,\n    tolerance: float = ...,\n    maxIter: int = ...,\n) -&gt; tuple[float, float]:\n    \"\"\"Mean Field Approximation for Weiss Curie temperature.\n    :param me: equilibrium magnetisation.\n    :param T: temperature.\n    :param J0: exchange coupling.\n    :param relax: relaxation factor.\n    :param tolerance: tolerance for convergence.\n    :param maxIter: maximum number of iterations.\"\"\"\n    ...\n</code></pre>"},{"location":"api/noise/","title":"Noise","text":""},{"location":"api/noise/#cmtj.noise.BufferedAlphaNoise","title":"<code>BufferedAlphaNoise</code>","text":"<p>Create a buffer of alpha noise generator. Alpha can be in [0, 2].</p> Source code in <code>cmtj/noise/__init__.pyi</code> <pre><code>class BufferedAlphaNoise:\n    \"\"\"Create a buffer of alpha noise generator. Alpha can be in [0, 2].\"\"\"\n\n    def __init__(self, bufferSize: int, alpha: float, std: float, scale: float) -&gt; None: ...\n    def fillBuffer(self) -&gt; None:\n        \"\"\"Fill the buffer with the noise. This method is called only once.\"\"\"\n        ...\n\n    def tick(self) -&gt; float:\n        \"\"\"Produce the next sample of the noise.\"\"\"\n        ...\n</code></pre>"},{"location":"api/noise/#cmtj.noise.BufferedAlphaNoise.fillBuffer","title":"<code>fillBuffer()</code>","text":"<p>Fill the buffer with the noise. This method is called only once.</p> Source code in <code>cmtj/noise/__init__.pyi</code> <pre><code>def fillBuffer(self) -&gt; None:\n    \"\"\"Fill the buffer with the noise. This method is called only once.\"\"\"\n    ...\n</code></pre>"},{"location":"api/noise/#cmtj.noise.BufferedAlphaNoise.tick","title":"<code>tick()</code>","text":"<p>Produce the next sample of the noise.</p> Source code in <code>cmtj/noise/__init__.pyi</code> <pre><code>def tick(self) -&gt; float:\n    \"\"\"Produce the next sample of the noise.\"\"\"\n    ...\n</code></pre>"},{"location":"api/noise/#cmtj.noise.VectorAlphaNoise","title":"<code>VectorAlphaNoise</code>","text":"<p>Create a vector alpha noise generator. Alpha can be in [0, 2].</p> Source code in <code>cmtj/noise/__init__.pyi</code> <pre><code>class VectorAlphaNoise:\n    \"\"\"Create a vector alpha noise generator. Alpha can be in [0, 2].\"\"\"\n\n    def __init__(\n        self,\n        bufferSize: int,\n        alpha: float,\n        std: float,\n        scale: float,\n        axis: cmtj.Axis = cmtj.Axis.all,\n    ) -&gt; None:\n        \"\"\"Kasdin algorithm for vector alpha noise generation.\n\n        :param bufferSize: Buffer size\n        :param alpha: Alpha parameter\n        :param std: Standard deviation\n        :param scale: Scale\n        :param axis: Axis, by default all axes are used\n        \"\"\"\n        ...\n\n    def getPrevSample(self) -&gt; cmtj.CVector:\n        \"\"\"Get the previous sample of the noise in a vector form.\"\"\"\n        ...\n\n    def getScale(self) -&gt; float:\n        \"\"\"Get the scale of the noise.\"\"\"\n        ...\n\n    def tick(self) -&gt; float: ...\n    def tickVector(self) -&gt; cmtj.CVector:\n        \"\"\"Get the next sample of the noise in a vector form.\"\"\"\n        ...\n</code></pre>"},{"location":"api/noise/#cmtj.noise.VectorAlphaNoise.__init__","title":"<code>__init__(bufferSize, alpha, std, scale, axis=cmtj.Axis.all)</code>","text":"<p>Kasdin algorithm for vector alpha noise generation.</p> <p>Parameters:</p> Name Type Description Default <code>bufferSize</code> <code>int</code> <p>Buffer size</p> required <code>alpha</code> <code>float</code> <p>Alpha parameter</p> required <code>std</code> <code>float</code> <p>Standard deviation</p> required <code>scale</code> <code>float</code> <p>Scale</p> required <code>axis</code> <code>cmtj.Axis</code> <p>Axis, by default all axes are used</p> <code>cmtj.Axis.all</code> Source code in <code>cmtj/noise/__init__.pyi</code> <pre><code>def __init__(\n    self,\n    bufferSize: int,\n    alpha: float,\n    std: float,\n    scale: float,\n    axis: cmtj.Axis = cmtj.Axis.all,\n) -&gt; None:\n    \"\"\"Kasdin algorithm for vector alpha noise generation.\n\n    :param bufferSize: Buffer size\n    :param alpha: Alpha parameter\n    :param std: Standard deviation\n    :param scale: Scale\n    :param axis: Axis, by default all axes are used\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/noise/#cmtj.noise.VectorAlphaNoise.getPrevSample","title":"<code>getPrevSample()</code>","text":"<p>Get the previous sample of the noise in a vector form.</p> Source code in <code>cmtj/noise/__init__.pyi</code> <pre><code>def getPrevSample(self) -&gt; cmtj.CVector:\n    \"\"\"Get the previous sample of the noise in a vector form.\"\"\"\n    ...\n</code></pre>"},{"location":"api/noise/#cmtj.noise.VectorAlphaNoise.getScale","title":"<code>getScale()</code>","text":"<p>Get the scale of the noise.</p> Source code in <code>cmtj/noise/__init__.pyi</code> <pre><code>def getScale(self) -&gt; float:\n    \"\"\"Get the scale of the noise.\"\"\"\n    ...\n</code></pre>"},{"location":"api/noise/#cmtj.noise.VectorAlphaNoise.tickVector","title":"<code>tickVector()</code>","text":"<p>Get the next sample of the noise in a vector form.</p> Source code in <code>cmtj/noise/__init__.pyi</code> <pre><code>def tickVector(self) -&gt; cmtj.CVector:\n    \"\"\"Get the next sample of the noise in a vector form.\"\"\"\n    ...\n</code></pre>"},{"location":"api/optimization-reference/","title":"Optimization","text":""},{"location":"api/optimization-reference/#cmtj.utils.optimization.coordinate_descent","title":"<code>coordinate_descent(operating_point, fn, best_mse=float('-inf'), granularity=10, percentage=0.05)</code>","text":"<p>Performs coordinate descent on the operating point.</p> <p>Parameters:</p> Name Type Description Default <code>operating_point</code> <code>dict[str, float]</code> <p>operating point to be optimised. Order of that dict matters.</p> required <code>fn</code> <code>Callable</code> <p>function to be optimised</p> required <code>best_mse</code> <code>float</code> <p>best mse so far</p> <code>float('-inf')</code> <code>granularity</code> <code>int</code> <p>granularity of the search</p> <code>10</code> <code>percentage</code> <code>float</code> <p>percentage of the search</p> <code>0.05</code> <p>Returns:</p> Type Description <p>best operating point, best mse</p> Source code in <code>cmtj/utils/optimization.py</code> <pre><code>def coordinate_descent(\n    operating_point: dict[str, float],\n    fn: Callable,\n    best_mse: float = float(\"-inf\"),\n    granularity: int = 10,\n    percentage: float = 0.05,\n):\n    \"\"\"Performs coordinate descent on the operating point.\n    :param operating_point: operating point to be optimised. Order of that dict matters.\n    :param fn: function to be optimised\n    :param best_mse: best mse so far\n    :param granularity: granularity of the search\n    :param percentage: percentage of the search\n    :returns: best operating point, best mse\n    \"\"\"\n    opt_params = operating_point\n    for k, org_v in tqdm(operating_point.items(), desc=\"Coordinate descent\"):\n        new_params = operating_point.copy()\n        for v in tqdm(\n            np.linspace((1 - percentage) * org_v, (1 + percentage) * org_v, granularity),\n            desc=f\"Optimising {k}\",\n            leave=False,\n        ):\n            new_params[k] = v\n            mse = fn(**new_params)\n            if mse &gt; best_mse:\n                opt_params = new_params\n                best_mse = mse\n    return opt_params, best_mse\n</code></pre>"},{"location":"api/optimization-reference/#cmtj.utils.optimization.hebo_optimization_loop","title":"<code>hebo_optimization_loop(cfg, fn, error_fn, target, fixed_parameters, n_iters=150, n_suggestions=8)</code>","text":"<p>Optimizes the parameters of a function using HEBO. See HEBO documentation for more details: https://github.com/huawei-noah/HEBO</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>dict</code> <p>configuration of the design space</p> required <code>fn</code> <code>Callable</code> <p>function to be optimised fn(parameters, fixed_parameters)</p> required <code>error_fn</code> <code>Callable</code> <p>function to compute the error: error_fn(target, result)</p> required <code>target</code> <code>np.ndarray</code> <p>target data</p> required <code>fixed_parameters</code> <code>dict</code> <p>parameters that are fixed</p> required <code>n_iters</code> <code>int</code> <p>number of iterations</p> <code>150</code> <code>n_suggestions</code> <code>int</code> <p>number of suggestions per iteration</p> <code>8</code> Source code in <code>cmtj/utils/optimization.py</code> <pre><code>def hebo_optimization_loop(\n    cfg: dict,\n    fn: Callable,\n    error_fn: Callable,\n    target: np.ndarray,\n    fixed_parameters: dict,\n    n_iters: int = 150,\n    n_suggestions: int = 8,\n):\n    \"\"\"Optimizes the parameters of a function using HEBO.\n    See HEBO documentation for more details: https://github.com/huawei-noah/HEBO\n    :param cfg: configuration of the design space\n    :param fn: function to be optimised fn(**parameters, **fixed_parameters)\n    :param error_fn: function to compute the error: error_fn(target, result)\n    :param target: target data\n    :param fixed_parameters: parameters that are fixed\n    :param n_iters: number of iterations\n    :param n_suggestions: number of suggestions per iteration\n    \"\"\"\n    try:\n        from hebo.design_space.design_space import DesignSpace\n        from hebo.optimizers.hebo import HEBO\n    except ImportError as e:\n        raise ImportError(\"HEBO is not installed. Please install it with `pip install HEBO`\") from e\n    space = DesignSpace().parse(cfg)\n    opt = HEBO(space)\n    best_mse = float(\"inf\")\n    for i in tqdm(range(1, n_iters + 1), desc=\"HEBO optimization loop\"):\n        rec = opt.suggest(n_suggestions)\n        errors = multiprocess_simulate(\n            fn=fn,\n            error_fn=error_fn,\n            suggestions=rec.to_dict(orient=\"records\"),\n            target=target,\n            fixed_parameters=fixed_parameters,\n        )\n        opt.observe(rec, errors)\n        val = opt.y.min()\n        if val &lt; best_mse:\n            best_mse = val\n            best_params = opt.best_x.iloc[0].to_dict()\n            print(f\"iteration {i} best mse {best_mse}\")\n            print(best_params)\n    return opt\n</code></pre>"},{"location":"api/parallel-reference/","title":"Parallel","text":""},{"location":"api/parallel-reference/#cmtj.utils.parallel.distribute","title":"<code>distribute(simulation_fn, spaces, n_cores=None, shuffle=False)</code>","text":"<p>Distribute a function over a list of parameters in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>simulation_fn</code> <code>Callable</code> <p>function to be distributed</p> required <code>spaces</code> <code>list[list[float]]</code> <p>list of lists of parameters</p> required <code>n_cores</code> <code>int</code> <p>number of cores to use.</p> <code>None</code> <p>Returns:</p> Type Description <p>tuple index (int): Index of the parameters in the spaces list, multiple dims. simulation_fn output (any): The output of the simulation function. index - index of the parameters in the spaces list, multiple dims.</p> Source code in <code>cmtj/utils/parallel.py</code> <pre><code>def distribute(\n    simulation_fn: Callable,\n    spaces: list[list[float]],\n    n_cores: int = None,\n    shuffle: bool = False,\n):\n    \"\"\"\n    Distribute a function over a list of parameters in parallel.\n    :param simulation_fn: function to be distributed\n    :param spaces: list of lists of parameters\n    :param n_cores: number of cores to use.\n    :returns: tuple\n        index (int): Index of the parameters in the spaces list, multiple dims.\n        simulation_fn output (any): The output of the simulation function.\n        index - index of the parameters in the spaces list, multiple dims.\n    \"\"\"\n    spaces = [np.asarray(space) for space in spaces]\n\n    def _get_index(values):\n        return [np.argwhere(space == values[i]).ravel()[0] for i, space in enumerate(spaces)]\n\n    iterables = list(product(*spaces))\n    indexes = [_get_index(val) for val in iterables]\n    # shuffle the indexes\n    if shuffle:\n        index_reshuffle = np.arange(len(indexes))\n        np.random.shuffle(index_reshuffle)\n        # reorder the indexes\n        iterables = np.asarray(iterables)[index_reshuffle].tolist()\n        indexes = np.asarray(indexes)[index_reshuffle].tolist()\n\n    def func_wrapper(iterable):\n        return iterable, simulation_fn(*iterable)\n\n    with Pool(processes=n_cores) as pool:\n        for result in tqdm(pool.imap_unordered(func_wrapper, iterables), total=len(iterables)):\n            iterable, output = result\n            indx = indexes[iterables.index(iterable)]\n            yield indx, output\n</code></pre>"},{"location":"api/parallel-reference/#cmtj.utils.parallel.parallel_vsd_sb_model","title":"<code>parallel_vsd_sb_model(simulation_fn, frequencies, Hvecs, layers, J1=None, J2=None, iDMI=None, n_cores=None)</code>","text":"<p>Parallelise the VSD SB model.</p> <p>Parameters:</p> Name Type Description Default <code>simulation_fn</code> <code>Callable</code> <p>function to be distributed. This function must take a tuple of arguments, where the first argument is the frequency, then Hvectors, the list of layers and finally the list of J1 and J2 values.</p> required <code>frequencies</code> <code>list[float]</code> <p>list of frequencies</p> required <code>Hvecs</code> <code>list[list[float]]</code> <p>list of Hvectors in cartesian coordinates</p> required <code>layers</code> <code>list[LayerDynamic]</code> <p>list of layers</p> required <code>J1</code> <code>list[float]</code> <p>list of J1 values</p> <code>None</code> <code>J2</code> <code>list[float]</code> <p>list of J2 values</p> <code>None</code> <code>n_cores</code> <code>int</code> <p>number of cores to use.</p> <code>None</code> <p>Returns:</p> Type Description <p>list of simulation_fn outputs for each frequency</p> Source code in <code>cmtj/utils/parallel.py</code> <pre><code>def parallel_vsd_sb_model(\n    simulation_fn: Callable,\n    frequencies: list[float],\n    Hvecs: list[list[float]],\n    layers: list[LayerDynamic],\n    J1: list[float] = None,\n    J2: list[float] = None,\n    iDMI: list[float] = None,\n    n_cores: int = None,\n):\n    \"\"\"\n    Parallelise the VSD SB model.\n    :param simulation_fn: function to be distributed.\n        This function must take a tuple of arguments, where the first argument is the\n        frequency, then Hvectors, the list of layers and finally the list of J1 and J2 values.\n    :param frequencies: list of frequencies\n    :param Hvecs: list of Hvectors in cartesian coordinates\n    :param layers: list of layers\n    :param J1: list of J1 values\n    :param J2: list of J2 values\n    :param n_cores: number of cores to use.\n    :returns: list of simulation_fn outputs for each frequency\n    \"\"\"\n    if J1 is None:\n        J1 = [0] * (len(layers) - 1)\n    if J2 is None:\n        J2 = [0] * (len(layers) - 1)\n    if iDMI is None:\n        iDMI = [0] * (len(layers) - 1)\n    args = [(f, Hvecs, *layers, J1, J2, iDMI) for f in frequencies]\n    with Pool(processes=n_cores) as pool:\n        return list(tqdm(pool.imap(simulation_fn, args), total=len(frequencies)))\n</code></pre>"},{"location":"api/plotting-reference/","title":"Plotting","text":""},{"location":"api/plotting-reference/#cmtj.utils.plotting.create_coordinates_plot","title":"<code>create_coordinates_plot(axes, ax_names, result_map, sample=0, alpha_black=0.01)</code>","text":"<p>Create parallel coordinates plot for multidimensional parameter space. Modified from: https://stackoverflow.com/questions/8230638/parallel-coordinates-plot-in-matplotlib</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <p>N list of parameters</p> required <code>ax_names</code> <p>N list of parameter names</p> required <code>result_map</code> <p>map of values (N-dim)</p> required <code>sample</code> <p>if != 0, subsample the parameter space</p> <code>0</code> <code>alpha_black</code> <p>alpha value zero value</p> <code>0.01</code> Source code in <code>cmtj/utils/plotting.py</code> <pre><code>def create_coordinates_plot(axes, ax_names, result_map, sample=0, alpha_black=0.01):\n    \"\"\"Create parallel coordinates plot for multidimensional parameter space.\n    Modified from:\n    https://stackoverflow.com/questions/8230638/parallel-coordinates-plot-in-matplotlib\n    :param axes: N list of parameters\n    :param ax_names: N list of parameter names\n    :param result_map: map of values (N-dim)\n    :param sample: if != 0, subsample the parameter space\n    :param alpha_black: alpha value zero value\n    \"\"\"\n    import matplotlib\n    import matplotlib.cm as cm\n    import matplotlib.patches as patches\n    from matplotlib.path import Path\n\n    with plt.style.context([\"science\", \"nature\"]):\n        fig, host = plt.subplots(dpi=400)\n        ax_lists, value_list = unpack_ndim_map(result_map, axes)\n\n        norm = matplotlib.colors.Normalize(vmin=min(value_list), vmax=max(value_list), clip=True)\n        mapper = cm.ScalarMappable(norm=norm, cmap=cm.magma)\n\n        # organize the data\n        ys = np.dstack([*ax_lists, value_list])[0]\n        indices = np.arange(len(ys))\n        if sample:\n            indices = np.random.choice(indices, sample).ravel()\n        ys = ys[indices]\n\n        ymins = ys.min(axis=0)\n        ymaxs = ys.max(axis=0)\n        dys = ymaxs - ymins\n        ymins -= dys * 0.05  # add 5% padding below and above\n        ymaxs += dys * 0.05\n        dys = ymaxs - ymins\n\n        # transform all data to be compatible with the main axis\n        zs = np.zeros_like(ys)\n        zs[:, 0] = ys[:, 0]\n        zs[:, 1:] = (ys[:, 1:] - ymins[1:]) / dys[1:] * dys[0] + ymins[0]\n\n        axes = [host] + [host.twinx() for _ in range(ys.shape[1] - 1)]\n        for i, ax in enumerate(axes):\n            ax.set_ylim(ymins[i], ymaxs[i])\n            ax.spines[\"top\"].set_visible(False)\n            ax.spines[\"bottom\"].set_visible(False)\n            if ax != host:\n                ax.spines[\"left\"].set_visible(False)\n                ax.yaxis.set_ticks_position(\"right\")\n                ax.spines[\"right\"].set_position((\"axes\", i / (ys.shape[1] - 1)))\n\n        host.set_xlim(0, ys.shape[1] - 1)\n        host.set_xticks(range(ys.shape[1]))\n        host.set_xticklabels(ax_names, fontsize=8)\n        host.tick_params(axis=\"x\", which=\"major\", pad=7)\n        host.spines[\"right\"].set_visible(False)\n        host.xaxis.tick_top()\n        host.set_title(\"Parallel Coordinates Plot\")\n\n        for j in range(ys.shape[0]):\n            # create bezier curves\n            # for each axis, there will a control vertex at the point itself, one at 1/3rd towards the previous and one\n            #   at one third towards the next axis; the first and last axis have one less control vertex\n            # x-coordinate of the control vertices: at each integer (for the axes) and two inbetween\n            # y-coordinate: repeat every point three times, except the first and last only twice\n            verts = list(\n                zip(\n                    list(np.linspace(0, len(ys) - 1, len(ys) * 3 - 2, endpoint=True)),\n                    np.repeat(zs[j, :], 3)[1:-1],\n                )\n            )\n            # for x,y in verts: host.plot(x, y, 'go') # to show the control points of the beziers\n            codes = [Path.MOVETO] + [Path.CURVE4 for _ in range(len(verts) - 1)]\n            path = Path(verts, codes)\n            alpha = alpha_black if ys[j, -1] == 0 else 0.8\n            patch = patches.PathPatch(\n                path,\n                facecolor=\"none\",\n                lw=0.5,\n                edgecolor=mapper.to_rgba(ys[j, -1], alpha),\n            )\n            host.add_patch(patch)\n        fig.tight_layout()\n</code></pre>"},{"location":"api/plotting-reference/#cmtj.utils.plotting.create_stack","title":"<code>create_stack(ax, colors, heights, angles, labels, width=2, labelpad_left=0.2, offset_x=0, offset_y=0, lw_arrow=1.5, ms=10, r=0.6, text_fontsize=4, reversed=True)</code>","text":"<p>Create a material stack plot. If a given layer is to have no arrow, pass None.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <p>matplotlib axis</p> required <code>colors</code> <p>list of colors</p> required <code>heights</code> <p>list of heights</p> required <code>angles</code> <p>list of angles</p> required <code>labels</code> <p>list of labels</p> required <code>width</code> <p>width of the bars</p> <code>2</code> <code>labelpad_left</code> <p>padding of the labels</p> <code>0.2</code> <code>offset_x</code> <p>offset of the patches in x direction</p> <code>0</code> <code>offset_y</code> <p>offset of the patches in y direction</p> <code>0</code> <code>lw_arrow</code> <p>linewidth of the arrows</p> <code>1.5</code> <code>ms</code> <p>mutation size of the arrows</p> <code>10</code> <code>r</code> <p>length of the arrows</p> <code>0.6</code> <code>reversed</code> <p>if True, the stack is reversed</p> <code>True</code> Source code in <code>cmtj/utils/plotting.py</code> <pre><code>def create_stack(\n    ax,\n    colors,\n    heights,\n    angles,\n    labels,\n    width=2,\n    labelpad_left=0.2,\n    offset_x=0,\n    offset_y=0,\n    lw_arrow=1.5,\n    ms=10,\n    r=0.6,\n    text_fontsize=4,\n    reversed=True,\n):\n    \"\"\"\n    Create a material stack plot.\n    If a given layer is to have no arrow, pass None.\n    :param ax: matplotlib axis\n    :param colors: list of colors\n    :param heights: list of heights\n    :param angles: list of angles\n    :param labels: list of labels\n    :param width: width of the bars\n    :param labelpad_left: padding of the labels\n    :param offset_x: offset of the patches in x direction\n    :param offset_y: offset of the patches in y direction\n    :param lw_arrow: linewidth of the arrows\n    :param ms: mutation size of the arrows\n    :param r: length of the arrows\n    :param reversed: if True, the stack is reversed\n    \"\"\"\n    [x, y] = [r, 0]\n    first_offset = offset_y\n    if reversed:\n        heights = heights[::-1]\n        colors = colors[::-1]\n        angles = angles[::-1]\n        labels = labels[::-1]\n    for _i, (height, angle, color, label) in enumerate(zip(heights, angles, colors, labels)):\n        ax.add_patch(patches.Rectangle((offset_x, offset_y), width, height, fill=True, color=color, zorder=10))\n        ax.text(\n            offset_x - labelpad_left,\n            offset_y + height / 2,\n            label,\n            horizontalalignment=\"center\",\n            verticalalignment=\"center\",\n            fontsize=text_fontsize,\n            zorder=11,\n        )\n        if angle is not None:\n            [dx, dy] = np.dot(rotation_matrix(np.deg2rad(angle)), [x, y])\n            x_mid = dx / 2\n            y_mid = dy / 2\n            centre_x = (offset_x + width) / 2 - x_mid\n            centre_y = offset_y + height / 2 - y_mid\n            ax.add_patch(\n                patches.FancyArrowPatch(\n                    (centre_x, centre_y),\n                    (centre_x + dx, centre_y + dy),\n                    mutation_scale=ms,\n                    lw=lw_arrow,\n                    color=\"black\",\n                    zorder=10,\n                )\n            )\n        offset_y += height\n    ax.set_ylim([first_offset - max(heights) / 2, offset_y + max(heights) / 2])\n    ax.set_xlim([offset_x - width / 2, offset_x + width + width / 2])\n    ax.axis(\"off\")\n    return ax\n</code></pre>"},{"location":"api/plotting-reference/#cmtj.utils.plotting.plot_coloured_trajectory","title":"<code>plot_coloured_trajectory(x, y, z, colormap='plasma', ax=None)</code>","text":"<p>Plot a coloured trajectory in 3D. Normalises to unit sphere. Colour of the trajectory now designates the flow of time.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <p>matplotlib axis</p> <code>None</code> <code>x</code> <p>x-coordinates</p> required <code>y</code> <p>y-coordinates</p> required <code>z</code> <p>z-coordinates</p> required <code>colormap</code> <p>colormap to use</p> <code>'plasma'</code> Source code in <code>cmtj/utils/plotting.py</code> <pre><code>def plot_coloured_trajectory(x, y, z, colormap=\"plasma\", ax=None):\n    \"\"\"Plot a coloured trajectory in 3D. Normalises to unit sphere.\n    Colour of the trajectory now designates the flow of time.\n    :param ax: matplotlib axis\n    :param x: x-coordinates\n    :param y: y-coordinates\n    :param z: z-coordinates\n    :param colormap: colormap to use\n    \"\"\"\n    import seaborn as sns\n\n    xs, ys, zs = get_sphere()\n    m = np.asarray([x, y, z])\n    points = m.T.reshape(-1, 1, 3)\n    segs = np.concatenate([points[:-1], points[1:]], axis=1)\n\n    colors = sns.color_palette(colormap, len(segs))\n    if ax is None:\n        with plt.style.context([\"science\", \"nature\"]):\n            fig = plt.figure(dpi=300)\n            ax = fig.add_subplot(1, 1, 1, projection=\"3d\")\n            # plot the sphere firext\n            ax.set_axis_off()\n            ax.plot_surface(\n                xs,\n                ys,\n                zs,\n                rstride=2,\n                cstride=2,\n                color=\"azure\",\n                alpha=0.1,\n                linewidth=0.1,\n            )\n            ax.add_collection(Line3DCollection(segs, colors=colors, alpha=1))\n    else:\n        ax.set_axis_off()\n        ax.plot_surface(xs, ys, zs, rstride=2, cstride=2, color=\"azure\", alpha=0.1, linewidth=0.1)\n        ax.add_collection(Line3DCollection(segs, colors=colors, alpha=1))\n</code></pre>"},{"location":"api/plotting-reference/#cmtj.utils.plotting.plot_trajectory_sphere","title":"<code>plot_trajectory_sphere(x, y, z, color='blue', alpha=1, ax=None)</code>","text":"<p>Plot a trajectory in 3D. Normalises to unit sphere</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <p>matplotlib axis</p> <code>None</code> <code>x</code> <p>x-coordinates</p> required <code>y</code> <p>y-coordinates</p> required <code>z</code> <p>z-coordinates</p> required <code>color</code> <p>color of the trajectory</p> <code>'blue'</code> <code>alpha</code> <p>alpha value of the trajectory</p> <code>1</code> Source code in <code>cmtj/utils/plotting.py</code> <pre><code>def plot_trajectory_sphere(x, y, z, color=\"blue\", alpha=1, ax=None):\n    \"\"\"Plot a trajectory in 3D. Normalises to unit sphere\n    :param ax: matplotlib axis\n    :param x: x-coordinates\n    :param y: y-coordinates\n    :param z: z-coordinates\n    :param color: color of the trajectory\n    :param alpha: alpha value of the trajectory\n    \"\"\"\n    # Compute a unit sphere first\n    xs, ys, zs = get_sphere()\n    m = np.asarray([x, y, z])\n    # make sure we are unit norm for m\n    m = m / np.linalg.norm(m)\n    if ax is None:\n        with plt.style.context([\"science\", \"nature\"]):\n            fig = plt.figure(dpi=300)\n            ax = fig.add_subplot(1, 1, 1, projection=\"3d\")\n            ax.plot3D(m[0], m[1], m[2], color=color, alpha=alpha)\n            ax.set_axis_off()\n            ax.plot_surface(\n                xs,\n                ys,\n                zs,\n                rstride=2,\n                cstride=2,\n                color=\"azure\",\n                alpha=0.1,\n                linewidth=0.1,\n            )\n            ax.scatter([0], [0], [1], color=\"crimson\", alpha=1.0)\n    else:\n        ax.plot3D(m[0], m[1], m[2], color=color, alpha=alpha)\n        ax.set_axis_off()\n        ax.plot_surface(xs, ys, zs, rstride=2, cstride=2, color=\"azure\", alpha=0.1, linewidth=0.1)\n        ax.scatter([0], [0], [1], color=\"crimson\", alpha=1.0)\n</code></pre>"},{"location":"api/plotting-reference/#cmtj.utils.plotting.unpack_ndim_map","title":"<code>unpack_ndim_map(map, axes)</code>","text":"<p>Unpack N-dimensional map into a list of 1-dimensional arrays</p> <p>Parameters:</p> Name Type Description Default <code>map</code> <p>N-dimensional map, each axis is separate parameter space.</p> required <code>axes</code> <p>list of axes to unpack.</p> required Source code in <code>cmtj/utils/plotting.py</code> <pre><code>def unpack_ndim_map(map, axes):\n    \"\"\"\n    Unpack N-dimensional map into a list of 1-dimensional arrays\n    :param map: N-dimensional map, each axis is separate parameter space.\n    :param axes: list of axes to unpack.\n    \"\"\"\n    # how long each one is\n    sample_length = len(axes[0])\n    perm_indx = permutations(range(sample_length), len(axes))\n\n    ax_lists = [[] for _ in axes]\n    value_list = []\n    for indx in perm_indx:\n        value_list.append(map[indx])\n        for i, ax in enumerate(axes):\n            ax_lists[i].append(ax[indx[i]])\n\n    return ax_lists, value_list\n</code></pre>"},{"location":"api/procedures-reference/","title":"Procedures","text":""},{"location":"api/procedures-reference/#cmtj.utils.procedures.ResistanceParameters","title":"<code>ResistanceParameters</code>  <code>dataclass</code>","text":"<p>A data holder for resistance parameters. Not all have to be filled in.</p> Source code in <code>cmtj/utils/procedures.py</code> <pre><code>@dataclass\nclass ResistanceParameters:\n    \"\"\"A data holder for resistance parameters. Not all have to be filled in.\"\"\"\n\n    Rxx0: float = 0\n    Rxy0: float = 0\n    Rahe: float = 0\n    Rsmr: float = 0\n    Ramr: float = 0\n    w: float = 0  # width\n    l: float = 0  # length\n</code></pre>"},{"location":"api/procedures-reference/#cmtj.utils.procedures.PIMM_procedure","title":"<code>PIMM_procedure(junction, Hvecs, int_step, resistance_params, Hoe_direction=Axis.zaxis, Hoe_excitation=50, Hoe_duration=3, simulation_duration=5e-09, wait_time=0.0, max_frequency=80000000000.0, resistance_fn=calculate_resistance_series, disturbance=0.001, take_last_n=100, full_output=False, disable_tqdm=False, static_only=False)</code>","text":"<p>Procedure for computing Pulse Induced Microwave Magnetometry. It computes both PIMM and Resistance (for instance AHE loops). Set <code>static_only</code> to True to only compute the static resistance.</p> <p>Parameters:</p> Name Type Description Default <code>junction</code> <code>Junction</code> <p>junction to be simulated.</p> required <code>Hvecs</code> <code>np.ndarray</code> <p>list of cartesian vectors. (use FieldScan.amplitude_scan or alike)</p> required <code>int_step</code> <code>float</code> <p>integration step [s].</p> required <code>resistance_params</code> <code>list[ResistanceParameters]</code> <p>list of resistance parameters.</p> required <code>Hoe_direction</code> <code>Axis</code> <p>direction of oersted field (x, y or z).</p> <code>Axis.zaxis</code> <code>simulation_duration</code> <code>float</code> <p>duration of simulation [s].</p> <code>5e-09</code> <code>wait_time</code> <code>float</code> <p>time to wait before taking vector for the fft [s].</p> <code>0.0</code> <code>Hoe_duration</code> <code>int</code> <p>duration of Hoe excitation in multiples of in step</p> <code>3</code> <code>max_frequency</code> <code>float</code> <p>maximum frequency -- larger will be dropped [Hz].</p> <code>80000000000.0</code> <code>resistance_fn</code> <code>Callable</code> <p>function to be used to compute the resistance (either calculate_resistance_series or calculate_resistance_parallel).</p> <code>calculate_resistance_series</code> <code>disturbance</code> <code>float</code> <p>disturbance to be applied to the magnetization (std of normal distribution).</p> <code>0.001</code> <code>take_last_n</code> <code>int</code> <p>number of last time steps to be taken for the compuation.</p> <code>100</code> <code>full_output</code> <code>bool</code> <p>if True, return the full trajectories and per layer spectra.</p> <code>False</code> <code>disable_tqdm</code> <code>bool</code> <p>if True, disable tqdm progress bar.</p> <code>False</code> <code>static_only</code> <code>bool</code> <p>if True, only compute the static resistance.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[np.ndarray, np.ndarray, dict[str, Any]]</code> <p>(spectrum, frequencies, other_data) other_data is a dictionary with the following keys: - 'H': Hext field [A/m] - 'Rx': resistance in x direction [Ohm] - 'Ry': resistance in y direction [Ohm] - 'm_avg': average magnetization [unit] - 'm_traj': magnetization trajectories [unit]</p> Source code in <code>cmtj/utils/procedures.py</code> <pre><code>def PIMM_procedure(\n    junction: \"Junction\",\n    Hvecs: np.ndarray,\n    int_step: float,\n    resistance_params: list[ResistanceParameters],\n    Hoe_direction: Axis = Axis.zaxis,\n    Hoe_excitation: float = 50,\n    Hoe_duration: int = 3,\n    simulation_duration: float = 5e-9,\n    wait_time: float = 0e-9,\n    max_frequency: float = 80e9,\n    resistance_fn: Callable = calculate_resistance_series,\n    disturbance: float = 1e-3,\n    take_last_n: int = 100,\n    full_output: bool = False,\n    disable_tqdm: bool = False,\n    static_only: bool = False,\n) -&gt; tuple[np.ndarray, np.ndarray, dict[str, Any]]:\n    \"\"\"Procedure for computing Pulse Induced Microwave Magnetometry.\n    It computes both PIMM and Resistance (for instance AHE loops).\n    Set `static_only` to True to only compute the static resistance.\n    :param junction: junction to be simulated.\n    :param Hvecs: list of cartesian vectors. (use FieldScan.amplitude_scan or alike)\n    :param int_step: integration step [s].\n    :param resistance_params: list of resistance parameters.\n    :param Hoe_direction: direction of oersted field (x, y or z).\n    :param simulation_duration: duration of simulation [s].\n    :param wait_time: time to wait before taking vector for the fft [s].\n    :param Hoe_duration: duration of Hoe excitation in multiples of in step\n    :param max_frequency: maximum frequency -- larger will be dropped [Hz].\n    :param resistance_fn: function to be used to compute the resistance\n        (either calculate_resistance_series or calculate_resistance_parallel).\n    :param disturbance: disturbance to be applied to the magnetization (std of normal distribution).\n    :param take_last_n: number of last time steps to be taken for the compuation.\n    :param full_output: if True, return the full trajectories and per layer spectra.\n    :param disable_tqdm: if True, disable tqdm progress bar.\n    :param static_only: if True, only compute the static resistance.\n    :return: (spectrum, frequencies, other_data)\n    other_data is a dictionary with the following keys:\n    - 'H': Hext field [A/m]\n    - 'Rx': resistance in x direction [Ohm]\n    - 'Ry': resistance in y direction [Ohm]\n    - 'm_avg': average magnetization [unit]\n    - 'm_traj': magnetization trajectories [unit]\n    \"\"\"\n    if wait_time &gt; simulation_duration:\n        raise ValueError(\"wait_time must be smaller than simulation_duration!\")\n    spectrum = []\n    extraction_m_component = None\n    if Hoe_direction == Axis.zaxis:\n        extraction_m_component = \"z\"\n        oedriver = AxialDriver(\n            NullDriver(),\n            NullDriver(),\n            ScalarDriver.getStepDriver(0, Hoe_excitation, 0, int_step * Hoe_duration),\n        )\n    elif Hoe_direction == Axis.yaxis:\n        extraction_m_component = \"y\"\n        oedriver = AxialDriver(\n            NullDriver(),\n            ScalarDriver.getStepDriver(0, Hoe_excitation, 0, int_step * Hoe_duration),\n            NullDriver(),\n        )\n    else:\n        extraction_m_component = \"x\"\n        oedriver = AxialDriver(\n            ScalarDriver.getStepDriver(0, Hoe_excitation, 0, int_step * Hoe_duration),\n            NullDriver(),\n            NullDriver(),\n        )\n\n    # get layer strings\n    layer_ids = junction.getLayerIds()\n    if len(layer_ids) != len(resistance_params):\n        raise ValueError(\"The number of layers in the junction must match the number of resistance parameters!\")\n    output = defaultdict(list)\n    normalising_factor = np.sum([layer.thickness * layer.Ms for layer in junction.layers])\n    freqs = None  # in case of static_only\n    for H in tqdm(Hvecs, desc=\"Computing PIMM\", disable=disable_tqdm):\n        junction.clearLog()\n        junction.setLayerExternalFieldDriver(\n            \"all\",\n            AxialDriver(\n                ScalarDriver.getConstantDriver(H[0]),\n                ScalarDriver.getConstantDriver(H[1]),\n                ScalarDriver.getConstantDriver(H[2]),\n            ),\n        )\n        junction.setLayerOerstedFieldDriver(\"all\", oedriver)\n        if disturbance:\n            for layer_id in layer_ids:\n                old_mag = junction.getLayerMagnetisation(layer_id)\n                new_mag = CVector(\n                    old_mag.x + np.random.normal(0, disturbance),\n                    old_mag.y + np.random.normal(0, disturbance),\n                    old_mag.z + np.random.normal(0, disturbance),\n                )\n                new_mag.normalize()\n                junction.setLayerMagnetisation(layer_id, new_mag)\n        junction.runSimulation(simulation_duration, int_step, int_step)\n        log = junction.getLog()\n        indx = np.argwhere(np.asarray(log[\"time\"]) &gt;= wait_time).ravel()\n        m_traj = np.asarray(\n            [\n                np.asarray(\n                    [\n                        log[f\"{layer.id}_mx\"],\n                        log[f\"{layer.id}_my\"],\n                        log[f\"{layer.id}_mz\"],\n                    ]\n                )\n                * layer.thickness\n                * layer.Ms\n                / normalising_factor\n                for layer in junction.layers\n            ]\n        )\n        m = m_traj[:, :, -take_last_n:]  # all layers, all x, y, z, last 100 steps\n        Rx, Ry = resistance_fn(\n            [r.Rxx0 for r in resistance_params],\n            [r.Rxy0 for r in resistance_params],\n            [r.Ramr for r in resistance_params],\n            [r.Rahe for r in resistance_params],\n            [r.Rsmr for r in resistance_params],\n            m,\n            l=[r.l for r in resistance_params],\n            w=[r.w for r in resistance_params],\n        )\n        if not static_only:\n            mixed = np.asarray(\n                [\n                    np.asarray(log[f\"{layer.id}_m{extraction_m_component}\"])[indx]\n                    * layer.thickness\n                    * layer.Ms\n                    / normalising_factor\n                    for layer in junction.layers\n                ]\n            )\n            mixed_sum = mixed.sum(axis=0)\n            yf, freqs = compute_spectrum_strip(mixed_sum, int_step, max_frequency)\n\n            spectrum.append(yf)\n\n        # fill the output dict\n        output[\"H\"].append(H)\n        output[\"Rx\"].append(Rx)\n        output[\"Ry\"].append(Ry)\n        output[\"m_avg\"].append(m_traj[:, :, -1].sum(0))\n        if full_output and not static_only:\n            output[\"m_traj\"].append(m_traj)\n            for li, layer_id in enumerate(layer_ids):\n                y, _ = compute_spectrum_strip(mixed[li], int_step, max_frequency)\n                output[layer_id].append(y)\n    spectrum = np.squeeze(np.asarray(spectrum))\n    if full_output:\n        for layer_id in layer_ids:\n            output[layer_id] = np.asarray(output[layer_id]).squeeze()\n    return spectrum, freqs, output\n</code></pre>"},{"location":"api/procedures-reference/#cmtj.utils.procedures.VSD_procedure","title":"<code>VSD_procedure(junction, Hvecs, frequencies, int_step, resistance_params=None, Hoe_direction=Axis.yaxis, Hoe_excitation=50, simulation_duration=3e-08, disturbance=0.001, Rtype='Rz', resistance_fn=calculate_resistance_series, disable_tqdm=False)</code>","text":"<p>Procedure for computing Voltage-Spin Diode. We use the Oersted field sine exctitation to excite the system.</p> <p>Parameters:</p> Name Type Description Default <code>junction</code> <code>Junction</code> <p>junction to be simulated.</p> required <code>Hvecs</code> <code>np.ndarray</code> <p>list of cartesian vectors. (use FieldScan.amplitude_scan or alike)</p> required <code>frequencies</code> <code>np.ndarray</code> <p>list of frequencies [Hz].</p> required <code>int_step</code> <code>float</code> <p>integration step [s].</p> required <code>resistance_params</code> <code>list[ResistanceParameters]</code> <p>list of resistance parameters.</p> <code>None</code> <code>Hoe_direction</code> <code>Axis</code> <p>direction of oersted field (x, y or z).</p> <code>Axis.yaxis</code> <code>Hoe_excitation</code> <code>float</code> <p>excitation amplitude of Hoe [A/m].</p> <code>50</code> <code>simulation_duration</code> <code>float</code> <p>duration of simulation [s].</p> <code>3e-08</code> <code>disturbance</code> <code>float</code> <p>disturbance to be applied to the magnetization (std of normal distribution).</p> <code>0.001</code> <code>resistance_fn</code> <code>Callable</code> <p>function to be used to compute the resistance (either calculate_resistance_series or calculate_resistance_parallel). Rz forces standard magnetores.</p> <code>calculate_resistance_series</code> <code>Rtype</code> <code>str</code> <p>type of resistance to be used. (Rx Ry or Rz)</p> <code>'Rz'</code> <code>disable_tqdm</code> <code>bool</code> <p>if True, disable tqdm progress bar.</p> <code>False</code> Source code in <code>cmtj/utils/procedures.py</code> <pre><code>def VSD_procedure(\n    junction: Junction,\n    Hvecs: np.ndarray,\n    frequencies: np.ndarray,\n    int_step: float,\n    resistance_params: list[ResistanceParameters] = None,\n    Hoe_direction: Axis = Axis.yaxis,\n    Hoe_excitation: float = 50,\n    simulation_duration: float = 30e-9,\n    disturbance: float = 1e-3,\n    Rtype: str = \"Rz\",\n    resistance_fn: Callable = calculate_resistance_series,\n    disable_tqdm: bool = False,\n):\n    \"\"\"Procedure for computing Voltage-Spin Diode.\n    We use the Oersted field sine exctitation to excite the system.\n    :param junction: junction to be simulated.\n    :param Hvecs: list of cartesian vectors. (use FieldScan.amplitude_scan or alike)\n    :param frequencies: list of frequencies [Hz].\n    :param int_step: integration step [s].\n    :param resistance_params: list of resistance parameters.\n    :param Hoe_direction: direction of oersted field (x, y or z).\n    :param Hoe_excitation: excitation amplitude of Hoe [A/m].\n    :param simulation_duration: duration of simulation [s].\n    :param disturbance: disturbance to be applied to the magnetization (std of normal distribution).\n    :param resistance_fn: function to be used to compute the resistance\n        (either calculate_resistance_series or calculate_resistance_parallel). Rz forces standard magnetores.\n    :param Rtype: type of resistance to be used. (Rx Ry or Rz)\n    :param disable_tqdm: if True, disable tqdm progress bar.\n    \"\"\"\n    if resistance_params is None:\n        resistance_params = []\n    layer_ids = junction.getLayerIds()\n    if Rtype == \"Rz\" and len(layer_ids) &gt; 2:\n        raise ValueError(\"Rz can only be used for 2 layer junctions. Use Rx or Ry instead.\")\n    elif len(resistance_params) != len(layer_ids):\n        raise ValueError(\"The number of layers in the junction must match the number of resistance parameters!\")\n\n    def simulate_VSD(H: np.ndarray, frequency: float, resistance_params: ResistanceParameters):\n        if Hoe_direction == Axis.zaxis:\n            oedriver = AxialDriver(\n                NullDriver(),\n                NullDriver(),\n                ScalarDriver.getSineDriver(0, Hoe_excitation, frequency, 0),\n            )\n        elif Hoe_direction == Axis.yaxis:\n            oedriver = AxialDriver(\n                NullDriver(),\n                ScalarDriver.getSineDriver(0, Hoe_excitation, frequency, 0),\n                NullDriver(),\n            )\n        else:\n            oedriver = AxialDriver(\n                ScalarDriver.getSineDriver(0, Hoe_excitation, frequency, 0),\n                NullDriver(),\n                NullDriver(),\n            )\n\n        junction.clearLog()\n        junction.setLayerExternalFieldDriver(\n            \"all\",\n            AxialDriver(\n                ScalarDriver.getConstantDriver(H[0]),\n                ScalarDriver.getConstantDriver(H[1]),\n                ScalarDriver.getConstantDriver(H[2]),\n            ),\n        )\n        junction.setLayerOerstedFieldDriver(\"all\", oedriver)\n        if disturbance:\n            for layer_id in layer_ids:\n                old_mag = junction.getLayerMagnetisation(layer_id)\n                new_mag = CVector(\n                    old_mag.x + np.random.normal(0, disturbance),\n                    old_mag.y + np.random.normal(0, disturbance),\n                    old_mag.z + np.random.normal(0, disturbance),\n                )\n                new_mag.normalize()\n                junction.setLayerMagnetisation(layer_id, new_mag)\n        junction.runSimulation(simulation_duration, int_step, int_step)\n        log = junction.getLog()\n        m_traj = np.asarray(\n            [\n                [\n                    log[f\"{layer_ids[i]}_mx\"],\n                    log[f\"{layer_ids[i]}_my\"],\n                    log[f\"{layer_ids[i]}_mz\"],\n                ]\n                for i in range(len(layer_ids))\n            ]\n        )\n        if Rtype == \"Rz\":\n            if len(layer_ids) &gt; 2:\n                raise ValueError(\"Rz can only be used for 2 layer junctions. One layer can be fictisious.\")\n            elif len(layer_ids) == 2:\n                R = log[f\"R_{layer_ids[0]}_{layer_ids[1]}\"]\n            elif len(layer_ids) == 1:\n                R = log[\"Resistance\"]\n            else:\n                raise ValueError(\n                    \"Resistance definition ambiguous!\"\n                    \"If you want to use Rz, you must provide\"\n                    \"a single resistance parameter set or set Rp Rap\"\n                    \" at junction creation.\"\n                )\n        else:\n            Rx, Ry = resistance_fn(\n                [r.Rxx0 for r in resistance_params],\n                [r.Rxy0 for r in resistance_params],\n                [r.Ramr for r in resistance_params],\n                [r.Rahe for r in resistance_params],\n                [r.Rsmr for r in resistance_params],\n                m_traj,\n                l=[r.l for r in resistance_params],\n                w=[r.w for r in resistance_params],\n            )\n            if Rtype == \"Rx\":\n                R = Rx\n            elif Rtype == \"Ry\":\n                R = Ry\n            else:\n                raise ValueError(\"Rtype must be either Rx or Ry or Rz\")\n        dynamicI = np.sin(2 * math.pi * frequency * np.asarray(log[\"time\"]))\n        vmix = compute_sd(R, dynamicI, int_step)\n        return vmix\n\n    spectrum = np.zeros((len(Hvecs), len(frequencies)))\n    for hindx, H in enumerate(tqdm(Hvecs, \"Computing VSD\", disable=disable_tqdm)):\n        for findx, f in enumerate(frequencies):\n            spectrum[hindx, findx] = simulate_VSD(H, f, resistance_params)\n    return spectrum\n</code></pre>"},{"location":"api/procedures-reference/#cmtj.utils.procedures.compute_spectrum_strip","title":"<code>compute_spectrum_strip(input_m, int_step, max_frequency)</code>","text":"<p>Compute the spectrum of a given magnetization trajectory.</p> Source code in <code>cmtj/utils/procedures.py</code> <pre><code>def compute_spectrum_strip(input_m: np.ndarray, int_step: float, max_frequency: float):\n    \"\"\"Compute the spectrum of a given magnetization trajectory.\"\"\"\n    yf = np.abs(fft(input_m))\n    freqs = fftfreq(len(yf), int_step)\n    freqs = freqs[: len(freqs) // 2]\n    yf = yf[: len(yf) // 2]\n\n    findx = np.argwhere(freqs &lt;= max_frequency)\n    freqs = freqs[findx]\n    yf = yf[findx]\n\n    return yf, freqs\n</code></pre>"},{"location":"api/reservoir/","title":"Group interactions","text":""},{"location":"api/reservoir/#cmtj.reservoir.GroupInteraction","title":"<code>GroupInteraction</code>","text":"Source code in <code>cmtj/reservoir/__init__.pyi</code> <pre><code>class GroupInteraction:\n    def __init__(\n        self,\n        coordinateMatrix: list[cmtj.CVector],\n        junctionList: list[cmtj.Junction],\n        topId: str = \"free\",\n    ) -&gt; None:\n        \"\"\"Initialize GroupInteraction for coupled junctions.\n\n        :param coordinateMatrix: List of position vectors for each junction\n        :param junctionList: List of junctions to couple\n        :param topId: ID of the top layer to use for interactions (default: \"free\")\n        :raises RuntimeError: If coordinate and junction lists have different sizes or are empty\n        \"\"\"\n        ...\n\n    def clearLogs(self) -&gt; None:\n        \"\"\"Clear the logs\"\"\"\n        ...\n\n    @overload\n    def getLog(self, junctionIndex: int) -&gt; dict[str, list[float]]:\n        \"\"\"Get the logs for a specific junction.\n\n        :param junctionIndex: Index of the junction\n        :raises RuntimeError: If junction index is out of bounds\n        :return: Dictionary containing log data\n        \"\"\"\n        ...\n\n    @overload\n    def getLog(self) -&gt; dict[str, list[float]]:\n        \"\"\"Get the logs for all junctions.\n\n        :return: Dictionary containing log data\n        \"\"\"\n        ...\n\n    def runSimulation(self, totalTime: float, timeStep: float = 1e-13, writeFrequency: float = 1e-13) -&gt; None:\n        \"\"\"Run the coupled simulation.\n\n        :param totalTime: Total simulation time\n        :param timeStep: Time step for integration\n        :param writeFrequency: How often to write data to logs\n        :raises RuntimeError: If timeStep &gt; writeFrequency or junctions have incompatible solver modes\n        \"\"\"\n        ...\n\n    def setInteractionFunction(\n        self,\n        function: Callable[[cmtj.CVector, cmtj.CVector, cmtj.Layer, cmtj.Layer], cmtj.CVector],\n    ) -&gt; None:\n        \"\"\"Set the interaction function for the coupled junctions.\n\n        :param function: Interaction function.\n            Either `computeDipoleInteraction` or `computeDipoleInteractionNoumra` or `nullDipoleInteraction`\n            or provide your own custom function.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/reservoir/#cmtj.reservoir.GroupInteraction.__init__","title":"<code>__init__(coordinateMatrix, junctionList, topId='free')</code>","text":"<p>Initialize GroupInteraction for coupled junctions.</p> <p>Parameters:</p> Name Type Description Default <code>coordinateMatrix</code> <code>list[cmtj.CVector]</code> <p>List of position vectors for each junction</p> required <code>junctionList</code> <code>list[cmtj.Junction]</code> <p>List of junctions to couple</p> required <code>topId</code> <code>str</code> <p>ID of the top layer to use for interactions (default: \"free\")</p> <code>'free'</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If coordinate and junction lists have different sizes or are empty</p> Source code in <code>cmtj/reservoir/__init__.pyi</code> <pre><code>def __init__(\n    self,\n    coordinateMatrix: list[cmtj.CVector],\n    junctionList: list[cmtj.Junction],\n    topId: str = \"free\",\n) -&gt; None:\n    \"\"\"Initialize GroupInteraction for coupled junctions.\n\n    :param coordinateMatrix: List of position vectors for each junction\n    :param junctionList: List of junctions to couple\n    :param topId: ID of the top layer to use for interactions (default: \"free\")\n    :raises RuntimeError: If coordinate and junction lists have different sizes or are empty\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/reservoir/#cmtj.reservoir.GroupInteraction.clearLogs","title":"<code>clearLogs()</code>","text":"<p>Clear the logs</p> Source code in <code>cmtj/reservoir/__init__.pyi</code> <pre><code>def clearLogs(self) -&gt; None:\n    \"\"\"Clear the logs\"\"\"\n    ...\n</code></pre>"},{"location":"api/reservoir/#cmtj.reservoir.GroupInteraction.runSimulation","title":"<code>runSimulation(totalTime, timeStep=1e-13, writeFrequency=1e-13)</code>","text":"<p>Run the coupled simulation.</p> <p>Parameters:</p> Name Type Description Default <code>totalTime</code> <code>float</code> <p>Total simulation time</p> required <code>timeStep</code> <code>float</code> <p>Time step for integration</p> <code>1e-13</code> <code>writeFrequency</code> <code>float</code> <p>How often to write data to logs</p> <code>1e-13</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If timeStep &gt; writeFrequency or junctions have incompatible solver modes</p> Source code in <code>cmtj/reservoir/__init__.pyi</code> <pre><code>def runSimulation(self, totalTime: float, timeStep: float = 1e-13, writeFrequency: float = 1e-13) -&gt; None:\n    \"\"\"Run the coupled simulation.\n\n    :param totalTime: Total simulation time\n    :param timeStep: Time step for integration\n    :param writeFrequency: How often to write data to logs\n    :raises RuntimeError: If timeStep &gt; writeFrequency or junctions have incompatible solver modes\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/reservoir/#cmtj.reservoir.GroupInteraction.setInteractionFunction","title":"<code>setInteractionFunction(function)</code>","text":"<p>Set the interaction function for the coupled junctions.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable[[cmtj.CVector, cmtj.CVector, cmtj.Layer, cmtj.Layer], cmtj.CVector]</code> <p>Interaction function. Either <code>computeDipoleInteraction</code> or <code>computeDipoleInteractionNoumra</code> or <code>nullDipoleInteraction</code> or provide your own custom function.</p> required Source code in <code>cmtj/reservoir/__init__.pyi</code> <pre><code>def setInteractionFunction(\n    self,\n    function: Callable[[cmtj.CVector, cmtj.CVector, cmtj.Layer, cmtj.Layer], cmtj.CVector],\n) -&gt; None:\n    \"\"\"Set the interaction function for the coupled junctions.\n\n    :param function: Interaction function.\n        Either `computeDipoleInteraction` or `computeDipoleInteractionNoumra` or `nullDipoleInteraction`\n        or provide your own custom function.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/reservoir/#cmtj.reservoir.Reservoir","title":"<code>Reservoir</code>","text":"Source code in <code>cmtj/reservoir/__init__.pyi</code> <pre><code>class Reservoir:\n    def __init__(\n        self,\n        coordinateMatrix: list[list[cmtj.CVector]],\n        layerMatrix: list[list[cmtj.Layer]],\n    ) -&gt; None:\n        \"\"\"Initialize Reservoir simulation.\n\n        :param coordinateMatrix: 2D matrix of position vectors\n        :param layerMatrix: 2D matrix of magnetic layers\n        \"\"\"\n        ...\n\n    def clearLogs(self) -&gt; None: ...\n    def getLayer(self, arg0: int) -&gt; cmtj.Layer:\n        \"\"\"Get layer at the specified index (using row-major ordering).\n\n        :param arg0: Index of the layer\n        :return: Layer object\n        \"\"\"\n        ...\n\n    def getMagnetisation(self, arg0: int) -&gt; cmtj.CVector:\n        \"\"\"Get magnetization vector for layer at specified index (using row-major ordering).\n\n        :param arg0: Index of the layer\n        :return: Magnetization vector\n        \"\"\"\n        ...\n\n    def runSimulation(self, totalTime: float, timeStep: float) -&gt; None:\n        \"\"\"Run reservoir simulation and log data.\n\n        :param totalTime: Total simulation time\n        :param timeStep: Integration time step\n        \"\"\"\n        ...\n\n    def saveLogs(self, filename: str) -&gt; None:\n        \"\"\"Save simulation logs to file.\n\n        :param filename: Path to save the log file. Empty string will skip saving.\n        \"\"\"\n        ...\n\n    def setAllExternalField(self, driver: cmtj.AxialDriver) -&gt; None:\n        \"\"\"Set external field for all layers.\n\n        :param driver: External field driver\n        \"\"\"\n        ...\n\n    def setLayerAnisotropy(self, arg0: int, driver: cmtj.ScalarDriver) -&gt; None:\n        \"\"\"Set anisotropy for specific layer.\n\n        :param arg0: Layer index\n        :param driver: Anisotropy driver\n        \"\"\"\n        ...\n\n    def setLayerExternalField(self, arg0: int, driver: cmtj.AxialDriver) -&gt; None:\n        \"\"\"Set external field for specific layer.\n\n        :param arg0: Layer index\n        :param driver: External field driver\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/reservoir/#cmtj.reservoir.Reservoir.__init__","title":"<code>__init__(coordinateMatrix, layerMatrix)</code>","text":"<p>Initialize Reservoir simulation.</p> <p>Parameters:</p> Name Type Description Default <code>coordinateMatrix</code> <code>list[list[cmtj.CVector]]</code> <p>2D matrix of position vectors</p> required <code>layerMatrix</code> <code>list[list[cmtj.Layer]]</code> <p>2D matrix of magnetic layers</p> required Source code in <code>cmtj/reservoir/__init__.pyi</code> <pre><code>def __init__(\n    self,\n    coordinateMatrix: list[list[cmtj.CVector]],\n    layerMatrix: list[list[cmtj.Layer]],\n) -&gt; None:\n    \"\"\"Initialize Reservoir simulation.\n\n    :param coordinateMatrix: 2D matrix of position vectors\n    :param layerMatrix: 2D matrix of magnetic layers\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/reservoir/#cmtj.reservoir.Reservoir.getLayer","title":"<code>getLayer(arg0)</code>","text":"<p>Get layer at the specified index (using row-major ordering).</p> <p>Parameters:</p> Name Type Description Default <code>arg0</code> <code>int</code> <p>Index of the layer</p> required <p>Returns:</p> Type Description <code>cmtj.Layer</code> <p>Layer object</p> Source code in <code>cmtj/reservoir/__init__.pyi</code> <pre><code>def getLayer(self, arg0: int) -&gt; cmtj.Layer:\n    \"\"\"Get layer at the specified index (using row-major ordering).\n\n    :param arg0: Index of the layer\n    :return: Layer object\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/reservoir/#cmtj.reservoir.Reservoir.getMagnetisation","title":"<code>getMagnetisation(arg0)</code>","text":"<p>Get magnetization vector for layer at specified index (using row-major ordering).</p> <p>Parameters:</p> Name Type Description Default <code>arg0</code> <code>int</code> <p>Index of the layer</p> required <p>Returns:</p> Type Description <code>cmtj.CVector</code> <p>Magnetization vector</p> Source code in <code>cmtj/reservoir/__init__.pyi</code> <pre><code>def getMagnetisation(self, arg0: int) -&gt; cmtj.CVector:\n    \"\"\"Get magnetization vector for layer at specified index (using row-major ordering).\n\n    :param arg0: Index of the layer\n    :return: Magnetization vector\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/reservoir/#cmtj.reservoir.Reservoir.runSimulation","title":"<code>runSimulation(totalTime, timeStep)</code>","text":"<p>Run reservoir simulation and log data.</p> <p>Parameters:</p> Name Type Description Default <code>totalTime</code> <code>float</code> <p>Total simulation time</p> required <code>timeStep</code> <code>float</code> <p>Integration time step</p> required Source code in <code>cmtj/reservoir/__init__.pyi</code> <pre><code>def runSimulation(self, totalTime: float, timeStep: float) -&gt; None:\n    \"\"\"Run reservoir simulation and log data.\n\n    :param totalTime: Total simulation time\n    :param timeStep: Integration time step\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/reservoir/#cmtj.reservoir.Reservoir.saveLogs","title":"<code>saveLogs(filename)</code>","text":"<p>Save simulation logs to file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to save the log file. Empty string will skip saving.</p> required Source code in <code>cmtj/reservoir/__init__.pyi</code> <pre><code>def saveLogs(self, filename: str) -&gt; None:\n    \"\"\"Save simulation logs to file.\n\n    :param filename: Path to save the log file. Empty string will skip saving.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/reservoir/#cmtj.reservoir.Reservoir.setAllExternalField","title":"<code>setAllExternalField(driver)</code>","text":"<p>Set external field for all layers.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>cmtj.AxialDriver</code> <p>External field driver</p> required Source code in <code>cmtj/reservoir/__init__.pyi</code> <pre><code>def setAllExternalField(self, driver: cmtj.AxialDriver) -&gt; None:\n    \"\"\"Set external field for all layers.\n\n    :param driver: External field driver\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/reservoir/#cmtj.reservoir.Reservoir.setLayerAnisotropy","title":"<code>setLayerAnisotropy(arg0, driver)</code>","text":"<p>Set anisotropy for specific layer.</p> <p>Parameters:</p> Name Type Description Default <code>arg0</code> <code>int</code> <p>Layer index</p> required <code>driver</code> <code>cmtj.ScalarDriver</code> <p>Anisotropy driver</p> required Source code in <code>cmtj/reservoir/__init__.pyi</code> <pre><code>def setLayerAnisotropy(self, arg0: int, driver: cmtj.ScalarDriver) -&gt; None:\n    \"\"\"Set anisotropy for specific layer.\n\n    :param arg0: Layer index\n    :param driver: Anisotropy driver\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/reservoir/#cmtj.reservoir.Reservoir.setLayerExternalField","title":"<code>setLayerExternalField(arg0, driver)</code>","text":"<p>Set external field for specific layer.</p> <p>Parameters:</p> Name Type Description Default <code>arg0</code> <code>int</code> <p>Layer index</p> required <code>driver</code> <code>cmtj.AxialDriver</code> <p>External field driver</p> required Source code in <code>cmtj/reservoir/__init__.pyi</code> <pre><code>def setLayerExternalField(self, arg0: int, driver: cmtj.AxialDriver) -&gt; None:\n    \"\"\"Set external field for specific layer.\n\n    :param arg0: Layer index\n    :param driver: External field driver\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/reservoir/#cmtj.reservoir.computeDipoleInteraction","title":"<code>computeDipoleInteraction(r1, r2, layer1, layer2)</code>","text":"<p>Compute dipole interaction between two junctions (Kanao et al. 2019 PRA).</p> <p>Parameters:</p> Name Type Description Default <code>r1</code> <code>cmtj.CVector</code> <p>Position vector of the first junction</p> required <code>r2</code> <code>cmtj.CVector</code> <p>Position vector of the second junction</p> required <code>layer1</code> <code>cmtj.Layer</code> <p>Magnetic layer of the first junction</p> required <code>layer2</code> <code>cmtj.Layer</code> <p>Magnetic layer of the second junction</p> required <p>Returns:</p> Type Description <code>cmtj.CVector</code> <p>Dipole interaction vector</p> Source code in <code>cmtj/reservoir/__init__.pyi</code> <pre><code>def computeDipoleInteraction(\n    r1: cmtj.CVector, r2: cmtj.CVector, layer1: cmtj.Layer, layer2: cmtj.Layer\n) -&gt; cmtj.CVector:\n    \"\"\"Compute dipole interaction between two junctions (Kanao et al. 2019 PRA).\n\n    :param r1: Position vector of the first junction\n    :param r2: Position vector of the second junction\n    :param layer1: Magnetic layer of the first junction\n    :param layer2: Magnetic layer of the second junction\n\n    :return: Dipole interaction vector\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/reservoir/#cmtj.reservoir.computeDipoleInteractionNoumra","title":"<code>computeDipoleInteractionNoumra(r1, r2, layer1, layer2)</code>","text":"<p>Compute dipole interaction between two junctions (Nomura et al. 2019 JJAP).</p> <p>Parameters:</p> Name Type Description Default <code>r1</code> <code>cmtj.CVector</code> <p>Position vector of the first junction</p> required <code>r2</code> <code>cmtj.CVector</code> <p>Position vector of the second junction</p> required <code>layer1</code> <code>cmtj.Layer</code> <p>Magnetic layer of the first junction</p> required <code>layer2</code> <code>cmtj.Layer</code> <p>Magnetic layer of the second junction</p> required <p>Returns:</p> Type Description <code>cmtj.CVector</code> <p>Dipole interaction vector</p> Source code in <code>cmtj/reservoir/__init__.pyi</code> <pre><code>def computeDipoleInteractionNoumra(\n    r1: cmtj.CVector, r2: cmtj.CVector, layer1: cmtj.Layer, layer2: cmtj.Layer\n) -&gt; cmtj.CVector:\n    \"\"\"Compute dipole interaction between two junctions (Nomura et al. 2019 JJAP).\n\n    :param r1: Position vector of the first junction\n    :param r2: Position vector of the second junction\n    :param layer1: Magnetic layer of the first junction\n    :param layer2: Magnetic layer of the second junction\n\n    :return: Dipole interaction vector\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/reservoir/#cmtj.reservoir.nullDipoleInteraction","title":"<code>nullDipoleInteraction(r1, r2, layer1, layer2)</code>","text":"<p>Compute null dipole interaction between two junctions. This is a placeholder function that returns a zero vector.</p> <p>Parameters:</p> Name Type Description Default <code>r1</code> <code>cmtj.CVector</code> <p>Position vector of the first junction</p> required <code>r2</code> <code>cmtj.CVector</code> <p>Position vector of the second junction</p> required <code>layer1</code> <code>cmtj.Layer</code> <p>Magnetic layer of the first junction</p> required <code>layer2</code> <code>cmtj.Layer</code> <p>Magnetic layer of the second junction</p> required <p>Returns:</p> Type Description <code>cmtj.CVector</code> <p>Zero vector</p> Source code in <code>cmtj/reservoir/__init__.pyi</code> <pre><code>def nullDipoleInteraction(r1: cmtj.CVector, r2: cmtj.CVector, layer1: cmtj.Layer, layer2: cmtj.Layer) -&gt; cmtj.CVector:\n    \"\"\"Compute null dipole interaction between two junctions.\n    This is a placeholder function that returns a zero vector.\n\n    :param r1: Position vector of the first junction\n    :param r2: Position vector of the second junction\n    :param layer1: Magnetic layer of the first junction\n    :param layer2: Magnetic layer of the second junction\n\n    :return: Zero vector\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/resistance-reference/","title":"Resistance functions","text":"<p>Those functions are used to compute the resistance of a given system. They are all defined in the <code>resistance</code> module for version upside of 1.2.0.</p>"},{"location":"api/resistance-reference/#cmtj.utils.resistance.GMR_expr","title":"<code>GMR_expr()</code>","text":"<p>Get the symbolic expression for the GMR.</p> <p>Returns:</p> Type Description <code>Callable[[float, float, float, float], float]</code> <p>GMR function: Callable[[theta1, phi1, theta2, phi2], float]</p> Source code in <code>cmtj/utils/resistance.py</code> <pre><code>def GMR_expr() -&gt; Callable[[float, float, float, float], float]:\n    \"\"\"Get the symbolic expression for the GMR.\n\n    :returns: GMR function: Callable[[theta1, phi1, theta2, phi2], float]\n    \"\"\"\n    GMR_s = sym.Symbol(r\"\\mathrm{GMR}\")\n    theta1 = sym.Symbol(r\"\\theta_1\")\n    phi1 = sym.Symbol(r\"\\phi_1\")\n    m1 = sym.Matrix(\n        [\n            sym.sin(theta1) * sym.cos(phi1),\n            sym.sin(theta1) * sym.sin(phi1),\n            sym.cos(theta1),\n        ]\n    )\n    theta2 = sym.Symbol(r\"\\theta_2\")\n    phi2 = sym.Symbol(r\"\\phi_2\")\n    m2 = sym.Matrix(\n        [\n            sym.sin(theta2) * sym.cos(phi2),\n            sym.sin(theta2) * sym.sin(phi2),\n            sym.cos(theta2),\n        ]\n    )\n    Rf = GMR_s * (1 - m1.dot(m2)) / 2\n    dRdt1 = sym.diff(Rf, theta1)\n    dRdp1 = sym.diff(Rf, phi1)\n    dRdt2 = sym.diff(Rf, theta2)\n    dRdp2 = sym.diff(Rf, phi2)\n    linearised_terms = sym.symbols(r\"\\partial\\theta_1, \\partial\\phi_1, \\partial\\theta_2, \\partial\\phi_2\")\n    dRf = (\n        dRdt1 * linearised_terms[0]\n        + dRdp1 * linearised_terms[1]\n        + dRdt2 * linearised_terms[2]\n        + dRdp2 * linearised_terms[3]\n    )\n\n    Rf_func = sym.lambdify([GMR_s, [theta1, phi1, theta2, phi2]], Rf)\n    dRf_func = sym.lambdify([GMR_s, [theta1, phi1, theta2, phi2], linearised_terms], dRf)\n    return Rf_func, dRf_func\n</code></pre>"},{"location":"api/resistance-reference/#cmtj.utils.resistance.Rxx_parallel_bilayer_expr","title":"<code>Rxx_parallel_bilayer_expr()</code>","text":"<p>Get the symbolic expressions for the parallel and linearised resistance of a bilayer system.</p> <p>Signals: - GMR: GMR - AMR1: AMR of layer 1 - SMR1: SMR of layer 1 - AMR2: AMR of layer 2 - SMR2: SMR of layer 2 - stationary angles: [t1, p1, t2, p2] - linearised angles: [dt1, dp1, dt2, dp2]</p> <p>Function signatures - Rlin_func: linearised resistance function     f(GMR, AMR1, SMR1, AMR2, SMR2, [t1, p1, t2, p2], [dt1, dp1, dt2, dp2]) - R_func: series resistance function     f(GMR, AMR1, SMR1, AMR2, SMR2, [t1, p1, t2, p2])</p> <p>Returns:</p> Type Description <code>tuple[Callable[[float, float, float, float, float, float, float, float, float, float, float, float, float, float], float], Callable[[float, float, float, float, float, float, float, float, float, float, float, float, float, float], float]]</code> <p>linearised and parallel resistance functions</p> Source code in <code>cmtj/utils/resistance.py</code> <pre><code>def Rxx_parallel_bilayer_expr() -&gt; (\n    tuple[\n        Callable[\n            [\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n            ],\n            float,\n        ],\n        Callable[\n            [\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n            ],\n            float,\n        ],\n    ]\n):\n    \"\"\"Get the symbolic expressions for the parallel and linearised resistance of a bilayer system.\n\n    Signals:\n    - GMR: GMR\n    - AMR1: AMR of layer 1\n    - SMR1: SMR of layer 1\n    - AMR2: AMR of layer 2\n    - SMR2: SMR of layer 2\n    - stationary angles: [t1, p1, t2, p2]\n    - linearised angles: [dt1, dp1, dt2, dp2]\n\n    Function signatures\n    - Rlin_func: linearised resistance function\n        f(GMR, AMR1, SMR1, AMR2, SMR2, [t1, p1, t2, p2], [dt1, dp1, dt2, dp2])\n    - R_func: series resistance function\n        f(GMR, AMR1, SMR1, AMR2, SMR2, [t1, p1, t2, p2])\n\n    :returns: linearised and parallel resistance functions\n    \"\"\"\n    AMR_1 = sym.Symbol(r\"\\mathrm{AMR}_1\")\n    SMR_1 = sym.Symbol(r\"\\mathrm{SMR}_1\")\n    AMR_2 = sym.Symbol(r\"\\mathrm{AMR}_2\")\n    SMR_2 = sym.Symbol(r\"\\mathrm{SMR}_2\")\n    GMR_s = sym.Symbol(r\"\\mathrm{GMR}\")\n    R_1, t1, p1, m1 = Rxx_symbolic(1, AMR_1, SMR_1)\n    R_2, t2, p2, m2 = Rxx_symbolic(2, AMR_2, SMR_2)\n    gmr_term = GMR_s * (1 - m1.dot(m2)) / 2\n\n    Rparallel = gmr_term + (R_1 * R_2) / (R_1 + R_2 + EPS)\n    linearised_terms = sym.symbols(r\"\\partial\\theta_1, \\partial\\phi_1, \\partial\\theta_2, \\partial\\phi_2\")\n    dRdtheta1 = sym.diff(Rparallel, t1) * linearised_terms[0]\n    dRdphi1 = sym.diff(Rparallel, p1) * linearised_terms[1]\n    dRdtheta2 = sym.diff(Rparallel, t2) * linearised_terms[2]\n    dRdphi2 = sym.diff(Rparallel, p2) * linearised_terms[3]\n\n    linearised_R = dRdtheta1 + dRdtheta2 + dRdphi1 + dRdphi2\n\n    Rlin_func = sym.lambdify(\n        [GMR_s, AMR_1, SMR_1, AMR_2, SMR_2, [t1, p1, t2, p2], linearised_terms],\n        linearised_R,\n    )\n    R_func = sym.lambdify([GMR_s, AMR_1, SMR_1, AMR_2, SMR_2, [t1, p1, t2, p2]], Rparallel)\n\n    return Rlin_func, R_func\n</code></pre>"},{"location":"api/resistance-reference/#cmtj.utils.resistance.Rxx_series_bilayer_expr","title":"<code>Rxx_series_bilayer_expr()</code>","text":"<p>Get the symbolic expressions for the series and linearised resistance of a bilayer system.</p> <p>Signals: - GMR: GMR - AMR1: AMR of layer 1 - SMR1: SMR of layer 1 - AMR2: AMR of layer 2 - SMR2: SMR of layer 2 - stationary angles: [t1, p1, t2, p2] - linearised angles: [dt1, dp1, dt2, dp2]</p> <p>Function signatures - Rlin_func: linearised resistance function     f(GMR, AMR1, SMR1, AMR2, SMR2, [t1, p1, t2, p2], [dt1, dp1, dt2, dp2]) - R_func: series resistance function     f(GMR, AMR1, SMR1, AMR2, SMR2, [t1, p1, t2, p2])</p> <p>Returns:</p> Type Description <code>tuple[Callable[[float, float, float, float, float, float, float, float, float, float, float, float, float, float], float], Callable[[float, float, float, float, float, float, float, float, float, float, float, float, float, float], float]]</code> <p>linearised and series resistance functions</p> Source code in <code>cmtj/utils/resistance.py</code> <pre><code>def Rxx_series_bilayer_expr() -&gt; (\n    tuple[\n        Callable[\n            [\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n            ],\n            float,\n        ],\n        Callable[\n            [\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n                float,\n            ],\n            float,\n        ],\n    ]\n):\n    \"\"\"Get the symbolic expressions for the series and linearised resistance of a bilayer system.\n\n    Signals:\n    - GMR: GMR\n    - AMR1: AMR of layer 1\n    - SMR1: SMR of layer 1\n    - AMR2: AMR of layer 2\n    - SMR2: SMR of layer 2\n    - stationary angles: [t1, p1, t2, p2]\n    - linearised angles: [dt1, dp1, dt2, dp2]\n\n    Function signatures\n    - Rlin_func: linearised resistance function\n        f(GMR, AMR1, SMR1, AMR2, SMR2, [t1, p1, t2, p2], [dt1, dp1, dt2, dp2])\n    - R_func: series resistance function\n        f(GMR, AMR1, SMR1, AMR2, SMR2, [t1, p1, t2, p2])\n\n    :returns: linearised and series resistance functions\n    \"\"\"\n    AMR_1 = sym.Symbol(r\"\\mathrm{AMR}_1\")\n    SMR_1 = sym.Symbol(r\"\\mathrm{SMR}_1\")\n    AMR_2 = sym.Symbol(r\"\\mathrm{AMR}_2\")\n    SMR_2 = sym.Symbol(r\"\\mathrm{SMR}_2\")\n    GMR_s = sym.Symbol(r\"\\mathrm{GMR}\")\n    R_1, t1, p1, m1 = Rxx_symbolic(1, AMR_1, SMR_1)\n    R_2, t2, p2, m2 = Rxx_symbolic(2, AMR_2, SMR_2)\n    gmr_term = GMR_s * (1 - m1.dot(m2)) / 2\n\n    Rseries = gmr_term + R_1 + R_2\n    linearised_terms = sym.symbols(r\"\\partial\\theta_1, \\partial\\phi_1, \\partial\\theta_2, \\partial\\phi_2\")\n    dRdtheta1 = sym.diff(Rseries, t1) * linearised_terms[0]\n    dRdphi1 = sym.diff(Rseries, p1) * linearised_terms[1]\n    dRdtheta2 = sym.diff(Rseries, t2) * linearised_terms[2]\n    dRdphi2 = sym.diff(Rseries, p2) * linearised_terms[3]\n\n    linearised_R = dRdtheta1 + dRdtheta2 + dRdphi1 + dRdphi2\n\n    Rlin_func = sym.lambdify(\n        [GMR_s, AMR_1, SMR_1, AMR_2, SMR_2, [t1, p1, t2, p2], linearised_terms],\n        linearised_R,\n    )\n    R_func = sym.lambdify([GMR_s, AMR_1, SMR_1, AMR_2, SMR_2, [t1, p1, t2, p2]], Rseries)\n\n    return Rlin_func, R_func\n</code></pre>"},{"location":"api/resistance-reference/#cmtj.utils.resistance.Rxx_symbolic","title":"<code>Rxx_symbolic(id, AMR, SMR)</code>  <code>cached</code>","text":"<p>Compute the Rxx resistance for a given layer.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>layer id</p> required <code>AMR</code> <code>float</code> <p>anisotropic magnetoresistance</p> required <code>SMR</code> <code>float</code> <p>spin Hall magnetoresistance</p> required Source code in <code>cmtj/utils/resistance.py</code> <pre><code>@lru_cache(maxsize=5)\ndef Rxx_symbolic(id: int, AMR: float, SMR: float) -&gt; tuple[float, sym.Symbol, sym.Symbol, sym.Matrix]:\n    \"\"\"Compute the Rxx resistance for a given layer.\n    :param id: layer id\n    :param AMR: anisotropic magnetoresistance\n    :param SMR: spin Hall magnetoresistance\n    \"\"\"\n    theta1 = sym.Symbol(r\"\\theta_\" + str(id))\n    phi1 = sym.Symbol(r\"\\phi_\" + str(id))\n    m = sym.Matrix(\n        [\n            sym.sin(theta1) * sym.cos(phi1),\n            sym.sin(theta1) * sym.sin(phi1),\n            sym.cos(theta1),\n        ]\n    )\n    return AMR * m[0] ** 2 + SMR * m[1] ** 2, theta1, phi1, m\n</code></pre>"},{"location":"api/resistance-reference/#cmtj.utils.resistance.Rxy_symbolic","title":"<code>Rxy_symbolic(id, AMR, SMR, AHE, w_l)</code>  <code>cached</code>","text":"<p>Compute the Rxy resistance for a given layer.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>layer id</p> required <code>AMR</code> <code>float</code> <p>anisotropic magnetoresistance</p> required <code>SMR</code> <code>float</code> <p>spin Hall magnetoresistance</p> required <code>AHE</code> <code>float</code> <p>anomalous Hall effect</p> required <code>w_l</code> <code>float</code> <p>width to length ratio</p> required Source code in <code>cmtj/utils/resistance.py</code> <pre><code>@lru_cache(maxsize=5)\ndef Rxy_symbolic(\n    id: int, AMR: float, SMR: float, AHE: float, w_l: float\n) -&gt; tuple[float, sym.Symbol, sym.Symbol, sym.Matrix]:\n    \"\"\"Compute the Rxy resistance for a given layer.\n    :param id: layer id\n    :param AMR: anisotropic magnetoresistance\n    :param SMR: spin Hall magnetoresistance\n    :param AHE: anomalous Hall effect\n    :param w_l: width to length ratio\n    \"\"\"\n    theta1 = sym.Symbol(r\"\\theta_\" + str(id))\n    phi1 = sym.Symbol(r\"\\phi_\" + str(id))\n    m = sym.Matrix(\n        [\n            sym.sin(theta1) * sym.cos(phi1),\n            sym.sin(theta1) * sym.sin(phi1),\n            sym.cos(theta1),\n        ]\n    )\n    return (0.5 * AHE * m[-1]) + w_l * (SMR - AMR) * m[0] * m[1], theta1, phi1, m\n</code></pre>"},{"location":"api/resistance-reference/#cmtj.utils.resistance.angular_calculate_resistance_gmr","title":"<code>angular_calculate_resistance_gmr(Rp, Rap, theta_1, phi_1, theta_2, phi_2)</code>","text":"<p>Computes the GMR using parallel and antiparallel resistance.</p> <p>Parameters:</p> Name Type Description Default <code>Rp</code> <code>float</code> <p>parallel resistance</p> required <code>Rap</code> <code>float</code> <p>antiparallel resistance</p> required <code>theta_1</code> <code>np.ndarray</code> <p>angle of layer 1</p> required <code>phi_1</code> <code>np.ndarray</code> <p>angle of layer 1</p> required <code>theta_2</code> <code>np.ndarray</code> <p>angle of layer 2</p> required <code>phi_2</code> <code>np.ndarray</code> <p>angle of layer 2</p> required Source code in <code>cmtj/utils/resistance.py</code> <pre><code>def angular_calculate_resistance_gmr(\n    Rp: float,\n    Rap: float,\n    theta_1: np.ndarray,\n    phi_1: np.ndarray,\n    theta_2: np.ndarray,\n    phi_2: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"Computes the GMR using parallel and antiparallel resistance.\n    :param Rp: parallel resistance\n    :param Rap: antiparallel resistance\n    :param theta_1: angle of layer 1\n    :param phi_1: angle of layer 1\n    :param theta_2: angle of layer 2\n    :param phi_2: angle of layer 2\n    \"\"\"\n    m1 = np.array(\n        [\n            np.cos(theta_1) * np.cos(phi_1),\n            np.cos(theta_1) * np.sin(phi_1),\n            np.sin(theta_1),\n        ]\n    )\n    m2 = np.array(\n        [\n            np.cos(theta_2) * np.cos(phi_2),\n            np.cos(theta_2) * np.sin(phi_2),\n            np.sin(theta_2),\n        ]\n    )\n    return compute_gmr(Rp, Rap, m1, m2)\n</code></pre>"},{"location":"api/resistance-reference/#cmtj.utils.resistance.calculate_linearised_resistance","title":"<code>calculate_linearised_resistance(GMR, AMR, SMR)</code>","text":"<p>Compute the resistance of the two FM bilayer system from the linearised angles.</p> <p>Parameters:</p> Name Type Description Default <code>GMR</code> <code>float</code> <p>GMR</p> required <code>AMR</code> <code>list[float]</code> <p>AMR</p> required <code>SMR</code> <code>list[float]</code> <p>SMR</p> required Source code in <code>cmtj/utils/resistance.py</code> <pre><code>def calculate_linearised_resistance(\n    GMR: float,\n    AMR: list[float],\n    SMR: list[float],\n) -&gt; tuple[float, float, float, sym.Symbol, sym.Symbol, sym.Symbol, sym.Symbol]:\n    \"\"\"\n    Compute the resistance of the two FM bilayer system from the linearised angles.\n\n    :param GMR: GMR\n    :param AMR: AMR\n    :param SMR: SMR\n    \"\"\"\n\n    Rxx1, theta1, phi1, m1 = Rxx_symbolic(1, AMR[0], SMR[0])\n    Rxx2, theta2, phi2, m2 = Rxx_symbolic(2, AMR[1], SMR[1])\n    GMR_resistance = GMR * (1 - (m1.dot(m2))) / 2.0\n    return Rxx1, Rxx2, GMR_resistance, theta1, phi1, theta2, phi2\n</code></pre>"},{"location":"api/resistance-reference/#cmtj.utils.resistance.calculate_linearised_resistance_parallel","title":"<code>calculate_linearised_resistance_parallel(GMR, AMR, SMR, stationary_angles, linearised_angles)</code>","text":"<p>Compute the parallel resistance of the two FM bilayer system from the linearised angles.</p> <p>Parameters:</p> Name Type Description Default <code>GMR</code> <code>float</code> <p>GMR</p> required <code>AMR</code> <code>list[float]</code> <p>AMR</p> required <code>SMR</code> <code>list[float]</code> <p>SMR</p> required <code>stationary_angles</code> <code>list[float]</code> <p>stationary angles [t1, p1, t2, p2]</p> required <code>linearised_angles</code> <code>list[float]</code> <p>linearised angles [dt1, dp1, dt2, dp2]</p> required Source code in <code>cmtj/utils/resistance.py</code> <pre><code>def calculate_linearised_resistance_parallel(\n    GMR: float,\n    AMR: list[float],\n    SMR: list[float],\n    stationary_angles: list[float],\n    linearised_angles: list[float],\n):\n    \"\"\"\n    Compute the parallel resistance of the two FM bilayer system from the linearised angles.\n\n    :param GMR: GMR\n    :param AMR: AMR\n    :param SMR: SMR\n    :param stationary_angles: stationary angles [t1, p1, t2, p2]\n    :param linearised_angles: linearised angles [dt1, dp1, dt2, dp2]\n    \"\"\"\n    t01, p01 = stationary_angles[:2]\n    t02, p02 = stationary_angles[2:]\n    dt1, dp1 = linearised_angles[:2]\n    dt2, dp2 = linearised_angles[2:]\n    Rxx1, Rxx2, GMR_resistance, theta1, phi1, theta2, phi2 = calculate_linearised_resistance(GMR, AMR, SMR)\n    Rparallel = GMR_resistance\n    if any(AMR) or any(SMR):\n        Rparallel += (Rxx1 * Rxx2) / (Rxx1 + Rxx2 + EPS)\n    elif GMR == 0:\n        return 0, 0\n    dRparallel = (\n        sym.diff(Rparallel, theta1) * dt1\n        + sym.diff(Rparallel, phi1) * dp1\n        + sym.diff(Rparallel, theta2) * dt2\n        + sym.diff(Rparallel, phi2) * dp2\n    )\n    if isinstance(dRparallel, (list, np.ndarray)):\n        dRparallel = dRparallel[0]\n    dRparallel = dRparallel.subs(\n        {\n            theta1: t01,\n            phi1: p01,\n            theta2: t02,\n            phi2: p02,\n        }\n    ).evalf()\n    Rparallel = Rparallel.subs(\n        {\n            theta1: t01,\n            phi1: p01,\n            theta2: t02,\n            phi2: p02,\n        }\n    ).evalf()\n    return dRparallel, Rparallel\n</code></pre>"},{"location":"api/resistance-reference/#cmtj.utils.resistance.calculate_linearised_resistance_series","title":"<code>calculate_linearised_resistance_series(GMR, AMR, SMR, stationary_angles, linearised_angles)</code>","text":"<p>Compute the resistance of the two FM bilayer system from the linearised angles.</p> <p>Parameters:</p> Name Type Description Default <code>GMR</code> <code>float</code> <p>GMR</p> required <code>AMR</code> <code>list[float]</code> <p>AMR</p> required <code>SMR</code> <code>list[float]</code> <p>SMR</p> required <code>stationary_angles</code> <code>list[float]</code> <p>stationary angles [t1, p1, t2, p2]</p> required <code>linearised_angles</code> <code>list[float]</code> <p>linearised angles [dt1, dp1, dt2, dp2]</p> required Source code in <code>cmtj/utils/resistance.py</code> <pre><code>def calculate_linearised_resistance_series(\n    GMR: float,\n    AMR: list[float],\n    SMR: list[float],\n    stationary_angles: list[float],\n    linearised_angles: list[float],\n) -&gt; tuple[float, float]:\n    \"\"\"\n    Compute the resistance of the two FM bilayer system from the linearised angles.\n    :param GMR: GMR\n    :param AMR: AMR\n    :param SMR: SMR\n    :param stationary_angles: stationary angles [t1, p1, t2, p2]\n    :param linearised_angles: linearised angles [dt1, dp1, dt2, dp2]\n    \"\"\"\n    t01, p01 = stationary_angles[:2]\n    t02, p02 = stationary_angles[2:]\n    dt1, dp1 = linearised_angles[:2]\n    dt2, dp2 = linearised_angles[2:]\n    Rxx1, Rxx2, GMR_resistance, theta1, phi1, theta2, phi2 = calculate_linearised_resistance(GMR, AMR, SMR)\n    Rseries = GMR_resistance + Rxx1 + Rxx2\n    dRseries = (\n        sym.diff(Rseries, theta1) * dt1\n        + sym.diff(Rseries, phi1) * dp1\n        + sym.diff(Rseries, theta2) * dt2\n        + sym.diff(Rseries, phi2) * dp2\n    )\n\n    dRseries = dRseries.subs(\n        {\n            theta1: t01,\n            phi1: p01,\n            theta2: t02,\n            phi2: p02,\n        }\n    ).evalf()\n    Rseries = Rseries.subs(\n        {\n            theta1: t01,\n            phi1: p01,\n            theta2: t02,\n            phi2: p02,\n        }\n    ).evalf()\n    return dRseries, Rseries\n</code></pre>"},{"location":"api/resistance-reference/#cmtj.utils.resistance.calculate_magnetoresistance","title":"<code>calculate_magnetoresistance(Rp, Rap, m)</code>","text":"<p>Computes the magnetoresistance using parallel and antiparallel resistance.</p> <p>Parameters:</p> Name Type Description Default <code>Rp</code> <code>float</code> <p>parallel resistance</p> required <code>Rap</code> <code>float</code> <p>antiparallel resistance</p> required <code>m</code> <code>np.ndarray</code> <p>magnetisation, 2 layers of shape [2, 3, T] where T is the time component</p> required Source code in <code>cmtj/utils/resistance.py</code> <pre><code>def calculate_magnetoresistance(Rp: float, Rap: float, m: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes the magnetoresistance using parallel and antiparallel resistance.\n    :param Rp: parallel resistance\n    :param Rap: antiparallel resistance\n    :param m: magnetisation, 2 layers of shape [2, 3, T] where T is the time component\n    \"\"\"\n    if not isinstance(m, np.ndarray):\n        m = np.asarray(m)\n    if m.shape[0] != 2:\n        raise ValueError(\"The magnetoresistance can only be computed for 2 layers\" f\". Current shape {m.shape}\")\n    return Rp + 0.5 * (Rap - Rp) * np.sum(m[0] * m[1], axis=0)\n</code></pre>"},{"location":"api/resistance-reference/#cmtj.utils.resistance.calculate_resistance_parallel","title":"<code>calculate_resistance_parallel(Rx0, Ry0, AMR, AHE, SMR, m, l, w)</code>","text":"<p>Calculates the resistance of the system in parallel. If you want to compute the resistance for an entire time series, pass m as a 3D array. [number_of_layers, 3, T] where T is the time component. Uses Kim's formula from the paper: https://link.aps.org/doi/10.1103/PhysRevLett.116.097201</p> <p>Parameters:</p> Name Type Description Default <code>Rx0</code> <code>list[float]</code> <p>resistance offset in longitudinal direction</p> required <code>Ry0</code> <code>list[float]</code> <p>resistance offset in transverse direction</p> required <code>AMR</code> <code>list[float]</code> <p>anisotropic magnetoresistance</p> required <code>AHE</code> <code>list[float]</code> <p>anomalous Hall effect</p> required <code>SMR</code> <code>list[float]</code> <p>spin Hall magnetoresistance</p> required <code>m</code> <code>list[float]</code> <p>magnetisation of the layers. Shape [number_of_layers, 3, T]</p> required <code>l</code> <code>list[float]</code> <p>length of the layers</p> required <code>w</code> <code>list[float]</code> <p>width of the layers</p> required Source code in <code>cmtj/utils/resistance.py</code> <pre><code>def calculate_resistance_parallel(\n    Rx0: list[float],\n    Ry0: list[float],\n    AMR: list[float],\n    AHE: list[float],\n    SMR: list[float],\n    m: list[float],\n    l: list[float],\n    w: list[float],\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Calculates the resistance of the system in parallel.\n    If you want to compute the resistance for an entire time series, pass m as a 3D array.\n    [number_of_layers, 3, T] where T is the time component.\n    Uses Kim's formula from the paper:\n    https://link.aps.org/doi/10.1103/PhysRevLett.116.097201\n\n    :param Rx0: resistance offset in longitudinal direction\n    :param Ry0: resistance offset in transverse direction\n    :param AMR: anisotropic magnetoresistance\n    :param AHE: anomalous Hall effect\n    :param SMR: spin Hall magnetoresistance\n    :param m: magnetisation of the layers. Shape [number_of_layers, 3, T]\n    :param l: length of the layers\n    :param w: width of the layers\n    \"\"\"\n    SxAll, SyAll = compute_resistance(Rx0, Ry0, AMR, AHE, SMR, m, l, w)\n    Rx = 1.0 / np.sum(1.0 / SxAll, axis=0)\n    Ry = 1.0 / np.sum(1.0 / SyAll, axis=0)\n    return Rx, Ry\n</code></pre>"},{"location":"api/resistance-reference/#cmtj.utils.resistance.calculate_resistance_series","title":"<code>calculate_resistance_series(Rx0, Ry0, AMR, AHE, SMR, m, l, w)</code>","text":"<p>Calculates the resistance of the system in series. If you want to compute the resistance for an entire time series, pass m as a 3D array. [number_of_layers, 3, T] where T is the time component. Uses Kim's formula from the paper: https://link.aps.org/doi/10.1103/PhysRevLett.116.097201</p> <p>Parameters:</p> Name Type Description Default <code>Rx0</code> <code>list[float]</code> <p>resistance offset in longitudinal direction</p> required <code>Ry0</code> <code>list[float]</code> <p>resistance offset in transverse direction</p> required <code>AMR</code> <code>list[float]</code> <p>anisotropic magnetoresistance</p> required <code>AHE</code> <code>list[float]</code> <p>anomalous Hall effect</p> required <code>SMR</code> <code>list[float]</code> <p>spin Hall magnetoresistance</p> required <code>m</code> <code>list[float]</code> <p>magnetisation of the layers. Shape [number_of_layers, 3, T]</p> required <code>l</code> <code>list[float]</code> <p>length of the layers</p> required <code>w</code> <code>list[float]</code> <p>width of the layers</p> required Source code in <code>cmtj/utils/resistance.py</code> <pre><code>def calculate_resistance_series(\n    Rx0: list[float],\n    Ry0: list[float],\n    AMR: list[float],\n    AHE: list[float],\n    SMR: list[float],\n    m: list[float],\n    l: list[float],\n    w: list[float],\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Calculates the resistance of the system in series.\n    If you want to compute the resistance for an entire time series, pass m as a 3D array.\n    [number_of_layers, 3, T] where T is the time component.\n    Uses Kim's formula from the paper:\n    https://link.aps.org/doi/10.1103/PhysRevLett.116.097201\n\n    :param Rx0: resistance offset in longitudinal direction\n    :param Ry0: resistance offset in transverse direction\n    :param AMR: anisotropic magnetoresistance\n    :param AHE: anomalous Hall effect\n    :param SMR: spin Hall magnetoresistance\n    :param m: magnetisation of the layers. Shape [number_of_layers, 3, T]\n    :param l: length of the layers\n    :param w: width of the layers\n    \"\"\"\n    SxAll, SyAll = compute_resistance(Rx0, Ry0, AMR, AHE, SMR, m, l, w)\n    Rx = np.sum(SxAll, axis=0)\n    Ry = np.sum(SyAll, axis=0)\n    return Rx, Ry\n</code></pre>"},{"location":"api/resistance-reference/#cmtj.utils.resistance.compute_gmr","title":"<code>compute_gmr(Rp, Rap, m1, m2)</code>","text":"<p>Computes the GMR using parallel and antiparallel resistance.</p> <p>Parameters:</p> Name Type Description Default <code>Rp</code> <code>float</code> <p>parallel resistance</p> required <code>Rap</code> <code>float</code> <p>antiparallel resistance</p> required <code>m1</code> <code>np.ndarray</code> <p>magnetisation of layer 1</p> required <code>m2</code> <code>np.ndarray</code> <p>magnetisation of layer 2</p> required Source code in <code>cmtj/utils/resistance.py</code> <pre><code>def compute_gmr(Rp: float, Rap: float, m1: np.ndarray, m2: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Computes the GMR using parallel and antiparallel resistance.\n    :param Rp: parallel resistance\n    :param Rap: antiparallel resistance\n    :param m1: magnetisation of layer 1\n    :param m2: magnetisation of layer 2\"\"\"\n    return Rp + 0.5 * (Rap - Rp) * (1 - np.sum(m1 * m2, axis=0))\n</code></pre>"},{"location":"api/resistance-reference/#cmtj.utils.resistance.compute_resistance","title":"<code>compute_resistance(Rx0, Ry0, AMR, AHE, SMR, m, l, w)</code>","text":"<p>Computes the resistance of the system.</p> <p>If you want to compute the resistance for an entire time series, pass m as a 3D array with shape [number_of_layers, 3, T], where T is the time component. [number_of_layers, 3, T] where T is the time component.</p> <p>Parameters:</p> Name Type Description Default <code>Rx0</code> <code>list[float]</code> <p>resistance offset in longitudinal direction</p> required <code>Ry0</code> <code>list[float]</code> <p>resistance offset in transverse direction</p> required <code>AMR</code> <code>list[float]</code> <p>anisotropic magnetoresistance</p> required <code>AHE</code> <code>list[float]</code> <p>anomalous Hall effect</p> required <code>SMR</code> <code>list[float]</code> <p>spin Hall magnetoresistance</p> required <code>m</code> <code>Union[list[float], np.ndarray]</code> <p>magnetisation of the layers. Shape [number_of_layers, 3, T]</p> required <code>l</code> <code>list[float]</code> <p>length of the layers</p> required <code>w</code> <code>list[float]</code> <p>width of the layers</p> required Source code in <code>cmtj/utils/resistance.py</code> <pre><code>def compute_resistance(\n    Rx0: list[float],\n    Ry0: list[float],\n    AMR: list[float],\n    AHE: list[float],\n    SMR: list[float],\n    m: Union[list[float], np.ndarray],\n    l: list[float],\n    w: list[float],\n) -&gt; tuple[list[float], list[float]]:\n    \"\"\"Computes the resistance of the system.\n\n    If you want to compute the resistance for an entire time series, pass m as a 3D array\n    with shape [number_of_layers, 3, T], where T is the time component.\n    [number_of_layers, 3, T] where T is the time component.\n\n    :param Rx0: resistance offset in longitudinal direction\n    :param Ry0: resistance offset in transverse direction\n    :param AMR: anisotropic magnetoresistance\n    :param AHE: anomalous Hall effect\n    :param SMR: spin Hall magnetoresistance\n    :param m: magnetisation of the layers. Shape [number_of_layers, 3, T]\n    :param l: length of the layers\n    :param w: width of the layers\n    \"\"\"\n    number_of_layers = len(Rx0)\n    if not isinstance(m, np.ndarray):\n        m = np.asarray(m)\n    if m.ndim == 2:\n        SxAll = np.zeros((number_of_layers,))\n        SyAll = np.zeros((number_of_layers,))\n\n    elif m.ndim == 3:\n        SxAll = np.zeros((number_of_layers, m.shape[2]))\n        SyAll = np.zeros((number_of_layers, m.shape[2]))\n\n    for i in range(number_of_layers):\n        w_l = w[i] / l[i]\n        SxAll[i] = Rx0[i] + (AMR[i] * m[i, 0] ** 2 + SMR[i] * m[i, 1] ** 2)\n        SyAll[i] = Ry0[i] + 0.5 * AHE[i] * m[i, 2] + (w_l) * (SMR[i] + AMR[i]) * m[i, 0] * m[i, 1]\n    return SxAll, SyAll\n</code></pre>"},{"location":"api/resistance-reference/#cmtj.utils.resistance.compute_sd","title":"<code>compute_sd(dynamic_r, dynamic_i, integration_step)</code>","text":"<p>Computes the SD voltage.</p> <p>Parameters:</p> Name Type Description Default <code>dynamic_r</code> <code>np.ndarray</code> <p>magnetoresistance from log</p> required <code>dynamic_i</code> <code>np.ndarray</code> <p>excitation current</p> required <code>integration_step</code> <code>float</code> <p>integration paramemter from run_simulation</p> required Source code in <code>cmtj/utils/resistance.py</code> <pre><code>def compute_sd(dynamic_r: np.ndarray, dynamic_i: np.ndarray, integration_step: float) -&gt; np.ndarray:\n    \"\"\"Computes the SD voltage.\n\n    :param dynamic_r: magnetoresistance from log\n    :param dynamic_i: excitation current\n    :param integration_step: integration paramemter from run_simulation\n    \"\"\"\n    SD = -dynamic_i * dynamic_r\n    fs = 1.0 / integration_step\n    SD_dc = Filters.butter_lowpass_filter(SD, cutoff=10e6, fs=fs, order=3)\n    return np.mean(SD_dc)\n</code></pre>"},{"location":"api/stack/","title":"Stack","text":""},{"location":"api/stack/#cmtj.stack.ParallelStack","title":"<code>ParallelStack</code>","text":"Source code in <code>cmtj/stack/__init__.pyi</code> <pre><code>class ParallelStack:\n    def __init__(\n        self,\n        junctionList: list[cmtj.Junction],\n        topId: str = \"free\",\n        bottomId: str = \"bottom\",\n        phaseOffset: float = 0,\n        useKCL: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        Initialises a parallel connection of junctions.\n        Layer ids are used to identify the layers in the junctions and for resistance calculations.\n        :param junctionList: list of junctions to be connected in parallel.\n        :param topId: the string id of the top layer in the stack. Default is \"free\".\n        :param bottomId: the string id of the bottom layer in the stack. Default is \"bottom\".\n        :param phaseOffset: the phase offset between the junctions. Default is 0.\n        \"\"\"\n        ...\n\n    def clearLogs(self) -&gt; None:\n        \"\"\"\n        Clear all the logs, both of the stack and the junctions\n        that constitute the stack.\n        \"\"\"\n        ...\n\n    @overload\n    def getLog(self, junctionId: int) -&gt; dict[str, list[float]]:\n        \"\"\"\n        Get the logs of a specific junction -- integer id\n        from the `junctionList`.\n        :param junctionId: integer junction id as was passed in the init.\n        \"\"\"\n        ...\n\n    @overload\n    def getLog(self) -&gt; dict[str, list[float]]:\n        \"\"\"\n        Get the logs of the stack\n        \"\"\"\n        ...\n\n    def runSimulation(self, totalTime: float, timeStep: float = ..., writeFrequency: float = ...) -&gt; None:\n        \"\"\"\n        Run the simulation of the stack.\n        :param totalTime: total time of a simulation, give it in seconds. Typical length is in ~couple ns.\n        :param timeStep: the integration step of the RK45 method. Default is 1e-13\n        :param writeFrequency: how often is the log saved to? Must be no smaller than `timeStep`. Default is 1e-11.\n        \"\"\"\n        ...\n\n    def setCoupledCurrentDriver(self, driver: cmtj.ScalarDriver) -&gt; None:\n        \"\"\"\n        Sets a global current driver for all junctions inside the stack.\n        Keep in mind the current passed down the stack will be modified\n        by the coupling constant.\n        :param driver: the current driver to be set.\n        \"\"\"\n        ...\n\n    def setCouplingStrength(self, coupling: float) -&gt; None:\n        \"\"\"\n        Coupling constant that represents the energy losses as the current\n        passes through the stack.\n        :param coupling: the coupling strength (or the losses)\n        \"\"\"\n        ...\n\n    def setExternalFieldDriver(self, driver: cmtj.AxialDriver) -&gt; None:\n        \"\"\"\n        Sets a external field current driver for all junctions inside the stack.\n        :param driver: the field driver to be set.\n        \"\"\"\n        ...\n\n    def setMagnetisation(self, junctionId: int, layerId: str, mag: cmtj.CVector) -&gt; None:\n        \"\"\"\n        Set magnetisation on a specific layer in a specific junction.\n        :param junctionId: the id of the junction (int) as passed in the init.\n        :param layerId: the string id of the layer in the junction.\n        :param mag: the magnetisation to be set.\n        \"\"\"\n        ...\n\n    def getMagnetisation(self, junction: int, layerId: str) -&gt; cmtj.CVector:\n        \"\"\"Get the magnetisation of a specific layer in a specific junction.\n        :param junction: the id of the junction (int) as passed in the init.\n        :param layerId: the string id of the layer in the junction.\"\"\"\n        ...\n\n    def getJunction(self, junctionId: int) -&gt; cmtj.Junction:\n        \"\"\"Get a specific junction from the stack. Returns a reference.\n        :param junctionId: the id of the junction (int) as passed in the init.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/stack/#cmtj.stack.ParallelStack.__init__","title":"<code>__init__(junctionList, topId='free', bottomId='bottom', phaseOffset=0, useKCL=True)</code>","text":"<p>Initialises a parallel connection of junctions. Layer ids are used to identify the layers in the junctions and for resistance calculations.</p> <p>Parameters:</p> Name Type Description Default <code>junctionList</code> <code>list[cmtj.Junction]</code> <p>list of junctions to be connected in parallel.</p> required <code>topId</code> <code>str</code> <p>the string id of the top layer in the stack. Default is \"free\".</p> <code>'free'</code> <code>bottomId</code> <code>str</code> <p>the string id of the bottom layer in the stack. Default is \"bottom\".</p> <code>'bottom'</code> <code>phaseOffset</code> <code>float</code> <p>the phase offset between the junctions. Default is 0.</p> <code>0</code> Source code in <code>cmtj/stack/__init__.pyi</code> <pre><code>def __init__(\n    self,\n    junctionList: list[cmtj.Junction],\n    topId: str = \"free\",\n    bottomId: str = \"bottom\",\n    phaseOffset: float = 0,\n    useKCL: bool = True,\n) -&gt; None:\n    \"\"\"\n    Initialises a parallel connection of junctions.\n    Layer ids are used to identify the layers in the junctions and for resistance calculations.\n    :param junctionList: list of junctions to be connected in parallel.\n    :param topId: the string id of the top layer in the stack. Default is \"free\".\n    :param bottomId: the string id of the bottom layer in the stack. Default is \"bottom\".\n    :param phaseOffset: the phase offset between the junctions. Default is 0.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stack/#cmtj.stack.ParallelStack.clearLogs","title":"<code>clearLogs()</code>","text":"<p>Clear all the logs, both of the stack and the junctions that constitute the stack.</p> Source code in <code>cmtj/stack/__init__.pyi</code> <pre><code>def clearLogs(self) -&gt; None:\n    \"\"\"\n    Clear all the logs, both of the stack and the junctions\n    that constitute the stack.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stack/#cmtj.stack.ParallelStack.getJunction","title":"<code>getJunction(junctionId)</code>","text":"<p>Get a specific junction from the stack. Returns a reference.</p> <p>Parameters:</p> Name Type Description Default <code>junctionId</code> <code>int</code> <p>the id of the junction (int) as passed in the init.</p> required Source code in <code>cmtj/stack/__init__.pyi</code> <pre><code>def getJunction(self, junctionId: int) -&gt; cmtj.Junction:\n    \"\"\"Get a specific junction from the stack. Returns a reference.\n    :param junctionId: the id of the junction (int) as passed in the init.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stack/#cmtj.stack.ParallelStack.getMagnetisation","title":"<code>getMagnetisation(junction, layerId)</code>","text":"<p>Get the magnetisation of a specific layer in a specific junction.</p> <p>Parameters:</p> Name Type Description Default <code>junction</code> <code>int</code> <p>the id of the junction (int) as passed in the init.</p> required <code>layerId</code> <code>str</code> <p>the string id of the layer in the junction.</p> required Source code in <code>cmtj/stack/__init__.pyi</code> <pre><code>def getMagnetisation(self, junction: int, layerId: str) -&gt; cmtj.CVector:\n    \"\"\"Get the magnetisation of a specific layer in a specific junction.\n    :param junction: the id of the junction (int) as passed in the init.\n    :param layerId: the string id of the layer in the junction.\"\"\"\n    ...\n</code></pre>"},{"location":"api/stack/#cmtj.stack.ParallelStack.runSimulation","title":"<code>runSimulation(totalTime, timeStep=Ellipsis, writeFrequency=Ellipsis)</code>","text":"<p>Run the simulation of the stack.</p> <p>Parameters:</p> Name Type Description Default <code>totalTime</code> <code>float</code> <p>total time of a simulation, give it in seconds. Typical length is in ~couple ns.</p> required <code>timeStep</code> <code>float</code> <p>the integration step of the RK45 method. Default is 1e-13</p> <code>Ellipsis</code> <code>writeFrequency</code> <code>float</code> <p>how often is the log saved to? Must be no smaller than <code>timeStep</code>. Default is 1e-11.</p> <code>Ellipsis</code> Source code in <code>cmtj/stack/__init__.pyi</code> <pre><code>def runSimulation(self, totalTime: float, timeStep: float = ..., writeFrequency: float = ...) -&gt; None:\n    \"\"\"\n    Run the simulation of the stack.\n    :param totalTime: total time of a simulation, give it in seconds. Typical length is in ~couple ns.\n    :param timeStep: the integration step of the RK45 method. Default is 1e-13\n    :param writeFrequency: how often is the log saved to? Must be no smaller than `timeStep`. Default is 1e-11.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stack/#cmtj.stack.ParallelStack.setCoupledCurrentDriver","title":"<code>setCoupledCurrentDriver(driver)</code>","text":"<p>Sets a global current driver for all junctions inside the stack. Keep in mind the current passed down the stack will be modified by the coupling constant.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>cmtj.ScalarDriver</code> <p>the current driver to be set.</p> required Source code in <code>cmtj/stack/__init__.pyi</code> <pre><code>def setCoupledCurrentDriver(self, driver: cmtj.ScalarDriver) -&gt; None:\n    \"\"\"\n    Sets a global current driver for all junctions inside the stack.\n    Keep in mind the current passed down the stack will be modified\n    by the coupling constant.\n    :param driver: the current driver to be set.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stack/#cmtj.stack.ParallelStack.setCouplingStrength","title":"<code>setCouplingStrength(coupling)</code>","text":"<p>Coupling constant that represents the energy losses as the current passes through the stack.</p> <p>Parameters:</p> Name Type Description Default <code>coupling</code> <code>float</code> <p>the coupling strength (or the losses)</p> required Source code in <code>cmtj/stack/__init__.pyi</code> <pre><code>def setCouplingStrength(self, coupling: float) -&gt; None:\n    \"\"\"\n    Coupling constant that represents the energy losses as the current\n    passes through the stack.\n    :param coupling: the coupling strength (or the losses)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stack/#cmtj.stack.ParallelStack.setExternalFieldDriver","title":"<code>setExternalFieldDriver(driver)</code>","text":"<p>Sets a external field current driver for all junctions inside the stack.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>cmtj.AxialDriver</code> <p>the field driver to be set.</p> required Source code in <code>cmtj/stack/__init__.pyi</code> <pre><code>def setExternalFieldDriver(self, driver: cmtj.AxialDriver) -&gt; None:\n    \"\"\"\n    Sets a external field current driver for all junctions inside the stack.\n    :param driver: the field driver to be set.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stack/#cmtj.stack.ParallelStack.setMagnetisation","title":"<code>setMagnetisation(junctionId, layerId, mag)</code>","text":"<p>Set magnetisation on a specific layer in a specific junction.</p> <p>Parameters:</p> Name Type Description Default <code>junctionId</code> <code>int</code> <p>the id of the junction (int) as passed in the init.</p> required <code>layerId</code> <code>str</code> <p>the string id of the layer in the junction.</p> required <code>mag</code> <code>cmtj.CVector</code> <p>the magnetisation to be set.</p> required Source code in <code>cmtj/stack/__init__.pyi</code> <pre><code>def setMagnetisation(self, junctionId: int, layerId: str, mag: cmtj.CVector) -&gt; None:\n    \"\"\"\n    Set magnetisation on a specific layer in a specific junction.\n    :param junctionId: the id of the junction (int) as passed in the init.\n    :param layerId: the string id of the layer in the junction.\n    :param mag: the magnetisation to be set.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stack/#cmtj.stack.SeriesStack","title":"<code>SeriesStack</code>","text":"Source code in <code>cmtj/stack/__init__.pyi</code> <pre><code>class SeriesStack:\n    def __init__(\n        self,\n        junctionList: list[cmtj.Junction],\n        topId: str = \"free\",\n        bottomId: str = \"bottom\",\n        phaseOffset: float = 0,\n        useKCL: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        Initialises a series connection of junctions.\n        Layer ids are used to identify the layers in the junctions and for resistance calculations.\n        :param junctionList: list of junctions to be connected in series.\n        :param topId: the string id of the top layer in the stack. Default is \"free\".\n        :param bottomId: the string id of the bottom layer in the stack. Default is \"bottom\".\n        :param phaseOffset: the phase offset between the junctions. Default is 0.\n        \"\"\"\n        ...\n\n    def clearLogs(self) -&gt; None:\n        \"\"\"\n        Clear all the logs, both of the stack and the junctions\n        that constitute the stack.\n        \"\"\"\n        ...\n\n    @overload\n    def getLog(self, junctionId: int) -&gt; dict[str, list[float]]:\n        \"\"\"\n        Get the logs of a specific junction -- integer id\n        from the `junctionList`.\n        :param junctionId: integer junction id as was passed in the init.\n        \"\"\"\n        ...\n\n    @overload\n    def getLog(self) -&gt; dict[str, list[float]]:\n        \"\"\"\n        Get the logs of the stack\n        \"\"\"\n        ...\n\n    def runSimulation(self, totalTime: float, timeStep: float = ..., writeFrequency: float = ...) -&gt; None:\n        \"\"\"\n        Run the simulation of the stack.\n        :param totalTime: total time of a simulation, give it in seconds. Typical length is in ~couple ns.\n        :param timeStep: the integration step of the RK45 method. Default is 1e-13\n        :param writeFrequency: how often is the log saved to? Must be no smaller than `timeStep`. Default is 1e-11.\n        \"\"\"\n        ...\n\n    def setCoupledCurrentDriver(self, driver: cmtj.ScalarDriver) -&gt; None:\n        \"\"\"\n        Sets a global current driver for all junctions inside the stack.\n        Keep in mind the current passed down the stack will be modified\n        by the coupling constant.\n        :param driver: the current driver to be set.\n        \"\"\"\n        ...\n\n    @overload\n    def setCouplingStrength(self, coupling: float) -&gt; None:\n        \"\"\"\n        Coupling constant that represents the energy losses as the current\n        passes through the stack.\n        :param coupling: the coupling strength (or the losses)\n        \"\"\"\n        ...\n\n    @overload\n    def setCouplingStrength(self, coupling: list[float]) -&gt; None:\n        \"\"\"\n        Coupling constant that represents the energy losses as the current\n        passes through the stack.\n        :param coupling: the coupling strength (or the losses) for each junction.\n            Must be the one less than length of the junction vector, i.e. len(junctionList)-1 .\n        \"\"\"\n        ...\n\n    def setExternalFieldDriver(self, driver: cmtj.AxialDriver) -&gt; None:\n        \"\"\"\n        Sets a external field current driver for all junctions inside the stack.\n        :param driver: the field driver to be set.\n        \"\"\"\n        ...\n\n    def setMagnetisation(self, junctionId: int, layerId: str, mag: cmtj.CVector) -&gt; None:\n        \"\"\"\n        Set magnetisation on a specific layer in a specific junction.\n        :param junctionId: the id of the junction (int) as passed in the init.\n        :param layerId: the string id of the layer in the junction.\n        :param mag: the magnetisation to be set.\n        \"\"\"\n        ...\n\n    def getMagnetisation(self, junction: int, layerId: str) -&gt; cmtj.CVector:\n        \"\"\"Get the magnetisation of a specific layer in a specific junction.\n        :param junction: the id of the junction (int) as passed in the init.\n        :param layerId: the string id of the layer in the junction.\"\"\"\n        ...\n\n    def getJunction(self, junctionId: int) -&gt; cmtj.Junction:\n        \"\"\"Get a specific junction from the stack. Returns a reference.\n        :param junctionId: the id of the junction (int) as passed in the init.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/stack/#cmtj.stack.SeriesStack.__init__","title":"<code>__init__(junctionList, topId='free', bottomId='bottom', phaseOffset=0, useKCL=True)</code>","text":"<p>Initialises a series connection of junctions. Layer ids are used to identify the layers in the junctions and for resistance calculations.</p> <p>Parameters:</p> Name Type Description Default <code>junctionList</code> <code>list[cmtj.Junction]</code> <p>list of junctions to be connected in series.</p> required <code>topId</code> <code>str</code> <p>the string id of the top layer in the stack. Default is \"free\".</p> <code>'free'</code> <code>bottomId</code> <code>str</code> <p>the string id of the bottom layer in the stack. Default is \"bottom\".</p> <code>'bottom'</code> <code>phaseOffset</code> <code>float</code> <p>the phase offset between the junctions. Default is 0.</p> <code>0</code> Source code in <code>cmtj/stack/__init__.pyi</code> <pre><code>def __init__(\n    self,\n    junctionList: list[cmtj.Junction],\n    topId: str = \"free\",\n    bottomId: str = \"bottom\",\n    phaseOffset: float = 0,\n    useKCL: bool = True,\n) -&gt; None:\n    \"\"\"\n    Initialises a series connection of junctions.\n    Layer ids are used to identify the layers in the junctions and for resistance calculations.\n    :param junctionList: list of junctions to be connected in series.\n    :param topId: the string id of the top layer in the stack. Default is \"free\".\n    :param bottomId: the string id of the bottom layer in the stack. Default is \"bottom\".\n    :param phaseOffset: the phase offset between the junctions. Default is 0.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stack/#cmtj.stack.SeriesStack.clearLogs","title":"<code>clearLogs()</code>","text":"<p>Clear all the logs, both of the stack and the junctions that constitute the stack.</p> Source code in <code>cmtj/stack/__init__.pyi</code> <pre><code>def clearLogs(self) -&gt; None:\n    \"\"\"\n    Clear all the logs, both of the stack and the junctions\n    that constitute the stack.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stack/#cmtj.stack.SeriesStack.getJunction","title":"<code>getJunction(junctionId)</code>","text":"<p>Get a specific junction from the stack. Returns a reference.</p> <p>Parameters:</p> Name Type Description Default <code>junctionId</code> <code>int</code> <p>the id of the junction (int) as passed in the init.</p> required Source code in <code>cmtj/stack/__init__.pyi</code> <pre><code>def getJunction(self, junctionId: int) -&gt; cmtj.Junction:\n    \"\"\"Get a specific junction from the stack. Returns a reference.\n    :param junctionId: the id of the junction (int) as passed in the init.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stack/#cmtj.stack.SeriesStack.getMagnetisation","title":"<code>getMagnetisation(junction, layerId)</code>","text":"<p>Get the magnetisation of a specific layer in a specific junction.</p> <p>Parameters:</p> Name Type Description Default <code>junction</code> <code>int</code> <p>the id of the junction (int) as passed in the init.</p> required <code>layerId</code> <code>str</code> <p>the string id of the layer in the junction.</p> required Source code in <code>cmtj/stack/__init__.pyi</code> <pre><code>def getMagnetisation(self, junction: int, layerId: str) -&gt; cmtj.CVector:\n    \"\"\"Get the magnetisation of a specific layer in a specific junction.\n    :param junction: the id of the junction (int) as passed in the init.\n    :param layerId: the string id of the layer in the junction.\"\"\"\n    ...\n</code></pre>"},{"location":"api/stack/#cmtj.stack.SeriesStack.runSimulation","title":"<code>runSimulation(totalTime, timeStep=Ellipsis, writeFrequency=Ellipsis)</code>","text":"<p>Run the simulation of the stack.</p> <p>Parameters:</p> Name Type Description Default <code>totalTime</code> <code>float</code> <p>total time of a simulation, give it in seconds. Typical length is in ~couple ns.</p> required <code>timeStep</code> <code>float</code> <p>the integration step of the RK45 method. Default is 1e-13</p> <code>Ellipsis</code> <code>writeFrequency</code> <code>float</code> <p>how often is the log saved to? Must be no smaller than <code>timeStep</code>. Default is 1e-11.</p> <code>Ellipsis</code> Source code in <code>cmtj/stack/__init__.pyi</code> <pre><code>def runSimulation(self, totalTime: float, timeStep: float = ..., writeFrequency: float = ...) -&gt; None:\n    \"\"\"\n    Run the simulation of the stack.\n    :param totalTime: total time of a simulation, give it in seconds. Typical length is in ~couple ns.\n    :param timeStep: the integration step of the RK45 method. Default is 1e-13\n    :param writeFrequency: how often is the log saved to? Must be no smaller than `timeStep`. Default is 1e-11.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stack/#cmtj.stack.SeriesStack.setCoupledCurrentDriver","title":"<code>setCoupledCurrentDriver(driver)</code>","text":"<p>Sets a global current driver for all junctions inside the stack. Keep in mind the current passed down the stack will be modified by the coupling constant.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>cmtj.ScalarDriver</code> <p>the current driver to be set.</p> required Source code in <code>cmtj/stack/__init__.pyi</code> <pre><code>def setCoupledCurrentDriver(self, driver: cmtj.ScalarDriver) -&gt; None:\n    \"\"\"\n    Sets a global current driver for all junctions inside the stack.\n    Keep in mind the current passed down the stack will be modified\n    by the coupling constant.\n    :param driver: the current driver to be set.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stack/#cmtj.stack.SeriesStack.setExternalFieldDriver","title":"<code>setExternalFieldDriver(driver)</code>","text":"<p>Sets a external field current driver for all junctions inside the stack.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>cmtj.AxialDriver</code> <p>the field driver to be set.</p> required Source code in <code>cmtj/stack/__init__.pyi</code> <pre><code>def setExternalFieldDriver(self, driver: cmtj.AxialDriver) -&gt; None:\n    \"\"\"\n    Sets a external field current driver for all junctions inside the stack.\n    :param driver: the field driver to be set.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stack/#cmtj.stack.SeriesStack.setMagnetisation","title":"<code>setMagnetisation(junctionId, layerId, mag)</code>","text":"<p>Set magnetisation on a specific layer in a specific junction.</p> <p>Parameters:</p> Name Type Description Default <code>junctionId</code> <code>int</code> <p>the id of the junction (int) as passed in the init.</p> required <code>layerId</code> <code>str</code> <p>the string id of the layer in the junction.</p> required <code>mag</code> <code>cmtj.CVector</code> <p>the magnetisation to be set.</p> required Source code in <code>cmtj/stack/__init__.pyi</code> <pre><code>def setMagnetisation(self, junctionId: int, layerId: str, mag: cmtj.CVector) -&gt; None:\n    \"\"\"\n    Set magnetisation on a specific layer in a specific junction.\n    :param junctionId: the id of the junction (int) as passed in the init.\n    :param layerId: the string id of the layer in the junction.\n    :param mag: the magnetisation to be set.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/models/dw-reference/","title":"Domain wall","text":""},{"location":"api/models/dw-reference/#cmtj.models.domain_dynamics.DW","title":"<code>DW</code>","text":"<p>Initial conditions for the phi of DW equation.</p> Source code in <code>cmtj/models/domain_dynamics.py</code> <pre><code>class DW:\n    \"\"\"Initial conditions for the phi of DW equation.\"\"\"\n\n    NEEL_RIGHT = 0\n    NEEL_LEFT = math.pi\n    BLOCH_UP = math.pi / 2.0\n    BLOCH_DOWN = 3.0 * math.pi / 2.0\n</code></pre>"},{"location":"api/models/dw-reference/#cmtj.models.domain_dynamics.DomainWallDynamics","title":"<code>DomainWallDynamics</code>  <code>dataclass</code>","text":"<p>Domain Wall dynamics class.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>VectorObj</code> <p>applied magnetic field vector.</p> required <code>alpha</code> <code>float</code> <p>Gilbert damping.</p> required <code>Ms</code> <code>float</code> <p>magnetisation saturation [A/m].</p> required <code>thickness</code> <code>float</code> <p>thickness of the FM material.</p> required <code>SHE_angle</code> <code>float</code> <p>Spin Hall Effect angle.</p> required <code>D</code> <code>float</code> <p>DMI constant.</p> required <code>Ku</code> <code>float</code> <p>perpendicular anisotropy constant.</p> required <code>Kp</code> <code>float</code> <p>inplane anisotropy constant.</p> required <code>A</code> <code>float</code> <p>exchange constant.</p> <code>1e-11</code> <code>beta</code> <code>float</code> <p>STT beta parameter.</p> <code>1</code> <code>p</code> <code>float</code> <p>STT polarisation efficiency.</p> <code>1</code> <code>V0_pin</code> <code>float</code> <p>pinning voltage constant.</p> <code>1.65e-20</code> <code>V0_edge</code> <code>float</code> <p>edge voltage constant.</p> <code>0</code> <code>pinning</code> <code>float</code> <p>the pinning period.</p> <code>3e-08</code> <code>Lx</code> <code>float</code> <p>z-dimension of the FM block.</p> <code>1.2e-07</code> <code>Ly</code> <code>float</code> <p>y-dimension of the FM block.</p> <code>1.2e-07</code> <code>Lz</code> <code>float</code> <p>z-dimension of the FM block.</p> <code>3e-09</code> <code>Q</code> <code>int</code> <p>up-down or down-up wall parameter (either 1 or -1).</p> <code>1</code> <code>Hr</code> <code>float</code> <p>Rashba field [A/m].</p> <code>0</code> <code>moving_field</code> <code>Literal['perpendicular', 'inplane']</code> <p>whether the anisotropy field is perpendicular or parallel</p> <code>'perpendicular'</code> <code>relax_dw</code> <code>DWRelax</code> <p>whether to relax the domain width. See DWRelax class. For classical formulation see: Current-driven dynamics of chiral ferromagnetic domain walls, Emori et al, 2013</p> <code>DWRelax.STATIC</code> Source code in <code>cmtj/models/domain_dynamics.py</code> <pre><code>@dataclass\nclass DomainWallDynamics:\n    \"\"\"Domain Wall dynamics class.\n    :param H: applied magnetic field vector.\n    :param alpha: Gilbert damping.\n    :param Ms: magnetisation saturation [A/m].\n    :param thickness: thickness of the FM material.\n    :param SHE_angle: Spin Hall Effect angle.\n    :param D: DMI constant.\n    :param Ku: perpendicular anisotropy constant.\n    :param Kp: inplane anisotropy constant.\n    :param A: exchange constant.\n    :param beta: STT beta parameter.\n    :param p: STT polarisation efficiency.\n    :param V0_pin: pinning voltage constant.\n    :param V0_edge: edge voltage constant.\n    :param pinning: the pinning period.\n    :param Lx: z-dimension of the FM block.\n    :param Ly: y-dimension of the FM block.\n    :param Lz: z-dimension of the FM block.\n    :param Q: up-down or down-up wall parameter (either 1 or -1).\n    :param Hr: Rashba field [A/m].\n    :param moving_field: whether the anisotropy field is perpendicular or parallel\n    :param relax_dw: whether to relax the domain width. See DWRelax class.\n    For classical formulation see:\n    Current-driven dynamics of chiral ferromagnetic domain walls, Emori et al, 2013\n    \"\"\"\n\n    H: VectorObj\n    alpha: float\n    Ms: float\n    thickness: float\n    SHE_angle: float\n    D: float\n    Ku: float  # The out-of-plane anisotropy constant\n    Kp: float  # The in-plane anisotropy constant\n    A: float = 1e-11  # J/m\n    beta: float = 1\n    p: float = 1\n    V0_pin: float = 1.65e-20\n    V0_edge: float = 0\n    pinning: float = 30e-9\n    Lx: float = 120e-9\n    Ly: float = 120e-9\n    Lz: float = 3e-9\n    Q: int = 1\n    Hr: float = 0\n    moving_field: Literal[\"perpendicular\", \"inplane\"] = \"perpendicular\"\n    relax_dw: DWRelax = DWRelax.STATIC\n    dw0: float = field(init=False)\n\n    def __post_init__(self):\n        # in post init we already have p\n        self.bj = bohr_magneton * self.p / (echarge * self.Ms)\n        self.je_driver = lambda t: 0\n        denom = 2 * self.Ms * mu0 * echarge * self.thickness\n        self.Hshe = hbar * self.SHE_angle / denom\n        self.hx, self.hy, self.hz = self.H.get_cartesian()\n        self.dw0 = self.get_unrelaxed_domain_width()\n\n        if self.moving_field == \"perpendicular\":\n            self.Hk = self.get_perpendicular_anisotropy_field()\n        elif self.moving_field == \"inplane\":\n            self.Hk = self.get_inplane_anisotropy_field()\n\n    def get_unrelaxed_domain_width(self, effective=False):\n        \"\"\"Domain width is based off the effective perpendicular anisotropy.\n        We reduce the perpendicular anisotropy by demagnetising field\"\"\"\n        # Keff = self.Ku - 0.5*mu0*(self.Ms)**2\n        Keff = self.Ku - (0.5 * mu0) * (self.Ms**2) if effective else self.Ku\n        return math.sqrt(self.A / Keff)\n\n    def set_current_function(self, driver: Callable):\n        \"\"\"\n        :param driver: A function of time that returns the current density\n        \"\"\"\n        self.je_driver = driver\n\n    def get_Hdmi(self, domain_width):\n        \"\"\"Returns the DMI field\"\"\"\n        return self.D / (mu0 * self.Ms * domain_width)\n\n    def get_perpendicular_anisotropy_field(self):\n        \"\"\"Returns the perpeanisotropy field\"\"\"\n        return 2 * self.Ku / (mu0 * self.Ms)\n\n    def get_inplane_anisotropy_field(self):\n        \"\"\"Returns the in-plane anisotropy field\"\"\"\n        return 2 * self.Kp / (mu0 * self.Ms)\n</code></pre>"},{"location":"api/models/dw-reference/#cmtj.models.domain_dynamics.DomainWallDynamics.get_Hdmi","title":"<code>get_Hdmi(domain_width)</code>","text":"<p>Returns the DMI field</p> Source code in <code>cmtj/models/domain_dynamics.py</code> <pre><code>def get_Hdmi(self, domain_width):\n    \"\"\"Returns the DMI field\"\"\"\n    return self.D / (mu0 * self.Ms * domain_width)\n</code></pre>"},{"location":"api/models/dw-reference/#cmtj.models.domain_dynamics.DomainWallDynamics.get_inplane_anisotropy_field","title":"<code>get_inplane_anisotropy_field()</code>","text":"<p>Returns the in-plane anisotropy field</p> Source code in <code>cmtj/models/domain_dynamics.py</code> <pre><code>def get_inplane_anisotropy_field(self):\n    \"\"\"Returns the in-plane anisotropy field\"\"\"\n    return 2 * self.Kp / (mu0 * self.Ms)\n</code></pre>"},{"location":"api/models/dw-reference/#cmtj.models.domain_dynamics.DomainWallDynamics.get_perpendicular_anisotropy_field","title":"<code>get_perpendicular_anisotropy_field()</code>","text":"<p>Returns the perpeanisotropy field</p> Source code in <code>cmtj/models/domain_dynamics.py</code> <pre><code>def get_perpendicular_anisotropy_field(self):\n    \"\"\"Returns the perpeanisotropy field\"\"\"\n    return 2 * self.Ku / (mu0 * self.Ms)\n</code></pre>"},{"location":"api/models/dw-reference/#cmtj.models.domain_dynamics.DomainWallDynamics.get_unrelaxed_domain_width","title":"<code>get_unrelaxed_domain_width(effective=False)</code>","text":"<p>Domain width is based off the effective perpendicular anisotropy. We reduce the perpendicular anisotropy by demagnetising field</p> Source code in <code>cmtj/models/domain_dynamics.py</code> <pre><code>def get_unrelaxed_domain_width(self, effective=False):\n    \"\"\"Domain width is based off the effective perpendicular anisotropy.\n    We reduce the perpendicular anisotropy by demagnetising field\"\"\"\n    # Keff = self.Ku - 0.5*mu0*(self.Ms)**2\n    Keff = self.Ku - (0.5 * mu0) * (self.Ms**2) if effective else self.Ku\n    return math.sqrt(self.A / Keff)\n</code></pre>"},{"location":"api/models/dw-reference/#cmtj.models.domain_dynamics.DomainWallDynamics.set_current_function","title":"<code>set_current_function(driver)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>driver</code> <code>Callable</code> <p>A function of time that returns the current density</p> required Source code in <code>cmtj/models/domain_dynamics.py</code> <pre><code>def set_current_function(self, driver: Callable):\n    \"\"\"\n    :param driver: A function of time that returns the current density\n    \"\"\"\n    self.je_driver = driver\n</code></pre>"},{"location":"api/models/dw-reference/#cmtj.models.domain_dynamics.MultilayerWallDynamics","title":"<code>MultilayerWallDynamics</code>  <code>dataclass</code>","text":"Source code in <code>cmtj/models/domain_dynamics.py</code> <pre><code>@dataclass\nclass MultilayerWallDynamics:\n    layers: list[DomainWallDynamics]\n    J: float = 0\n    vector_size: int = 3  # 3 for X, phi, delta\n\n    def __post_init__(self):\n        if len(self.layers) &gt; 2:\n            raise ValueError(\"Wall dynamics supported up to 2 layers\")\n\n    def multilayer_dw_llg(self, t, vec):\n        \"\"\"Solve the Thiaville llg equation for LLG.\n        :param t: current simulation time.\n        :param vec: contains [X, phi, delta], current DW position, its angle and domain width.\n        :returns (dXdt, dPhidt, dDeltad): velocity and change of angle and domain width.\n        \"\"\"\n        # vector is X1, phi1, Delta1, X2, phi2, Delta2...\n        layer: DomainWallDynamics\n        new_vec = []\n        for i, layer in enumerate(self.layers):\n            je_at_t = layer.je_driver(t=t)\n            reduced_alpha = 1.0 + layer.alpha**2\n            lx = vec[self.vector_size * i]\n            lphi = vec[(self.vector_size * i) + 1]\n            ldomain_width = vec[(self.vector_size * i) + 2]\n            if len(self.layers) == 1:\n                Jterm = 0\n            else:\n                Jterm = 2 * self.J / (layer.Ms * mu0 * layer.thickness)\n                otherphi = vec[self.vector_size * (i - 1) + 1]\n                Jterm *= math.sin(lphi - otherphi)\n\n            hdmi = layer.get_Hdmi(ldomain_width)\n            dXdt, dPhidt, dDeltadt = compute_dynamics(\n                X=lx,\n                phi=lphi,\n                delta=ldomain_width,\n                Q=layer.Q,\n                hx=layer.hx,\n                hy=layer.hy,\n                hz=layer.hz,\n                alpha=layer.alpha,\n                bj=layer.bj * je_at_t,\n                hr=layer.Hr,\n                beta=layer.beta,\n                hshe=layer.Hshe * je_at_t,\n                hdmi=hdmi,\n                hk=layer.Hk,\n                Ms=layer.Ms,\n                IECterm=Jterm,\n                V0_pin=layer.V0_pin,\n                V0_edge=layer.V0_edge,\n                pinning=layer.pinning,\n                Lx=layer.Lx,\n                Ly=layer.Ly,\n                Lz=layer.Lz,\n                A=layer.A,\n                Ku=layer.Ku,\n                Kp=layer.Kp,\n                thickness=layer.thickness,\n            )\n            dXdt = dXdt / reduced_alpha\n            dPhidt = dPhidt / reduced_alpha\n            if layer.relax_dw != DWRelax.DYNAMIC:\n                dDeltadt = 0  # no relaxation in the ODE\n            new_vec.extend([dXdt, dPhidt, dDeltadt])\n        return new_vec\n\n    def run(self, sim_time: float, starting_conditions: list[float], max_step: float = 1e-10):\n        \"\"\"Run simulation of DW dynamics.\n        :param sim_time: total simulation time (simulation units).\n        :param starting_conditions: starting position and angle of the DW.\n        :param max_step: maximum allowed step of the RK45 method.\n        \"\"\"\n        integrator = RK45(\n            fun=self.multilayer_dw_llg,\n            t0=0.0,\n            first_step=1e-16,\n            max_step=max_step,\n            y0=starting_conditions,\n            rtol=1e-12,\n            t_bound=sim_time,\n        )\n        result = defaultdict(list)\n        while True:\n            integrator.step()\n            if integrator.status == \"failed\":\n                print(\"Failed to converge\")\n                break\n            layer_vecs = integrator.y\n            result[\"t\"].append(integrator.t)\n            for i, layer in enumerate(self.layers):\n                x, phi, dw = (\n                    layer_vecs[self.vector_size * i],\n                    layer_vecs[self.vector_size * i + 1],\n                    layer_vecs[self.vector_size * i + 2],\n                )\n                # static relaxation Thiaville\n                if layer.relax_dw == DWRelax.STATIC:\n                    ratio = layer.Kp / layer.Ku\n                    dw = layer.dw0 / math.sqrt(1 + ratio * math.sin(phi) ** 2)\n                vel = (x - integrator.y_old[2 * i]) / integrator.step_size\n                result[f\"dw_{i}\"].append(dw)\n                result[f\"v_{i}\"].append(vel)\n                result[f\"x_{i}\"].append(x)\n                result[f\"phi_{i}\"].append(phi)\n                result[f\"je_{i}\"].append(layer.je_driver(t=integrator.t))\n            if integrator.status == \"finished\":\n                break\n\n        return result\n</code></pre>"},{"location":"api/models/dw-reference/#cmtj.models.domain_dynamics.MultilayerWallDynamics.multilayer_dw_llg","title":"<code>multilayer_dw_llg(t, vec)</code>","text":"<p>Solve the Thiaville llg equation for LLG.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <p>current simulation time.</p> required <code>vec</code> <p>contains [X, phi, delta], current DW position, its angle and domain width.</p> required <p>Returns:</p> Type Description <p>velocity and change of angle and domain width.</p> Source code in <code>cmtj/models/domain_dynamics.py</code> <pre><code>def multilayer_dw_llg(self, t, vec):\n    \"\"\"Solve the Thiaville llg equation for LLG.\n    :param t: current simulation time.\n    :param vec: contains [X, phi, delta], current DW position, its angle and domain width.\n    :returns (dXdt, dPhidt, dDeltad): velocity and change of angle and domain width.\n    \"\"\"\n    # vector is X1, phi1, Delta1, X2, phi2, Delta2...\n    layer: DomainWallDynamics\n    new_vec = []\n    for i, layer in enumerate(self.layers):\n        je_at_t = layer.je_driver(t=t)\n        reduced_alpha = 1.0 + layer.alpha**2\n        lx = vec[self.vector_size * i]\n        lphi = vec[(self.vector_size * i) + 1]\n        ldomain_width = vec[(self.vector_size * i) + 2]\n        if len(self.layers) == 1:\n            Jterm = 0\n        else:\n            Jterm = 2 * self.J / (layer.Ms * mu0 * layer.thickness)\n            otherphi = vec[self.vector_size * (i - 1) + 1]\n            Jterm *= math.sin(lphi - otherphi)\n\n        hdmi = layer.get_Hdmi(ldomain_width)\n        dXdt, dPhidt, dDeltadt = compute_dynamics(\n            X=lx,\n            phi=lphi,\n            delta=ldomain_width,\n            Q=layer.Q,\n            hx=layer.hx,\n            hy=layer.hy,\n            hz=layer.hz,\n            alpha=layer.alpha,\n            bj=layer.bj * je_at_t,\n            hr=layer.Hr,\n            beta=layer.beta,\n            hshe=layer.Hshe * je_at_t,\n            hdmi=hdmi,\n            hk=layer.Hk,\n            Ms=layer.Ms,\n            IECterm=Jterm,\n            V0_pin=layer.V0_pin,\n            V0_edge=layer.V0_edge,\n            pinning=layer.pinning,\n            Lx=layer.Lx,\n            Ly=layer.Ly,\n            Lz=layer.Lz,\n            A=layer.A,\n            Ku=layer.Ku,\n            Kp=layer.Kp,\n            thickness=layer.thickness,\n        )\n        dXdt = dXdt / reduced_alpha\n        dPhidt = dPhidt / reduced_alpha\n        if layer.relax_dw != DWRelax.DYNAMIC:\n            dDeltadt = 0  # no relaxation in the ODE\n        new_vec.extend([dXdt, dPhidt, dDeltadt])\n    return new_vec\n</code></pre>"},{"location":"api/models/dw-reference/#cmtj.models.domain_dynamics.MultilayerWallDynamics.run","title":"<code>run(sim_time, starting_conditions, max_step=1e-10)</code>","text":"<p>Run simulation of DW dynamics.</p> <p>Parameters:</p> Name Type Description Default <code>sim_time</code> <code>float</code> <p>total simulation time (simulation units).</p> required <code>starting_conditions</code> <code>list[float]</code> <p>starting position and angle of the DW.</p> required <code>max_step</code> <code>float</code> <p>maximum allowed step of the RK45 method.</p> <code>1e-10</code> Source code in <code>cmtj/models/domain_dynamics.py</code> <pre><code>def run(self, sim_time: float, starting_conditions: list[float], max_step: float = 1e-10):\n    \"\"\"Run simulation of DW dynamics.\n    :param sim_time: total simulation time (simulation units).\n    :param starting_conditions: starting position and angle of the DW.\n    :param max_step: maximum allowed step of the RK45 method.\n    \"\"\"\n    integrator = RK45(\n        fun=self.multilayer_dw_llg,\n        t0=0.0,\n        first_step=1e-16,\n        max_step=max_step,\n        y0=starting_conditions,\n        rtol=1e-12,\n        t_bound=sim_time,\n    )\n    result = defaultdict(list)\n    while True:\n        integrator.step()\n        if integrator.status == \"failed\":\n            print(\"Failed to converge\")\n            break\n        layer_vecs = integrator.y\n        result[\"t\"].append(integrator.t)\n        for i, layer in enumerate(self.layers):\n            x, phi, dw = (\n                layer_vecs[self.vector_size * i],\n                layer_vecs[self.vector_size * i + 1],\n                layer_vecs[self.vector_size * i + 2],\n            )\n            # static relaxation Thiaville\n            if layer.relax_dw == DWRelax.STATIC:\n                ratio = layer.Kp / layer.Ku\n                dw = layer.dw0 / math.sqrt(1 + ratio * math.sin(phi) ** 2)\n            vel = (x - integrator.y_old[2 * i]) / integrator.step_size\n            result[f\"dw_{i}\"].append(dw)\n            result[f\"v_{i}\"].append(vel)\n            result[f\"x_{i}\"].append(x)\n            result[f\"phi_{i}\"].append(phi)\n            result[f\"je_{i}\"].append(layer.je_driver(t=integrator.t))\n        if integrator.status == \"finished\":\n            break\n\n    return result\n</code></pre>"},{"location":"api/models/sb-general-reference/","title":"Smit-Beljers","text":"<p>This module contains the basic implementation of the Smit-Beljers model. The model is based on the following paper which introduced a corrected model: Rodr\u00edguez-Su\u00e1rez et al., \"Ferromagnetic resonance investigation of the residual coupling in spin-valve systems\" 10.1103/PhysRevB.71.224406</p>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.LayerDynamic","title":"<code>LayerDynamic</code>  <code>dataclass</code>","text":"<p>         Bases: <code>LayerSB</code></p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>@dataclass\nclass LayerDynamic(LayerSB):\n    alpha: float = 0.01\n    torque_par: float = 0\n    torque_perp: float = 0\n\n    @staticmethod\n    def get_hoe_ex_symbol():\n        return sym.Symbol(r\"H_{oe}\")\n\n    @staticmethod\n    def get_Vp_symbol():\n        return sym.Symbol(r\"V_{p}\")\n\n    def rhs_spherical_llg(\n        self,\n        U: sym.Matrix,\n        osc: bool = False,\n    ):\n        \"\"\"Returns the symbolic expression for the RHS of the spherical LLG equation.\n        Coupling contribution comes only from the bottom layer (top-down crawl)\n\n        :param H: external field\n        :param U: energy expression of the layer\n        \"\"\"\n        # sum all components\n        prefac = gamma_rad / (1.0 + self.alpha**2)\n        inv_sin = 1.0 / (sym.sin(self.theta) + EPS)\n        dUdtheta = sym.diff(U, self.theta)\n        dUdphi = sym.diff(U, self.phi)\n\n        # Hoe can be used only for excitation, unlike Vp which controls torquances\n        Hoe = LayerDynamic.get_hoe_ex_symbol() if osc else 0\n        dtheta = -inv_sin * dUdphi - self.alpha * dUdtheta + self.Ms * Hoe\n        dphi = inv_sin * dUdtheta - self.alpha * dUdphi * (inv_sin) ** 2 + self.alpha * self.Ms * Hoe * inv_sin\n        return prefac * (sym.Matrix([dtheta, dphi]) + self.torque(osc=osc)) / self.Ms\n\n    def torque(self, osc: bool = True):\n        # cannot be 0 because you may want to use Hoe + torques\n        Vp = LayerDynamic.get_Vp_symbol() if osc else 1\n        torque_ex_par = self.torque_par * Vp\n        torque_ex_perp = self.torque_perp * Vp\n\n        return sym.ImmutableMatrix(\n            [\n                sym.sin(self.theta) * (-torque_ex_par - self.alpha * torque_ex_perp),\n                -torque_ex_perp + self.alpha * torque_ex_par,\n            ]\n        )\n\n    def __eq__(self, __value: \"LayerDynamic\") -&gt; bool:\n        return super().__eq__(__value) and self.alpha == __value.alpha\n\n    def __hash__(self) -&gt; int:\n        return super().__hash__()\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.LayerDynamic.rhs_spherical_llg","title":"<code>rhs_spherical_llg(U, osc=False)</code>","text":"<p>Returns the symbolic expression for the RHS of the spherical LLG equation. Coupling contribution comes only from the bottom layer (top-down crawl)</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <p>external field</p> required <code>U</code> <code>sym.Matrix</code> <p>energy expression of the layer</p> required Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def rhs_spherical_llg(\n    self,\n    U: sym.Matrix,\n    osc: bool = False,\n):\n    \"\"\"Returns the symbolic expression for the RHS of the spherical LLG equation.\n    Coupling contribution comes only from the bottom layer (top-down crawl)\n\n    :param H: external field\n    :param U: energy expression of the layer\n    \"\"\"\n    # sum all components\n    prefac = gamma_rad / (1.0 + self.alpha**2)\n    inv_sin = 1.0 / (sym.sin(self.theta) + EPS)\n    dUdtheta = sym.diff(U, self.theta)\n    dUdphi = sym.diff(U, self.phi)\n\n    # Hoe can be used only for excitation, unlike Vp which controls torquances\n    Hoe = LayerDynamic.get_hoe_ex_symbol() if osc else 0\n    dtheta = -inv_sin * dUdphi - self.alpha * dUdtheta + self.Ms * Hoe\n    dphi = inv_sin * dUdtheta - self.alpha * dUdphi * (inv_sin) ** 2 + self.alpha * self.Ms * Hoe * inv_sin\n    return prefac * (sym.Matrix([dtheta, dphi]) + self.torque(osc=osc)) / self.Ms\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.LayerSB","title":"<code>LayerSB</code>  <code>dataclass</code>","text":"<p>Basic Layer for Smit-Beljers model.</p> <p>Parameters:</p> Name Type Description Default <code>thickness</code> <code>float</code> <p>thickness of the FM layer (effective).</p> required <code>Kv</code> <code>VectorObj</code> <p>volumetric (in-plane) anisotropy. Only phi and mag count [J/m^3].</p> required <code>Ks</code> <code>float</code> <p>surface anisotropy (out-of plane, or perpendicular) value [J/m^3].</p> required <code>Ms</code> <code>float</code> <p>magnetisation saturation value in [A/m].</p> required <code>Hdmi</code> <code>VectorObj</code> <p>DMI field in the layer. Defaults to [0, 0, 0].</p> <code>None</code> <code>Ndemag</code> <code>VectorObj</code> <p>demagnetisation tensor diagonal. Defaults to [0, 0, 1] (thin film). for sphere, use [1/3, 1/3, 1/3].</p> <code>VectorObj.from_cartesian(0, 0, 1)</code> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>@dataclass\nclass LayerSB:\n    \"\"\"Basic Layer for Smit-Beljers model.\n    :param thickness: thickness of the FM layer (effective).\n    :param Kv: volumetric (in-plane) anisotropy. Only phi and mag count [J/m^3].\n    :param Ks: surface anisotropy (out-of plane, or perpendicular) value [J/m^3].\n    :param Ms: magnetisation saturation value in [A/m].\n    :param Hdmi: DMI field in the layer. Defaults to [0, 0, 0].\n    :param Ndemag: demagnetisation tensor diagonal. Defaults to [0, 0, 1] (thin film).\n                  for sphere, use [1/3, 1/3, 1/3].\n    \"\"\"\n\n    _id: int\n    thickness: float\n    Kv: VectorObj\n    Ks: float\n    Ms: float\n    Hdmi: VectorObj = None  # TODO: change when we support py3.10 upwards (field(kw_only=True, default=None))\n    Ndemag: VectorObj = VectorObj.from_cartesian(0, 0, 1)\n    coordinate_system: Literal[\"spherical\", \"cartesian\"] = \"spherical\"\n\n    def __post_init__(self):\n        if self._id &gt; 9:\n            raise ValueError(\"Only up to 10 layers supported.\")\n        if self.Hdmi is None:\n            self.Hdmi = [0, 0, 0]\n        self.Hdmi = _default_matrix_conversion(self.Hdmi)\n        self.Ndemag = _default_matrix_conversion(self.Ndemag)\n\n        self.anisotropy_axis = _default_matrix_conversion([sym.cos(self.Kv.phi), sym.sin(self.Kv.phi), 0])\n\n        if self.coordinate_system == \"spherical\":\n            self.phi = sym.Symbol(r\"\\phi_\" + str(self._id))\n            self.theta = sym.Symbol(r\"\\theta_\" + str(self._id))\n            self.m = _default_matrix_conversion(\n                [\n                    sym.sin(self.theta) * sym.cos(self.phi),\n                    sym.sin(self.theta) * sym.sin(self.phi),\n                    sym.cos(self.theta),\n                ]\n            )\n            self.get_coord_sym = self.get_coord_sym_spherical\n        elif self.coordinate_system == \"cartesian\":\n            self.x = sym.Symbol(\"m_{\" + \"x,\" + f\"{self._id}\" + \"}\")\n            self.y = sym.Symbol(\"m_{\" + \"y,\" + f\"{self._id}\" + \"}\")\n            self.z = sym.Symbol(\"m_{\" + \"z,\" + f\"{self._id}\" + \"}\")\n            self.m = _default_matrix_conversion(\n                [\n                    self.x,\n                    self.y,\n                    self.z,\n                ]\n            )\n            self.get_coord_sym = self.get_coord_sym_cartesian\n\n    def get_coord_sym_spherical(self):\n        \"\"\"Returns the symbolic coordinates of the layer.\"\"\"\n        return self.theta, self.phi\n\n    def get_coord_sym_cartesian(self):\n        \"\"\"Returns the symbolic coordinates of the layer.\"\"\"\n        return self.x, self.y, self.z\n\n    def get_m_sym(self):\n        \"\"\"Returns the magnetisation vector.\"\"\"\n        return self.m\n\n    @lru_cache(3)  # noqa: B019\n    def total_symbolic_layer_energy(\n        self,\n        H: sym.ImmutableMatrix,\n        J1top: float,\n        J1bottom: float,\n        J2top: float,\n        J2bottom: float,\n        top_layer: \"LayerSB\",\n        down_layer: \"LayerSB\",\n    ):\n        \"\"\"Returns the symbolic expression for the energy of the layer.\n        Coupling contribution comes only from the bottom layer (top-down crawl)\"\"\"\n        m = self.get_m_sym()\n\n        eng_non_interaction = self.no_interaction_symbolic_energy(H) * self.thickness\n\n        top_iec_energy = 0\n        bottom_iec_energy = 0\n\n        if top_layer is not None:\n            other_m = top_layer.get_m_sym()\n            mdot = m.dot(other_m)\n            top_iec_energy = -J1top * mdot - J2top * mdot**2\n        if down_layer is not None:\n            other_m = down_layer.get_m_sym()\n            mdot = m.dot(other_m)\n            bottom_iec_energy = -J1bottom * mdot - J2bottom * mdot**2\n        return eng_non_interaction + top_iec_energy + bottom_iec_energy\n\n    def no_interaction_symbolic_energy(self, H: sym.ImmutableMatrix):\n        \"\"\"Returns the symbolic expression for the energy of the layer.\n        Coupling contribution comes only from the bottom layer (top-down crawl)\"\"\"\n        m = self.get_m_sym()\n\n        alpha = sym.ImmutableMatrix([sym.cos(self.Kv.phi), sym.sin(self.Kv.phi), 0])\n\n        field_energy = -mu0 * self.Ms * m.dot(H)\n        hdmi_energy = -mu0 * self.Ms * m.dot(self.Hdmi)\n        # old surface anisotropy only took into account the thin slab demag\n        # surface_anistropy = (-self.Ks + (1.0 / 2.0) * mu0 * self.Ms**2) * (m[-1] ** 2)\n        surface_anistropy = -self.Ks * (m[-1] ** 2)\n        volume_anisotropy = -self.Kv.mag * (m.dot(alpha) ** 2)\n        m_2 = sym.ImmutableMatrix([m_i**2 for m_i in m])\n        demagnetisation_energy = 0.5 * mu0 * (self.Ms**2) * m_2.dot(self.Ndemag)\n\n        return field_energy + surface_anistropy + volume_anisotropy + hdmi_energy + demagnetisation_energy\n\n    def sb_correction(self):\n        \"\"\"\n        Using gamma here instead of gamma_rad for two reason:\n        1. It seems to provide more stable solutinos\n        2. Root finding needs to be done over smaller range of frequencies\n            (gamma_rad is 2pi times larger than gamma) which is faster\n\n        Just remember NOT to divide by 2pi when returning the roots!\n        \"\"\"\n        return (OMEGA / gamma) * self.Ms * sym.sin(self.theta) * self.thickness\n\n    def __hash__(self) -&gt; int:\n        return hash(str(self))\n\n    def __eq__(self, __value: \"LayerSB\") -&gt; bool:\n        return (\n            self._id == __value._id\n            and self.thickness == __value.thickness\n            and self.Kv == __value.Kv\n            and self.Ks == __value.Ks\n            and self.Ms == __value.Ms\n        )\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.LayerSB.get_coord_sym_cartesian","title":"<code>get_coord_sym_cartesian()</code>","text":"<p>Returns the symbolic coordinates of the layer.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def get_coord_sym_cartesian(self):\n    \"\"\"Returns the symbolic coordinates of the layer.\"\"\"\n    return self.x, self.y, self.z\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.LayerSB.get_coord_sym_spherical","title":"<code>get_coord_sym_spherical()</code>","text":"<p>Returns the symbolic coordinates of the layer.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def get_coord_sym_spherical(self):\n    \"\"\"Returns the symbolic coordinates of the layer.\"\"\"\n    return self.theta, self.phi\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.LayerSB.get_m_sym","title":"<code>get_m_sym()</code>","text":"<p>Returns the magnetisation vector.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def get_m_sym(self):\n    \"\"\"Returns the magnetisation vector.\"\"\"\n    return self.m\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.LayerSB.no_interaction_symbolic_energy","title":"<code>no_interaction_symbolic_energy(H)</code>","text":"<p>Returns the symbolic expression for the energy of the layer. Coupling contribution comes only from the bottom layer (top-down crawl)</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def no_interaction_symbolic_energy(self, H: sym.ImmutableMatrix):\n    \"\"\"Returns the symbolic expression for the energy of the layer.\n    Coupling contribution comes only from the bottom layer (top-down crawl)\"\"\"\n    m = self.get_m_sym()\n\n    alpha = sym.ImmutableMatrix([sym.cos(self.Kv.phi), sym.sin(self.Kv.phi), 0])\n\n    field_energy = -mu0 * self.Ms * m.dot(H)\n    hdmi_energy = -mu0 * self.Ms * m.dot(self.Hdmi)\n    # old surface anisotropy only took into account the thin slab demag\n    # surface_anistropy = (-self.Ks + (1.0 / 2.0) * mu0 * self.Ms**2) * (m[-1] ** 2)\n    surface_anistropy = -self.Ks * (m[-1] ** 2)\n    volume_anisotropy = -self.Kv.mag * (m.dot(alpha) ** 2)\n    m_2 = sym.ImmutableMatrix([m_i**2 for m_i in m])\n    demagnetisation_energy = 0.5 * mu0 * (self.Ms**2) * m_2.dot(self.Ndemag)\n\n    return field_energy + surface_anistropy + volume_anisotropy + hdmi_energy + demagnetisation_energy\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.LayerSB.sb_correction","title":"<code>sb_correction()</code>","text":"<p>Using gamma here instead of gamma_rad for two reason: 1. It seems to provide more stable solutinos 2. Root finding needs to be done over smaller range of frequencies     (gamma_rad is 2pi times larger than gamma) which is faster</p> <p>Just remember NOT to divide by 2pi when returning the roots!</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def sb_correction(self):\n    \"\"\"\n    Using gamma here instead of gamma_rad for two reason:\n    1. It seems to provide more stable solutinos\n    2. Root finding needs to be done over smaller range of frequencies\n        (gamma_rad is 2pi times larger than gamma) which is faster\n\n    Just remember NOT to divide by 2pi when returning the roots!\n    \"\"\"\n    return (OMEGA / gamma) * self.Ms * sym.sin(self.theta) * self.thickness\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.LayerSB.total_symbolic_layer_energy","title":"<code>total_symbolic_layer_energy(H, J1top, J1bottom, J2top, J2bottom, top_layer, down_layer)</code>  <code>cached</code>","text":"<p>Returns the symbolic expression for the energy of the layer. Coupling contribution comes only from the bottom layer (top-down crawl)</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>@lru_cache(3)  # noqa: B019\ndef total_symbolic_layer_energy(\n    self,\n    H: sym.ImmutableMatrix,\n    J1top: float,\n    J1bottom: float,\n    J2top: float,\n    J2bottom: float,\n    top_layer: \"LayerSB\",\n    down_layer: \"LayerSB\",\n):\n    \"\"\"Returns the symbolic expression for the energy of the layer.\n    Coupling contribution comes only from the bottom layer (top-down crawl)\"\"\"\n    m = self.get_m_sym()\n\n    eng_non_interaction = self.no_interaction_symbolic_energy(H) * self.thickness\n\n    top_iec_energy = 0\n    bottom_iec_energy = 0\n\n    if top_layer is not None:\n        other_m = top_layer.get_m_sym()\n        mdot = m.dot(other_m)\n        top_iec_energy = -J1top * mdot - J2top * mdot**2\n    if down_layer is not None:\n        other_m = down_layer.get_m_sym()\n        mdot = m.dot(other_m)\n        bottom_iec_energy = -J1bottom * mdot - J2bottom * mdot**2\n    return eng_non_interaction + top_iec_energy + bottom_iec_energy\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver","title":"<code>Solver</code>  <code>dataclass</code>","text":"<p>General solver for the system.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[Union[LayerSB, LayerDynamic]]</code> <p>list of layers in the system.</p> required <code>J1</code> <code>list[float]</code> <p>list of interlayer exchange constants. Goes (i)-(i+1), i = 0, 1, 2, ... with i being the index of the layer.</p> required <code>J2</code> <code>list[float]</code> <p>list of interlayer exchange constants.</p> required <code>ilD</code> <code>list[VectorObj]</code> <p>list of interlayer DMI vectors, e.g. (0, 0, D)., ilD * (m1 x m2)</p> <code>None</code> <code>H</code> <code>VectorObj</code> <p>external field.</p> <code>None</code> <code>Ndipole</code> <code>list[list[VectorObj]]</code> <p>list of dipole fields for each layer. Defaults to None. Goes (i)-(i+1), i = 0, 1, 2, ... with i being the index of the layer.</p> <code>None</code> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>@dataclass\nclass Solver:\n    \"\"\"General solver for the system.\n\n    :param layers: list of layers in the system.\n    :param J1: list of interlayer exchange constants. Goes (i)-(i+1), i = 0, 1, 2, ...\n        with i being the index of the layer.\n    :param J2: list of interlayer exchange constants.\n    :param ilD: list of interlayer DMI vectors, e.g. (0, 0, D).,\n        ilD * (m1 x m2)\n    :param H: external field.\n    :param Ndipole: list of dipole fields for each layer. Defaults to None.\n        Goes (i)-(i+1), i = 0, 1, 2, ... with i being the index of the layer.\n    \"\"\"\n\n    layers: list[Union[LayerSB, LayerDynamic]]\n    J1: list[float]\n    J2: list[float]\n    H: VectorObj = None\n    ilD: list[VectorObj] = None\n    Ndipole: list[list[VectorObj]] = None\n\n    # Configuration options as regular fields\n    prefer_numerical_roots: bool = True\n    use_LU_decomposition: bool = True\n\n    def __post_init__(self):\n        if len(self.layers) != len(self.J1) + 1:\n            raise ValueError(\"Number of layers must be 1 more than J1.\")\n        if len(self.layers) != len(self.J2) + 1:\n            raise ValueError(\"Number of layers must be 1 more than J2.\")\n        if self.ilD is None:\n            # this is optional, if not provided, we assume zero DMI\n            self.ilD = [VectorObj(0, 0, 0) for _ in range(len(self.layers) - 1)]\n        if len(self.layers) != len(self.ilD) + 1:\n            raise ValueError(\"Number of layers must be 1 more than ilD.\")\n        if not all(isinstance(d, VectorObj) for d in self.ilD):\n            raise ValueError(\"ilD must be a list of VectorObj.\")\n\n        self.ilD = [sym.ImmutableMatrix(d.get_cartesian()) for d in self.ilD]\n        self.dipoleMatrix: list[sym.Matrix] = None\n        if self.Ndipole is not None:\n            if len(self.layers) != len(self.Ndipole) + 1:\n                raise ValueError(\"Number of layers must be 1 more than number of tensors.\")\n            self.dipoleMatrix = [sym.Matrix([d.get_cartesian() for d in dipole]) for dipole in self.Ndipole]\n\n        id_sets = {layer._id for layer in self.layers}\n        ideal_set = set(range(len(self.layers)))\n        if id_sets != ideal_set:\n            raise ValueError(\"Layer ids must be 0, 1, 2, ... and unique.Ids must start from 0.\")\n\n        self.det_solver: callable = None\n        self.root_solver: callable = None\n\n        if not self.prefer_numerical_roots and self.use_LU_decomposition:\n            warnings.warn(\n                \"LU sometimes causes slow numerical convergence for analytical solve. \"\n                \"Setting use_LU_decomposition to False.\",\n                stacklevel=2,\n            )\n            self.use_LU_decomposition = False\n        self.root_solver = _root_solver_numerical if self.prefer_numerical_roots else _root_solver_analytical\n        self.det_solver = _lu_decomposition_det if self.use_LU_decomposition else _berkowitz_det\n\n    def get_layer_references(self, layer_indx: int, interaction_constant: list[float]):\n        \"\"\"Returns the references to the layers above and below the layer\n        with index layer_indx.\"\"\"\n        if len(self.layers) == 1:\n            return None, None, 0, 0\n        if layer_indx == 0:\n            return None, self.layers[layer_indx + 1], 0, interaction_constant[0]\n        elif layer_indx == len(self.layers) - 1:\n            return self.layers[layer_indx - 1], None, interaction_constant[-1], 0\n        return (\n            self.layers[layer_indx - 1],\n            self.layers[layer_indx + 1],\n            interaction_constant[layer_indx - 1],\n            interaction_constant[layer_indx],\n        )\n\n    def _heff_per_m(self, e, m):\n        \"\"\"Effective field H_eff = -\u2202e/\u2202m, with e = E/(\u03bc0 Ms_i t_i).\"\"\"\n        return -sym.Matrix([sym.diff(e, mi) for mi in m])\n\n    def compose_llg_jacobian(self, H, form: Literal[\"energy\", \"field\"] = \"energy\"):\n        if form not in (\"energy\", \"field\"):\n            raise ValueError(\"form must be either 'energy' or 'field'\")\n        if isinstance(H, VectorObj):\n            H = sym.ImmutableMatrix(H.get_cartesian())\n\n        symbols, vecs = [], []\n        U = self.create_energy(H=H, volumetric=False)  # energy per area\n        # mu0, gamma_rad = sym.Symbol(r\"\\mu_0\"), sym.Symbol(r\"\\gamma\")\n        for layer in self.layers:\n            if form == \"energy\":\n                symbols.extend((layer.theta, layer.phi))\n                expr = layer.rhs_spherical_llg(U / layer.thickness, osc=False)\n            else:\n                m = layer.get_m_sym()  # (x,y,z) 3\u00d71\n                symbols.extend((layer.x, layer.y, layer.z))\n                # e_i = E/(\u03bc0 Ms_i t_i) in field units\n                e_i = U / (mu0 * layer.thickness * layer.Ms)\n                H_eff_i = self._heff_per_m(e_i, m)  # 3\u00d71\n                expr = -mu0 * gamma_rad * m.cross(H_eff_i)  # 3\u00d71: F_i(m)\n            vecs.append(expr)\n\n        F = sym.Matrix.vstack(*vecs)  # 3N \u00d7 1\n        J = F.jacobian(symbols)  # 3N \u00d7 3N\n        return J, symbols\n\n    @coordinate(require=\"cartesian\")\n    def linearised_frequencies(self, H, linearisation_axis: Literal[\"x\", \"y\", \"z\"]):\n        J, symbols = self.compose_llg_jacobian(H=H, form=\"field\")\n\n        # partition symbols by axis and indices by axis\n        axis_pos = {\"x\": 0, \"y\": 1, \"z\": 2}\n        by_axis_syms = {a: [s for i, s in enumerate(symbols) if i % 3 == p] for a, p in axis_pos.items()}\n        by_axis_idx = {a: [i for i in range(len(symbols)) if i % 3 == p] for a, p in axis_pos.items()}\n        n = len(self.layers)\n\n        # evaluate at equilibrium: set non-linearised axes to 0, linearised axis to \u00b11\n        hold = linearisation_axis\n        subs_zero = {s: 0 for a, syms in by_axis_syms.items() if a != hold for s in syms}\n        J0 = J.subs(subs_zero)\n\n        if hold == \"z\":\n            P_vals = {by_axis_syms[\"z\"][i]: 1 for i in range(n)}\n            AP_vals = {by_axis_syms[\"z\"][i]: (1 if i % 2 == 0 else -1) for i in range(n)}\n            drop = by_axis_idx[\"z\"]\n        elif hold == \"x\":\n            P_vals = {by_axis_syms[\"x\"][i]: 1 for i in range(n)}\n            AP_vals = {by_axis_syms[\"x\"][i]: (1 if i % 2 == 0 else -1) for i in range(n)}\n            drop = by_axis_idx[\"x\"]\n        else:  # hold == \"y\"\n            P_vals = {by_axis_syms[\"y\"][i]: 1 for i in range(n)}\n            AP_vals = {by_axis_syms[\"y\"][i]: (1 if i % 2 == 0 else -1) for i in range(n)}\n            drop = by_axis_idx[\"y\"]\n\n        J0_P = J0.subs(P_vals)\n        J0_AP = J0.subs(AP_vals)\n\n        # remove the fixed-axis rows/cols (those components are second-order small)\n        keep = [i for i in range(J0.shape[0]) if i not in drop]\n        J0_P = J0_P.extract(keep, keep)\n        J0_AP = J0_AP.extract(keep, keep)\n\n        omega = sym.Symbol(r\"\\omega\", complex=True)\n        char_P = sym.I * omega * sym.eye(J0_P.shape[0]) - J0_P\n        char_AP = sym.I * omega * sym.eye(J0_AP.shape[0]) - J0_AP\n        return char_P, char_AP, J0_P, J0_AP\n\n    @lru_cache(3)  # cache for 3 calls\n    def create_energy(\n        self,\n        H: Union[VectorObj, sym.ImmutableMatrix, None] = None,\n        volumetric: bool = False,\n    ):\n        \"\"\"Creates the symbolic energy expression.\n\n        Due to problematic nature of coupling, there is an issue of\n        computing each layer's FMR in the presence of IEC.\n        If volumetric = True then we use the thickness of the layer to multiply the\n        energy and hence avoid having to divide J by the thickness of a layer.\n        If volumetric = False the J constant is divided by weighted thickness\n        and included in every layer's energy, correcting FMR automatically.\n        \"\"\"\n        if H is None:\n            h = self.H.get_cartesian()\n            H = sym.ImmutableMatrix(h)\n        energy = sum(layer.no_interaction_symbolic_energy(H) * layer.thickness for layer in self.layers)\n\n        for i in range(len(self.layers) - 1):\n            l1m = self.layers[i].get_m_sym()\n            l2m = self.layers[i + 1].get_m_sym()\n\n            # IEC\n            ldot = l1m.dot(l2m)\n            energy -= self.J1[i] * ldot\n            energy -= self.J2[i] * (ldot) ** 2\n\n            # IDMI, sign is the same J1\n            lcross = l1m.cross(l2m)\n            energy -= self.ilD[i].dot(lcross)\n\n            # dipole fields\n            if self.dipoleMatrix is not None:\n                mat = self.dipoleMatrix[i]\n                # is positive, just like demag\n                energy += (\n                    (mu0 / 2.0)\n                    * l1m.dot(mat * l2m)\n                    * self.layers[i].Ms\n                    * self.layers[i + 1].Ms\n                    * self.layers[i].thickness\n                )\n                energy += (\n                    (mu0 / 2.0)\n                    * l2m.dot(mat * l1m)\n                    * self.layers[i].Ms\n                    * self.layers[i + 1].Ms\n                    * self.layers[i + 1].thickness\n                )\n        return energy\n\n    def create_energy_hessian(self, equilibrium_position: list[float]):\n        \"\"\"Creates the symbolic hessian of the energy expression.\"\"\"\n        energy = self.create_energy(volumetric=False)\n        subs = self.get_subs(equilibrium_position)\n        N = len(self.layers)\n        hessian = [[0 for _ in range(2 * N)] for _ in range(2 * N)]\n        for i in range(N):\n            z = self.layers[i].sb_correction()\n            theta_i, phi_i = self.layers[i].get_coord_sym()\n            for j in range(i, N):\n                # dtheta dtheta\n                theta_j, phi_j = self.layers[j].get_coord_sym()\n\n                expr = sym.diff(sym.diff(energy, theta_i), theta_j)\n                hessian[2 * i][2 * j] = expr\n                hessian[2 * j][2 * i] = expr\n\n                # dphi dphi\n                expr = sym.diff(sym.diff(energy, phi_i), phi_j)\n                hessian[2 * i + 1][2 * j + 1] = expr\n                hessian[2 * j + 1][2 * i + 1] = expr\n\n                expr = sym.diff(sym.diff(energy, theta_i), phi_j)\n                # mixed terms\n                if i == j:\n                    hessian[2 * i + 1][2 * j] = expr + sym.I * z\n                    hessian[2 * i][2 * j + 1] = expr - sym.I * z\n                else:\n                    hessian[2 * i][2 * j + 1] = expr\n                    hessian[2 * j + 1][2 * i] = expr\n\n                    expr = sym.diff(sym.diff(energy, phi_i), theta_j)\n                    hessian[2 * i + 1][2 * j] = expr\n                    hessian[2 * j][2 * i + 1] = expr\n\n        hes = sym.ImmutableMatrix(hessian)\n        return hes, subs\n\n    def get_gradient_expr(self, accel=\"math\"):\n        \"\"\"Returns the symbolic gradient of the energy expression.\"\"\"\n        energy = self.create_energy(volumetric=False)\n        grad_vector = []\n        symbols = []\n        for layer in self.layers:\n            (theta, phi) = layer.get_coord_sym()\n            grad_vector.extend((sym.diff(energy, theta), sym.diff(energy, phi)))\n            symbols.extend((theta, phi))\n        return sym.lambdify(symbols, grad_vector, accel)\n\n    def adam_gradient_descent(\n        self,\n        init_position: np.ndarray,\n        max_steps: int,\n        tol: float = 1e-8,\n        learning_rate: float = 1e-4,\n        first_momentum_decay: float = 0.9,\n        second_momentum_decay: float = 0.999,\n        perturbation: float = 1e-6,\n    ):\n        \"\"\"\n        A naive implementation of Adam gradient descent.\n        See: ADAM: A METHOD FOR STOCHASTIC OPTIMIZATION, Kingma et Ba, 2015\n        :param max_steps: maximum number of gradient steps.\n        :param tol: tolerance of the solution.\n        :param learning_rate: the learning rate (descent speed).\n        :param first_momentum_decay: constant for the first momentum.\n        :param second_momentum_decay: constant for the second momentum.\n        \"\"\"\n        step = 0\n        gradfn = self.get_gradient_expr()\n        current_position = init_position\n        if perturbation:\n            current_position = perturb_position(init_position, perturbation)\n        m = np.zeros_like(current_position)  # first momentum\n        v = np.zeros_like(current_position)  # second momentum\n        eps = 1e-12\n        # history = []\n        while True:\n            step += 1\n            grad = np.asarray(gradfn(*current_position))\n            m = first_momentum_decay * m + (1.0 - first_momentum_decay) * grad\n            v = second_momentum_decay * v + (1.0 - second_momentum_decay) * grad**2\n            m_hat = m / (1.0 - first_momentum_decay**step)\n            v_hat = v / (1.0 - second_momentum_decay**step)\n            new_position = current_position - learning_rate * m_hat / (np.sqrt(v_hat) + eps)\n            if step &gt; max_steps:\n                break\n            if fast_norm(current_position - new_position) &lt; tol:\n                break\n            current_position = new_position\n            # history.append(current_position)\n        # return np.asarray(current_position), np.asarray(history)\n        return np.asarray(current_position)\n\n    def amsgrad_gradient_descent(\n        self,\n        init_position: np.ndarray,\n        max_steps: int,\n        tol: float = 1e-8,\n        learning_rate: float = 1e-4,\n        first_momentum_decay: float = 0.9,\n        second_momentum_decay: float = 0.999,\n        perturbation: float = 1e-6,\n    ):\n        \"\"\"\n        A naive implementation of AMSGrad gradient descent.\n        See: On the Convergence of Adam and Beyond, Reddi et al., 2018\n        :param max_steps: maximum number of gradient steps.\n        :param tol: tolerance of the solution.\n        :param learning_rate: the learning rate (descent speed).\n        :param first_momentum_decay: constant for the first momentum.\n        :param second_momentum_decay: constant for the second momentum.\n        \"\"\"\n        step = 0\n        gradfn = self.get_gradient_expr()\n        current_position = init_position\n        if perturbation:\n            current_position = perturb_position(init_position, perturbation)\n        m = np.zeros_like(current_position)\n        v = np.zeros_like(current_position)\n        v_hat = np.zeros_like(current_position)\n        eps = 1e-12\n        while True:\n            step += 1\n            grad = np.asarray(gradfn(*current_position))\n            m = first_momentum_decay * m + (1.0 - first_momentum_decay) * grad\n            v = second_momentum_decay * v + (1.0 - second_momentum_decay) * grad**2\n            v_hat = np.maximum(v_hat, v)\n            new_position = current_position - learning_rate * m / (np.sqrt(v_hat) + eps)\n            if step &gt; max_steps:\n                break\n            if fast_norm(current_position - new_position) &lt; tol:\n                break\n            current_position = new_position\n        return np.asarray(current_position)\n\n    def single_layer_resonance(self, layer_indx: int, eq_position: np.ndarray):\n        \"\"\"We can compute the equilibrium position of a single layer directly.\n        :param layer_indx: the index of the layer to compute the equilibrium\n        :param eq_position: the equilibrium position vector\"\"\"\n        layer = self.layers[layer_indx]\n        theta_eq = eq_position[2 * layer_indx]\n        theta, phi = self.layers[layer_indx].get_coord_sym()\n        energy = self.create_energy(volumetric=True)\n        subs = self.get_subs(eq_position)\n        d2Edtheta2 = sym.diff(sym.diff(energy, theta), theta).subs(subs)\n        d2Edphi2 = sym.diff(sym.diff(energy, phi), phi).subs(subs)\n        # mixed, assuming symmetry\n        d2Edthetaphi = sym.diff(sym.diff(energy, theta), phi).subs(subs)\n        vareps = 1e-18\n\n        fmr = (d2Edtheta2 * d2Edphi2 - d2Edthetaphi**2) / np.power(np.sin(theta_eq + vareps) * layer.Ms, 2)\n        fmr = np.sqrt(float(fmr)) * gamma_rad / (2 * np.pi)\n        return fmr\n\n    @coordinate(require=\"cartesian\")\n    def solve_linearised_frequencies(self, H: VectorObj, linearisation_axis: Literal[\"x\", \"y\", \"z\"]):\n        \"\"\"Solves the linearised frequencies of the system.\n        Select linearisation axis and solve characteristic equation to get the frequencies.\n        Requires the system to be in cartesian coordinates.\n\n        WARNING: This circumvents gradient descent and solves the system analytically\n        and is only valid for small amplitudes (e.g. when the system is close to equilibrium along\n        the linearised axis).\n\n        :param H: the magnetic field.\n        :param linearisation_axis: the axis to linearise around.\n        :return: the solutions for the frequencies in the P and AP states.\n        \"\"\"\n        char_P, char_AP, _, _ = self.linearised_frequencies(H=H, linearisation_axis=linearisation_axis)\n        poly_P = self.det_solver(char_P)\n        poly_AP = self.det_solver(char_AP)\n        roots_P = self.root_solver(poly_P, n_layers=len(self.layers), normalise_roots_by_2pi=True)\n        roots_AP = self.root_solver(poly_AP, n_layers=len(self.layers), normalise_roots_by_2pi=True)\n        return roots_P, roots_AP\n\n    def solve(\n        self,\n        init_position: np.ndarray,\n        max_steps: int = 1e9,\n        learning_rate: float = 1e-4,\n        adam_tol: float = 1e-8,\n        first_momentum_decay: float = 0.9,\n        second_momentum_decay: float = 0.999,\n        perturbation: float = 1e-3,\n        ftol: float = 0.01e9,\n        max_freq: float = 80e9,\n        force_single_layer: bool = False,\n        force_sb: bool = False,\n    ):\n        \"\"\"Solves the system.\n        For dynamic LayerDynamic, the return is different, check :return.\n        1. Computes the energy functional.\n        2. Computes the gradient of the energy functional.\n        3. Performs a gradient descent to find the equilibrium position.\n        Returns the equilibrium position and frequencies in [GHz].\n        If there's only one layer, the frequency is computed analytically.\n        For full analytical solution, see: `analytical_field_scan`\n        :param init_position: initial position for the gradient descent.\n                              Must be a 1D array of size 2 * number of layers (theta, phi)\n        :param max_steps: maximum number of gradient steps.\n        :param learning_rate: the learning rate (descent speed).\n        :param adam_tol: tolerance for the consecutive Adam minima.\n        :param first_momentum_decay: constant for the first momentum.\n        :param second_momentum_decay: constant for the second momentum.\n        :param perturbation: the perturbation to use for the numerical gradient computation.\n        :param ftol: tolerance for the frequency search. [numerical only]\n        :param max_freq: maximum frequency to search for. [numerical only]\n        :param force_single_layer: whether to force the computation of the frequencies\n                                   for each layer individually.\n        :param force_sb: whether to force the computation of the frequencies.\n                        Takes effect only if the layers are LayerDynamic, not LayerSB.\n        :return: equilibrium position and frequencies in [GHz] (and eigenvectors if LayerDynamic instead of LayerSB).\n        \"\"\"\n        if self.H is None:\n            raise ValueError(\"H must be set before solving the system numerically.\")\n        assert len(init_position) == 2 * len(self.layers), (\n            f\"Incorrect initial position size. Given: {len(init_position)}, expected: {2 * len(self.layers)}\"\n        )\n        eq = self.adam_gradient_descent(\n            init_position=init_position,\n            max_steps=max_steps,\n            tol=adam_tol,\n            learning_rate=learning_rate,\n            first_momentum_decay=first_momentum_decay,\n            second_momentum_decay=second_momentum_decay,\n            perturbation=perturbation,\n        )\n        if not force_sb and isinstance(self.layers[0], LayerDynamic):\n            eigenvalues, eigenvectors = self.dynamic_layer_solve(eq)\n            return eq, eigenvalues / 1e9, eigenvectors\n        N = len(self.layers)\n        if N == 1:\n            return eq, [self.single_layer_resonance(0, eq) / 1e9]\n        if force_single_layer:\n            frequencies = []\n            for indx in range(N):\n                frequency = self.single_layer_resonance(indx, eq) / 1e9\n                frequencies.append(frequency)\n            return eq, frequencies\n        return self.hessian_to_roots(eq, ftol=ftol, max_freq=max_freq)\n\n    def dynamic_layer_solve(self, eq: list[float]):\n        \"\"\"Return the FMR frequencies and modes for N layers using the\n        dynamic RHS model\n        :param eq: the equilibrium position of the system.\n        :return: frequencies and eigenmode vectors.\"\"\"\n        jac, symbols = self.compose_llg_jacobian(self.H)\n        subs = {symbols[i]: eq[i] for i in range(len(eq))}\n        jac = jac.subs(subs)\n        jac = np.asarray(jac, dtype=np.float32)\n        eigvals, eigvecs = np.linalg.eig(jac)\n        eigvals_im = np.imag(eigvals) / (2 * np.pi)\n        indx = np.argwhere(eigvals_im &gt; 0).ravel()\n        return eigvals_im[indx], eigvecs[indx]\n\n    def hessian_to_roots(self, eq: list[float], ftol: float = 0.01e9, max_freq: float = 80e9):\n        hes, subs = self.create_energy_hessian(eq)\n        omega_expr = self.det_solver(hes).subs(subs)\n        # We do not normalise the roots by 2pi here because of the SB correction\n        roots = self.root_solver(\n            omega_expr,\n            n_layers=len(self.layers),\n            normalise_roots_by_2pi=False,\n            ftol=ftol,\n            max_freq=max_freq,\n        )\n        return eq, roots\n\n    def analytical_roots(self):\n        \"\"\"Find &amp; cache the analytical roots of the system.\n        Returns a list of solutions.\n        Ineffecient for more than 2 layers (can try though).\n        \"\"\"\n        Hsym = sym.Matrix(\n            [\n                sym.Symbol(r\"H_{x}\"),\n                sym.Symbol(r\"H_{y}\"),\n                sym.Symbol(r\"H_{z}\"),\n            ]\n        )\n        N = len(self.layers)\n        if N &gt; 2:\n            warnings.warn(\n                \"Analytical solutions for over 2 layers may be computationally expensive.\",\n                stacklevel=2,\n            )\n        system_energy = self.create_energy(H=Hsym, volumetric=False)\n        root_expr, energy_functional_expr = find_analytical_roots(N)\n        subs = get_all_second_derivatives(energy_functional_expr, energy_expression=system_energy, subs={})\n        subs.update(self.get_ms_subs())\n        return [s.subs(subs) for s in root_expr]\n\n    def get_subs(self, equilibrium_position: list[float]):\n        \"\"\"Returns the substitution dictionary for the energy expression.\"\"\"\n        subs = {}\n        for i in range(len(self.layers)):\n            theta, phi = self.layers[i].get_coord_sym()\n            subs[theta] = equilibrium_position[2 * i]\n            subs[phi] = equilibrium_position[(2 * i) + 1]\n        return subs\n\n    def get_ms_subs(self):\n        \"\"\"Returns a dictionary of substitutions for the Ms symbols.\"\"\"\n        a = {r\"M_{\" + str(layer._id) + \"}\": layer.Ms for layer in self.layers}\n        b = {r\"t_{\" + str(layer._id) + r\"}\": layer.thickness for layer in self.layers}\n        return a | b\n\n    def set_H(self, H: VectorObj):\n        \"\"\"Sets the external field.\"\"\"\n        self.H = H\n\n    def analytical_field_scan(\n        self,\n        Hrange: list[VectorObj],\n        init_position: Union[list[float], None] = None,\n        max_steps: int = 1e9,\n        learning_rate: float = 1e-4,\n        first_momentum_decay: float = 0.9,\n        second_momentum_decay: float = 0.999,\n        disable_tqdm: bool = False,\n    ) -&gt; Iterable[tuple[list[float], list[float], VectorObj]]:\n        \"\"\"Performs a field scan using the analytical solutions.\n        :param Hrange: the range of fields to scan.\n        :param init_position: the initial position for the gradient descent.\n                              If None, the first field in Hrange will be used.\n        :param max_steps: maximum number of gradient steps.\n        :param learning_rate: the learning rate (descent speed).\n        :param first_momentum_decay: constant for the first momentum.\n        :param second_momentum_decay: constant for the second momentum.\n        :param disable_tqdm: disable the progress bar.\n        :return: an iterable of (equilibrium position, frequencies, field)\n        \"\"\"\n        s1 = time.time()\n        global_roots = self.analytical_roots()\n        s2 = time.time()\n        if not disable_tqdm:\n            print(f\"Analytical roots found in {s2 - s1:.2f} seconds.\")\n        if init_position is None:\n            start = Hrange[0]\n            start.mag = 1\n            init_position = []\n            # align with the first field\n            for _ in self.layers:\n                init_position.extend([start.theta, start.phi])\n        Hsym = sym.Matrix(\n            [\n                sym.Symbol(r\"H_{x}\"),\n                sym.Symbol(r\"H_{y}\"),\n                sym.Symbol(r\"H_{z}\"),\n            ]\n        )\n        current_position = init_position\n        for Hvalue in tqdm(Hrange, disable=disable_tqdm):\n            self.set_H(Hvalue)\n            hx, hy, hz = Hvalue.get_cartesian()\n            eq = self.adam_gradient_descent(\n                init_position=current_position,\n                max_steps=max_steps,\n                tol=1e-9,\n                learning_rate=learning_rate,\n                first_momentum_decay=first_momentum_decay,\n                second_momentum_decay=second_momentum_decay,\n            )\n            step_subs = self.get_subs(eq)\n            step_subs.update(self.get_ms_subs())\n            step_subs.update({Hsym[0]: hx, Hsym[1]: hy, Hsym[2]: hz})\n            roots = [s.subs(step_subs) for s in global_roots]\n            # TODO fix scaling by gamma below\n            roots = np.asarray(roots, dtype=np.float32) * gamma_rad / (2.0 * np.pi) / 1e9\n            yield eq, roots, Hvalue\n            current_position = eq\n\n    def _independent_linearised_jacobian_expr(\n        self,\n        Vdc_ex_variable: sym.Expr,\n        Vdc_ex_value: float,\n        zero_pos: list[float],\n        H: Union[VectorObj, None] = None,\n        frequency: float = None,\n    ):\n        \"\"\"Avoid recomputing the same expression for the same system given fixed\n        parameters. Computes a linearised Jacobian matrix and its inverse.\n        :param Vdc_ex_variable: the variable to use for the excitation (Vp or Hoe).\n        :param Vdc_ex_value: the value of the excitation.\n        :param zero_pos: the equilibrium position of the system.\n        :param H: the external field. If None, the H symbol is used.\n        :param frequency: the frequency of the external field. If None, the omega symbol is used.\n        :return: the inverse of the Jacobian matrix and the V matrix.\n        \"\"\"\n        n = len(self.layers)\n        H = (\n            sym.ImmutableMatrix(H.get_cartesian())\n            if H is not None\n            else sym.ImmutableMatrix([sym.Symbol(r\"H_{x}\"), sym.Symbol(r\"H_{y}\"), sym.Symbol(r\"H_{z}\")])\n        )\n        A_matrix, V_matrix = self._compute_A_and_V_matrices(\n            n=n,\n            Vdc_ex_variable=Vdc_ex_variable,\n            H=H,\n            frequency=frequency,\n        )\n        subs = {\n            Vdc_ex_variable: Vdc_ex_value,\n            OMEGA: 2 * sym.pi * frequency,\n            sym.Symbol(r\"H_{x}\"): H[0],\n            sym.Symbol(r\"H_{y}\"): H[1],\n            sym.Symbol(r\"H_{z}\"): H[2],\n        }\n        dummy_vp = LayerDynamic.get_Vp_symbol()\n        dummy_hoe = LayerDynamic.get_hoe_ex_symbol()\n        # subs for dummy variables if one of the excitations is present\n        if dummy_vp not in subs:\n            subs[dummy_vp] = 0\n        if dummy_hoe not in subs:\n            subs[dummy_hoe] = 0\n\n        for i, layer in enumerate(self.layers):\n            theta, phi = layer.get_coord_sym()\n            subs[theta] = zero_pos[2 * i]\n            subs[phi] = zero_pos[2 * i + 1]\n        A_matrix = sym.ImmutableMatrix(A_matrix)\n        A_matrix = A_matrix.subs(subs)\n        V_matrix = V_matrix.subs(subs)\n        return A_matrix, V_matrix\n\n    def _compute_numerical_inverse(self, A_matrix):\n        # Use NumPy for faster matrix inversion\n        A_np = np.asarray(A_matrix, dtype=np.complex128)\n        A_inv_np = np.linalg.inv(A_np)\n        return sym.Matrix(A_inv_np)\n\n    def _compute_A_and_V_matrices(self, n, Vdc_ex_variable, H, frequency):\n        A_matrix = sym.zeros(2 * n, 2 * n)\n        V_matrix = sym.zeros(2 * n, 1)\n        U = self.create_energy(H=H, volumetric=False)\n        omega = OMEGA if frequency is None else 2 * sym.pi * frequency\n        for i, layer in enumerate(self.layers):\n            rhs = layer.rhs_spherical_llg(U / layer.thickness, osc=True)\n            alpha_factor = 1 + layer.alpha**2\n            V_matrix[2 * i] = sym.diff(rhs[0] * alpha_factor, Vdc_ex_variable)\n            V_matrix[2 * i + 1] = sym.diff(rhs[1] * alpha_factor, Vdc_ex_variable)\n            theta, phi = layer.get_coord_sym()\n            fn_theta = (omega * sym.I * theta - rhs[0]) * alpha_factor\n            fn_phi = (omega * sym.I * phi - rhs[1]) * alpha_factor\n            # the functions are only valid for that row i (theta) and i + 1 (phi)\n            # so we only need to compute the derivatives for the other layers\n            # for the other layers, the derivatives are zero\n            for j, layer_j in enumerate(self.layers):\n                theta_, phi_ = layer_j.get_coord_sym()\n                A_matrix[2 * i, 2 * j] = sym.diff(fn_theta, theta_)\n                A_matrix[2 * i, 2 * j + 1] = sym.diff(fn_theta, phi_)\n                A_matrix[2 * i + 1, 2 * j] = sym.diff(fn_phi, theta_)\n                A_matrix[2 * i + 1, 2 * j + 1] = sym.diff(fn_phi, phi_)\n        return A_matrix, V_matrix\n\n    @lru_cache(maxsize=1000)  # noqa: B019\n    def _compute_A_and_V_matrices_old(self, n, Vdc_ex_variable, H, frequency):\n        A_matrix = sym.zeros(2 * n, 2 * n)\n        V_matrix = sym.zeros(2 * n, 1)\n        U = self.create_energy(H=H, volumetric=False)\n        omega = OMEGA if frequency is None else 2 * sym.pi * frequency\n        for i, layer in enumerate(self.layers):\n            rhs = layer.rhs_spherical_llg(U / layer.thickness, osc=True)\n            V_matrix[2 * i] = sym.diff(rhs[0], Vdc_ex_variable)\n            V_matrix[2 * i + 1] = sym.diff(rhs[1], Vdc_ex_variable)\n            alpha_factor = 1 + layer.alpha**2\n            for j, layer_j in enumerate(self.layers):\n                theta_, phi_ = layer_j.get_coord_sym()\n                A_matrix[2 * i, 2 * j] = -sym.diff(rhs[0], theta_) * alpha_factor\n                A_matrix[2 * i + 1, 2 * j + 1] = -sym.diff(rhs[1], phi_) * alpha_factor\n                A_matrix[2 * i, 2 * j + 1] = -sym.diff(rhs[0], phi_) * alpha_factor\n                A_matrix[2 * i + 1, 2 * j] = -sym.diff(rhs[1], theta_) * alpha_factor\n                if i == j:\n                    A_matrix[2 * i, 2 * j] += alpha_factor * omega * sym.I\n                    A_matrix[2 * i + 1, 2 * j + 1] += alpha_factor * omega * sym.I\n        return A_matrix, V_matrix\n\n    def linearised_N_spin_diode(\n        self,\n        H: Union[VectorObj, np.ndarray],\n        frequency: float,\n        Vdc_ex_variable: sym.Expr,\n        Vdc_ex_value: float,\n        zero_pos: np.ndarray,\n        phase_shift: float = 0,\n        cache_var: str = \"H\",\n    ):\n        \"\"\"Linearised N-spin diode. Use `LayerDynamic.get_Vp_symbol()`\n        or `LayerDynamic.get_hoe_ex_symbol()` for Vdc_ex_variable.\n        :param H: the external field.\n        :param frequency: the frequency of the external field.\n        :param Vdc_ex_variable: the variable to use for the excitation (Vp or Hoe).\n        :param Vdc_ex_value: the value of the excitation.\n        :param zero_pos: the equilibrium position of the system.\n        :param phase_shift: the phase shift of the external field.\n        :return: the N-spin diode angle variations.\n        \"\"\"\n        # allow only if the layers are LayerDynamic\n        if not all(isinstance(layer, LayerDynamic) for layer in self.layers):\n            raise ValueError(\"Linearised N-spin diode only works with LayerDynamic.\")\n        H = VectorObj.from_cartesian(*H) if isinstance(H, np.ndarray) else H\n\n        extra_args = {}\n        extra_subs = {}\n        if cache_var == \"H\":\n            extra_args[\"frequency\"] = frequency\n            Hcart = H.get_cartesian()\n            extra_subs = {\n                sym.Symbol(r\"H_{x}\"): Hcart[0],\n                sym.Symbol(r\"H_{y}\"): Hcart[1],\n                sym.Symbol(r\"H_{z}\"): Hcart[2],\n            }\n        elif cache_var == \"f\":\n            extra_args[\"H\"] = H\n            extra_subs = {\n                OMEGA: 2 * sym.pi * frequency,\n            }\n\n        A_matrix, V_matrix = self._independent_linearised_jacobian_expr(\n            Vdc_ex_variable=Vdc_ex_variable,\n            Vdc_ex_value=Vdc_ex_value,\n            zero_pos=tuple(zero_pos.tolist()),  # for hashing &amp; caching\n            **extra_args,\n        )\n        A_matrix = A_matrix.subs(extra_subs)\n        V_matrix = V_matrix.subs(extra_subs)\n\n        A_inv = self._compute_numerical_inverse(A_matrix)\n        fstep = A_inv * V_matrix * sym.exp(sym.I * phase_shift)\n        return np.real(np.complex64(fstep.evalf()))\n\n    def __hash__(self):\n        return hash(str(self))\n\n    def __eq__(self, other):\n        return str(self) == str(other)\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.adam_gradient_descent","title":"<code>adam_gradient_descent(init_position, max_steps, tol=1e-08, learning_rate=0.0001, first_momentum_decay=0.9, second_momentum_decay=0.999, perturbation=1e-06)</code>","text":"<p>A naive implementation of Adam gradient descent. See: ADAM: A METHOD FOR STOCHASTIC OPTIMIZATION, Kingma et Ba, 2015</p> <p>Parameters:</p> Name Type Description Default <code>max_steps</code> <code>int</code> <p>maximum number of gradient steps.</p> required <code>tol</code> <code>float</code> <p>tolerance of the solution.</p> <code>1e-08</code> <code>learning_rate</code> <code>float</code> <p>the learning rate (descent speed).</p> <code>0.0001</code> <code>first_momentum_decay</code> <code>float</code> <p>constant for the first momentum.</p> <code>0.9</code> <code>second_momentum_decay</code> <code>float</code> <p>constant for the second momentum.</p> <code>0.999</code> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def adam_gradient_descent(\n    self,\n    init_position: np.ndarray,\n    max_steps: int,\n    tol: float = 1e-8,\n    learning_rate: float = 1e-4,\n    first_momentum_decay: float = 0.9,\n    second_momentum_decay: float = 0.999,\n    perturbation: float = 1e-6,\n):\n    \"\"\"\n    A naive implementation of Adam gradient descent.\n    See: ADAM: A METHOD FOR STOCHASTIC OPTIMIZATION, Kingma et Ba, 2015\n    :param max_steps: maximum number of gradient steps.\n    :param tol: tolerance of the solution.\n    :param learning_rate: the learning rate (descent speed).\n    :param first_momentum_decay: constant for the first momentum.\n    :param second_momentum_decay: constant for the second momentum.\n    \"\"\"\n    step = 0\n    gradfn = self.get_gradient_expr()\n    current_position = init_position\n    if perturbation:\n        current_position = perturb_position(init_position, perturbation)\n    m = np.zeros_like(current_position)  # first momentum\n    v = np.zeros_like(current_position)  # second momentum\n    eps = 1e-12\n    # history = []\n    while True:\n        step += 1\n        grad = np.asarray(gradfn(*current_position))\n        m = first_momentum_decay * m + (1.0 - first_momentum_decay) * grad\n        v = second_momentum_decay * v + (1.0 - second_momentum_decay) * grad**2\n        m_hat = m / (1.0 - first_momentum_decay**step)\n        v_hat = v / (1.0 - second_momentum_decay**step)\n        new_position = current_position - learning_rate * m_hat / (np.sqrt(v_hat) + eps)\n        if step &gt; max_steps:\n            break\n        if fast_norm(current_position - new_position) &lt; tol:\n            break\n        current_position = new_position\n        # history.append(current_position)\n    # return np.asarray(current_position), np.asarray(history)\n    return np.asarray(current_position)\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.amsgrad_gradient_descent","title":"<code>amsgrad_gradient_descent(init_position, max_steps, tol=1e-08, learning_rate=0.0001, first_momentum_decay=0.9, second_momentum_decay=0.999, perturbation=1e-06)</code>","text":"<p>A naive implementation of AMSGrad gradient descent. See: On the Convergence of Adam and Beyond, Reddi et al., 2018</p> <p>Parameters:</p> Name Type Description Default <code>max_steps</code> <code>int</code> <p>maximum number of gradient steps.</p> required <code>tol</code> <code>float</code> <p>tolerance of the solution.</p> <code>1e-08</code> <code>learning_rate</code> <code>float</code> <p>the learning rate (descent speed).</p> <code>0.0001</code> <code>first_momentum_decay</code> <code>float</code> <p>constant for the first momentum.</p> <code>0.9</code> <code>second_momentum_decay</code> <code>float</code> <p>constant for the second momentum.</p> <code>0.999</code> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def amsgrad_gradient_descent(\n    self,\n    init_position: np.ndarray,\n    max_steps: int,\n    tol: float = 1e-8,\n    learning_rate: float = 1e-4,\n    first_momentum_decay: float = 0.9,\n    second_momentum_decay: float = 0.999,\n    perturbation: float = 1e-6,\n):\n    \"\"\"\n    A naive implementation of AMSGrad gradient descent.\n    See: On the Convergence of Adam and Beyond, Reddi et al., 2018\n    :param max_steps: maximum number of gradient steps.\n    :param tol: tolerance of the solution.\n    :param learning_rate: the learning rate (descent speed).\n    :param first_momentum_decay: constant for the first momentum.\n    :param second_momentum_decay: constant for the second momentum.\n    \"\"\"\n    step = 0\n    gradfn = self.get_gradient_expr()\n    current_position = init_position\n    if perturbation:\n        current_position = perturb_position(init_position, perturbation)\n    m = np.zeros_like(current_position)\n    v = np.zeros_like(current_position)\n    v_hat = np.zeros_like(current_position)\n    eps = 1e-12\n    while True:\n        step += 1\n        grad = np.asarray(gradfn(*current_position))\n        m = first_momentum_decay * m + (1.0 - first_momentum_decay) * grad\n        v = second_momentum_decay * v + (1.0 - second_momentum_decay) * grad**2\n        v_hat = np.maximum(v_hat, v)\n        new_position = current_position - learning_rate * m / (np.sqrt(v_hat) + eps)\n        if step &gt; max_steps:\n            break\n        if fast_norm(current_position - new_position) &lt; tol:\n            break\n        current_position = new_position\n    return np.asarray(current_position)\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.analytical_field_scan","title":"<code>analytical_field_scan(Hrange, init_position=None, max_steps=1000000000.0, learning_rate=0.0001, first_momentum_decay=0.9, second_momentum_decay=0.999, disable_tqdm=False)</code>","text":"<p>Performs a field scan using the analytical solutions.</p> <p>Parameters:</p> Name Type Description Default <code>Hrange</code> <code>list[VectorObj]</code> <p>the range of fields to scan.</p> required <code>init_position</code> <code>Union[list[float], None]</code> <p>the initial position for the gradient descent. If None, the first field in Hrange will be used.</p> <code>None</code> <code>max_steps</code> <code>int</code> <p>maximum number of gradient steps.</p> <code>1000000000.0</code> <code>learning_rate</code> <code>float</code> <p>the learning rate (descent speed).</p> <code>0.0001</code> <code>first_momentum_decay</code> <code>float</code> <p>constant for the first momentum.</p> <code>0.9</code> <code>second_momentum_decay</code> <code>float</code> <p>constant for the second momentum.</p> <code>0.999</code> <code>disable_tqdm</code> <code>bool</code> <p>disable the progress bar.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[tuple[list[float], list[float], VectorObj]]</code> <p>an iterable of (equilibrium position, frequencies, field)</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def analytical_field_scan(\n    self,\n    Hrange: list[VectorObj],\n    init_position: Union[list[float], None] = None,\n    max_steps: int = 1e9,\n    learning_rate: float = 1e-4,\n    first_momentum_decay: float = 0.9,\n    second_momentum_decay: float = 0.999,\n    disable_tqdm: bool = False,\n) -&gt; Iterable[tuple[list[float], list[float], VectorObj]]:\n    \"\"\"Performs a field scan using the analytical solutions.\n    :param Hrange: the range of fields to scan.\n    :param init_position: the initial position for the gradient descent.\n                          If None, the first field in Hrange will be used.\n    :param max_steps: maximum number of gradient steps.\n    :param learning_rate: the learning rate (descent speed).\n    :param first_momentum_decay: constant for the first momentum.\n    :param second_momentum_decay: constant for the second momentum.\n    :param disable_tqdm: disable the progress bar.\n    :return: an iterable of (equilibrium position, frequencies, field)\n    \"\"\"\n    s1 = time.time()\n    global_roots = self.analytical_roots()\n    s2 = time.time()\n    if not disable_tqdm:\n        print(f\"Analytical roots found in {s2 - s1:.2f} seconds.\")\n    if init_position is None:\n        start = Hrange[0]\n        start.mag = 1\n        init_position = []\n        # align with the first field\n        for _ in self.layers:\n            init_position.extend([start.theta, start.phi])\n    Hsym = sym.Matrix(\n        [\n            sym.Symbol(r\"H_{x}\"),\n            sym.Symbol(r\"H_{y}\"),\n            sym.Symbol(r\"H_{z}\"),\n        ]\n    )\n    current_position = init_position\n    for Hvalue in tqdm(Hrange, disable=disable_tqdm):\n        self.set_H(Hvalue)\n        hx, hy, hz = Hvalue.get_cartesian()\n        eq = self.adam_gradient_descent(\n            init_position=current_position,\n            max_steps=max_steps,\n            tol=1e-9,\n            learning_rate=learning_rate,\n            first_momentum_decay=first_momentum_decay,\n            second_momentum_decay=second_momentum_decay,\n        )\n        step_subs = self.get_subs(eq)\n        step_subs.update(self.get_ms_subs())\n        step_subs.update({Hsym[0]: hx, Hsym[1]: hy, Hsym[2]: hz})\n        roots = [s.subs(step_subs) for s in global_roots]\n        # TODO fix scaling by gamma below\n        roots = np.asarray(roots, dtype=np.float32) * gamma_rad / (2.0 * np.pi) / 1e9\n        yield eq, roots, Hvalue\n        current_position = eq\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.analytical_roots","title":"<code>analytical_roots()</code>","text":"<p>Find &amp; cache the analytical roots of the system. Returns a list of solutions. Ineffecient for more than 2 layers (can try though).</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def analytical_roots(self):\n    \"\"\"Find &amp; cache the analytical roots of the system.\n    Returns a list of solutions.\n    Ineffecient for more than 2 layers (can try though).\n    \"\"\"\n    Hsym = sym.Matrix(\n        [\n            sym.Symbol(r\"H_{x}\"),\n            sym.Symbol(r\"H_{y}\"),\n            sym.Symbol(r\"H_{z}\"),\n        ]\n    )\n    N = len(self.layers)\n    if N &gt; 2:\n        warnings.warn(\n            \"Analytical solutions for over 2 layers may be computationally expensive.\",\n            stacklevel=2,\n        )\n    system_energy = self.create_energy(H=Hsym, volumetric=False)\n    root_expr, energy_functional_expr = find_analytical_roots(N)\n    subs = get_all_second_derivatives(energy_functional_expr, energy_expression=system_energy, subs={})\n    subs.update(self.get_ms_subs())\n    return [s.subs(subs) for s in root_expr]\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.create_energy","title":"<code>create_energy(H=None, volumetric=False)</code>  <code>cached</code>","text":"<p>Creates the symbolic energy expression.</p> <p>Due to problematic nature of coupling, there is an issue of computing each layer's FMR in the presence of IEC. If volumetric = True then we use the thickness of the layer to multiply the energy and hence avoid having to divide J by the thickness of a layer. If volumetric = False the J constant is divided by weighted thickness and included in every layer's energy, correcting FMR automatically.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>@lru_cache(3)  # cache for 3 calls\ndef create_energy(\n    self,\n    H: Union[VectorObj, sym.ImmutableMatrix, None] = None,\n    volumetric: bool = False,\n):\n    \"\"\"Creates the symbolic energy expression.\n\n    Due to problematic nature of coupling, there is an issue of\n    computing each layer's FMR in the presence of IEC.\n    If volumetric = True then we use the thickness of the layer to multiply the\n    energy and hence avoid having to divide J by the thickness of a layer.\n    If volumetric = False the J constant is divided by weighted thickness\n    and included in every layer's energy, correcting FMR automatically.\n    \"\"\"\n    if H is None:\n        h = self.H.get_cartesian()\n        H = sym.ImmutableMatrix(h)\n    energy = sum(layer.no_interaction_symbolic_energy(H) * layer.thickness for layer in self.layers)\n\n    for i in range(len(self.layers) - 1):\n        l1m = self.layers[i].get_m_sym()\n        l2m = self.layers[i + 1].get_m_sym()\n\n        # IEC\n        ldot = l1m.dot(l2m)\n        energy -= self.J1[i] * ldot\n        energy -= self.J2[i] * (ldot) ** 2\n\n        # IDMI, sign is the same J1\n        lcross = l1m.cross(l2m)\n        energy -= self.ilD[i].dot(lcross)\n\n        # dipole fields\n        if self.dipoleMatrix is not None:\n            mat = self.dipoleMatrix[i]\n            # is positive, just like demag\n            energy += (\n                (mu0 / 2.0)\n                * l1m.dot(mat * l2m)\n                * self.layers[i].Ms\n                * self.layers[i + 1].Ms\n                * self.layers[i].thickness\n            )\n            energy += (\n                (mu0 / 2.0)\n                * l2m.dot(mat * l1m)\n                * self.layers[i].Ms\n                * self.layers[i + 1].Ms\n                * self.layers[i + 1].thickness\n            )\n    return energy\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.create_energy_hessian","title":"<code>create_energy_hessian(equilibrium_position)</code>","text":"<p>Creates the symbolic hessian of the energy expression.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def create_energy_hessian(self, equilibrium_position: list[float]):\n    \"\"\"Creates the symbolic hessian of the energy expression.\"\"\"\n    energy = self.create_energy(volumetric=False)\n    subs = self.get_subs(equilibrium_position)\n    N = len(self.layers)\n    hessian = [[0 for _ in range(2 * N)] for _ in range(2 * N)]\n    for i in range(N):\n        z = self.layers[i].sb_correction()\n        theta_i, phi_i = self.layers[i].get_coord_sym()\n        for j in range(i, N):\n            # dtheta dtheta\n            theta_j, phi_j = self.layers[j].get_coord_sym()\n\n            expr = sym.diff(sym.diff(energy, theta_i), theta_j)\n            hessian[2 * i][2 * j] = expr\n            hessian[2 * j][2 * i] = expr\n\n            # dphi dphi\n            expr = sym.diff(sym.diff(energy, phi_i), phi_j)\n            hessian[2 * i + 1][2 * j + 1] = expr\n            hessian[2 * j + 1][2 * i + 1] = expr\n\n            expr = sym.diff(sym.diff(energy, theta_i), phi_j)\n            # mixed terms\n            if i == j:\n                hessian[2 * i + 1][2 * j] = expr + sym.I * z\n                hessian[2 * i][2 * j + 1] = expr - sym.I * z\n            else:\n                hessian[2 * i][2 * j + 1] = expr\n                hessian[2 * j + 1][2 * i] = expr\n\n                expr = sym.diff(sym.diff(energy, phi_i), theta_j)\n                hessian[2 * i + 1][2 * j] = expr\n                hessian[2 * j][2 * i + 1] = expr\n\n    hes = sym.ImmutableMatrix(hessian)\n    return hes, subs\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.dynamic_layer_solve","title":"<code>dynamic_layer_solve(eq)</code>","text":"<p>Return the FMR frequencies and modes for N layers using the dynamic RHS model</p> <p>Parameters:</p> Name Type Description Default <code>eq</code> <code>list[float]</code> <p>the equilibrium position of the system.</p> required <p>Returns:</p> Type Description <p>frequencies and eigenmode vectors.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def dynamic_layer_solve(self, eq: list[float]):\n    \"\"\"Return the FMR frequencies and modes for N layers using the\n    dynamic RHS model\n    :param eq: the equilibrium position of the system.\n    :return: frequencies and eigenmode vectors.\"\"\"\n    jac, symbols = self.compose_llg_jacobian(self.H)\n    subs = {symbols[i]: eq[i] for i in range(len(eq))}\n    jac = jac.subs(subs)\n    jac = np.asarray(jac, dtype=np.float32)\n    eigvals, eigvecs = np.linalg.eig(jac)\n    eigvals_im = np.imag(eigvals) / (2 * np.pi)\n    indx = np.argwhere(eigvals_im &gt; 0).ravel()\n    return eigvals_im[indx], eigvecs[indx]\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.get_gradient_expr","title":"<code>get_gradient_expr(accel='math')</code>","text":"<p>Returns the symbolic gradient of the energy expression.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def get_gradient_expr(self, accel=\"math\"):\n    \"\"\"Returns the symbolic gradient of the energy expression.\"\"\"\n    energy = self.create_energy(volumetric=False)\n    grad_vector = []\n    symbols = []\n    for layer in self.layers:\n        (theta, phi) = layer.get_coord_sym()\n        grad_vector.extend((sym.diff(energy, theta), sym.diff(energy, phi)))\n        symbols.extend((theta, phi))\n    return sym.lambdify(symbols, grad_vector, accel)\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.get_layer_references","title":"<code>get_layer_references(layer_indx, interaction_constant)</code>","text":"<p>Returns the references to the layers above and below the layer with index layer_indx.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def get_layer_references(self, layer_indx: int, interaction_constant: list[float]):\n    \"\"\"Returns the references to the layers above and below the layer\n    with index layer_indx.\"\"\"\n    if len(self.layers) == 1:\n        return None, None, 0, 0\n    if layer_indx == 0:\n        return None, self.layers[layer_indx + 1], 0, interaction_constant[0]\n    elif layer_indx == len(self.layers) - 1:\n        return self.layers[layer_indx - 1], None, interaction_constant[-1], 0\n    return (\n        self.layers[layer_indx - 1],\n        self.layers[layer_indx + 1],\n        interaction_constant[layer_indx - 1],\n        interaction_constant[layer_indx],\n    )\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.get_ms_subs","title":"<code>get_ms_subs()</code>","text":"<p>Returns a dictionary of substitutions for the Ms symbols.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def get_ms_subs(self):\n    \"\"\"Returns a dictionary of substitutions for the Ms symbols.\"\"\"\n    a = {r\"M_{\" + str(layer._id) + \"}\": layer.Ms for layer in self.layers}\n    b = {r\"t_{\" + str(layer._id) + r\"}\": layer.thickness for layer in self.layers}\n    return a | b\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.get_subs","title":"<code>get_subs(equilibrium_position)</code>","text":"<p>Returns the substitution dictionary for the energy expression.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def get_subs(self, equilibrium_position: list[float]):\n    \"\"\"Returns the substitution dictionary for the energy expression.\"\"\"\n    subs = {}\n    for i in range(len(self.layers)):\n        theta, phi = self.layers[i].get_coord_sym()\n        subs[theta] = equilibrium_position[2 * i]\n        subs[phi] = equilibrium_position[(2 * i) + 1]\n    return subs\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.linearised_N_spin_diode","title":"<code>linearised_N_spin_diode(H, frequency, Vdc_ex_variable, Vdc_ex_value, zero_pos, phase_shift=0, cache_var='H')</code>","text":"<p>Linearised N-spin diode. Use <code>LayerDynamic.get_Vp_symbol()</code> or <code>LayerDynamic.get_hoe_ex_symbol()</code> for Vdc_ex_variable.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>Union[VectorObj, np.ndarray]</code> <p>the external field.</p> required <code>frequency</code> <code>float</code> <p>the frequency of the external field.</p> required <code>Vdc_ex_variable</code> <code>sym.Expr</code> <p>the variable to use for the excitation (Vp or Hoe).</p> required <code>Vdc_ex_value</code> <code>float</code> <p>the value of the excitation.</p> required <code>zero_pos</code> <code>np.ndarray</code> <p>the equilibrium position of the system.</p> required <code>phase_shift</code> <code>float</code> <p>the phase shift of the external field.</p> <code>0</code> <p>Returns:</p> Type Description <p>the N-spin diode angle variations.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def linearised_N_spin_diode(\n    self,\n    H: Union[VectorObj, np.ndarray],\n    frequency: float,\n    Vdc_ex_variable: sym.Expr,\n    Vdc_ex_value: float,\n    zero_pos: np.ndarray,\n    phase_shift: float = 0,\n    cache_var: str = \"H\",\n):\n    \"\"\"Linearised N-spin diode. Use `LayerDynamic.get_Vp_symbol()`\n    or `LayerDynamic.get_hoe_ex_symbol()` for Vdc_ex_variable.\n    :param H: the external field.\n    :param frequency: the frequency of the external field.\n    :param Vdc_ex_variable: the variable to use for the excitation (Vp or Hoe).\n    :param Vdc_ex_value: the value of the excitation.\n    :param zero_pos: the equilibrium position of the system.\n    :param phase_shift: the phase shift of the external field.\n    :return: the N-spin diode angle variations.\n    \"\"\"\n    # allow only if the layers are LayerDynamic\n    if not all(isinstance(layer, LayerDynamic) for layer in self.layers):\n        raise ValueError(\"Linearised N-spin diode only works with LayerDynamic.\")\n    H = VectorObj.from_cartesian(*H) if isinstance(H, np.ndarray) else H\n\n    extra_args = {}\n    extra_subs = {}\n    if cache_var == \"H\":\n        extra_args[\"frequency\"] = frequency\n        Hcart = H.get_cartesian()\n        extra_subs = {\n            sym.Symbol(r\"H_{x}\"): Hcart[0],\n            sym.Symbol(r\"H_{y}\"): Hcart[1],\n            sym.Symbol(r\"H_{z}\"): Hcart[2],\n        }\n    elif cache_var == \"f\":\n        extra_args[\"H\"] = H\n        extra_subs = {\n            OMEGA: 2 * sym.pi * frequency,\n        }\n\n    A_matrix, V_matrix = self._independent_linearised_jacobian_expr(\n        Vdc_ex_variable=Vdc_ex_variable,\n        Vdc_ex_value=Vdc_ex_value,\n        zero_pos=tuple(zero_pos.tolist()),  # for hashing &amp; caching\n        **extra_args,\n    )\n    A_matrix = A_matrix.subs(extra_subs)\n    V_matrix = V_matrix.subs(extra_subs)\n\n    A_inv = self._compute_numerical_inverse(A_matrix)\n    fstep = A_inv * V_matrix * sym.exp(sym.I * phase_shift)\n    return np.real(np.complex64(fstep.evalf()))\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.set_H","title":"<code>set_H(H)</code>","text":"<p>Sets the external field.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def set_H(self, H: VectorObj):\n    \"\"\"Sets the external field.\"\"\"\n    self.H = H\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.single_layer_resonance","title":"<code>single_layer_resonance(layer_indx, eq_position)</code>","text":"<p>We can compute the equilibrium position of a single layer directly.</p> <p>Parameters:</p> Name Type Description Default <code>layer_indx</code> <code>int</code> <p>the index of the layer to compute the equilibrium</p> required <code>eq_position</code> <code>np.ndarray</code> <p>the equilibrium position vector</p> required Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def single_layer_resonance(self, layer_indx: int, eq_position: np.ndarray):\n    \"\"\"We can compute the equilibrium position of a single layer directly.\n    :param layer_indx: the index of the layer to compute the equilibrium\n    :param eq_position: the equilibrium position vector\"\"\"\n    layer = self.layers[layer_indx]\n    theta_eq = eq_position[2 * layer_indx]\n    theta, phi = self.layers[layer_indx].get_coord_sym()\n    energy = self.create_energy(volumetric=True)\n    subs = self.get_subs(eq_position)\n    d2Edtheta2 = sym.diff(sym.diff(energy, theta), theta).subs(subs)\n    d2Edphi2 = sym.diff(sym.diff(energy, phi), phi).subs(subs)\n    # mixed, assuming symmetry\n    d2Edthetaphi = sym.diff(sym.diff(energy, theta), phi).subs(subs)\n    vareps = 1e-18\n\n    fmr = (d2Edtheta2 * d2Edphi2 - d2Edthetaphi**2) / np.power(np.sin(theta_eq + vareps) * layer.Ms, 2)\n    fmr = np.sqrt(float(fmr)) * gamma_rad / (2 * np.pi)\n    return fmr\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.solve","title":"<code>solve(init_position, max_steps=1000000000.0, learning_rate=0.0001, adam_tol=1e-08, first_momentum_decay=0.9, second_momentum_decay=0.999, perturbation=0.001, ftol=10000000.0, max_freq=80000000000.0, force_single_layer=False, force_sb=False)</code>","text":"<p>Solves the system. For dynamic LayerDynamic, the return is different, check :return. 1. Computes the energy functional. 2. Computes the gradient of the energy functional. 3. Performs a gradient descent to find the equilibrium position. Returns the equilibrium position and frequencies in [GHz]. If there's only one layer, the frequency is computed analytically. For full analytical solution, see: <code>analytical_field_scan</code></p> <p>Parameters:</p> Name Type Description Default <code>init_position</code> <code>np.ndarray</code> <p>initial position for the gradient descent. Must be a 1D array of size 2 * number of layers (theta, phi)</p> required <code>max_steps</code> <code>int</code> <p>maximum number of gradient steps.</p> <code>1000000000.0</code> <code>learning_rate</code> <code>float</code> <p>the learning rate (descent speed).</p> <code>0.0001</code> <code>adam_tol</code> <code>float</code> <p>tolerance for the consecutive Adam minima.</p> <code>1e-08</code> <code>first_momentum_decay</code> <code>float</code> <p>constant for the first momentum.</p> <code>0.9</code> <code>second_momentum_decay</code> <code>float</code> <p>constant for the second momentum.</p> <code>0.999</code> <code>perturbation</code> <code>float</code> <p>the perturbation to use for the numerical gradient computation.</p> <code>0.001</code> <code>ftol</code> <code>float</code> <p>tolerance for the frequency search. [numerical only]</p> <code>10000000.0</code> <code>max_freq</code> <code>float</code> <p>maximum frequency to search for. [numerical only]</p> <code>80000000000.0</code> <code>force_single_layer</code> <code>bool</code> <p>whether to force the computation of the frequencies for each layer individually.</p> <code>False</code> <code>force_sb</code> <code>bool</code> <p>whether to force the computation of the frequencies. Takes effect only if the layers are LayerDynamic, not LayerSB.</p> <code>False</code> <p>Returns:</p> Type Description <p>equilibrium position and frequencies in [GHz] (and eigenvectors if LayerDynamic instead of LayerSB).</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def solve(\n    self,\n    init_position: np.ndarray,\n    max_steps: int = 1e9,\n    learning_rate: float = 1e-4,\n    adam_tol: float = 1e-8,\n    first_momentum_decay: float = 0.9,\n    second_momentum_decay: float = 0.999,\n    perturbation: float = 1e-3,\n    ftol: float = 0.01e9,\n    max_freq: float = 80e9,\n    force_single_layer: bool = False,\n    force_sb: bool = False,\n):\n    \"\"\"Solves the system.\n    For dynamic LayerDynamic, the return is different, check :return.\n    1. Computes the energy functional.\n    2. Computes the gradient of the energy functional.\n    3. Performs a gradient descent to find the equilibrium position.\n    Returns the equilibrium position and frequencies in [GHz].\n    If there's only one layer, the frequency is computed analytically.\n    For full analytical solution, see: `analytical_field_scan`\n    :param init_position: initial position for the gradient descent.\n                          Must be a 1D array of size 2 * number of layers (theta, phi)\n    :param max_steps: maximum number of gradient steps.\n    :param learning_rate: the learning rate (descent speed).\n    :param adam_tol: tolerance for the consecutive Adam minima.\n    :param first_momentum_decay: constant for the first momentum.\n    :param second_momentum_decay: constant for the second momentum.\n    :param perturbation: the perturbation to use for the numerical gradient computation.\n    :param ftol: tolerance for the frequency search. [numerical only]\n    :param max_freq: maximum frequency to search for. [numerical only]\n    :param force_single_layer: whether to force the computation of the frequencies\n                               for each layer individually.\n    :param force_sb: whether to force the computation of the frequencies.\n                    Takes effect only if the layers are LayerDynamic, not LayerSB.\n    :return: equilibrium position and frequencies in [GHz] (and eigenvectors if LayerDynamic instead of LayerSB).\n    \"\"\"\n    if self.H is None:\n        raise ValueError(\"H must be set before solving the system numerically.\")\n    assert len(init_position) == 2 * len(self.layers), (\n        f\"Incorrect initial position size. Given: {len(init_position)}, expected: {2 * len(self.layers)}\"\n    )\n    eq = self.adam_gradient_descent(\n        init_position=init_position,\n        max_steps=max_steps,\n        tol=adam_tol,\n        learning_rate=learning_rate,\n        first_momentum_decay=first_momentum_decay,\n        second_momentum_decay=second_momentum_decay,\n        perturbation=perturbation,\n    )\n    if not force_sb and isinstance(self.layers[0], LayerDynamic):\n        eigenvalues, eigenvectors = self.dynamic_layer_solve(eq)\n        return eq, eigenvalues / 1e9, eigenvectors\n    N = len(self.layers)\n    if N == 1:\n        return eq, [self.single_layer_resonance(0, eq) / 1e9]\n    if force_single_layer:\n        frequencies = []\n        for indx in range(N):\n            frequency = self.single_layer_resonance(indx, eq) / 1e9\n            frequencies.append(frequency)\n        return eq, frequencies\n    return self.hessian_to_roots(eq, ftol=ftol, max_freq=max_freq)\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.Solver.solve_linearised_frequencies","title":"<code>solve_linearised_frequencies(H, linearisation_axis)</code>","text":"<p>Solves the linearised frequencies of the system. Select linearisation axis and solve characteristic equation to get the frequencies. Requires the system to be in cartesian coordinates.</p> <p>WARNING: This circumvents gradient descent and solves the system analytically and is only valid for small amplitudes (e.g. when the system is close to equilibrium along the linearised axis).</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>VectorObj</code> <p>the magnetic field.</p> required <code>linearisation_axis</code> <code>Literal['x', 'y', 'z']</code> <p>the axis to linearise around.</p> required <p>Returns:</p> Type Description <p>the solutions for the frequencies in the P and AP states.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>@coordinate(require=\"cartesian\")\ndef solve_linearised_frequencies(self, H: VectorObj, linearisation_axis: Literal[\"x\", \"y\", \"z\"]):\n    \"\"\"Solves the linearised frequencies of the system.\n    Select linearisation axis and solve characteristic equation to get the frequencies.\n    Requires the system to be in cartesian coordinates.\n\n    WARNING: This circumvents gradient descent and solves the system analytically\n    and is only valid for small amplitudes (e.g. when the system is close to equilibrium along\n    the linearised axis).\n\n    :param H: the magnetic field.\n    :param linearisation_axis: the axis to linearise around.\n    :return: the solutions for the frequencies in the P and AP states.\n    \"\"\"\n    char_P, char_AP, _, _ = self.linearised_frequencies(H=H, linearisation_axis=linearisation_axis)\n    poly_P = self.det_solver(char_P)\n    poly_AP = self.det_solver(char_AP)\n    roots_P = self.root_solver(poly_P, n_layers=len(self.layers), normalise_roots_by_2pi=True)\n    roots_AP = self.root_solver(poly_AP, n_layers=len(self.layers), normalise_roots_by_2pi=True)\n    return roots_P, roots_AP\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.coordinate","title":"<code>coordinate(require)</code>","text":"<p>Decorator to ensure layers use the required coordinate system.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def coordinate(require: Literal[\"spherical\", \"cartesian\"]):\n    \"\"\"Decorator to ensure layers use the required coordinate system.\"\"\"\n\n    def decorator(func):\n        @wraps(func)\n        def wrapper(self: \"Solver\", *args, **kwargs):\n            systems = {layer.coordinate_system for layer in self.layers}\n\n            if len(systems) &gt; 1:\n                raise ValueError(f\"Mixed coordinate systems: {systems}\")\n\n            if require in systems:\n                return func(self, *args, **kwargs)\n\n            # Convert temporarily\n            original_layers = self.layers\n            self.layers = [_convert_layer(layer, require) for layer in self.layers]\n\n            try:\n                return func(self, *args, **kwargs)\n            finally:\n                self.layers = original_layers\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.fast_norm","title":"<code>fast_norm(x)</code>","text":"<p>Fast norm function for 1D arrays.</p> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>@njit\ndef fast_norm(x):  # sourcery skip: for-index-underscore, sum-comprehension\n    \"\"\"Fast norm function for 1D arrays.\"\"\"\n    sum_ = 0\n    for x_ in x:\n        sum_ += x_**2\n    return math.sqrt(sum_)\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.general_hessian_functional","title":"<code>general_hessian_functional(N)</code>  <code>cached</code>","text":"<p>Create a generalised hessian functional for N layers.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>number of layers. ! WARNING: remember Ms Symbols must match!!!</p> required Source code in <code>cmtj/models/general_sb.py</code> <pre><code>@lru_cache\ndef general_hessian_functional(N: int):\n    \"\"\"Create a generalised hessian functional for N layers.\n    :param N: number of layers.\n    ! WARNING: remember Ms Symbols must match!!!\n    \"\"\"\n    all_symbols = []\n    for i in range(N):\n        # indx_i = str(i + 1) # for display purposes\n        indx_i = str(i)\n        all_symbols.extend((sym.Symbol(r\"\\theta_\" + indx_i), sym.Symbol(r\"\\phi_\" + indx_i)))\n    energy_functional_expr = sym.Function(\"E\")(*all_symbols)\n    return (\n        get_hessian_from_energy_expr(N, energy_functional_expr),\n        energy_functional_expr,\n    )\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.get_all_second_derivatives","title":"<code>get_all_second_derivatives(energy_functional_expr, energy_expression, subs=None)</code>","text":"<p>Get all second derivatives of the energy expression.</p> <p>Parameters:</p> Name Type Description Default <code>energy_functional_expr</code> <p>symbolic energy_functional expression</p> required <code>energy_expression</code> <p>symbolic energy expression (from solver)</p> required <code>subs</code> <p>substitutions to be made.</p> <code>None</code> Source code in <code>cmtj/models/general_sb.py</code> <pre><code>def get_all_second_derivatives(energy_functional_expr, energy_expression, subs=None):\n    \"\"\"Get all second derivatives of the energy expression.\n    :param energy_functional_expr: symbolic energy_functional expression\n    :param energy_expression: symbolic energy expression (from solver)\n    :param subs: substitutions to be made.\"\"\"\n    if subs is None:\n        subs = {}\n    second_derivatives = subs\n    symbols = energy_expression.free_symbols\n    for i, s1 in enumerate(symbols):\n        for j, s2 in enumerate(symbols):\n            if i &lt;= j:\n                org_diff = sym.diff(energy_functional_expr, s1, s2)\n                if subs is not None:\n                    second_derivatives[org_diff] = sym.diff(energy_expression, s1, s2).subs(subs)\n                else:\n                    second_derivatives[org_diff] = sym.diff(energy_expression, s1, s2)\n    return second_derivatives\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.get_hessian_from_energy_expr","title":"<code>get_hessian_from_energy_expr(N, energy_functional_expr)</code>  <code>cached</code>","text":"<p>Computes the Hessian matrix of the energy functional expression with respect to the spin angles and phases.</p> <p>Parameters:</p> Name Type Description Default <code>(int)</code> <code>N</code> <p>The number of spins.</p> required <code>(sympy.Expr)</code> <code>energy_functional_expr</code> <p>The energy functional expression.  returns: sympy.Matrix: The Hessian matrix of the energy functional expression.</p> required Source code in <code>cmtj/models/general_sb.py</code> <pre><code>@lru_cache\ndef get_hessian_from_energy_expr(N: int, energy_functional_expr: sym.Expr):\n    \"\"\"\n    Computes the Hessian matrix of the energy functional expression with respect to the spin angles and phases.\n\n    :param N (int): The number of spins.\n    :param energy_functional_expr (sympy.Expr): The energy functional expression.\n\n    returns: sympy.Matrix: The Hessian matrix of the energy functional expression.\n    \"\"\"\n    hessian = [[0 for _ in range(2 * N)] for _ in range(2 * N)]\n    for i in range(N):\n        # indx_i = str(i + 1) # for display purposes\n        indx_i = str(i)\n        # z = sym.Symbol(\"Z\")\n        # these here must match the Ms symbols!\n        z = (\n            OMEGA\n            * sym.Symbol(r\"M_{\" + indx_i + \"}\")\n            * sym.sin(sym.Symbol(r\"\\theta_\" + indx_i))\n            * sym.Symbol(r\"t_{\" + indx_i + \"}\")\n        )\n        for j in range(i, N):\n            # indx_j = str(j + 1) # for display purposes\n            indx_j = str(j)\n            s1 = sym.Symbol(r\"\\theta_\" + indx_i)\n            s2 = sym.Symbol(r\"\\theta_\" + indx_j)\n\n            expr = sym.diff(energy_functional_expr, s1, s2)\n            hessian[2 * i][2 * j] = expr\n            hessian[2 * j][2 * i] = expr\n            s1 = sym.Symbol(r\"\\phi_\" + indx_i)\n            s2 = sym.Symbol(r\"\\phi_\" + indx_j)\n            expr = sym.diff(energy_functional_expr, s1, s2)\n            hessian[2 * i + 1][2 * j + 1] = expr\n            hessian[2 * j + 1][2 * i + 1] = expr\n\n            s1 = sym.Symbol(r\"\\theta_\" + indx_i)\n            s2 = sym.Symbol(r\"\\phi_\" + indx_j)\n            expr = sym.diff(energy_functional_expr, s1, s2)\n            if i == j:\n                hessian[2 * i + 1][2 * j] = expr + sym.I * z\n                hessian[2 * i][2 * j + 1] = expr - sym.I * z\n            else:\n                hessian[2 * i][2 * j + 1] = expr\n                hessian[2 * j + 1][2 * i] = expr\n\n                s1 = sym.Symbol(r\"\\phi_\" + indx_i)\n                s2 = sym.Symbol(r\"\\theta_\" + indx_j)\n                expr = sym.diff(energy_functional_expr, s1, s2)\n                hessian[2 * i + 1][2 * j] = expr\n                hessian[2 * j][2 * i + 1] = expr\n    return sym.Matrix(hessian)\n</code></pre>"},{"location":"api/models/sb-general-reference/#cmtj.models.general_sb.solve_for_determinant","title":"<code>solve_for_determinant(N)</code>  <code>cached</code>","text":"<p>Solve for the determinant of the hessian functional.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>number of layers.</p> required Source code in <code>cmtj/models/general_sb.py</code> <pre><code>@lru_cache\ndef solve_for_determinant(N: int):\n    \"\"\"Solve for the determinant of the hessian functional.\n    :param N: number of layers.\n    \"\"\"\n    hessian, energy_functional_expr = general_hessian_functional(N)\n    if N == 1:\n        return hessian.det(), energy_functional_expr\n\n    # LU decomposition\n    _, U, _ = hessian.LUdecomposition()\n    return U.det(), energy_functional_expr\n</code></pre>"},{"location":"autogen/","title":"Tutorial: cmtj","text":"<p>cmtj is a modular Python/C++ toolbox for simulating a wide range of nanoscale magnetic phenomena. It uses 3D vector objects and time\u2011dependent drivers to feed Landau\u2013Lifshitz\u2013Gilbert solvers for both uniform layer models and domain wall dynamics. You can perform field scans, inject noise, compute Oersted fields, apply signal filters, and orchestrate complete PIMM &amp; VSD experiments via high\u2011level procedures.</p> <p>Source Repository: https://github.com/LemurPwned/cmtj</p> <pre><code>flowchart TD\n    A0[\"Vector Objects (CVector &amp; VectorObj)\n\"]\n    A1[\"Time\u2011Dependent Drivers (ScalarDriver &amp; AxialDriver)\n\"]\n    A2[\"Magnetic Layer Models (LayerSB &amp; LayerDynamic)\n\"]\n    A3[\"SB Solver (Solver)\n\"]\n    A4[\"Domain Wall Dynamics (DomainWallDynamics &amp; MultilayerWallDynamics)\n\"]\n    A5[\"FieldScan Utilities\n\"]\n    A6[\"PIMM &amp; VSD Procedures\n\"]\n    A7[\"Signal Filters\n\"]\n    A8[\"Noise Generation Models\n\"]\n    A9[\"Oersted Field &amp; Pinning Calculations\n\"]\n    A2 -- \"Uses\" --&gt; A0\n    A4 -- \"Drives\" --&gt; A1\n    A3 -- \"Solves\" --&gt; A2\n    A6 -- \"Scans fields\" --&gt; A5\n    A6 -- \"Sets drivers\" --&gt; A1\n    A6 -- \"Configures\" --&gt; A2\n    A6 -- \"Computes Oersted\" --&gt; A9\n    A6 -- \"Applies filters\" --&gt; A7\n    A4 -- \"Adds noise\" --&gt; A8\n    A8 -- \"Injects noise\" --&gt; A6\n</code></pre>"},{"location":"autogen/#chapters","title":"Chapters","text":"<ol> <li>PIMM &amp; VSD Procedures    </li> <li>FieldScan Utilities    </li> <li>Time\u2011Dependent Drivers (ScalarDriver &amp; AxialDriver)    </li> <li>Magnetic Layer Models (LayerSB &amp; LayerDynamic)    </li> <li>Domain Wall Dynamics (DomainWallDynamics &amp; MultilayerWallDynamics)    </li> <li>Oersted Field &amp; Pinning Calculations    </li> <li>Noise Generation Models    </li> <li>Signal Filters    </li> <li>Vector Objects (CVector &amp; VectorObj)    </li> <li>SB Solver (Solver)     </li> </ol> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"autogen/01_pimm___vsd_procedures_/","title":"Chapter 1: PIMM &amp; VSD Procedures","text":"<p>Welcome to the first chapter! Here we learn how to automate two common micromagnetic experiments\u2014PIMM (Pulse\u2011Induced Microwave Magnetometry) and VSD (Voltage Spin Diode)\u2014using high\u2011level \u201crecipes\u201d in <code>cmtj</code>. These procedures orchestrate many low\u2011level steps (setting fields, running simulations, computing resistances, doing FFTs) so you can focus on \u201cwhat\u201d you want to measure, not \u201chow\u201d to do every detail.</p>"},{"location":"autogen/01_pimm___vsd_procedures_/#1-motivation-central-use-case","title":"1. Motivation &amp; Central Use Case","text":"<p>Imagine you have a magnetic junction and you want to:</p> <ol> <li>Apply a short magnetic pulse.</li> <li>Record how the magnetization rings down (that\u2019s PIMM).</li> <li>Sweep frequencies of a sinusoidal drive and measure the spin\u2011diode voltage (that\u2019s VSD).</li> </ol> <p>Writing all the boilerplate to set fields, run the solver, extract logs, do FFTs, combine layers\u2026 is tedious. PIMM_procedure and VSD_procedure let you do this in one call.</p> <p>Use case in code:</p> <pre><code>from cmtj.utils.procedures import PIMM_procedure, VSD_procedure, ResistanceParameters\nimport numpy as np\n\n# 1. Define a small field scan:\nHvecs = np.array([[0,0,1e5], [0,0,1.2e5]])\n\n# 2. Define resistance parameters per layer (length, width, base resistances\u2026)\nres_params = [ResistanceParameters(Rxx0=100, Rxy0=5, Rahe=1, Ramr=0.5, w=50e-9, l=100e-9)]\n\n# 3. Call PIMM:\nspectrum, freqs, data = PIMM_procedure(junction, Hvecs, 1e-12, res_params)\n\n# 4. Call VSD at some frequencies:\nfreqs_to_test = np.linspace(1e9, 10e9, 50)\nvsd_map = VSD_procedure(junction, Hvecs, freqs_to_test, 1e-12, res_params)\n</code></pre> <p>After that you get:</p> <ul> <li><code>spectrum</code>: PIMM amplitudes vs frequency</li> <li><code>freqs</code>: the frequency axis</li> <li><code>data[\"Rx\"]</code>, <code>data[\"Ry\"]</code>, <code>data[\"m_avg\"]</code>\u2026 for further analysis</li> <li><code>vsd_map</code>: a 2D array of spin\u2011diode voltages vs field &amp; frequency</li> </ul>"},{"location":"autogen/01_pimm___vsd_procedures_/#2-key-concepts","title":"2. Key Concepts","text":"<ol> <li>Junction    Your magnetic system (see Magnetic Layer Models).</li> <li>Drivers</li> <li>External field: constant H<sub>ext</sub></li> <li>Oersted field: pulse (PIMM) or sine (VSD) via <code>ScalarDriver</code> + <code>AxialDriver</code></li> <li>ResistanceParameters    Holds geometry + magnetoresistance coefficients for each layer.</li> <li>FFT &amp; Spectrum    We take the time\u2011series of magnetization projection, run an FFT, and keep frequencies \u2264 <code>max_frequency</code>.</li> </ol>"},{"location":"autogen/01_pimm___vsd_procedures_/#3-how-to-run-pimm-vsd","title":"3. How to Run PIMM &amp; VSD","text":""},{"location":"autogen/01_pimm___vsd_procedures_/#31-pimm-procedure-highlevel","title":"3.1 PIMM Procedure (High\u2011Level)","text":"<pre><code>spectrum, freqs, other = PIMM_procedure(\n    junction=your_junction,\n    Hvecs=Hvecs,\n    int_step=1e-12,\n    resistance_params=res_params,\n    Hoe_duration=5,        # pulse length in #steps\n    simulation_duration=5e-9,\n    take_last_n=200        # how many last time\u2011points to FFT\n)\n</code></pre> <ul> <li>Inputs:</li> <li><code>junction</code>: your initialized <code>Junction</code></li> <li><code>Hvecs</code>: array of external fields</li> <li><code>int_step</code>: time\u2011step in seconds</li> <li><code>resistance_params</code>: list of <code>ResistanceParameters</code> per layer</li> <li>Outputs:</li> <li><code>spectrum[h, f]</code>: FFT amplitude for each H and frequency bin</li> <li><code>freqs[f]</code>: array of frequencies</li> <li><code>other</code>: dict with static Rx, Ry, average magnetization, raw trajectories if <code>full_output=True</code></li> </ul>"},{"location":"autogen/01_pimm___vsd_procedures_/#32-vsd-procedure-highlevel","title":"3.2 VSD Procedure (High\u2011Level)","text":"<pre><code>vsd_map = VSD_procedure(\n    junction=your_junction,\n    Hvecs=Hvecs,\n    frequencies=np.linspace(1e9,5e9,30),\n    int_step=1e-12,\n    resistance_params=res_params,\n    Hoe_excitation=40\n)\n</code></pre> <ul> <li>Inputs:</li> <li><code>frequencies</code>: drive frequencies for the sine Oersted field</li> <li><code>Rtype</code>: choose <code>\"Rx\"</code>, <code>\"Ry\"</code> or <code>\"Rz\"</code></li> <li>Output:</li> <li><code>vsd_map[h, f]</code>: DC mixing voltage vs H and drive frequency</li> </ul>"},{"location":"autogen/01_pimm___vsd_procedures_/#4-inside-pimm_procedure-stepbystep","title":"4. Inside PIMM_procedure: Step\u2011by\u2011Step","text":"<p>Before diving into code, here is what happens:</p> <pre><code>sequenceDiagram\n  participant U as User code\n  participant P as PIMM_procedure\n  participant J as Junction\n  participant F as FFT routine\n  participant R as Resistance calculator\n\n  U-&gt;&gt;P: call PIMM_procedure(...)\n  P-&gt;&gt;J: clear logs, set Hext &amp; Oe\n  P-&gt;&gt;J: optionally add disturbance\n  P-&gt;&gt;J: runSimulation(duration, step)\n  P-&gt;&gt;J: getLog()\n  P-&gt;&gt;R: compute Rx, Ry from m(t)\n  P-&gt;&gt;F: FFT average m component\n  P--&gt;&gt;U: return spectrum, freqs, data\n</code></pre>"},{"location":"autogen/01_pimm___vsd_procedures_/#5-peek-at-the-code","title":"5. Peek at the Code","text":"<p>File: <code>cmtj/utils/procedures.py</code></p>"},{"location":"autogen/01_pimm___vsd_procedures_/#51-building-the-oersted-pulse","title":"5.1 Building the Oersted Pulse","text":"<pre><code># decide which axis gets the pulse\nif Hoe_direction == Axis.zaxis:\n    oedriver = AxialDriver(\n      NullDriver(), NullDriver(),\n      ScalarDriver.getStepDriver(0, amplitude, 0, step * duration_steps)\n    )\n# similar for x and y...\n</code></pre> <p>We wrap a step\u2011function in a 3\u2011component <code>AxialDriver</code>.</p>"},{"location":"autogen/01_pimm___vsd_procedures_/#52-main-loop-over-h-fields","title":"5.2 Main Loop over H Fields","text":"<pre><code>for H in Hvecs:\n    junction.clearLog()\n    # 1) set static field\n    junction.setLayerExternalFieldDriver(\n      \"all\",\n      AxialDriver(\n        ScalarDriver.getConstantDriver(H[0]),\n        ScalarDriver.getConstantDriver(H[1]),\n        ScalarDriver.getConstantDriver(H[2]),\n      ),\n    )\n    # 2) set Oe pulse/sine\n    junction.setLayerOerstedFieldDriver(\"all\", oedriver)\n    # 3) apply small random disturbance\n    # 4) junction.runSimulation(sim_dur, int_step, int_step)\n    # 5) extract log, compute Rx,Ry, FFT\n</code></pre> <p>Each iteration collects:</p> <ul> <li>Static resistances (<code>Rx</code>,<code>Ry</code>) via <code>calculate_resistance_series</code></li> <li>Spectrum of the magnetization ring\u2011down</li> </ul>"},{"location":"autogen/01_pimm___vsd_procedures_/#6-vsd_procedure-internals","title":"6. VSD_procedure Internals","text":"<p>Very similar\u2014except:</p> <ol> <li>Uses a sine Oersted driver at each <code>frequency</code></li> <li>Computes the time\u2011series of R(t), multiplies by I<sub>drive</sub>(t) and integrates to get the mixing voltage via <code>compute_sd</code>.</li> </ol> <p>Under the hood:</p> <pre><code>dynamicI = np.sin(2 * math.pi * f * np.asarray(log[\"time\"]))\nvmix = compute_sd(R, dynamicI, int_step)\n</code></pre>"},{"location":"autogen/01_pimm___vsd_procedures_/#7-conclusion-next-steps","title":"7. Conclusion &amp; Next Steps","text":"<p>You\u2019ve learned how PIMM_procedure and VSD_procedure hide all the low\u2011level plumbing required to run typical magnetization\u2011dynamics experiments. Next, we\u2019ll look at how to generate the field lists (<code>Hvecs</code>) using convenient scans.</p> <p>On to FieldScan Utilities!</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"autogen/02_fieldscan_utilities_/","title":"Chapter 2: FieldScan Utilities","text":"<p>Welcome back! In Chapter\u00a01: PIMM\u00a0&amp;\u00a0VSD Procedures we saw how to run common micromagnetic experiments. Now, before we drive those simulations, we need to generate the lists of magnetic\u2010field vectors that sweep over amplitudes or directions. That\u2019s where FieldScan Utilities come in\u2014turning simple numeric ranges into ready\u2011to\u2011use <code>(Hx,\u00a0Hy,\u00a0Hz)</code> sequences.</p>"},{"location":"autogen/02_fieldscan_utilities_/#1-motivation-central-use-case","title":"1. Motivation &amp; Central Use Case","text":"<p>Imagine you want to:</p> <ol> <li>Sweep the strength of an applied magnetic field from 0 to 1\u00d710^5\u00a0A/m in 10 steps.</li> <li>Always point that field at a 45\u00b0 tilt from the z\u2011axis (polar \u03b8)    and 30\u00b0 around the z\u2011axis (azimuth \u03c6).</li> <li>Feed those field vectors into <code>PIMM_procedure</code> or <code>VSD_procedure</code>.</li> </ol> <p>Without FieldScan, you'd manually compute sin(\u03b8), cos(\u03c6), multiply by each amplitude, pack into arrays\u2026 tedious and error\u2011prone. With FieldScan, you call one method and get back both the list of amplitudes and the matched <code>(Hx,Hy,Hz)</code> waypoints\u2014just like plotting a route on a map.</p>"},{"location":"autogen/02_fieldscan_utilities_/#2-key-concepts","title":"2. Key Concepts","text":"<ol> <li> <p>Spherical Coordinates</p> </li> <li> <p>Amplitude (radius): how strong the field is.</p> </li> <li>Polar angle \u03b8: tilt measured from the +z\u2011axis (0\u00b0 = straight up).</li> <li> <p>Azimuthal angle \u03c6: rotation around the z\u2011axis (0\u00b0 = +x direction).</p> </li> <li> <p>Conversion Routines</p> </li> <li> <p><code>angle2vector(\u03b8, \u03c6, amplitude)</code> \u2192 Cartesian vector <code>CVector(x,y,z)</code>.</p> </li> <li> <p><code>vector2angle(x, y, z)</code> \u2192 <code>(\u03b8, \u03c6, amplitude)</code>.</p> </li> <li> <p>Scan Types</p> </li> <li>Amplitude scan: vary magnitude, keep angles fixed.</li> <li>\u03b8\u2011scan: vary polar angle, keep magnitude &amp; \u03c6 fixed.</li> <li>\u03c6\u2011scan: vary azimuth, keep magnitude &amp; \u03b8 fixed.</li> </ol>"},{"location":"autogen/02_fieldscan_utilities_/#3-using-fieldscan-to-solve-our-use-case","title":"3. Using FieldScan to Solve Our Use Case","text":"<p>Here\u2019s how to get 10 field vectors from 0 \u2192 1\u00d710^5\u00a0A/m at \u03b8=45\u00b0, \u03c6=30\u00b0:</p> <pre><code>import numpy as np\nfrom cmtj.utils.linear import FieldScan\n\n# 1. Choose sweep parameters\nstart_H = 0.0\nstop_H  = 1e5      # A/m\nsteps   = 10\ntheta   = 45.0     # degrees\nphi     = 30.0     # degrees\n\n# 2. Generate amplitude list and H\u2011vectors\nHspan, Hvecs = FieldScan.amplitude_scan(start_H, stop_H, steps, theta, phi)\n\nprint(\"Amplitudes:\", Hspan)\nprint(\"First H\u2011vector:\", Hvecs[0])\nprint(\"Last  H\u2011vector:\", Hvecs[-1])\n</code></pre> <p>After running this, you\u2019ll see:</p> <ul> <li><code>Hspan</code> is a 1D array of 10 magnitudes from 0 to 1\u00d710^5\u00a0A/m.</li> <li><code>Hvecs</code> is a 10\u00d73 array: each row is <code>[Hx,Hy,Hz]</code> matching that amplitude.</li> </ul> <p>You can now feed <code>Hvecs</code> directly into your high\u2011level procedures:</p> <pre><code>spectrum, freqs, data = PIMM_procedure(\n  junction,\n  Hvecs,\n  int_step=1e-12,\n  resistance_params=res_params\n)\n</code></pre>"},{"location":"autogen/02_fieldscan_utilities_/#4-what-happens-under-the-hood","title":"4. What Happens Under the Hood?","text":"<p>Here\u2019s a simple sequence of what <code>FieldScan.amplitude_scan</code> does:</p> <pre><code>sequenceDiagram\n  participant U as User code\n  participant FS as FieldScan\n  participant NP as NumPy\n  participant U as User\n\n  U-&gt;&gt;FS: call amplitude_scan(start, stop, steps, \u03b8, \u03c6)\n  FS-&gt;&gt;NP: linspace(start, stop, steps) \u2192 amplitudes\n  FS-&gt;&gt;FS: compute sin/cos of \u03b8 &amp; \u03c6\n  FS-&gt;&gt;FS: Hx = sin\u03b8\u00b7cos\u03c6\u00b7amplitudes\n  FS-&gt;&gt;FS: Hy = sin\u03b8\u00b7sin\u03c6\u00b7amplitudes\n  FS-&gt;&gt;FS: Hz = cos\u03b8\u00b7amplitudes\n  FS-&gt;&gt;U: return amplitudes, stack([Hx,Hy,Hz])\n</code></pre> <p>Essentially, it takes a 1D \u201cradius\u201d array and projects it into 3D via spherical\u2010to\u2010Cartesian math.</p>"},{"location":"autogen/02_fieldscan_utilities_/#5-peek-at-the-code","title":"5. Peek at the Code","text":"<p>The implementation lives in <code>cmtj/utils/linear.py</code>. Here\u2019s a simplified view of <code>angle2vector</code> and <code>amplitude_scan</code>:</p> <pre><code># File: cmtj/utils/linear.py\nimport numpy as np\nfrom cmtj import CVector\n\nclass FieldScan:\n    @staticmethod\n    def angle2vector(theta, phi, amplitude=1):\n        # Convert angles from deg to rad\n        th = np.deg2rad(theta)\n        ph = np.deg2rad(phi)\n        # spherical\u2192Cartesian\n        x = np.sin(th) * np.cos(ph) * amplitude\n        y = np.sin(th) * np.sin(ph) * amplitude\n        z = np.cos(th) * amplitude\n        return CVector(x, y, z)\n\n    @staticmethod\n    def amplitude_scan(start, stop, steps, theta, phi, back=False):\n        # 1) Make a line of amplitudes\n        Hspan = np.linspace(start, stop, num=steps)\n        # 2) Reuse angle2vector math in bulk\n        # (vectorized below to avoid loops)\n        th = np.deg2rad(theta)\n        ph = np.deg2rad(phi)\n        s, c = np.sin(th), np.cos(th)\n        cp, sp = np.cos(ph), np.sin(ph)\n        Hx = s * cp * Hspan\n        Hy = s * sp * Hspan\n        Hz = c * Hspan\n        Hvecs = np.vstack((Hx, Hy, Hz)).T\n        return Hspan, Hvecs\n</code></pre> <ul> <li><code>angle2vector</code>: one\u2010off conversion from <code>(\u03b8,\u03c6,amplitude)</code> to <code>CVector(x,y,z)</code>.</li> <li><code>amplitude_scan</code>: bulk version that avoids Python loops by using NumPy broadcasting.</li> </ul>"},{"location":"autogen/02_fieldscan_utilities_/#7-conclusion-next-steps","title":"7. Conclusion &amp; Next Steps","text":"<p>You\u2019ve learned how FieldScan Utilities take simple numeric ranges and angles, and produce full Cartesian field sequences\u2014your \u201cwaypoints\u201d for any simulation drive. Next, we\u2019ll see how to turn those static fields into time\u2011dependent pulses or sine drives with Time\u2011Dependent Drivers (ScalarDriver\u00a0&amp;\u00a0AxialDriver).</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"autogen/03_time_dependent_drivers__scalardriver___axialdriver__/","title":"Chapter 3: Time\u2011Dependent Drivers (ScalarDriver &amp; AxialDriver)","text":"<p>Welcome back! In Chapter\u00a02: FieldScan Utilities we learned how to build lists of static field vectors. Now we\u2019ll see how to turn those static fields into time\u2011varying signals\u2014pulses, sine waves or even custom functions\u2014using ScalarDriver and AxialDriver.</p>"},{"location":"autogen/03_time_dependent_drivers__scalardriver___axialdriver__/#1-motivation-central-use-case","title":"1. Motivation &amp; Central Use Case","text":"<p>Imagine you want to simulate how your magnetic junction responds to:</p> <ol> <li>A short pulse of Oersted field along z for PIMM.</li> <li>A sine wave of current (thus field) for VSD.</li> <li>A rotating field in the xy\u2011plane.</li> </ol> <p>Writing your own loop over time, computing sin(t), checking start/stop, and packing into 3\u2011vectors is tedious. ScalarDriver and AxialDriver are programmable \u201cwave machines\u201d:</p> <ul> <li>ScalarDriver = one waveform (pulse, sine, custom).</li> <li>AxialDriver = three ScalarDrivers \u2192 3D, applied to x/y/z.</li> </ul> <p>Use case: \u2022 Create a 1\u00a0GHz sine drive of amplitude 1\u00d710^4\u00a0A/m along z and feed it to your junction.</p>"},{"location":"autogen/03_time_dependent_drivers__scalardriver___axialdriver__/#2-key-concepts","title":"2. Key Concepts","text":"<ol> <li> <p>ScalarDriver</p> </li> <li> <p>Produces a 1D time\u2011series: constant, pulse, sine, custom Python callback\u2026</p> </li> <li> <p>Static constructors like <code>getSineDriver</code>, <code>getStepDriver</code>.</p> </li> <li> <p>AxialDriver</p> </li> <li>Bundles three ScalarDrivers (x, y, z).</li> <li>Helpers:<ul> <li><code>getUniAxialDriver(driver, Axis.zaxis)</code> \u2192 apply driver on one axis.</li> <li><code>AxialDriver(driver_x, driver_y, driver_z)</code> \u2192 custom combo.</li> </ul> </li> </ol> <p>Analogy:</p> <ul> <li>Think of ScalarDriver as a single musical note (tone over time).</li> <li>AxialDriver is a three\u2011instrument chord (notes on x, y, z axes).</li> </ul>"},{"location":"autogen/03_time_dependent_drivers__scalardriver___axialdriver__/#3-how-to-use-drivers","title":"3. How to Use Drivers","text":"<p>Here\u2019s how to set up a 1\u00a0GHz sine Oersted field on z:</p> <pre><code>from cmtj.models.drivers import ScalarDriver, AxialDriver, Axis\n\n# 1) Build a 1\u00a0GHz sine: offset=0, amp=1e4, freq=1e9 Hz, phase=0\nsine = ScalarDriver.getSineDriver(0, 1e4, 1e9, 0)\n\n# 2) Wrap it into an AxialDriver on z\u2011axis\noe_driver = AxialDriver.getUniAxialDriver(sine, Axis.zaxis)\n\n# 3) Apply to your junction\njunction.setLayerOerstedFieldDriver(\"all\", oe_driver)\n\n# 4) Run your simulation as usual!\njunction.runSimulation(duration, time_step, time_step)\n</code></pre> <p>What happens?</p> <ul> <li>At each time <code>t</code>, the solver asks <code>oe_driver</code> for a 3\u2011vector.</li> <li>You get <code>[0, 0, sin(2\u03c0\u00b71e9\u00b7t)*1e4]</code>.</li> </ul> <p>You can also do a rotating xy field:</p> <pre><code>import math\nsx = ScalarDriver.getSineDriver(0, 1e4, 1e9, 0)\nsy = ScalarDriver.getSineDriver(0, 1e4, 1e9, math.pi/2)\nrot = AxialDriver(sx, sy, ScalarDriver.getConstantDriver(0))\njunction.setLayerExternalFieldDriver(\"all\", rot)\n</code></pre> <p>This gives a circular field of radius\u00a01e4 in the xy\u2011plane.</p>"},{"location":"autogen/03_time_dependent_drivers__scalardriver___axialdriver__/#4-under-the-hood-stepbystep","title":"4. Under the Hood: Step\u2011by\u2011Step","text":"<p>When the simulation runs, it needs the field at each time step:</p> <pre><code>sequenceDiagram\n  participant Sim as Solver\n  participant AD as AxialDriver\n  participant SD as ScalarDriver\n\n  Sim-&gt;&gt;AD: getCurrentAxialDrivers(t)\n  AD-&gt;&gt;SD: getCurrentScalarValue(t) for each axis\n  SD--&gt;&gt;AD: scalar values (e.g. sin(\u2026)*amp)\n  AD--&gt;&gt;Sim: CVector(x,y,z)\n  Sim-&gt;&gt;Sim: advance magnetization with field\n</code></pre>"},{"location":"autogen/03_time_dependent_drivers__scalardriver___axialdriver__/#5-driver-implementation-simplified","title":"5. Driver Implementation (Simplified)","text":""},{"location":"autogen/03_time_dependent_drivers__scalardriver___axialdriver__/#51-scalardriver-core-logic","title":"5.1 ScalarDriver (core logic)","text":"<p>File: <code>cmtj/models/drivers.py</code></p> <pre><code>class ScalarDriver:\n    def __init__(self, update, constant, amp, freq, phase, callback=None):\n        # store parameters\u2026\n        self.update = update\n        # \u2026\n\n    @staticmethod\n    def getSineDriver(constant, amp, freq, phase):\n        return ScalarDriver('sine', constant, amp, freq, phase)\n\n    def getCurrentScalarValue(self, t):\n        val = self.constant\n        if self.update == 'sine':\n            val += self.amp * math.sin(2*math.pi*self.freq*t + self.phase)\n        # other types (step, pulse\u2026) are similar\n        return val\n</code></pre> <p>Explanation:</p> <ul> <li><code>getSineDriver</code> sets up a sine.</li> <li><code>getCurrentScalarValue(t)</code> returns the value at time\u00a0<code>t</code>.</li> </ul>"},{"location":"autogen/03_time_dependent_drivers__scalardriver___axialdriver__/#52-axialdriver-combines-3-scalars","title":"5.2 AxialDriver (combines 3 scalars)","text":"<p>File: <code>cmtj/models/drivers.py</code></p> <pre><code>class AxialDriver:\n    def __init__(self, dx, dy, dz):\n        self.drivers = [dx, dy, dz]\n\n    @staticmethod\n    def getUniAxialDriver(drv, axis):\n        # axis: xaxis=0, yaxis=1, zaxis=2, all=3\n        vec = [NullDriver(), NullDriver(), NullDriver()]\n        vec[axis.value] = drv\n        return AxialDriver(*vec)\n\n    def getCurrentAxialDrivers(self, t):\n        return CVector(\n            self.drivers[0].getCurrentScalarValue(t),\n            self.drivers[1].getCurrentScalarValue(t),\n            self.drivers[2].getCurrentScalarValue(t)\n        )\n</code></pre> <p>Explanation:</p> <ul> <li>Stores three ScalarDrivers.</li> <li>On each call returns a <code>CVector(x,y,z)</code> of current values.</li> </ul> <p>And in C++ (core/drivers.hpp) the logic mirrors this for high performance.</p>"},{"location":"autogen/03_time_dependent_drivers__scalardriver___axialdriver__/#7-conclusion-next-steps","title":"7. Conclusion &amp; Next Steps","text":"<p>You\u2019ve learned how to create time\u2011dependent drivers in <code>cmtj</code>:</p> <ul> <li>ScalarDriver for 1D waveforms (sine, pulse, custom).</li> <li>AxialDriver for 3\u2011component signals.</li> </ul> <p>Now you can feed precise time patterns into your magnetization simulations. In the next chapter we\u2019ll see how to define and manage your magnetic layers with Magnetic Layer Models (LayerSB &amp; LayerDynamic).</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"autogen/04_magnetic_layer_models__layersb___layerdynamic__/","title":"Chapter 4: Magnetic Layer Models (LayerSB &amp; LayerDynamic)","text":"<p>Welcome back! In Chapter\u00a03: Time\u2011Dependent Drivers (ScalarDriver\u00a0&amp;\u00a0AxialDriver) we learned how to craft time\u2011varying field pulses and sine drives. Now it\u2019s time to define the magnetic layers themselves\u2014the \u201cspinning tops\u201d of your junction. We\u2019ll see how to:</p> <ul> <li>Compute static FMR frequencies with LayerSB (Smit\u2013Beljers model).</li> <li>Extend to full LLG dynamics (damping &amp; torques) with LayerDynamic.</li> </ul>"},{"location":"autogen/04_magnetic_layer_models__layersb___layerdynamic__/#1-motivation-central-use-case","title":"1. Motivation &amp; Central Use Case","text":"<p>Imagine you want to:</p> <ol> <li>Define a single ferromagnetic film with its own thickness, anisotropy and saturation (a tiny spinning top).</li> <li>Under an applied static field, compute its ferromagnetic\u2011resonance (FMR) frequency.</li> <li>Or include damping (\u03b1) to run full time\u2011domain LLG simulations later (e.g., PIMM/VSD).</li> </ol> <p>Without <code>cmtj</code>, you\u2019d have to derive energy, build Hessians, solve eigenproblems, implement gradient\u2010descent\u2026 a lot! LayerSB and LayerDynamic give you ready\u2010made building blocks.</p>"},{"location":"autogen/04_magnetic_layer_models__layersb___layerdynamic__/#2-key-concepts","title":"2. Key Concepts","text":"<ul> <li> <p>LayerSB   A static, symbolic Smit\u2013Beljers model.   \u2022 Stores thickness, in\u2011plane/surface anisotropy, Ms, demag tensor.   \u2022 Builds a symbolic energy functional.   \u2022 Computes Hessian \u2192 FMR frequencies.</p> </li> <li> <p>LayerDynamic   Inherits LayerSB.   \u2022 Adds damping (\u03b1) and spin\u2011torque parameters.   \u2022 Defines the RHS of the LLG equation in spherical coordinates.   \u2022 Enables dynamic eigenmode and mode\u2010mixing calculations.</p> </li> <li> <p>Solver   Takes one or more layers (SB or Dynamic), interlayer couplings J\u2081/J\u2082, external field H, dipoles\u2026   \u2022 solve() finds equilibrium (via Adam gradient\u2010descent) and then:   \u2013 For LayerSB: finds FMR roots of the Hessian.   \u2013 For LayerDynamic: builds the LLG Jacobian, finds dynamic eigenmodes.</p> </li> </ul>"},{"location":"autogen/04_magnetic_layer_models__layersb___layerdynamic__/#3-static-fmr-with-layersb","title":"3. Static FMR with LayerSB","text":"<p>Here\u2019s how to compute the FMR of a single layer under a static field:</p> <pre><code>from cmtj.models.general_sb import LayerSB, Solver\nfrom cmtj.utils import VectorObj\n\n# 1) Define a static layer (id=0)\nlayer = LayerSB(\n    _id=0,\n    thickness=1e-9,               # 1\u00a0nm thick\n    Kv=VectorObj(1e4, 0, 0),      # in\u2010plane anisotropy of 1e4\u00a0J/m\u00b3 along x\n    Ks=0,                         # no perpendicular surface anisotropy\n    Ms=8e5                        # saturation magnetisation [A/m]\n)\n\n# 2) Build a solver around this layer (no coupling J1,J2)\nsolver = Solver(layers=[layer], J1=[], J2=[])\n\n# 3) Apply an external field H = (0,0,1e5) A/m\nsolver.set_H(VectorObj(0, 0, 1e5))\n\n# 4) Solve for equilibrium angles and FMR frequency\n#    init_position = [\u03b80, \u03c60] in radians\neq_pos, freqs = solver.solve(init_position=[0.0, 0.0])\n\nprint(\"Equilibrium (\u03b8,\u03c6):\", eq_pos)\nprint(\"FMR frequency (GHz):\", freqs)\n</code></pre> <p>Explanation:</p> <ol> <li>We create a LayerSB with basic magnetic properties.</li> <li>We wrap it in a Solver, set H, then call <code>solve()</code>.</li> <li>Under the hood, <code>solve</code> finds the minimum of the energy, builds the Hessian, finds its eigen\u2011roots \u2192 FMR.</li> </ol>"},{"location":"autogen/04_magnetic_layer_models__layersb___layerdynamic__/#4-dynamic-llg-with-layerdynamic","title":"4. Dynamic LLG with LayerDynamic","text":"<p>To include damping (\u03b1) and torques for full LLG dynamics, swap in LayerDynamic:</p> <pre><code>from cmtj.models.general_sb import LayerDynamic\n\n# 1) Define a dynamic layer\nlayer_dyn = LayerDynamic(\n    _id=0,\n    thickness=1e-9,\n    Kv=VectorObj(1e4, 0, 0),\n    Ks=0,\n    Ms=8e5,\n    alpha=0.02,     # Gilbert damping\n    torque_par=0,   # no extra spin torque\n    torque_perp=0\n)\n\n# 2) Build the solver\nsolver_dyn = Solver(layers=[layer_dyn], J1=[], J2[])\nsolver_dyn.set_H(VectorObj(0, 0, 1e5))\n\n# 3) Solve: returns (eq_pos, freqs, modes)\neq_dyn, freqs_dyn, modes = solver_dyn.solve(init_position=[0.0, 0.0])\n\nprint(\"Dynamic FMR (GHz):\", freqs_dyn)\n# 'modes' holds the eigenvectors for each excited mode\n</code></pre> <p>Now <code>solve()</code> spots that the layer is dynamic, builds the LLG Jacobian, and returns both frequencies and mode vectors for time\u2011domain behavior.</p>"},{"location":"autogen/04_magnetic_layer_models__layersb___layerdynamic__/#5-what-happens-under-the-hood","title":"5. What Happens Under the Hood?","text":"<p>Here\u2019s a simplified view of <code>Solver.solve()</code> in action:</p> <pre><code>sequenceDiagram\n  participant U as User code\n  participant S as Solver.solve\n  participant G as Gradient\u2010descent\n  participant M as Layer (SB or Dynamic)\n  participant R as RootFinder / NumPy eig\n\n  U-&gt;&gt;S: solve(init_position)\n  S-&gt;&gt;G: find equilibrium angles (minimize energy)\n  G--&gt;&gt;S: eq_pos\n  alt M is LayerDynamic\n    S-&gt;&gt;M: build LLG Jacobian at eq_pos\n    S-&gt;&gt;R: NumPy\u2010eig to get freqs &amp; modes\n  else M is LayerSB\n    S-&gt;&gt;M: build energy Hessian at eq_pos\n    S-&gt;&gt;R: root\u2010finder to get FMR roots\n  end\n  S--&gt;&gt;U: return eq_pos, freqs (and modes)\n</code></pre> <ul> <li>Step 1: Gradient\u2010descent locates the energy minimum (<code>\u03b8_eq, \u03c6_eq</code>).</li> <li>Step 2:</li> <li>LayerSB \u2192 symbolic Hessian \u2192 numeric root\u2010finding \u2192 FMR.</li> <li>LayerDynamic \u2192 LLG Jacobian \u2192 eigen\u2010decomposition \u2192 dynamic modes.</li> </ul>"},{"location":"autogen/04_magnetic_layer_models__layersb___layerdynamic__/#6-a-peek-at-the-source","title":"6. A Peek at the Source","text":"<p>All lives in <code>cmtj/models/general_sb.py</code>. Here\u2019s a toy sketch of <code>solve()</code>:</p> <pre><code>def solve(self, init_position):\n    # 1) equilibrium\n    eq = self.adam_gradient_descent(init_position)\n    # 2) if dynamic \u2192 LLG eigenmodes\n    if isinstance(self.layers[0], LayerDynamic):\n        return eq, *self.dynamic_layer_solve(eq)\n    # 3) else static \u2192 FMR roots\n    return eq, self.num_solve(eq)\n</code></pre> <p>And static\u2010FMR calls something like:</p> <pre><code>def num_solve(self, eq):\n    hes_det = self.create_energy_hessian(eq)      # symbolic Hessian det\n    roots = RootFinder(...).find(hes_det)         # find \u03c9\u2010roots\n    return np.unique(np.round(roots/1e9,2))       # in GHz\n</code></pre>"},{"location":"autogen/04_magnetic_layer_models__layersb___layerdynamic__/#7-conclusion-next-steps","title":"7. Conclusion &amp; Next Steps","text":"<p>You\u2019ve now met LayerSB and LayerDynamic\u2014the core building blocks for defining magnetic layers in <code>cmtj</code>. You know how to:</p> <ul> <li>Instantiate static layers and compute Smit\u2013Beljers FMR.</li> <li>Instantiate dynamic layers with damping &amp; torques for full LLG eigenmode analysis.</li> </ul> <p>Next up: handling domain\u2010wall dynamics across multiple layers in Chapter\u00a05: Domain Wall Dynamics (DomainWallDynamics\u00a0&amp;\u00a0MultilayerWallDynamics).</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"autogen/05_domain_wall_dynamics__domainwalldynamics___multilayerwalldynamics__/","title":"Chapter 5: Domain Wall Dynamics (DomainWallDynamics &amp; MultilayerWallDynamics)","text":"<p>Welcome back! In Chapter\u00a04: Magnetic Layer Models (LayerSB\u00a0&amp;\u00a0LayerDynamic) we learned how to describe uniform films and compute their FMR. Now we turn our attention to domain walls\u2014the boundaries between \u201cup\u201d and \u201cdown\u201d regions in a magnet\u2014and see how to simulate their motion under fields, currents, pinning, and interlayer coupling.</p>"},{"location":"autogen/05_domain_wall_dynamics__domainwalldynamics___multilayerwalldynamics__/#1-motivation-central-use-case","title":"1. Motivation &amp; Central Use Case","text":"<p>Imagine you have a nanowire with a single domain wall and you want to know:</p> <ol> <li>How fast the wall moves when you apply a spin\u2011Hall current pulse.</li> <li>How its internal angle (<code>\u03c6</code>) tilts over time.</li> <li>How the wall width (<code>\u03b4</code>) adapts dynamically (or is pinned by imperfections).</li> </ol> <p>Or imagine two walls in adjacent layers that interact like train cars\u2014the front car pulls the next one via an interlayer coupling <code>J</code>.</p> <p>With <code>DomainWallDynamics</code> and <code>MultilayerWallDynamics</code> you get a 1D \u201ccollective coordinate\u201d model: each wall is just three numbers\u2014position <code>X</code>, angle <code>\u03c6</code>, width <code>\u03b4</code>\u2014and a set of ODEs describes how they evolve. <code>MultilayerWallDynamics</code> then glues one or two walls together and integrates them via an adaptive Runge\u2013Kutta solver (<code>RK45</code>).</p> <p>Here\u2019s how to solve our single\u2011wall use case in just a few lines of code.</p>"},{"location":"autogen/05_domain_wall_dynamics__domainwalldynamics___multilayerwalldynamics__/#2-key-concepts","title":"2. Key Concepts","text":"<p>\u2022 X, \u03c6, \u03b4</p> <ul> <li>X: center of the wall along the wire</li> <li>\u03c6: internal magnetization angle (e.g. N\u00e9el or Bloch type)</li> <li>\u03b4: domain\u2011wall width</li> </ul> <p>\u2022 DomainWallDynamics</p> <ul> <li>Holds all material parameters (Ms, \u03b1, DMI, anisotropies, pinning strength\u2026)</li> <li>Knows the external field H and any time\u2011dependent current via <code>set_current_function</code></li> <li>Computes <code>dX/dt</code>, <code>d\u03c6/dt</code>, <code>d\u03b4/dt</code> at each time</li> </ul> <p>\u2022 MultilayerWallDynamics</p> <ul> <li>Takes one or two <code>DomainWallDynamics</code> objects</li> <li>Adds an interlayer coupling term <code>J</code> (zero for single wall)</li> <li>Packs all <code>X</code>, <code>\u03c6</code>, <code>\u03b4</code> into one big state vector</li> <li>Uses SciPy\u2019s <code>RK45</code> to step the ODEs and record trajectories</li> </ul>"},{"location":"autogen/05_domain_wall_dynamics__domainwalldynamics___multilayerwalldynamics__/#3-how-to-use-simple-example","title":"3. How to Use: Simple Example","text":"<pre><code>from cmtj.models.domain_dynamics import DomainWallDynamics, MultilayerWallDynamics, DW\nfrom cmtj.utils.general import VectorObj\n\n# 1) Define an external field along +z (100 kA/m)\nH_ext = VectorObj(0, 0, 1e5)\n\n# 2) Create a single-wall dynamics object\ndw = DomainWallDynamics(\n    H=H_ext,         # applied field\n    alpha=0.02,      # damping\n    Ms=8e5,          # A/m\n    thickness=1e-9,  # m\n    SHE_angle=0.1,   # spin Hall angle\n    D=1e-3,          # DMI constant\n    Ku=1e6,          # perpendicular anisotropy\n    Kp=1e4,          # in\u2011plane anisotropy\n)\n\n# 3) (Optional) set a current pulse: 1e12 A/m\u00b2 after t&gt;1 ns\ndw.set_current_function(lambda t: 1e12 if t &gt; 1e-9 else 0)\n\n# 4) Wrap into a Multilayer solver (J=0 for uncoupled)\nmlw = MultilayerWallDynamics(layers=[dw], J=0)\n\n# 5) Run for 5\u00a0ns, starting at X=0, \u03c6=N\u00e9el-right, \u03b4=natural width\nstart = [0, DW.NEEL_RIGHT, dw.dw0]\nres = mlw.run(sim_time=5e-9, starting_conditions=start)\n\n# Result is a dict of time\u2011series:\n#  res[\"t\"]     \u2192 times\n#  res[\"x_0\"]   \u2192 wall position\n#  res[\"phi_0\"] \u2192 wall angle\n#  res[\"dw_0\"]  \u2192 wall width\n</code></pre> <p>After running, you can plot <code>res[\"x_0\"]</code> vs <code>res[\"t\"]</code> to see how fast your wall moves under the current pulse.</p>"},{"location":"autogen/05_domain_wall_dynamics__domainwalldynamics___multilayerwalldynamics__/#4-under-the-hood-what-happens-when-you-call-run","title":"4. Under the Hood: What Happens When You Call <code>run()</code>","text":"<p>Here\u2019s a high\u2011level sequence of events:</p> <pre><code>sequenceDiagram\n  participant U as User Code\n  participant MLW as MultilayerWallDynamics\n  participant RK as RK45 Integrator\n  participant DW as DomainWallDynamics\n\n  U-&gt;&gt;MLW: run(sim_time, start_cond)\n  MLW-&gt;&gt;RK: initialize with multilayer_dw_llg()\n  RK-&gt;&gt;DW: at each t, call compute_dynamics(...)\n  DW--&gt;&gt;RK: return dX/dt, d\u03c6/dt, d\u03b4/dt\n  RK--&gt;&gt;MLW: update state vector, record results\n  MLW--&gt;&gt;U: return collected time series\n</code></pre> <ol> <li>Initialization: <code>RK45</code> is set up with your custom ODE function <code>multilayer_dw_llg</code>.</li> <li>ODE Function: For each step in time, <code>multilayer_dw_llg(t, y)</code> unpacks each wall\u2019s <code>X, \u03c6, \u03b4</code> and calls a Numba\u2011accelerated <code>compute_dynamics(...)</code> to get the derivatives.</li> <li>Coupling: If you have two walls, an extra <code>J</code> term couples their angles like springs between train cars.</li> <li>Recording: After every successful step, <code>run()</code> records <code>t</code>, each <code>x_i</code>, <code>\u03c6_i</code>, <code>\u03b4_i</code>, velocity, and instantaneous current <code>je_i</code>.</li> </ol>"},{"location":"autogen/05_domain_wall_dynamics__domainwalldynamics___multilayerwalldynamics__/#5-peeking-at-the-core-implementation","title":"5. Peeking at the Core Implementation","text":"<p>File: <code>cmtj/models/domain_dynamics.py</code></p>"},{"location":"autogen/05_domain_wall_dynamics__domainwalldynamics___multilayerwalldynamics__/#51-the-singlewall-ode-compute_dynamics","title":"5.1 The single\u2011wall ODE (<code>compute_dynamics</code>)","text":"<pre><code>@njit\ndef compute_dynamics(X, phi, delta, alpha, Q, hx, hy, hz, hk, hdmi, hr,\n                     hshe, beta, bj, Ms, Lx, Ly, Lz, V0_pin, V0_edge,\n                     pinning, IECterm, thickness, A, Ku, Kp):\n    # (1) compute torque terms \u03b3\u2090, \u03b3_b\n    # (2) build dXdt, dPhidt, dDeltadt\n    return dXdt, dPhidt, dDeltadt\n</code></pre> <p>\u2013 <code>Q</code> selects up\u2013down or down\u2013up wall. \u2013 <code>hx,hy,hz</code> are the external field components. \u2013 <code>bj</code> and <code>hshe</code> scale with the current density you set.</p>"},{"location":"autogen/05_domain_wall_dynamics__domainwalldynamics___multilayerwalldynamics__/#52-coupling-walls-multilayer_dw_llg","title":"5.2 Coupling walls (<code>multilayer_dw_llg</code>)","text":"<pre><code>def multilayer_dw_llg(self, t, vec):\n    results = []\n    for i, layer in enumerate(self.layers):\n        X, phi, delt = vec[3*i:3*i+3]\n        # compute interlayer term Jterm if 2 walls\n        dX, dphi, ddelt = compute_dynamics( X, phi, delt, \u2026, IECterm )\n        results += [dX, dphi, ddelt]\n    return results\n</code></pre> <p>\u2013 Loops over each wall, unpacks its state, calls <code>compute_dynamics</code>, then packs all derivatives into one list for RK45.</p>"},{"location":"autogen/05_domain_wall_dynamics__domainwalldynamics___multilayerwalldynamics__/#6-visualizing-coupled-walls-trainofcars-analogy","title":"6. Visualizing Coupled Walls (Train\u2011of\u2011Cars Analogy)","text":"<pre><code>graph LR\n  subgraph Wall 1\n    X1[ X 1, phi 1, delta 1 ]\n  end\n  subgraph Wall 2\n    X2[ X 2, phi 2, delta 2 ]\n  end\n  X1 -- J coupling --&gt; X2\n  click X1 href \"#\"\n  click X2 href \"#\"\n</code></pre> <p>Each \u201ccar\u201d (wall) has its own state, but the coupling <code>J</code> acts like a spring linking their angles.</p>"},{"location":"autogen/05_domain_wall_dynamics__domainwalldynamics___multilayerwalldynamics__/#7-conclusion-next-steps","title":"7. Conclusion &amp; Next Steps","text":"<p>You\u2019ve now learned how to simulate domain\u2011wall dynamics in <code>cmtj</code>:</p> <ul> <li>DomainWallDynamics holds material &amp; field parameters, computes <code>dX/dt</code>, <code>d\u03c6/dt</code>, <code>d\u03b4/dt</code>.</li> <li>MultilayerWallDynamics couples one or two walls, runs them with <code>RK45</code>, and returns full time\u2011series of positions, angles, widths, velocities, and currents.</li> </ul> <p>With this in hand, you can explore domain\u2011wall velocity under different pulses, pinning landscapes, or layer couplings. Up next, we\u2019ll dive into the details of how to calculate Oersted fields and pinning potentials in Chapter\u00a06: Oersted Field &amp; Pinning Calculations.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"autogen/06_oersted_field___pinning_calculations_/","title":"Chapter 6: Oersted Field &amp; Pinning Calculations","text":"<p>Welcome back! In Chapter\u00a05: Domain Wall Dynamics we learned how to move and couple domain walls. Now, before we drive walls with currents or fields, we need to know:</p> <ul> <li>How the conductor\u2019s own current generates magnetic fields (Oersted fields).</li> <li>How imperfections in the wire create a pinning potential that can block wall motion.</li> </ul> <p>Imagine slicing your wire into a 2D or 3D grid of tiny cubes. Each cube carries some current and \u201cwhispers\u201d a magnetic field to its neighbors. Then, if there are rough spots, they create little hills and valleys in an energy landscape that can pin (trap) the wall.</p> <p>In this chapter you\u2019ll learn how to:</p> <ol> <li>Build a <code>Structure</code> of blocks representing your conductor.</li> <li>Assign currents to regions.</li> <li>Compute local Oersted fields via Amp\u00e8re\u2019s law or Biot\u2013Savart.</li> <li>Extract pinning fields or energies for domain walls.</li> </ol>"},{"location":"autogen/06_oersted_field___pinning_calculations_/#1-motivation-central-use-case","title":"1. Motivation &amp; Central Use Case","text":"<p>Use case: You have a rectangular stripe, 200\u00a0nm wide, 5\u00a0nm thick. You drive 1\u00a0mA along its length and want to know:</p> <ol> <li>What\u2019s the spatial map of the Oersted field across the stripe?</li> <li>How strong is the pinning at a defect located at y\u00a0=\u00a050\u00a0nm?</li> </ol> <p>With this information you can predict where a domain wall will stall or how much current you need to overcome pinning.</p>"},{"location":"autogen/06_oersted_field___pinning_calculations_/#2-key-concepts","title":"2. Key Concepts","text":"<ol> <li> <p>Block    A little cube (dx\u00d7dy\u00d7dz) that:</p> </li> <li> <p>Knows its center <code>(x,y,z)</code>.</p> </li> <li>Carries a local current <code>I</code>.</li> <li> <p>Accumulates its self\u2010field <code>Hlocal</code>.</p> </li> <li> <p>Structure    A 2D/3D array of <code>Block</code> objects filling your conductor.</p> </li> <li> <p><code>Structure.set_region_I</code> divides the total current among blocks in a stripe.</p> </li> <li> <p><code>Structure.compute_blocks</code> loops over all block pairs and applies either:</p> <ul> <li>Amp\u00e8re\u2019s law (for 2D sheets)</li> <li>Biot\u2013Savart law (for 3D volumes)</li> </ul> </li> <li> <p>Pinning Potential    By summing Oersted contributions over a local region around a defect, you get an extra local field or energy barrier that acts like a pinning site.</p> </li> </ol>"},{"location":"autogen/06_oersted_field___pinning_calculations_/#3-how-to-use-in-code","title":"3. How to Use in Code","text":"<p>Below is a minimal example for our 200\u00a0nm\u00d7100\u00a0nm stripe:</p> <pre><code>from cmtj.models.oersted import Structure\n\n# 1) Build a 200\u00d7100\u00a0nm stripe with 10\u00d75\u00a0nm blocks (2\u00d720 blocks)\nstripe = Structure(\n    maxX=200e-9, maxY=100e-9, maxZ=5e-9,\n    dx=10e-9, dy=5e-9, dz=5e-9,\n    method=\"ampere\"   # use Amp\u00e8re\u2019s law in 2D\n)\n\n# 2) Send I=1\u00a0mA through stripe (uniform in y from 0 to 100\u00a0nm)\nstripe.set_region_I(I=1e-3, min_y=0, max_y=100e-9)\n\n# 3) Compute the Oersted field on each block\nstripe.compute_blocks()\n\n# 4) Get the total field acting near y=50\u00a0nm (pinning region)\nH_pin = stripe.compute_region_contribution(\n    source_min_y=0, source_max_y=100e-9,\n    target_min_y=45e-9, target_max_y=55e-9\n)\nprint(f\"Pinning field near y=50\u00a0nm: {H_pin:.2e} A/m\")\n\n# 5) Visualize the full field map\nfield_map = stripe.show_field(log=False)\n</code></pre> <p>Explanation:</p> <ul> <li>We divide the stripe into 2\u00d720 blocks.</li> <li><code>set_region_I</code> shares the 1\u00a0mA evenly across all blocks.</li> <li><code>compute_blocks</code> loops over pairs and adds up each block\u2019s contribution.</li> <li>We then query the field near y\u00a0=\u00a050\u00a0nm to see how strong the \u201cpin\u201d is.</li> <li>Finally, <code>show_field</code> gives a nice 2D color plot of the Oersted field.</li> </ul>"},{"location":"autogen/06_oersted_field___pinning_calculations_/#4-under-the-hood-stepbystep","title":"4. Under the Hood: Step\u2011by\u2011Step","text":"<p>Here\u2019s what happens when you call <code>stripe.compute_blocks()</code>:</p> <pre><code>sequenceDiagram\n  participant U as User Code\n  participant S as Structure\n  participant B1 as Block i\n  participant B2 as Block j\n\n  U-&gt;&gt;S: compute_blocks()\n  S-&gt;&gt;B1: for each block i\n  B1-&gt;&gt;B2: compute H_ij = ampere_law or biot_savart\n  B2--&gt;&gt;B1: (symmetric) H_ji\n  B1-&gt;&gt;B1: Hlocal += H_ij\n  B2-&gt;&gt;B2: Hlocal += H_ji\n  S--&gt;&gt;U: all blocks updated\n</code></pre> <ol> <li>Loop pairs: We take every pair of blocks (i,j).</li> <li>Compute field: Block\u00a0i whispers to block\u00a0j and vice versa.</li> <li>Accumulate: Each block adds the computed field to its <code>Hlocal</code>.</li> </ol>"},{"location":"autogen/06_oersted_field___pinning_calculations_/#5-peeking-at-the-implementation","title":"5. Peeking at the Implementation","text":"<p>File: <code>cmtj/models/oersted.py</code></p>"},{"location":"autogen/06_oersted_field___pinning_calculations_/#51-simplified-block-class","title":"5.1 Simplified <code>Block</code> class","text":"<pre><code>class Block:\n    def __init__(self, ix, iy, iz, dx, dy, dz):\n        self.x = (ix+0.5)*dx  # center\n        self.y = (iy+0.5)*dy\n        self.z = (iz+0.5)*dz\n        self.area = dx*dy\n        self.dl = dz\n        self.I = 0\n        self.Hlocal = 0\n\n    def set_I(self, I):\n        self.I = I\n\n    def ampere_law(self, other):\n        #  H = I / (2\u03c0r)\n        r = ((self.x-other.x)**2 + (self.y-other.y)**2)**0.5\n        return other.I/(2*math.pi*r)\n\n    def biot_savart(self, other):\n        # 3D version, H \u223c I * area * dl / r^2\n        r2 = (self.x-other.x)**2 + (self.y-other.y)**2\n        return other.I*other.area*self.dl/(4*math.pi*r2) if r2&gt;0 else 0\n</code></pre> <p>Explanation:</p> <ul> <li>The block stores its center and current.</li> <li>Two methods implement Amp\u00e8re vs Biot\u2013Savart.</li> <li>Both return a scalar field <code>H</code> at this block from <code>other</code>.</li> </ul>"},{"location":"autogen/06_oersted_field___pinning_calculations_/#52-simplified-structure-setup-and-compute","title":"5.2 Simplified <code>Structure</code> setup and compute","text":"<pre><code>class Structure:\n    def __init__(self, maxX, maxY, maxZ, dx, dy, dz, method):\n        self.Xsize = ceil(maxX/dx)\n        self.Ysize = ceil(maxY/dy)\n        self.Zsize = max(ceil(maxZ/dz),1)\n        self.blocks = [[[Block(i,j,k,dx,dy,dz)\n                         for k in range(self.Zsize)]\n                        for j in range(self.Ysize)]\n                       for i in range(self.Xsize)]\n        self.method = method\n\n    def set_region_I(self, I, min_y, max_y):\n        # equally split I over blocks with y in [min_y,max_y]\n        # \u2026\n\n    def compute_blocks(self):\n        for i in range(len(self.blocks)):\n          for j in range(len(self.blocks)):\n            for k in range(len(self.blocks[i])):\n              b1 = self.blocks[i][j][k]\n              for ii in range(i,len(self.blocks)):\n                for jj in range(len(self.blocks[ii])):\n                  for kk in range(len(self.blocks[ii][jj])):\n                    b2 = self.blocks[ii][jj][kk]\n                    if b1 is b2: continue\n                    # pick law:\n                    H = (b1.ampere_law(b2) if self.method==\"ampere\"\n                         else b1.biot_savart(b2))\n                    b1.Hlocal += H\n                    b2.Hlocal += H\n</code></pre>"},{"location":"autogen/06_oersted_field___pinning_calculations_/#6-visualizing-pinning-as-an-energy-hill","title":"6. Visualizing Pinning as an Energy Hill","text":"<p>Once you compute <code>Hlocal</code> across the stripe, you can convert it into a local energy barrier for a domain wall:</p> <ul> <li>The pinning force \u223c 2\u00a0M\u209b\u00a0t\u00a0H<sub>pin</sub>.</li> <li>Where <code>t</code> is thickness, <code>Hpin</code> from <code>compute_region_contribution</code>.</li> </ul> <p>Plot <code>Hpin</code> vs y to see where your wall will buckle under current.</p> <pre><code>graph LR\n  A[Blocks with Hlocal] --&gt; B[Pinning Field map]\n  B --&gt; C[Compute F_pin(y)]\n  C --&gt; D[Energy barrier vs position]\n</code></pre>"},{"location":"autogen/06_oersted_field___pinning_calculations_/#7-conclusion-next-steps","title":"7. Conclusion &amp; Next Steps","text":"<p>You\u2019ve learned how to:</p> <ul> <li>Dissect your conductor into tiny blocks that carry current and generate fields.</li> <li>Use Amp\u00e8re\u2019s law or Biot\u2013Savart to compute local Oersted fields.</li> <li>Extract a pinning field for specific regions where domain walls might get stuck.</li> </ul> <p>Armed with this, you can now predict how much current is needed to free a domain wall from a defect. Next up, we\u2019ll add thermal fluctuations with Noise Generation Models.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"autogen/07_noise_generation_models_/","title":"Chapter 7: Noise Generation Models","text":"<p>Welcome back! In Chapter\u00a06: Oersted Field &amp; Pinning Calculations we learned how to compute fields from currents and defects. Now we add a sprinkle of randomness\u2014noise\u2014to our simulations. Noise models help you mimic thermal agitation or natural fluctuations in your magnetic system, like the jiggling of molecules at finite temperature.</p>"},{"location":"autogen/07_noise_generation_models_/#1-motivation-central-use-case","title":"1. Motivation &amp; Central Use Case","text":"<p>Use Case: You\u2019re simulating a domain wall in a nanowire and want to include thermal noise so that the wall \u201cwobbles\u201d realistically. Instead of writing your own for\u2011loop with random kicks, you can call <code>noise_model(...)</code> once and get back a time\u2011series of random fluctuations.</p>"},{"location":"autogen/07_noise_generation_models_/#what-youll-do","title":"What You\u2019ll Do","text":"<ol> <li>Generate an ensemble of N tiny \u201cdomains\u201d each with its own random fluctuations.</li> <li>Sum these fluctuations into a single noise time\u2011series.</li> <li>(Optionally) Add pink\u2011noise oscillations or background noise.</li> <li>Analyze the result with an autocorrelation or power spectrum.</li> </ol>"},{"location":"autogen/07_noise_generation_models_/#2-key-concepts","title":"2. Key Concepts","text":"<ol> <li>Ensemble Oscillators    We model N independent fluctuators (small volumes) that randomly kick the magnetization.</li> <li>Thermal Noise    Gaussian white noise with standard deviation <code>thermal_noise_std</code>.</li> <li>Volume Distribution    How to weight each oscillator (e.g. \u201cpareto\u201d for a few big volumes, or \u201cuniform\u201d).</li> <li>Frequency Distribution    Define each oscillator\u2019s natural tick rate\u2014uniformly random or a function of volume.</li> <li>Optional Oscillations    Enable coherent oscillations (pink\u2011noise style) by setting <code>enable_oscillations=True</code>.</li> </ol>"},{"location":"autogen/07_noise_generation_models_/#3-how-to-use-noise_model","title":"3. How to Use <code>noise_model</code>","text":"<p>Here\u2019s a minimal example:</p> <pre><code>from cmtj.models.noise import noise_model\n\n# Generate noise for N=100 volumes over 10\u00a0000 steps\nm_values, volumes, freqs, dt, f_counts = noise_model(\n    N=100,\n    steps=10_000,\n    thermal_noise_std=1e-3,\n    background_thermal_noise_std=0.0,  # no background\n    enable_oscillations=False,\n    volume_distribution=\"pareto\",\n    freq_distribution=\"uniform\",\n    seed=123\n)\n\nprint(\"m_values shape:\", m_values.shape)\nprint(\"dt (s):\", dt)\n</code></pre> <p>Explanation:</p> <ul> <li>Inputs:</li> <li><code>N</code>: number of fluctuators.</li> <li><code>steps</code>: total time\u2011steps.</li> <li><code>thermal_noise_std</code>: strength of the random kicks.</li> <li>Outputs:</li> <li><code>m_values</code>: array of shape <code>(steps, dims)</code>, the summed noise at each time.</li> <li><code>volumes</code>: weight of each oscillator.</li> <li><code>freqs</code>: their assigned frequencies.</li> <li><code>dt</code>: time between steps.</li> <li><code>f_counts</code>: how many times each oscillator \u201cfired.\u201d</li> </ul>"},{"location":"autogen/07_noise_generation_models_/#4-visualizing-the-noise","title":"4. Visualizing the Noise","text":"<p>We can plot autocorrelation, the PSD, and the time series in one go:</p> <pre><code>from cmtj.models.noise import plot_noise_data\n\n# plot_noise_data returns a Matplotlib figure\nfig = plot_noise_data(m_values, volumes, freqs, dt)\nfig.show()\n</code></pre> <ul> <li>Panel a) autocorrelation vs time lag</li> <li>Panel b) volume vs activation count</li> <li>Panel c) power spectral density (log\u2013log)</li> <li>Panel d) raw noise vs time</li> </ul>"},{"location":"autogen/07_noise_generation_models_/#5-under-the-hood-what-happens-when-you-call-noise_model","title":"5. Under the Hood: What Happens When You Call <code>noise_model</code>?","text":"<pre><code>sequenceDiagram\n  participant U as User Code\n  participant F as noise_model()\n  participant RNG as NumPy RNG\n\n  U-&gt;&gt;F: call noise_model(N, steps, \u2026)\n  F-&gt;&gt;RNG: sample volumes (pareto/uniform)\n  F-&gt;&gt;RNG: sample frequencies\n  loop for each time i\n    F-&gt;&gt;RNG: decide which oscillators fire\n    F--&gt;&gt;RNG: generate random kicks\n    F-&gt;&gt;F: update m_values[i]\n  end\n  F--&gt;&gt;U: return m_values, volumes, freqs, dt, f_counts\n</code></pre> <ol> <li>Volume &amp; frequency assignment</li> <li>Time loop deciding random triggers</li> <li>Gaussian noise added when triggered</li> <li>Summation into <code>m_values</code></li> </ol>"},{"location":"autogen/07_noise_generation_models_/#6-a-peek-at-the-implementation","title":"6. A Peek at the Implementation","text":"<p>File: <code>cmtj/models/noise.py</code> Here\u2019s a simplified skeleton:</p> <pre><code>def noise_model(N, steps=1000, thermal_noise_std=1e-3, \u2026):\n    rng = np.random.default_rng()\n    # 1) pick volumes\n    if volume_distribution==\"pareto\":\n        volumes = rng.gamma(shape, scale, size=N)\n    else:\n        volumes = rng.random(N)\n        volumes /= volumes.sum()\n    # 2) pick frequencies\n    if freq_distribution==\"uniform\":\n        freqs = rng.integers(low, high, N)\n    # prepare output\n    m_values = np.zeros((steps, 1))\n    f_counts = np.zeros(N, int)\n\n    # 3) main loop\n    for i in range(steps):\n        # choose which oscillators fire this step\n        mask = (i % freqs)==0\n        if mask.any():\n            # each firing oscillator gets a random kick\n            kicks = rng.normal(0, thermal_noise_std, mask.sum())\n            m_values[i] = np.sum(volumes[mask]*kicks)\n            f_counts[mask] += 1\n        else:\n            m_values[i] = m_values[i-1]\n    return m_values, volumes, freqs, time_scale, f_counts\n</code></pre> <ul> <li>We only keep a 1D noise trace (<code>dims=1</code>) for simplicity.</li> <li>Real code also supports <code>dims=3</code>, background noise, oscillations, and saves individual vectors if asked.</li> </ul>"},{"location":"autogen/07_noise_generation_models_/#7-next-steps-conclusion","title":"7. Next Steps &amp; Conclusion","text":"<p>You\u2019ve learned how to:</p> <ul> <li>Use <code>noise_model</code> to generate realistic thermal or pink\u2011noise fluctuations.</li> <li>Visualize and analyze noise via autocorrelation and spectral plots.</li> <li>Peek under the hood at how volumes and triggers combine into a time\u2011series.</li> </ul> <p>Up next, we\u2019ll clean up these noisy signals with Signal Filters\u2014learning how to focus on the frequencies that matter. Have fun adding realistic \u201cjiggles\u201d to your simulations!</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"autogen/08_signal_filters_/","title":"Chapter 8: Signal Filters","text":"<p>Welcome back! In Chapter\u00a07: Noise Generation Models we added realistic thermal or pink\u2010noise fluctuations to our simulations. Now these time\u2010series can be quite messy. In this chapter, we\u2019ll learn how to clean and focus on the frequencies you care about by using signal filters\u2014much like an audio equalizer weeds out hiss or hum so you only hear the melody.</p>"},{"location":"autogen/08_signal_filters_/#1-motivation-central-use-case","title":"1. Motivation &amp; Central Use Case","text":"<p>Imagine you\u2019ve recorded a voltage signal from your junction and the raw trace looks like this:</p> <ul> <li>A slow drift (baseline)</li> <li>A 50\u00a0Hz pickup from the power line</li> <li>High\u2011frequency thermal jitters</li> </ul> <p>You want to:</p> <ol> <li>Remove the slow drift.</li> <li>Suppress the 50\u00a0Hz hum.</li> <li>Keep the dynamic response between 100\u00a0Hz and 10\u00a0kHz.</li> </ol> <p>With signal filters you can do all three in just a few lines of code.</p>"},{"location":"autogen/08_signal_filters_/#2-key-concepts","title":"2. Key Concepts","text":"<ol> <li>Butterworth Band\u2011Pass Filter</li> <li>A smooth filter that only passes a frequency band you choose (e.g. 100\u00a0Hz\u201310\u00a0kHz).</li> <li>Butterworth Low\u2011Pass Filter</li> <li>Lets through frequencies below a cutoff (e.g. remove everything above 20\u00a0kHz).</li> <li>Detrending</li> <li>Removes slow drifts or offsets by subtracting the median or linear trend.</li> </ol> <p>Think of your raw data as a tangled rope.</p> <ul> <li>Band\u2011pass picks out only the middle section you care about.</li> <li>Low\u2011pass chops off the noisy high\u2011frequency ends.</li> <li>Detrend straightens the rope so its middle is level.</li> </ul>"},{"location":"autogen/08_signal_filters_/#3-how-to-use-filters-a-minimal-example","title":"3. How to Use Filters: A Minimal Example","text":"<p>Below is a simple workflow. Suppose you have:</p> <ul> <li><code>raw_signal</code>: a NumPy array of voltage vs. time</li> <li><code>fs</code>: sampling frequency in Hz (e.g. 50\u00a0000\u00a0Hz)</li> </ul> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom cmtj.utils.filters import Filters\n\n# 1) Create a noisy test signal\nt = np.linspace(0, 1, 50000)  # 1\u00a0s at 50\u00a0kHz\nclean = np.sin(2*np.pi*1000*t)          # 1\u00a0kHz tone\nhum   = 0.5*np.sin(2*np.pi*50  *t)      # 50\u00a0Hz hum\nnoise = 0.2*np.random.randn(len(t))     # white noise\nraw_signal = clean + hum + noise\n\n# 2) Apply a band\u2011pass from 100\u00a0Hz to 10\u00a0kHz\nbp = Filters.butter_bandpass_filter(\n    data=raw_signal,\n    pass_freq=(100, 10000),\n    fs=50000,\n    order=4\n)\n\n# 3) Detrend to remove baseline drift\nfiltered = Filters.detrend_axis(bp, axis=0)\n\n# 4) Plot raw vs filtered\nplt.plot(t, raw_signal, alpha=0.3, label=\"raw\")\nplt.plot(t, filtered,     label=\"filtered\")\nplt.legend()\nplt.show()\n</code></pre> <p>Explanation:</p> <ol> <li>We build a synthetic signal with a 1\u00a0kHz tone, 50\u00a0Hz hum, and random noise.</li> <li><code>butter_bandpass_filter</code> keeps only 100\u00a0Hz\u201310\u00a0kHz.</li> <li><code>detrend_axis</code> subtracts the median so the baseline sits at zero.</li> <li>The final plot shows the clean 1\u00a0kHz oscillation without drift or hum.</li> </ol>"},{"location":"autogen/08_signal_filters_/#4-under-the-hood-what-happens-when-you-call-a-filter","title":"4. Under the Hood: What Happens When You Call a Filter","text":"<p>Here\u2019s a high\u2011level view of <code>butter_bandpass_filter</code>:</p> <pre><code>sequenceDiagram\n  participant U as User Code\n  participant F as Filters.butter_bandpass_filter\n  participant S as scipy.signal.butter\n  participant L as scipy.signal.lfilter\n\n  U-&gt;&gt;F: call butter_bandpass_filter(data, pass_freq, fs, order)\n  F-&gt;&gt;S: design filter coefficients (b, a)\n  F-&gt;&gt;L: apply filter to data\n  L--&gt;&gt;F: return filtered data\n  F--&gt;&gt;U: provide filtered time\u2010series\n</code></pre> <ol> <li>Design: Butterworth analog prototype \u2192 digital coefficients <code>b, a</code>.</li> <li>Apply: <code>lfilter(b, a, data)</code> runs the filter over your array.</li> <li>Return: You get back a cleaned array of the same length.</li> </ol>"},{"location":"autogen/08_signal_filters_/#5-peeking-into-the-implementation","title":"5. Peeking into the Implementation","text":"<p>All of this lives in <code>cmtj/utils/filters.py</code>. Here are the core pieces, simplified:</p> <pre><code># File: cmtj/utils/filters.py\nimport numpy as np\nfrom scipy.signal import butter, lfilter\n\nclass Filters:\n    @staticmethod\n    def butter_bandpass_filter(data, pass_freq, fs, order=5):\n        nyq = 0.5 * fs\n        low, high = pass_freq[0]/nyq, pass_freq[1]/nyq\n        # design band\u2011pass filter\n        b, a = butter(order, [low, high], btype=\"bandpass\")\n        # apply filter\n        return lfilter(b, a, data)\n\n    @staticmethod\n    def butter_lowpass_filter(data, cutoff, fs, order=5):\n        nyq = 0.5 * fs\n        norm_cut = cutoff / nyq\n        b, a = butter(order, norm_cut, btype=\"low\")\n        return lfilter(b, a, data)\n\n    @staticmethod\n    def detrend_axis(arr, axis):\n        med = np.median(arr, axis=axis)\n        # subtract median along the chosen axis\n        return (arr.T - med).T if axis else arr - med\n</code></pre> <ul> <li>We first normalize frequencies by the Nyquist rate (<code>fs/2</code>).</li> <li>We call SciPy\u2019s <code>butter</code> to get filter polynomials.</li> <li>Then <code>lfilter</code> runs the actual smoothing.</li> <li><code>detrend_axis</code> subtracts the median to remove slow drifts.</li> </ul>"},{"location":"autogen/08_signal_filters_/#6-conclusion-next-steps","title":"6. Conclusion &amp; Next Steps","text":"<p>You\u2019ve now learned how to:</p> <ul> <li>Apply Butterworth band\u2011pass and low\u2011pass filters to isolate your frequency band of interest.</li> <li>Detrend your data to remove baseline drifts.</li> <li>Peek under the hood at how these filters are designed and applied in <code>cmtj</code>.</li> </ul> <p>With your signals now clean and focused, the next chapter will introduce Vector Objects\u2014a handy way to manipulate multi\u2011component data like 3D field arrays. Onward to Chapter\u00a09: Vector Objects (CVector\u00a0&amp;\u00a0VectorObj)!</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"autogen/09_vector_objects__cvector___vectorobj__/","title":"Chapter 9: Vector Objects (CVector &amp; VectorObj)","text":"<p>In Chapter\u00a08: Signal Filters we learned how to clean up time\u2011series data. Now we introduce Vector Objects\u2014our universal \u201carrow\u201d type for pointing in 3D space. Whether you\u2019re in Python or C++, you\u2019ll use these to represent magnetic moments, fields, displacements, or any directional quantity.</p>"},{"location":"autogen/09_vector_objects__cvector___vectorobj__/#1-motivation-central-use-case","title":"1. Motivation &amp; Central Use Case","text":"<p>Imagine you want to:</p> <ol> <li>Define a magnetic field that\u2019s 1\u00d710\u2075\u00a0A/m at a 30\u00b0 tilt from the z\u2011axis.</li> <li>Rotate it by 90\u00b0 around z and add another field.</li> <li>Feed that vector into a C++ solver or Python routine seamlessly.</li> </ol> <p>Rather than juggling 3\u2011tuples manually, VectorObj (Python) and CVector (C++) give you a clean API to:</p> <ul> <li>Store in spherical (\u03b8,\u00a0\u03c6,\u00a0magnitude) or Cartesian (x,\u00a0y,\u00a0z).</li> <li>Convert back and forth.</li> <li>Add, scale, normalize with intuitive operators.</li> </ul> <p>By the end of this chapter you\u2019ll be able to build and manipulate these \u201carrows\u201d without worrying about the math under the hood.</p>"},{"location":"autogen/09_vector_objects__cvector___vectorobj__/#2-key-concepts","title":"2. Key Concepts","text":"<ol> <li> <p>Cartesian vs Spherical</p> </li> <li> <p>Cartesian: (x,\u00a0y,\u00a0z) components.</p> </li> <li> <p>Spherical: (\u03b8 polar,\u00a0\u03c6 azimuth,\u00a0r magnitude).</p> </li> <li> <p>CVector (C++ core)</p> </li> <li> <p>High\u2011performance templated class.</p> </li> <li>Use in C++ simulation code.</li> <li> <p>Operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>normalize()</code>, <code>length()</code>, <code>fromSpherical()</code>.</p> </li> <li> <p>VectorObj (Python)</p> </li> <li> <p>Dataclass wrapping spherical coords.</p> </li> <li>Methods: <code>to_cvector()</code>, <code>from_cvector()</code>, <code>get_cartesian()</code>, <code>from_cartesian()</code>.</li> <li> <p>Overloaded <code>+</code>, <code>*</code> for easy math.</p> </li> <li> <p>Seamless Conversion</p> </li> <li>Python <code>VectorObj.to_cvector()</code> \u2192 C++ <code>CVector</code> for passing into the core.</li> <li><code>VectorObj.from_cvector()</code> reads back results.</li> </ol>"},{"location":"autogen/09_vector_objects__cvector___vectorobj__/#3-how-to-use-vector-objects","title":"3. How to Use Vector Objects","text":""},{"location":"autogen/09_vector_objects__cvector___vectorobj__/#31-python-vectorobj","title":"3.1 Python: VectorObj","text":"<pre><code>from cmtj.utils.general import VectorObj\n\n# 1) Create from spherical coords (\u03b8,\u03c6 in radians, r)\nv1 = VectorObj(theta=30*np.pi/180, phi=0, mag=1e5)\n\n# 2) Rotate around z by 90\u00b0 (add another vector)\nv2 = VectorObj(theta=30*np.pi/180, phi=np.pi/2, mag=1e5)\nv_total = v1 + v2\n\n# 3) Normalize and scale\nv_norm = v_total * (1 / v_total.mag)  # unit vector\nv_scaled = v_norm * 5e4\n\n# 4) Convert to CVector to pass to C++ core\ncv = v_scaled.to_cvector()\n# cv is now a CVector(x, y, z)\n</code></pre> <p>Explanation:</p> <ul> <li>We built two 3D vectors in spherical form and added them.</li> <li>We normalized and scaled to get desired magnitude.</li> <li>Finally we turned it into a <code>CVector</code> ready for the solver.</li> </ul>"},{"location":"autogen/09_vector_objects__cvector___vectorobj__/#32-c-cvector","title":"3.2 C++: CVector","text":"<pre><code>#include \"cvector.hpp\"\n\nint main() {\n  // 1) Build from Cartesian\n  CVector&lt;double&gt; a(1.0, 2.0, 3.0);\n\n  // 2) Build from spherical: \u03b8=\u03c0/4, \u03c6=\u03c0/2, r=5\n  auto b = CVector&lt;double&gt;::fromSpherical(M_PI/4, M_PI/2, 5.0);\n\n  // 3) Add and normalize\n  CVector&lt;double&gt; c = a + b;\n  c.normalize();\n\n  // 4) Scale by 2\n  CVector&lt;double&gt; d = c * 2.0;\n\n  std::cout &lt;&lt; \"Result: \" &lt;&lt; d &lt;&lt; std::endl;\n}\n</code></pre> <p>Explanation:</p> <ul> <li><code>fromSpherical</code> sets <code>x = r\u00a0sin\u00a0\u03b8\u00a0cos\u00a0\u03c6</code>, etc.</li> <li><code>operator+</code> and <code>operator*</code> make vector math concise.</li> <li><code>normalize()</code> rescales to unit length.</li> </ul>"},{"location":"autogen/09_vector_objects__cvector___vectorobj__/#4-under-the-hood","title":"4. Under the Hood","text":"<p>When you call <code>VectorObj.to_cvector()</code> or <code>CVector::fromSpherical</code>, here\u2019s the flow:</p> <pre><code>sequenceDiagram\n  participant U as User Code\n  participant VO as VectorObj\n  participant CV as CVector\n  participant Core as C++ Core\n\n  U-&gt;&gt;VO: create or add vectors\n  VO-&gt;&gt;CV: to_cvector()\n  CV-&gt;&gt;Core: solver.setField(CVector)\n  Core--&gt;&gt;CV: returns CVector result\n  CV-&gt;&gt;VO: VectorObj.from_cvector()\n  VO--&gt;&gt;U: new spherical/vector data\n</code></pre> <ol> <li>User Code builds or combines Python <code>VectorObj</code>.</li> <li><code>to_cvector()</code> converts spherical \u2192 Cartesian inside Python.</li> <li>The C++ Core receives <code>CVector</code> and runs high\u2011speed routines.</li> <li>Results come back as <code>CVector</code>, and <code>from_cvector()</code> wraps them into Python <code>VectorObj</code> again.</li> </ol>"},{"location":"autogen/09_vector_objects__cvector___vectorobj__/#5-peek-at-the-implementation","title":"5. Peek at the Implementation","text":""},{"location":"autogen/09_vector_objects__cvector___vectorobj__/#51-vectorobj-conversions-simplified","title":"5.1 VectorObj conversions (simplified)","text":"<pre><code># File: cmtj/utils/general.py\n@dataclass\nclass VectorObj:\n    theta: float; phi: float; mag: float = 1\n\n    def get_cartesian(self):\n        return [\n          self.mag * math.sin(self.theta) * math.cos(self.phi),\n          self.mag * math.sin(self.theta) * math.sin(self.phi),\n          self.mag * math.cos(self.theta),\n        ]\n\n    def to_cvector(self):\n        x,y,z = self.get_cartesian()\n        return CVector(x, y, z)\n\n    @staticmethod\n    def from_cvector(cv):\n        r = cv.length()\n        if r == 0: return VectorObj(0, 0, 0)\n        theta = math.acos(cv.z / r)\n        phi   = math.atan2(cv.y, cv.x)\n        return VectorObj(theta, phi, r)\n</code></pre> <p>Explanation:</p> <ul> <li><code>get_cartesian()</code> does the math.</li> <li><code>to_cvector()</code> wraps it into the C++ class.</li> <li><code>from_cvector()</code> reads back length and angles.</li> </ul>"},{"location":"autogen/09_vector_objects__cvector___vectorobj__/#52-cvector-spherical-factory-simplified","title":"5.2 CVector spherical factory (simplified)","text":"<pre><code>// File: core/cvector.hpp\nstatic CVector&lt;T&gt; fromSpherical(T \u03b8, T \u03c6, T r=1) {\n  return CVector&lt;T&gt;(\n    r * sin(\u03b8) * cos(\u03c6),\n    r * sin(\u03b8) * sin(\u03c6),\n    r * cos(\u03b8)\n  );\n}\n</code></pre> <p>Explanation:</p> <ul> <li>Identical spherical\u2192Cartesian formula in the C++ core.</li> <li>Since both sides use the same math, conversions are lossless.</li> </ul>"},{"location":"autogen/09_vector_objects__cvector___vectorobj__/#conclusion-next-steps","title":"Conclusion &amp; Next Steps","text":"<p>You\u2019ve learned how to represent and manipulate 3D vectors in both Python and C++:</p> <ul> <li>Python\u2019s VectorObj: easy spherical storage + Pythonic operators.</li> <li>C++\u2019s CVector: high\u2011performance core class with the same API.</li> <li>Seamless to_cvector and from_cvector conversions.</li> </ul> <p>Next, we\u2019ll see how to tie all these pieces into a full micromagnetic calculation with the SB Solver.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"autogen/10_sb_solver__solver__/","title":"Chapter 10: SB Solver (Solver)","text":"<p>Welcome back! In Chapter\u00a09: Vector Objects (CVector\u00a0&amp;\u00a0VectorObj) we learned how to represent 3D vectors cleanly. Now we\u2019ll bring everything together to find the natural oscillations of one or more magnetic layers under an applied field. Meet the SB Solver, your \u201cresonance detective\u201d \u2013 it builds the energy, finds equilibrium, then shakes the system to extract FMR frequencies.</p>"},{"location":"autogen/10_sb_solver__solver__/#1-motivation-central-use-case","title":"1. Motivation &amp; Central Use Case","text":"<p>Imagine you have a stack of thin magnetic films (layers), each with its own anisotropy and saturation. You want to:</p> <ol> <li>Sweep an external field H from 0 to 1\u00d710\u2075\u00a0A/m.</li> <li>For each H, find the equilibrium magnetization angles (\u03b8,\u00a0\u03c6).</li> <li>Compute the ferromagnetic\u2011resonance (FMR) frequencies.</li> </ol> <p>Instead of deriving Hessians yourself, the Solver automates:</p> <ul> <li>Constructing the total energy (Zeeman, anisotropy, IEC\u2026).</li> <li>Finding the minimum via Adam or AMSGrad gradient descent.</li> <li>Building the Hessian (or LLG Jacobian) at equilibrium.</li> <li>Solving for resonance frequencies (analytically for 1 layer, numerically for many).</li> </ul> <p>By the end, you\u2019ll know how to call one simple routine to get equilibrium and FMR vs field.</p>"},{"location":"autogen/10_sb_solver__solver__/#2-key-concepts","title":"2. Key Concepts","text":"<ol> <li> <p>Layers</p> </li> <li> <p>LayerSB: static Smit\u2013Beljers model (no damping).</p> </li> <li> <p>LayerDynamic: adds damping &amp; spin\u2011torques (uses LLG Jacobian).</p> </li> <li> <p>Solver</p> </li> <li> <p>Takes a list of layers, interlayer couplings J1, J2, optional DMI and dipoles.</p> </li> <li><code>set_H(VectorObj)</code>: sets the external field.</li> <li> <p><code>solve(init_position)</code>: returns equilibrium angles and FMR frequencies (and modes if dynamic).</p> </li> <li> <p>Gradient Descent</p> </li> <li> <p>Uses Adam (or AMSGrad) to minimize the symbolic energy and find (\u03b8_eq,\u00a0\u03c6_eq).</p> </li> <li> <p>Resonance Extraction</p> </li> <li>LayerSB: builds the Hessian of the energy and finds its \u03c9\u2011roots.</li> <li>LayerDynamic: builds the LLG Jacobian and finds eigenvalues \u2192 im(\u03c9).</li> </ol>"},{"location":"autogen/10_sb_solver__solver__/#3-solving-the-use-case-example-code","title":"3. Solving the Use Case: Example Code","text":"<p>Below is the minimal code to scan a single layer\u2019s FMR vs H_z:</p> <pre><code>from cmtj.models.general_sb import LayerSB, Solver\nfrom cmtj.utils.general import VectorObj\nimport numpy as np\n\n# 1) Define a layer\nlayer = LayerSB(\n    _id=0,\n    thickness=1e-9,\n    Kv=VectorObj(theta=0, phi=0, mag=1e4),\n    Ks=0,\n    Ms=8e5\n)\n\n# 2) Make a solver with no coupling (single layer)\nsolver = Solver(layers=[layer], J1=[], J2=[])\n\n# 3) Field scan: H_z from 0 \u2192 1e5\u00a0A/m in 5 steps\nHz = np.linspace(0, 1e5, 5)\nfor h in Hz:\n    solver.set_H(VectorObj(theta=0, phi=0, mag=h))\n    eq_pos, freqs = solver.solve(init_position=[0, 0])\n    print(f\"H={h:.1e}\u00a0A/m \u2192 FMR (GHz) = {freqs}\")\n</code></pre> <p>Explanation:</p> <ul> <li>We made one LayerSB with easy anisotropy.</li> <li>Wrapped it in a Solver (lists J1, J2 must each have length\u00a00).</li> <li>For each field, <code>solve</code> returns <code>[\u03b8_eq,\u00a0\u03c6_eq]</code> and a list of frequencies in GHz.</li> </ul>"},{"location":"autogen/10_sb_solver__solver__/#4-under-the-hood-stepbystep","title":"4. Under the Hood: Step\u2011by\u2011Step","text":"<p>Here\u2019s a simplified sequence when you call <code>solver.solve(...)</code>:</p> <pre><code>sequenceDiagram\n  participant U as User Code\n  participant S as Solver.solve\n  participant G as AdamDescent\n  participant H as HessianBuilder\n  participant R as RootFinder\n\n  U-&gt;&gt;S: solve(init_position)\n  S-&gt;&gt;G: minimize energy \u2192 eq_pos\n  S-&gt;&gt;H: build Hessian at eq_pos\n  S-&gt;&gt;R: find \u03c9\u2010roots of Hessian det\n  S--&gt;&gt;U: return eq_pos, frequencies\n</code></pre> <ol> <li>Energy: symbolic expression from each layer and couplings.</li> <li>Gradient descent finds the minimum spin angles.</li> <li>Hessian: second derivatives of energy at equilibrium.</li> <li>Root\u2010finding extracts FMR modes.</li> </ol>"},{"location":"autogen/10_sb_solver__solver__/#5-a-peek-into-the-implementation","title":"5. A Peek into the Implementation","text":"<p>File: <code>cmtj/models/general_sb.py</code></p> <p>Below is a toy version of <code>solve()</code> and numerical\u2010solve:</p> <pre><code>def solve(self, init_position):\n    # 1) find minimum\n    eq = self.adam_gradient_descent(init_position, max_steps=1e5)\n    # 2) single\u2010layer analytic?\n    if len(self.layers) == 1:\n        f = self.single_layer_resonance(0, eq) / 1e9\n        return eq, [f]\n    # 3) multi\u2010layer numeric\n    return self.num_solve(eq)\n\ndef num_solve(self, eq):\n    # build determinant of Hessian at eq\n    det_fn = lambdify(omega, self.create_energy_hessian(eq))\n    roots = RootFinder(0, max_freq, step=ftol).find(det_fn)\n    # convert to GHz\n    return np.unique(np.round(roots/1e9,2))\n</code></pre> <ul> <li><code>adam_gradient_descent</code> returns the 1D array of angles.</li> <li><code>create_energy_hessian</code> builds a symbolic Hessian and substitutes <code>eq</code>.</li> <li>We find the \u03c9 where <code>det(H)=0</code>.</li> </ul>"},{"location":"autogen/10_sb_solver__solver__/#6-conclusion","title":"6. Conclusion","text":"<p>You\u2019ve learned how to use the SB Solver in <code>cmtj</code> to:</p> <ul> <li>Define one or more magnetic layers with LayerSB or LayerDynamic.</li> <li>Set up interlayer couplings J1, J2.</li> <li>Sweep an external field H and call <code>solver.solve</code> to get equilibrium and FMR frequencies.</li> </ul> <p>This closes our core tutorial. Happy resonating!</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"experimental-methods/CIMS/","title":"CIMS Tutorial","text":"In\u00a0[1]: Copied! <pre>import multiprocess as mp\nfrom functools import partial\nfrom cmtj import *\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom cmtj.utils import OetoAm, calculate_resistance_parallel\nfrom cmtj.utils.linear import FieldScan\nfrom tqdm import tqdm\n\n\ndef compute_hyst_params(hysteresis, x_axis):\n    # sort according to X first\n    sorted_hyst = [\n        x for _, x in sorted(zip(x_axis, hysteresis), key=lambda pair: pair[0])\n    ]\n    Rval = np.asarray(sorted_hyst)\n    Jscan = np.asarray(x_axis)\n    # take only the ones on the right hand side\n    Rval = Rval[Jscan &gt;= 0]\n    Jpos = Jscan[Jscan &gt;= 0]\n    diff = np.diff(Rval, n=1)\n    low_indx, high_indx = 0, 0\n    eps = 0.01\n    for i, d in enumerate(diff):\n        if np.abs(d) &gt; eps:\n            low_indx = i\n            high_indx = i + 1\n            break\n\n    slew = np.abs(Jpos[high_indx] - Jpos[low_indx])\n    width = (Jpos[high_indx] + Jpos[low_indx]) / 2\n    return slew, width, Jpos[low_indx]\n\n\ndef critical_current_detection(hysteresis, j_scan):\n    \"\"\"\n    This has to be one way hysteresis\n    \"\"\"\n    assert len(np.unique(j_scan)) == len(j_scan)\n    j_scan = np.asarray(j_scan)\n    x = np.abs(np.diff(hysteresis))\n    transition_threshold = (np.max(hysteresis) - np.min(hysteresis)) / 2\n    y = np.argwhere(x &gt;= transition_threshold).ravel()\n    if len(y) &gt; 2:\n        print(\"Warning: more than 2 transitions detected\")\n        return 0\n    if len(y) &gt; 1:\n        return np.min(j_scan[y])\n    elif len(y) == 1:\n        return j_scan[y][0]\n    return -1e12\n</pre> import multiprocess as mp from functools import partial from cmtj import * import numpy as np import pandas as pd import matplotlib.pyplot as plt from cmtj.utils import OetoAm, calculate_resistance_parallel from cmtj.utils.linear import FieldScan from tqdm import tqdm   def compute_hyst_params(hysteresis, x_axis):     # sort according to X first     sorted_hyst = [         x for _, x in sorted(zip(x_axis, hysteresis), key=lambda pair: pair[0])     ]     Rval = np.asarray(sorted_hyst)     Jscan = np.asarray(x_axis)     # take only the ones on the right hand side     Rval = Rval[Jscan &gt;= 0]     Jpos = Jscan[Jscan &gt;= 0]     diff = np.diff(Rval, n=1)     low_indx, high_indx = 0, 0     eps = 0.01     for i, d in enumerate(diff):         if np.abs(d) &gt; eps:             low_indx = i             high_indx = i + 1             break      slew = np.abs(Jpos[high_indx] - Jpos[low_indx])     width = (Jpos[high_indx] + Jpos[low_indx]) / 2     return slew, width, Jpos[low_indx]   def critical_current_detection(hysteresis, j_scan):     \"\"\"     This has to be one way hysteresis     \"\"\"     assert len(np.unique(j_scan)) == len(j_scan)     j_scan = np.asarray(j_scan)     x = np.abs(np.diff(hysteresis))     transition_threshold = (np.max(hysteresis) - np.min(hysteresis)) / 2     y = np.argwhere(x &gt;= transition_threshold).ravel()     if len(y) &gt; 2:         print(\"Warning: more than 2 transitions detected\")         return 0     if len(y) &gt; 1:         return np.min(j_scan[y])     elif len(y) == 1:         return j_scan[y][0]     return -1e12 In\u00a0[2]: Copied! <pre>def compute_cims_trilayer(\n    field: float, J: float, j_scan: np.ndarray, Ms: float, Ku: float, Kudir_theta: float\n):\n    #  define some device parameters\n    t_fm = 1e-9\n    w = 10e-6\n    l = 80e-6\n    area = w * l\n    demagTensor = [\n        CVector(0.0, 0.0, 0.0),\n        CVector(0.0, 0.0, 0.0),\n        CVector(0.0, 0.0, 1.0),\n    ]\n    alpha = 0.05\n    # torque parameters\n    # The Hdl/Hfl  is in units A/m per (A/m^2) = 1/m\n    jden = 4.24e10\n    HDL = 5.86e1 * OetoAm / jden\n    HFL = 1.25e2 * OetoAm / jden\n    Kdir = FieldScan.angle2vector(Kudir_theta, 0)\n    layer_free = Layer.createSOTLayer(\n        id=\"free\",\n        mag=CVector(0.0, 0.0, 1.0),\n        anis=CVector(0.0, 0.0, 1),\n        Ms=Ms,\n        thickness=t_fm,\n        cellSurface=area,\n        demagTensor=demagTensor,\n        damping=alpha,\n        dampingLikeTorque=HDL,\n        fieldLikeTorque=HFL,\n    )\n\n    layer_bottom = Layer.createSOTLayer(\n        id=\"bottom\",\n        mag=Kdir,\n        anis=Kdir,\n        Ms=Ms,\n        thickness=t_fm,\n        cellSurface=area,\n        demagTensor=demagTensor,\n        damping=alpha,\n        dampingLikeTorque=HDL * 0.4,  # add some asymmetry (just to make it interesting)\n        fieldLikeTorque=HFL * 0.4,\n    )\n\n    j = Junction([layer_free, layer_bottom])\n    j.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(0.455e6))\n    j.setLayerAnisotropyDriver(\"bottom\", ScalarDriver.getConstantDriver(Ku))\n    j.setLayerReferenceLayer(\"free\", CVector(0.0, 1, 0))\n    j.setLayerReferenceLayer(\"bottom\", CVector(0.0, 1, 0))\n    j.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J))\n    j.setLayerExternalFieldDriver(\n        \"all\",\n        AxialDriver(\n            ScalarDriver.getConstantDriver(field),\n            ScalarDriver.getConstantDriver(0),\n            ScalarDriver.getConstantDriver(0),\n        ),\n    )\n\n    tstep = 1e-12\n    hysteresis = []\n    j.setLayerMagnetisation(\"bottom\", CVector(0, 0, -1))\n    n_lay = 2\n    for current in j_scan:\n        j.clearLog()\n        j.setLayerCurrentDriver(\n            \"all\", ScalarDriver.getStepDriver(0, current, -1e-9, 1e-9)\n        )\n        j.runSimulation(8e-9, tstep, tstep)\n\n        log = j.getLog()\n        m = np.asarray(\n            [\n                [log[f\"{str_}_mx\"], log[f\"{str_}_my\"], log[f\"{str_}_mz\"]]\n                for str_ in (\"free\", \"bottom\")\n            ]\n        )\n        # some resistance parameters\n        Rx0 = [100] * n_lay\n        Ry0 = [9] * n_lay\n        SMR = [5.11] * n_lay\n        AMR = [0.41] * n_lay\n        AHE = [5.5] * n_lay\n\n        _, Rxy = calculate_resistance_parallel(\n            Rx0, Ry0, AMR=AMR, AHE=AHE, SMR=SMR, m=m, l=[l] * n_lay, w=[w] * n_lay\n        )\n        Rstable = Rxy[-100:].mean()\n        hysteresis.append(Rstable)\n    end_mag_top = j.getLayerMagnetisation(\"free\")\n    end_mag_bottom = j.getLayerMagnetisation(\"bottom\")\n    hysteresis = np.asarray(hysteresis)\n    Icrit = critical_current_detection(hysteresis, j_scan=j_scan)\n\n    return (\n        hysteresis,\n        Icrit,\n        [end_mag_top.x, end_mag_top.y, end_mag_top.z],\n        [end_mag_bottom.x, end_mag_bottom.y, end_mag_bottom.z],\n        field,\n        J,\n        Ku,\n        Kudir_theta,\n    )\n</pre> def compute_cims_trilayer(     field: float, J: float, j_scan: np.ndarray, Ms: float, Ku: float, Kudir_theta: float ):     #  define some device parameters     t_fm = 1e-9     w = 10e-6     l = 80e-6     area = w * l     demagTensor = [         CVector(0.0, 0.0, 0.0),         CVector(0.0, 0.0, 0.0),         CVector(0.0, 0.0, 1.0),     ]     alpha = 0.05     # torque parameters     # The Hdl/Hfl  is in units A/m per (A/m^2) = 1/m     jden = 4.24e10     HDL = 5.86e1 * OetoAm / jden     HFL = 1.25e2 * OetoAm / jden     Kdir = FieldScan.angle2vector(Kudir_theta, 0)     layer_free = Layer.createSOTLayer(         id=\"free\",         mag=CVector(0.0, 0.0, 1.0),         anis=CVector(0.0, 0.0, 1),         Ms=Ms,         thickness=t_fm,         cellSurface=area,         demagTensor=demagTensor,         damping=alpha,         dampingLikeTorque=HDL,         fieldLikeTorque=HFL,     )      layer_bottom = Layer.createSOTLayer(         id=\"bottom\",         mag=Kdir,         anis=Kdir,         Ms=Ms,         thickness=t_fm,         cellSurface=area,         demagTensor=demagTensor,         damping=alpha,         dampingLikeTorque=HDL * 0.4,  # add some asymmetry (just to make it interesting)         fieldLikeTorque=HFL * 0.4,     )      j = Junction([layer_free, layer_bottom])     j.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(0.455e6))     j.setLayerAnisotropyDriver(\"bottom\", ScalarDriver.getConstantDriver(Ku))     j.setLayerReferenceLayer(\"free\", CVector(0.0, 1, 0))     j.setLayerReferenceLayer(\"bottom\", CVector(0.0, 1, 0))     j.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J))     j.setLayerExternalFieldDriver(         \"all\",         AxialDriver(             ScalarDriver.getConstantDriver(field),             ScalarDriver.getConstantDriver(0),             ScalarDriver.getConstantDriver(0),         ),     )      tstep = 1e-12     hysteresis = []     j.setLayerMagnetisation(\"bottom\", CVector(0, 0, -1))     n_lay = 2     for current in j_scan:         j.clearLog()         j.setLayerCurrentDriver(             \"all\", ScalarDriver.getStepDriver(0, current, -1e-9, 1e-9)         )         j.runSimulation(8e-9, tstep, tstep)          log = j.getLog()         m = np.asarray(             [                 [log[f\"{str_}_mx\"], log[f\"{str_}_my\"], log[f\"{str_}_mz\"]]                 for str_ in (\"free\", \"bottom\")             ]         )         # some resistance parameters         Rx0 = [100] * n_lay         Ry0 = [9] * n_lay         SMR = [5.11] * n_lay         AMR = [0.41] * n_lay         AHE = [5.5] * n_lay          _, Rxy = calculate_resistance_parallel(             Rx0, Ry0, AMR=AMR, AHE=AHE, SMR=SMR, m=m, l=[l] * n_lay, w=[w] * n_lay         )         Rstable = Rxy[-100:].mean()         hysteresis.append(Rstable)     end_mag_top = j.getLayerMagnetisation(\"free\")     end_mag_bottom = j.getLayerMagnetisation(\"bottom\")     hysteresis = np.asarray(hysteresis)     Icrit = critical_current_detection(hysteresis, j_scan=j_scan)      return (         hysteresis,         Icrit,         [end_mag_top.x, end_mag_top.y, end_mag_top.z],         [end_mag_bottom.x, end_mag_bottom.y, end_mag_bottom.z],         field,         J,         Ku,         Kudir_theta,     ) In\u00a0[3]: Copied! <pre>I = 9.5e12\nKu = 0.237e6\nn = 60\ninum = 35\nHspace_k = np.linspace(0, 400e3, n + 1).tolist()[1:][::-1]\nIspace = np.linspace(0, I, num=inum)\nKuspace = np.linspace(0, 180, n).tolist()\nK_res_map = np.zeros((len(Kuspace), len(Hspace_k)), dtype=np.float32)\ncomponents_top = np.zeros((len(Kuspace), len(Hspace_k), 3), dtype=np.float32)\ncomponents_bottom = np.zeros((len(Kuspace), len(Hspace_k), 3), dtype=np.float32)\nhysts2 = np.zeros((len(Kuspace), len(Hspace_k), len(Ispace)), dtype=np.float32)\nend_mag = CVector(0, 0, 1)\nJ = 4.784e-3\nwith mp.Pool(8) as pool:\n    for Ku_ in tqdm(Kuspace):\n        for result in pool.imap_unordered(\n            partial(\n                compute_cims_trilayer,\n                j_scan=Ispace,  # min starting point\n                Ms=1.13,\n                J=J,\n                Ku=Ku,\n                Kudir_theta=Ku_,\n            ),\n            Hspace_k,\n        ):\n            (\n                hists,\n                Icrit,\n                end_mag_components_top,\n                end_mag_components_bottom,\n                f,\n                j,\n                k,\n                d,\n            ) = result\n            K_res_map[Kuspace.index(d), Hspace_k.index(f)] = Icrit\n            components_top[Kuspace.index(d), Hspace_k.index(f)] = end_mag_components_top\n            components_bottom[Kuspace.index(d), Hspace_k.index(f)] = (\n                end_mag_components_bottom\n            )\n            hysts2[Kuspace.index(d), Hspace_k.index(f)] = hists\n</pre> I = 9.5e12 Ku = 0.237e6 n = 60 inum = 35 Hspace_k = np.linspace(0, 400e3, n + 1).tolist()[1:][::-1] Ispace = np.linspace(0, I, num=inum) Kuspace = np.linspace(0, 180, n).tolist() K_res_map = np.zeros((len(Kuspace), len(Hspace_k)), dtype=np.float32) components_top = np.zeros((len(Kuspace), len(Hspace_k), 3), dtype=np.float32) components_bottom = np.zeros((len(Kuspace), len(Hspace_k), 3), dtype=np.float32) hysts2 = np.zeros((len(Kuspace), len(Hspace_k), len(Ispace)), dtype=np.float32) end_mag = CVector(0, 0, 1) J = 4.784e-3 with mp.Pool(8) as pool:     for Ku_ in tqdm(Kuspace):         for result in pool.imap_unordered(             partial(                 compute_cims_trilayer,                 j_scan=Ispace,  # min starting point                 Ms=1.13,                 J=J,                 Ku=Ku,                 Kudir_theta=Ku_,             ),             Hspace_k,         ):             (                 hists,                 Icrit,                 end_mag_components_top,                 end_mag_components_bottom,                 f,                 j,                 k,                 d,             ) = result             K_res_map[Kuspace.index(d), Hspace_k.index(f)] = Icrit             components_top[Kuspace.index(d), Hspace_k.index(f)] = end_mag_components_top             components_bottom[Kuspace.index(d), Hspace_k.index(f)] = (                 end_mag_components_bottom             )             hysts2[Kuspace.index(d), Hspace_k.index(f)] = hists <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 60/60 [03:25&lt;00:00,  3.42s/it]\n</pre> In\u00a0[4]: Copied! <pre>I = 30e12\nKu = 0.455e6\nn = 50\ninum = 35\nHspace_j = np.linspace(0, 400e3, n + 1).tolist()[1:]\nIspace = np.linspace(0e12, 8.1e12, num=inum)\n\nJspace = np.linspace(3.5e-3, 7e-3, n).tolist()\nJ_res_map = np.zeros((len(Jspace), len(Hspace_j)), dtype=np.float32)\ncomponents_top = np.zeros((len(Jspace), len(Hspace_j), 3), dtype=np.float32)\ncomponents_bottom = np.zeros((len(Jspace), len(Hspace_j), 3), dtype=np.float32)\nhysts = np.zeros((len(Jspace), len(Hspace_j), len(Ispace)), dtype=np.float32)\nwith mp.Pool(32) as pool:\n    for J in tqdm(Jspace):\n        for result in pool.imap_unordered(\n            partial(\n                compute_cims_trilayer,\n                j_scan=Ispace,  # min starting point\n                Ms=1.13,\n                J=J,\n                Ku=Ku,\n                Kudir_theta=60,\n            ),\n            Hspace_j,\n        ):\n            (\n                hists,\n                Icrit,\n                end_mag_components_top,\n                end_mag_components_bottom,\n                f,\n                j,\n                k,\n                d,\n            ) = result\n            J_res_map[Jspace.index(j), Hspace_j.index(f)] = Icrit\n            components_top[Jspace.index(j), Hspace_j.index(f)] = end_mag_components_top\n            components_bottom[Jspace.index(j), Hspace_j.index(f)] = (\n                end_mag_components_bottom\n            )\n            hysts[Jspace.index(j), Hspace_j.index(f)] = hists\n</pre> I = 30e12 Ku = 0.455e6 n = 50 inum = 35 Hspace_j = np.linspace(0, 400e3, n + 1).tolist()[1:] Ispace = np.linspace(0e12, 8.1e12, num=inum)  Jspace = np.linspace(3.5e-3, 7e-3, n).tolist() J_res_map = np.zeros((len(Jspace), len(Hspace_j)), dtype=np.float32) components_top = np.zeros((len(Jspace), len(Hspace_j), 3), dtype=np.float32) components_bottom = np.zeros((len(Jspace), len(Hspace_j), 3), dtype=np.float32) hysts = np.zeros((len(Jspace), len(Hspace_j), len(Ispace)), dtype=np.float32) with mp.Pool(32) as pool:     for J in tqdm(Jspace):         for result in pool.imap_unordered(             partial(                 compute_cims_trilayer,                 j_scan=Ispace,  # min starting point                 Ms=1.13,                 J=J,                 Ku=Ku,                 Kudir_theta=60,             ),             Hspace_j,         ):             (                 hists,                 Icrit,                 end_mag_components_top,                 end_mag_components_bottom,                 f,                 j,                 k,                 d,             ) = result             J_res_map[Jspace.index(j), Hspace_j.index(f)] = Icrit             components_top[Jspace.index(j), Hspace_j.index(f)] = end_mag_components_top             components_bottom[Jspace.index(j), Hspace_j.index(f)] = (                 end_mag_components_bottom             )             hysts[Jspace.index(j), Hspace_j.index(f)] = hists <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 50/50 [02:14&lt;00:00,  2.69s/it]\n</pre> In\u00a0[5]: Copied! <pre>def colorbar(mappable, cbar_title):\n    from mpl_toolkits.axes_grid1 import make_axes_locatable\n    import matplotlib.pyplot as plt\n    last_axes = plt.gca()\n    ax = mappable.axes\n    fig = ax.figure\n    divider = make_axes_locatable(ax)\n    cax = divider.append_axes(\"top\", size=\"5%\", pad=0.2)\n    cbar = fig.colorbar(mappable, cax=cax, orientation='horizontal')\n    if cbar_title:\n        cbar.ax.get_yaxis().labelpad = 25\n        cbar.ax.set_ylabel(cbar_title, rotation=0)\n    plt.sca(last_axes)\n    return cbar\n\n\nwith plt.style.context(['science', 'nature']):\n    fig, (ax1, ax2) = plt.subplots(1,\n                                   2,\n                                   sharey='row',\n                                   figsize=(6.5, 3),\n                                   dpi=400)\n    im1 = ax1.pcolor(\n        np.asarray(Kuspace),  # /1e6,\n        np.asarray(Hspace_k) / 1e3,\n        K_res_map.T / 1e12,\n        cmap='magma',\n        shading='auto')\n    ax1.set_xlabel(r\"$\\theta_\\mathrm{K}$ ($^\\circ$)\")\n    ax1.set_ylabel(r\"H $(\\mathrm{kA/m})$\")\n    \n    im2 = ax2.pcolor(np.asarray(Jspace) * 1e3,\n                     np.asarray(Hspace_j) / 1e3,\n                     J_res_map.T / 1e12,\n                     shading='auto',\n                     cmap='magma')\n    ax2.set_xlabel(r\"$J_\\mathrm{IEC}$ ($\\mathrm{mJ/m^2}$)\")\n    colorbar(im1, r'$\\mathrm{J}_\\mathrm{crit}$ ($\\mathrm{TA/m^2}$)')\n    colorbar(im2, '')\n    import matplotlib.transforms as mtransforms\n    for label, ax in zip(['a)', 'b)'], (ax1, ax2)):\n        # label physical distance in and down:\n        trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,\n                                              fig.dpi_scale_trans)\n        ax.text(0.0,\n                1.0,\n                label,\n                transform=ax.transAxes + trans,\n                fontsize='medium',\n                verticalalignment='top',\n                color='lavender',\n                bbox=dict(facecolor='none', alpha=0.4, edgecolor='none', pad=3.0))\n\n    fig.subplots_adjust(wspace=0.01)\n</pre> def colorbar(mappable, cbar_title):     from mpl_toolkits.axes_grid1 import make_axes_locatable     import matplotlib.pyplot as plt     last_axes = plt.gca()     ax = mappable.axes     fig = ax.figure     divider = make_axes_locatable(ax)     cax = divider.append_axes(\"top\", size=\"5%\", pad=0.2)     cbar = fig.colorbar(mappable, cax=cax, orientation='horizontal')     if cbar_title:         cbar.ax.get_yaxis().labelpad = 25         cbar.ax.set_ylabel(cbar_title, rotation=0)     plt.sca(last_axes)     return cbar   with plt.style.context(['science', 'nature']):     fig, (ax1, ax2) = plt.subplots(1,                                    2,                                    sharey='row',                                    figsize=(6.5, 3),                                    dpi=400)     im1 = ax1.pcolor(         np.asarray(Kuspace),  # /1e6,         np.asarray(Hspace_k) / 1e3,         K_res_map.T / 1e12,         cmap='magma',         shading='auto')     ax1.set_xlabel(r\"$\\theta_\\mathrm{K}$ ($^\\circ$)\")     ax1.set_ylabel(r\"H $(\\mathrm{kA/m})$\")          im2 = ax2.pcolor(np.asarray(Jspace) * 1e3,                      np.asarray(Hspace_j) / 1e3,                      J_res_map.T / 1e12,                      shading='auto',                      cmap='magma')     ax2.set_xlabel(r\"$J_\\mathrm{IEC}$ ($\\mathrm{mJ/m^2}$)\")     colorbar(im1, r'$\\mathrm{J}_\\mathrm{crit}$ ($\\mathrm{TA/m^2}$)')     colorbar(im2, '')     import matplotlib.transforms as mtransforms     for label, ax in zip(['a)', 'b)'], (ax1, ax2)):         # label physical distance in and down:         trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,                                               fig.dpi_scale_trans)         ax.text(0.0,                 1.0,                 label,                 transform=ax.transAxes + trans,                 fontsize='medium',                 verticalalignment='top',                 color='lavender',                 bbox=dict(facecolor='none', alpha=0.4, edgecolor='none', pad=3.0))      fig.subplots_adjust(wspace=0.01)  <p>The graph we produced has a very pretty shape and is clearly non-linear in both of cases. One can argue that there is a diagonal dependence $j(H, J)$ as both H and J increase proportionally. <code>b)</code> also shows $~\\exp(-x)$ contour lines separating the regions of the same or nearly similar resistance. This is a very interesting result as it shows that the resistance is not a simple function of the current density and the applied field.</p> In\u00a0[6]: Copied! <pre>def compute_cims(j_scan: np.ndarray,\n                 field: float,\n                 Ms: float,\n                 Ku: float,\n                 start_mag: CVector = None,\n                 mode: str = 'gaussian'):\n\n    rho_f = 27e-8\n    rho_h = 21e-8\n    t_fm = 1e-9\n    t_hm = 4e-9\n    w = 10e-6\n    l = 75e-6\n    area = w * l\n    FM_R = rho_f * t_fm / area\n    HM_R = rho_h * l / (w * t_hm)\n    # parallel, current in plane\n    T_R = 1. / FM_R + 1. / HM_R\n    T_R = 1. / T_R\n\n    demagTensor = [\n        CVector(0., 0., 0.),\n        CVector(0., 0., 0.),\n        CVector(0., 0., 1.)\n    ]\n    alpha = 0.03\n\n    jden = 6.94e10\n    HDL = 25.92 * OetoAm / jden\n    HFL = 18 * OetoAm / jden\n    layer = Layer.createSOTLayer(id=\"free\",\n                                 mag=CVector(0.1, 0.1, 0.9),\n                                 anis=CVector(0, 0, 1),\n                                 Ms=Ms,\n                                 thickness=t_fm,\n                                 cellSurface=area,\n                                 demagTensor=demagTensor,\n                                 damping=alpha,\n                                 dampingLikeTorque=HDL,\n                                 fieldLikeTorque=HFL)\n\n    layer.setReferenceLayer(CVector(0, 1, 0))\n    j = Junction([layer])\n    j.setLayerAnisotropyDriver(\"all\", ScalarDriver.getConstantDriver(Ku))\n    j.setLayerReferenceLayer(\"free\", CVector(0, 1, 0))\n    j.setLayerExternalFieldDriver(\n        \"free\",\n        AxialDriver(ScalarDriver.getConstantDriver(field),\n                    ScalarDriver.getConstantDriver(0),\n                    ScalarDriver.getConstantDriver(0)))\n\n    tstep = 1e-12\n    hysteresis = []\n\n    if start_mag is not None:\n        j.setLayerMagnetisation(\"free\", start_mag)\n\n    for current in j_scan:\n        j.clearLog()\n        t0 = 5e-9\n        dur = 3e-9\n        if mode == 'gaussian':\n            j.setLayerCurrentDriver(\n                \"free\",\n                ScalarDriver.getGaussianStepDriver(0, current, t0 + dur / 2,\n                                                   dur / 2))\n        else:\n            j.setLayerCurrentDriver(\n                \"free\", ScalarDriver.getStepDriver(0, current, t0, t0 + dur))\n\n        j.runSimulation(20e-9, tstep, tstep, calculateEnergies=False)\n\n        log = j.getLog()\n        str_ = \"free\"\n        m = np.asarray(\n            [[log[f'{str_}_mx'], log[f'{str_}_my'], log[f'{str_}_mz']]])\n        Rx0 = [100]\n        Ry0 = [1]\n        SMR = [1.11]\n        AMR = [0.41]\n        AHE = [2.23]\n\n        _, Rxy = calculate_resistance_parallel(Rx0,\n                                               Ry0,\n                                               AMR=AMR,\n                                               AHE=AHE,\n                                               SMR=SMR,\n                                               m=m,\n                                               l=[l],\n                                               w=[w])\n        R = Rxy\n        Rstable = R[-100:].mean()\n        hysteresis.append(Rstable)\n    end_mag = j.getLayerMagnetisation(\"free\")\n    hysteresis = np.asarray(hysteresis)\n    slew, width, _ = compute_hyst_params(hysteresis=hysteresis, x_axis=j_scan)\n    return hysteresis, slew, width, end_mag\n</pre> def compute_cims(j_scan: np.ndarray,                  field: float,                  Ms: float,                  Ku: float,                  start_mag: CVector = None,                  mode: str = 'gaussian'):      rho_f = 27e-8     rho_h = 21e-8     t_fm = 1e-9     t_hm = 4e-9     w = 10e-6     l = 75e-6     area = w * l     FM_R = rho_f * t_fm / area     HM_R = rho_h * l / (w * t_hm)     # parallel, current in plane     T_R = 1. / FM_R + 1. / HM_R     T_R = 1. / T_R      demagTensor = [         CVector(0., 0., 0.),         CVector(0., 0., 0.),         CVector(0., 0., 1.)     ]     alpha = 0.03      jden = 6.94e10     HDL = 25.92 * OetoAm / jden     HFL = 18 * OetoAm / jden     layer = Layer.createSOTLayer(id=\"free\",                                  mag=CVector(0.1, 0.1, 0.9),                                  anis=CVector(0, 0, 1),                                  Ms=Ms,                                  thickness=t_fm,                                  cellSurface=area,                                  demagTensor=demagTensor,                                  damping=alpha,                                  dampingLikeTorque=HDL,                                  fieldLikeTorque=HFL)      layer.setReferenceLayer(CVector(0, 1, 0))     j = Junction([layer])     j.setLayerAnisotropyDriver(\"all\", ScalarDriver.getConstantDriver(Ku))     j.setLayerReferenceLayer(\"free\", CVector(0, 1, 0))     j.setLayerExternalFieldDriver(         \"free\",         AxialDriver(ScalarDriver.getConstantDriver(field),                     ScalarDriver.getConstantDriver(0),                     ScalarDriver.getConstantDriver(0)))      tstep = 1e-12     hysteresis = []      if start_mag is not None:         j.setLayerMagnetisation(\"free\", start_mag)      for current in j_scan:         j.clearLog()         t0 = 5e-9         dur = 3e-9         if mode == 'gaussian':             j.setLayerCurrentDriver(                 \"free\",                 ScalarDriver.getGaussianStepDriver(0, current, t0 + dur / 2,                                                    dur / 2))         else:             j.setLayerCurrentDriver(                 \"free\", ScalarDriver.getStepDriver(0, current, t0, t0 + dur))          j.runSimulation(20e-9, tstep, tstep, calculateEnergies=False)          log = j.getLog()         str_ = \"free\"         m = np.asarray(             [[log[f'{str_}_mx'], log[f'{str_}_my'], log[f'{str_}_mz']]])         Rx0 = [100]         Ry0 = [1]         SMR = [1.11]         AMR = [0.41]         AHE = [2.23]          _, Rxy = calculate_resistance_parallel(Rx0,                                                Ry0,                                                AMR=AMR,                                                AHE=AHE,                                                SMR=SMR,                                                m=m,                                                l=[l],                                                w=[w])         R = Rxy         Rstable = R[-100:].mean()         hysteresis.append(Rstable)     end_mag = j.getLayerMagnetisation(\"free\")     hysteresis = np.asarray(hysteresis)     slew, width, _ = compute_hyst_params(hysteresis=hysteresis, x_axis=j_scan)     return hysteresis, slew, width, end_mag In\u00a0[7]: Copied! <pre>Ms = 0.5\nKu = 3e5\ndemagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.)]\nalpha = 0.03\nt_fm = 1e-9\nw = 10e-6\nl = 75e-6\narea = w * l\njden = 6.94e10\nHDL = 25.92 * OetoAm / jden\nHFL = 18 * OetoAm / jden\n\n\nI = 4e13\ninum = 100\nhnum = 100\nHmin = 100e3\nfield_values = np.linspace(-Hmin, Hmin, endpoint=True, num=hnum)\ncurrent_values = np.linspace(-I, I, num=inum)\n\nlast_m = CVector(0, 0, 1)\n\ndata_matrix_gauss = np.zeros(shape=(hnum, inum))\nR_matrix_gauss = np.zeros(shape=(hnum, inum))\n\nend_mag = CVector(0, 0, 1)\nfor fi, field in enumerate(tqdm(field_values)):\n    Rleft, _, _, end_mag = compute_cims(current_values,\n                                        field=field,\n                                        Ms=Ms,\n                                        Ku=Ku,\n                                        mode='gaussian',\n                                        start_mag=end_mag)\n    Rright, _, _, end_mag = compute_cims(current_values[::-1],\n                                         field=field,\n                                         Ms=Ms,\n                                         Ku=Ku,\n                                         mode='gaussian',\n                                         start_mag=end_mag)\n    Rright = Rright[::-1]\n    diff = np.abs(Rleft - Rright)\n    eps = 0.5\n    data_matrix_gauss[fi, :] = diff.tolist()\n    R_matrix_gauss[fi, :] = Rleft\n</pre> Ms = 0.5 Ku = 3e5 demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.)] alpha = 0.03 t_fm = 1e-9 w = 10e-6 l = 75e-6 area = w * l jden = 6.94e10 HDL = 25.92 * OetoAm / jden HFL = 18 * OetoAm / jden   I = 4e13 inum = 100 hnum = 100 Hmin = 100e3 field_values = np.linspace(-Hmin, Hmin, endpoint=True, num=hnum) current_values = np.linspace(-I, I, num=inum)  last_m = CVector(0, 0, 1)  data_matrix_gauss = np.zeros(shape=(hnum, inum)) R_matrix_gauss = np.zeros(shape=(hnum, inum))  end_mag = CVector(0, 0, 1) for fi, field in enumerate(tqdm(field_values)):     Rleft, _, _, end_mag = compute_cims(current_values,                                         field=field,                                         Ms=Ms,                                         Ku=Ku,                                         mode='gaussian',                                         start_mag=end_mag)     Rright, _, _, end_mag = compute_cims(current_values[::-1],                                          field=field,                                          Ms=Ms,                                          Ku=Ku,                                          mode='gaussian',                                          start_mag=end_mag)     Rright = Rright[::-1]     diff = np.abs(Rleft - Rright)     eps = 0.5     data_matrix_gauss[fi, :] = diff.tolist()     R_matrix_gauss[fi, :] = Rleft <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [02:52&lt;00:00,  1.72s/it]\n</pre> In\u00a0[8]: Copied! <pre>data_matrix_step = np.zeros(shape=(hnum, inum))\nR_matrix_step = np.zeros(shape=(hnum, inum))\nfor fi, field in enumerate(tqdm(field_values)):\n    Rleft, _, _, end_mag = compute_cims(current_values,\n                                        field=field,\n                                        Ms=Ms,\n                                        Ku=Ku,\n                                        mode='step',\n                                        start_mag=end_mag)\n    Rright, _, _, end_mag = compute_cims(current_values[::-1],\n                                         field=field,\n                                         Ms=Ms,\n                                         Ku=Ku,\n                                         mode='step',\n                                         start_mag=end_mag)\n    Rright = Rright[::-1]\n    diff = np.abs(Rleft - Rright)\n    eps = 0.5\n    data_matrix_step[fi, :] = diff.tolist()\n    R_matrix_step[fi, :] = Rleft\n</pre> data_matrix_step = np.zeros(shape=(hnum, inum)) R_matrix_step = np.zeros(shape=(hnum, inum)) for fi, field in enumerate(tqdm(field_values)):     Rleft, _, _, end_mag = compute_cims(current_values,                                         field=field,                                         Ms=Ms,                                         Ku=Ku,                                         mode='step',                                         start_mag=end_mag)     Rright, _, _, end_mag = compute_cims(current_values[::-1],                                          field=field,                                          Ms=Ms,                                          Ku=Ku,                                          mode='step',                                          start_mag=end_mag)     Rright = Rright[::-1]     diff = np.abs(Rleft - Rright)     eps = 0.5     data_matrix_step[fi, :] = diff.tolist()     R_matrix_step[fi, :] = Rleft <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [02:44&lt;00:00,  1.65s/it]\n</pre> <p>Below we create the map. We mask first the resistance states &gt; 0 as high, 0 &lt; 0 as low.  <code>data_matrix_step</code> and <code>data_matrix_gauss</code> are contain the gradient of resistance indicating any switching between the two states (the derivative). If the derivative over resistance state is not zero at any point, that means the state has switched from low to high or vice versa.</p> In\u00a0[9]: Copied! <pre>from matplotlib import colors\nimport matplotlib.patches as mpatches\n\neps = 0\ncolor_mask_step = R_matrix_step.copy()\ncolor_mask_step[color_mask_step &gt; eps] = 1\ncolor_mask_step[color_mask_step &lt; eps] = -1\ncolor_mask_step[data_matrix_step != 0] = 0\n\ncolor_mask_gauss = R_matrix_gauss.copy()\ncolor_mask_gauss[color_mask_gauss &gt; eps] = 1\ncolor_mask_gauss[color_mask_gauss &lt; eps] = -1\ncolor_mask_gauss[data_matrix_gauss != 0] = 0\n\ncmap = colors.ListedColormap(['navy', 'yellow', 'crimson'])\n\nwith plt.style.context(['science', 'nature']):\n    fig, (ax1, ax2) = plt.subplots(2, 1, sharey='col', sharex='col', dpi=300)\n    ax1.pcolor(field_values / 1e3,\n               current_values / 1e12,\n               color_mask_step.T,\n               cmap=cmap)\n    ax2.pcolor(field_values / 1e3,\n               current_values / 1e12,\n               color_mask_gauss.T,\n               cmap=cmap)\n\n    red_patch = mpatches.Patch(color='crimson', label='High resistance')\n    blue_patch = mpatches.Patch(color='navy', label='Low resistance')\n    yellow_patch = mpatches.Patch(color='yellow', label='Both states')\n    ax2.legend(handles=[blue_patch, red_patch, yellow_patch], frameon=True,\n    # frame color \n    facecolor='white', fontsize=6\n    )\n\n    ax1.set_ylabel(\"$\\mathrm{j}$ ($\\mathrm{TA/m^2}$)\")\n    ax2.set_ylabel(\"$\\mathrm{j}$ ($\\mathrm{TA/m^2}$)\")\n    ax2.set_xlabel(\"H ($\\mathrm{kA/m}$)\")\n\n    fig.subplots_adjust(hspace=0.)\n    fig.align_ylabels()\n\n    import matplotlib.transforms as mtransforms\n    for label, ax in zip(['a)', 'b)'], (ax1, ax2)):\n        # label physical distance in and down:\n        trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,\n                                              fig.dpi_scale_trans)\n        ax.text(0.0,\n                1.0,\n                label,\n                transform=ax.transAxes + trans,\n                fontsize='medium',\n                verticalalignment='top',\n                color='lavender',\n                bbox=dict(facecolor='none', alpha=0.4, edgecolor='none', pad=3.0))\n</pre> from matplotlib import colors import matplotlib.patches as mpatches  eps = 0 color_mask_step = R_matrix_step.copy() color_mask_step[color_mask_step &gt; eps] = 1 color_mask_step[color_mask_step &lt; eps] = -1 color_mask_step[data_matrix_step != 0] = 0  color_mask_gauss = R_matrix_gauss.copy() color_mask_gauss[color_mask_gauss &gt; eps] = 1 color_mask_gauss[color_mask_gauss &lt; eps] = -1 color_mask_gauss[data_matrix_gauss != 0] = 0  cmap = colors.ListedColormap(['navy', 'yellow', 'crimson'])  with plt.style.context(['science', 'nature']):     fig, (ax1, ax2) = plt.subplots(2, 1, sharey='col', sharex='col', dpi=300)     ax1.pcolor(field_values / 1e3,                current_values / 1e12,                color_mask_step.T,                cmap=cmap)     ax2.pcolor(field_values / 1e3,                current_values / 1e12,                color_mask_gauss.T,                cmap=cmap)      red_patch = mpatches.Patch(color='crimson', label='High resistance')     blue_patch = mpatches.Patch(color='navy', label='Low resistance')     yellow_patch = mpatches.Patch(color='yellow', label='Both states')     ax2.legend(handles=[blue_patch, red_patch, yellow_patch], frameon=True,     # frame color      facecolor='white', fontsize=6     )      ax1.set_ylabel(\"$\\mathrm{j}$ ($\\mathrm{TA/m^2}$)\")     ax2.set_ylabel(\"$\\mathrm{j}$ ($\\mathrm{TA/m^2}$)\")     ax2.set_xlabel(\"H ($\\mathrm{kA/m}$)\")      fig.subplots_adjust(hspace=0.)     fig.align_ylabels()      import matplotlib.transforms as mtransforms     for label, ax in zip(['a)', 'b)'], (ax1, ax2)):         # label physical distance in and down:         trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,                                               fig.dpi_scale_trans)         ax.text(0.0,                 1.0,                 label,                 transform=ax.transAxes + trans,                 fontsize='medium',                 verticalalignment='top',                 color='lavender',                 bbox=dict(facecolor='none', alpha=0.4, edgecolor='none', pad=3.0))"},{"location":"experimental-methods/CIMS/#cims-tutorial","title":"CIMS Tutorial\u00b6","text":"<p>CIMS stands for Current Induced Magnetisation Switching. In this method, we excite the magnetisation with a current pulse which, as we will show here can take different forms:  sometimes it's a step function, Gaussian impulse or a sinc impulse. The choice of the current pulse, and its duration, is important as it can affect the magnetisation dynamics.</p> <p>After magnetisation is excited we measure the resistance level in a stable state. This resistance level is a function of the magnetisation direction and can be used to determine the magnetisation direction -- and thus, by scanning with the magnitude of the excitation, we can determine the hysteresis curve of the device.</p> <p>In this tutorial, we will show how to simulate the CIMS method using the <code>cmtj</code> package. We will simulate the magnetisation dynamics of a trilayer and a bilayer devices in function not only of a current density magnitude, but also applied field and, for a trilayer system, IEC (coupling) and anisotropy.</p>"},{"location":"experimental-methods/CIMS/#trilayer-cims","title":"Trilayer CIMS\u00b6","text":""},{"location":"experimental-methods/CIMS/#bilayer-cims","title":"Bilayer CIMS\u00b6","text":"<p>For this experiment we will scan the current density and the applied field to produce a state map.</p> <p>A state map consists of 3 values: high, low and both resistance levels. The high resistance level means that the alignment of the magnetisation is such that it produces the highest possible resistance level for this configuration of resistance parameters and the resistance devices. The low resistance level is the opposite, the lowest possible resistance level. The both resistance level is when the resistance level switches from high to low or vice versa during the hysteresis -- ergo, both resistance states are possible and the state depends on the scanning direction of the current.</p>"},{"location":"experimental-methods/HarmonicsFits/","title":"Harmonic Fits","text":"In\u00a0[1]: Copied! <pre>import pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nOeToAm = 79.57747\n</pre> import pandas as pd import matplotlib.pyplot as plt import numpy as np  OeToAm = 79.57747 In\u00a0[2]: Copied! <pre>from scipy.optimize import curve_fit\n\n\ndef fit_beta_rxx(beta_scan, R0, SMR):\n    return R0 + SMR * np.power(np.sin(beta_scan), 2)\n\n\ndef fit_beta_rxy(beta_scan, R0, AHE):\n    return R0 + 0.5 * AHE * np.cos(beta_scan)\n\n\ndef fit_gamma_rxx(gamma_scan, R0, AMR):\n    return R0 + AMR * np.power(np.sin(gamma_scan), 2)\n\n\ndef fit_gamma_rxy(gamma_scan, R0, AHE):\n    return R0 + 0.5 * AHE * np.cos(gamma_scan)\n\n\ndef fit_alpha_rxx(alpha_scan, R0, AMR, SMR, offset):\n    return R0 + 0.5 * (AMR + SMR) + 0.5 * (AMR - SMR) * np.cos(2 * alpha_scan +\n                                                               offset)\n\n\ndef fit_alpha_rxy(alpha_scan, R0, AMR, SMR, offset):\n    return R0 + 0.5 * (AMR + SMR) * np.sin(2 * alpha_scan + offset)\n\n\nrxx = pd.read_csv(\"./data/Ta_CoFeB/5360_rxx_alpha_beta_gamma.csv\", sep=',')\nrxy = pd.read_csv(\"./data/Ta_CoFeB/5360_rxy_alpha_beta_gamma.csv\", sep=',')\n\nw = 3e-5\nl = 2e-5\n\n### BETA FITS\nbeta_scan_rxx_deg = rxx['beta'].dropna() - 90\nbeta_scan_rxy_deg = rxy['beta'].dropna() - 90\nbeta_scan_rxx = np.deg2rad(rxx['beta'].dropna() - 90)\nbeta_scan_rxy = np.deg2rad(rxy['beta'].dropna() - 90)\n\npopt, _ = curve_fit(fit_beta_rxx,\n                    xdata=beta_scan_rxx,\n                    ydata=rxx['rxx_beta'].dropna())\nRX0, SMR_XX = popt\nbeta_rxx = fit_beta_rxx(beta_scan_rxx, RX0, SMR_XX)\npopt, _ = curve_fit(fit_beta_rxy,\n                    xdata=beta_scan_rxy,\n                    ydata=rxy['rxy_beta'].dropna() -\n                    rxy['rxy_beta'].dropna().min())\nRY0, AHE = popt\nRY0 = 1.067\nprint(f\"BETA: {RX0=:.3f}, {SMR_XX=:.3f}, {AHE=:.3f}, {RY0=:.3f}\")\n\nbeta_rxy = fit_beta_rxy(beta_scan_rxy, RY0, AHE)\n\n### GAMMA FITS\ngamma_scan_rxx_deg = rxx['gamma'].dropna() - 90\ngamma_scan_rxy_deg = rxy['gamma'].dropna() - 90\n\ngamma_scan_rxx = np.deg2rad(rxx['gamma'].dropna() - 90)\ngamma_scan_rxy = np.deg2rad(rxy['gamma'].dropna() - 90)\n\npopt, _ = curve_fit(fit_gamma_rxx,\n                    xdata=gamma_scan_rxx,\n                    ydata=rxx['rxx_gamma'].dropna())\nRX0, AMR_XX = popt\ngamma_rxx = fit_gamma_rxx(gamma_scan_rxx, RX0, AMR_XX)\npopt, _ = curve_fit(fit_gamma_rxy,\n                    xdata=gamma_scan_rxy,\n                    ydata=rxy['rxy_gamma'].dropna())\nRY0, AHE = popt\nprint(f\"GAMMA: {RX0=:.3f}, {AMR_XX=:.3f}, {AHE=:.3f}, {RY0=:.3f}\")\ngamma_rxy = fit_gamma_rxy(gamma_scan_rxy, RY0, AHE)\n\n### ALPHA FITS\n\nalpha_scan_rxx_deg = rxx['alpha'].dropna()[2:]\nalpha_scan_rxy_deg = rxy['alpha'].dropna()\nalpha_scan_rxx = np.deg2rad(rxx['alpha'].dropna())\nalpha_scan_rxy = np.deg2rad(rxy['alpha'].dropna())\n\npopt, _ = curve_fit(fit_alpha_rxx,\n                    xdata=alpha_scan_rxx,\n                    ydata=rxx['rxx_alpha'].dropna(),\n                    p0=(RX0, AMR_XX, SMR_XX, 0),\n                    bounds=((0, -abs(-AMR_XX * (w / l) * 3),\n                             -abs(SMR_XX * (w / l) * 3), -100),\n                            (400, abs(-AMR_XX * (w / l) * 3),\n                             abs(SMR_XX * (w / l) * 3), 100)))\nRX0, AMR_XX, SMR_XX, offset1 = popt\n\npopt, _ = curve_fit(fit_alpha_rxy,\n                    xdata=alpha_scan_rxy,\n                    ydata=rxy['rxy_alpha'].dropna(),\n                    bounds=((0, -abs(-AMR_XX * (w / l) * 3),\n                             -abs(SMR_XX * (w / l) * 3), -100),\n                            (400, abs(-AMR_XX * (w / l) * 3),\n                             abs(SMR_XX * (w / l) * 3), 100)),\n                    p0=(0, -AMR_XX * (w / l), SMR_XX * (w / l), 0))\nRY0, AMR_XY, SMR_XY, offset2 = popt\noffsetdeg = np.rad2deg(offset2)\nprint(\n    f\"ALPHA: {RX0=:.3f}, {RY0=:.3f}, {AMR_XX=:.3f}, {SMR_XX=:.3f}, {AMR_XY=:.3f}, {SMR_XY=:.3f}, {offsetdeg=:.3f}\"\n)\n\nAMR_XY = AMR_XX * -(w / l)\nSMR_XY = SMR_XX * (w / l)\n\nalpha_rxx = fit_alpha_rxx(alpha_scan_rxx, RX0, AMR_XX, SMR_XX, offset1)\nalpha_rxy = fit_alpha_rxy(alpha_scan_rxy, RY0, AMR_XY, SMR_XY, offset2)\nprint(f\"{AMR_XY=:.3f}, {SMR_XY=:.3f}\")\nprint(f\"{AMR_XX*(-w/l)=:.3f}, {SMR_XX*(w/l)=:.3f}\")\n</pre> from scipy.optimize import curve_fit   def fit_beta_rxx(beta_scan, R0, SMR):     return R0 + SMR * np.power(np.sin(beta_scan), 2)   def fit_beta_rxy(beta_scan, R0, AHE):     return R0 + 0.5 * AHE * np.cos(beta_scan)   def fit_gamma_rxx(gamma_scan, R0, AMR):     return R0 + AMR * np.power(np.sin(gamma_scan), 2)   def fit_gamma_rxy(gamma_scan, R0, AHE):     return R0 + 0.5 * AHE * np.cos(gamma_scan)   def fit_alpha_rxx(alpha_scan, R0, AMR, SMR, offset):     return R0 + 0.5 * (AMR + SMR) + 0.5 * (AMR - SMR) * np.cos(2 * alpha_scan +                                                                offset)   def fit_alpha_rxy(alpha_scan, R0, AMR, SMR, offset):     return R0 + 0.5 * (AMR + SMR) * np.sin(2 * alpha_scan + offset)   rxx = pd.read_csv(\"./data/Ta_CoFeB/5360_rxx_alpha_beta_gamma.csv\", sep=',') rxy = pd.read_csv(\"./data/Ta_CoFeB/5360_rxy_alpha_beta_gamma.csv\", sep=',')  w = 3e-5 l = 2e-5  ### BETA FITS beta_scan_rxx_deg = rxx['beta'].dropna() - 90 beta_scan_rxy_deg = rxy['beta'].dropna() - 90 beta_scan_rxx = np.deg2rad(rxx['beta'].dropna() - 90) beta_scan_rxy = np.deg2rad(rxy['beta'].dropna() - 90)  popt, _ = curve_fit(fit_beta_rxx,                     xdata=beta_scan_rxx,                     ydata=rxx['rxx_beta'].dropna()) RX0, SMR_XX = popt beta_rxx = fit_beta_rxx(beta_scan_rxx, RX0, SMR_XX) popt, _ = curve_fit(fit_beta_rxy,                     xdata=beta_scan_rxy,                     ydata=rxy['rxy_beta'].dropna() -                     rxy['rxy_beta'].dropna().min()) RY0, AHE = popt RY0 = 1.067 print(f\"BETA: {RX0=:.3f}, {SMR_XX=:.3f}, {AHE=:.3f}, {RY0=:.3f}\")  beta_rxy = fit_beta_rxy(beta_scan_rxy, RY0, AHE)  ### GAMMA FITS gamma_scan_rxx_deg = rxx['gamma'].dropna() - 90 gamma_scan_rxy_deg = rxy['gamma'].dropna() - 90  gamma_scan_rxx = np.deg2rad(rxx['gamma'].dropna() - 90) gamma_scan_rxy = np.deg2rad(rxy['gamma'].dropna() - 90)  popt, _ = curve_fit(fit_gamma_rxx,                     xdata=gamma_scan_rxx,                     ydata=rxx['rxx_gamma'].dropna()) RX0, AMR_XX = popt gamma_rxx = fit_gamma_rxx(gamma_scan_rxx, RX0, AMR_XX) popt, _ = curve_fit(fit_gamma_rxy,                     xdata=gamma_scan_rxy,                     ydata=rxy['rxy_gamma'].dropna()) RY0, AHE = popt print(f\"GAMMA: {RX0=:.3f}, {AMR_XX=:.3f}, {AHE=:.3f}, {RY0=:.3f}\") gamma_rxy = fit_gamma_rxy(gamma_scan_rxy, RY0, AHE)  ### ALPHA FITS  alpha_scan_rxx_deg = rxx['alpha'].dropna()[2:] alpha_scan_rxy_deg = rxy['alpha'].dropna() alpha_scan_rxx = np.deg2rad(rxx['alpha'].dropna()) alpha_scan_rxy = np.deg2rad(rxy['alpha'].dropna())  popt, _ = curve_fit(fit_alpha_rxx,                     xdata=alpha_scan_rxx,                     ydata=rxx['rxx_alpha'].dropna(),                     p0=(RX0, AMR_XX, SMR_XX, 0),                     bounds=((0, -abs(-AMR_XX * (w / l) * 3),                              -abs(SMR_XX * (w / l) * 3), -100),                             (400, abs(-AMR_XX * (w / l) * 3),                              abs(SMR_XX * (w / l) * 3), 100))) RX0, AMR_XX, SMR_XX, offset1 = popt  popt, _ = curve_fit(fit_alpha_rxy,                     xdata=alpha_scan_rxy,                     ydata=rxy['rxy_alpha'].dropna(),                     bounds=((0, -abs(-AMR_XX * (w / l) * 3),                              -abs(SMR_XX * (w / l) * 3), -100),                             (400, abs(-AMR_XX * (w / l) * 3),                              abs(SMR_XX * (w / l) * 3), 100)),                     p0=(0, -AMR_XX * (w / l), SMR_XX * (w / l), 0)) RY0, AMR_XY, SMR_XY, offset2 = popt offsetdeg = np.rad2deg(offset2) print(     f\"ALPHA: {RX0=:.3f}, {RY0=:.3f}, {AMR_XX=:.3f}, {SMR_XX=:.3f}, {AMR_XY=:.3f}, {SMR_XY=:.3f}, {offsetdeg=:.3f}\" )  AMR_XY = AMR_XX * -(w / l) SMR_XY = SMR_XX * (w / l)  alpha_rxx = fit_alpha_rxx(alpha_scan_rxx, RX0, AMR_XX, SMR_XX, offset1) alpha_rxy = fit_alpha_rxy(alpha_scan_rxy, RY0, AMR_XY, SMR_XY, offset2) print(f\"{AMR_XY=:.3f}, {SMR_XY=:.3f}\") print(f\"{AMR_XX*(-w/l)=:.3f}, {SMR_XX*(w/l)=:.3f}\") <pre>BETA: RX0=304.770, SMR_XX=-0.466, AHE=5.747, RY0=1.067\nGAMMA: RX0=304.788, AMR_XX=-0.053, AHE=5.711, RY0=1.067\nALPHA: RX0=305.561, RY0=1.008, AMR_XX=-0.053, SMR_XX=-0.463, AMR_XY=0.091, SMR_XY=-0.486, offsetdeg=-13.728\nAMR_XY=0.079, SMR_XY=-0.695\nAMR_XX*(-w/l)=0.079, SMR_XX*(w/l)=-0.695\n</pre> <p>The <code>Rxy</code> parameter is not considered crucial. For the <code>AHE</code> we pick 5.71. The fits for the ALPHA have fixed values from earlier as there's some fluctuation in the measurement.</p> <p>The following parameters will be used for further fittings:</p> <pre><code>Rx0 = [304.306]\nRy0 = [1.008] or [3] # this is only the offset\nSMR = [-0.464]\nAMR = [-0.053]\nAHE = [-5.71]\nw = [3e-5]\nl = [2e-5]</code></pre> In\u00a0[3]: Copied! <pre>import matplotlib as mpl\n\nmpl.rcParams['axes.formatter.useoffset'] = False\n\nlw = 2.5\nwith plt.style.context(['science', 'nature']):\n    fig, ax = plt.subplots(3, 2, figsize=(4, 4), dpi=400)\n    ax[0, 0].plot(beta_scan_rxx_deg,\n                  rxx['rxx_beta'].dropna(),\n                  'bo',\n                  label='Exp.')\n    ax[0, 0].plot(beta_scan_rxx_deg, beta_rxx, 'r-', label='Fit', linewidth=lw)\n    ax[0, 0].set_xlabel(r\"$\\beta (\\mathrm{deg})$\")\n    ax[0, 0].set_ylabel(r\"Rxx $(\\Omega)$\")\n\n    ax[0, 1].plot(beta_scan_rxy_deg, rxy['rxy_beta'].dropna(), 'bo')\n    ax[0, 1].plot(beta_scan_rxy_deg, beta_rxy, 'r-', linewidth=lw)\n    ax[0, 1].set_xlabel(r\"$\\beta (\\mathrm{deg})$\")\n    ax[0, 1].set_ylabel(r\"Rxy $(\\Omega)$\", rotation=270, labelpad=8)\n\n    spac = 120\n    ax[0, 1].set_xlim([-spac, spac])\n    ax[0, 0].set_xlim([-spac, spac])\n\n    ax[1, 0].plot(gamma_scan_rxx_deg, rxx['rxx_gamma'].dropna(), 'bo')\n    ax[1, 0].plot(gamma_scan_rxx_deg, gamma_rxx, 'r-', linewidth=lw)\n    ax[1, 0].set_xlabel(r\"$\\gamma (\\mathrm{deg})$\")\n    ax[1, 0].set_ylabel(r\"Rxx $(\\Omega)$\")\n\n    ax[1, 1].plot(gamma_scan_rxy_deg, rxy['rxy_gamma'].dropna(), 'bo')\n    ax[1, 1].plot(gamma_scan_rxy_deg, gamma_rxy, 'r-', linewidth=lw)\n    ax[1, 1].set_xlabel(r\"$\\gamma (\\mathrm{deg})$\")\n    ax[1, 1].set_ylabel(r\"Rxy $(\\Omega)$\", rotation=270, labelpad=8)\n\n    ax[1, 1].set_xlim([-spac, spac])\n    ax[1, 0].set_xlim([-spac, spac])\n\n    ax[2, 0].plot(alpha_scan_rxx_deg, rxx['rxx_alpha'].dropna()[2:], 'bo')\n    ax[2, 0].plot(alpha_scan_rxx_deg, alpha_rxx[2:], 'r-', linewidth=lw)\n    ax[2, 0].set_xlabel(r\"$\\alpha (\\mathrm{deg})$\")\n    ax[2, 0].set_ylabel(r\"Rxx $(\\Omega)$\")\n\n    ax[2, 1].plot(alpha_scan_rxy_deg, rxy['rxy_alpha'].dropna(), 'bo')\n    ax[2, 1].plot(alpha_scan_rxy_deg, alpha_rxy, 'r-', linewidth=lw)\n    ax[2, 1].set_xlabel(r\"$\\alpha (\\mathrm{deg})$\")\n    ax[2, 1].set_ylabel(\"Rxy $(\\Omega)$\", rotation=270, labelpad=8)\n    ax[0, 0].legend(loc=8)\n\n    for i in range(3):\n        ax[i, 1].yaxis.tick_right()\n        ax[i, 1].yaxis.set_label_position(\"right\")\n\n    import matplotlib.transforms as mtransforms\n    for label, ax in zip(['(a)', '(b)', '(c)', '(d)', '(e)', '(f)'], ax.flatten()):\n        # label physical distance in and down:\n        trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,\n                                              fig.dpi_scale_trans)\n        ax.text(0.0,\n                1.0,\n                label,\n                transform=ax.transAxes + trans,\n                fontsize='medium',\n                verticalalignment='top',\n                bbox=dict(facecolor='none', edgecolor='none', pad=3.0))\n\n    fig.subplots_adjust(wspace=0., hspace=0.55)\n    fig.align_ylabels()\n</pre> import matplotlib as mpl  mpl.rcParams['axes.formatter.useoffset'] = False  lw = 2.5 with plt.style.context(['science', 'nature']):     fig, ax = plt.subplots(3, 2, figsize=(4, 4), dpi=400)     ax[0, 0].plot(beta_scan_rxx_deg,                   rxx['rxx_beta'].dropna(),                   'bo',                   label='Exp.')     ax[0, 0].plot(beta_scan_rxx_deg, beta_rxx, 'r-', label='Fit', linewidth=lw)     ax[0, 0].set_xlabel(r\"$\\beta (\\mathrm{deg})$\")     ax[0, 0].set_ylabel(r\"Rxx $(\\Omega)$\")      ax[0, 1].plot(beta_scan_rxy_deg, rxy['rxy_beta'].dropna(), 'bo')     ax[0, 1].plot(beta_scan_rxy_deg, beta_rxy, 'r-', linewidth=lw)     ax[0, 1].set_xlabel(r\"$\\beta (\\mathrm{deg})$\")     ax[0, 1].set_ylabel(r\"Rxy $(\\Omega)$\", rotation=270, labelpad=8)      spac = 120     ax[0, 1].set_xlim([-spac, spac])     ax[0, 0].set_xlim([-spac, spac])      ax[1, 0].plot(gamma_scan_rxx_deg, rxx['rxx_gamma'].dropna(), 'bo')     ax[1, 0].plot(gamma_scan_rxx_deg, gamma_rxx, 'r-', linewidth=lw)     ax[1, 0].set_xlabel(r\"$\\gamma (\\mathrm{deg})$\")     ax[1, 0].set_ylabel(r\"Rxx $(\\Omega)$\")      ax[1, 1].plot(gamma_scan_rxy_deg, rxy['rxy_gamma'].dropna(), 'bo')     ax[1, 1].plot(gamma_scan_rxy_deg, gamma_rxy, 'r-', linewidth=lw)     ax[1, 1].set_xlabel(r\"$\\gamma (\\mathrm{deg})$\")     ax[1, 1].set_ylabel(r\"Rxy $(\\Omega)$\", rotation=270, labelpad=8)      ax[1, 1].set_xlim([-spac, spac])     ax[1, 0].set_xlim([-spac, spac])      ax[2, 0].plot(alpha_scan_rxx_deg, rxx['rxx_alpha'].dropna()[2:], 'bo')     ax[2, 0].plot(alpha_scan_rxx_deg, alpha_rxx[2:], 'r-', linewidth=lw)     ax[2, 0].set_xlabel(r\"$\\alpha (\\mathrm{deg})$\")     ax[2, 0].set_ylabel(r\"Rxx $(\\Omega)$\")      ax[2, 1].plot(alpha_scan_rxy_deg, rxy['rxy_alpha'].dropna(), 'bo')     ax[2, 1].plot(alpha_scan_rxy_deg, alpha_rxy, 'r-', linewidth=lw)     ax[2, 1].set_xlabel(r\"$\\alpha (\\mathrm{deg})$\")     ax[2, 1].set_ylabel(\"Rxy $(\\Omega)$\", rotation=270, labelpad=8)     ax[0, 0].legend(loc=8)      for i in range(3):         ax[i, 1].yaxis.tick_right()         ax[i, 1].yaxis.set_label_position(\"right\")      import matplotlib.transforms as mtransforms     for label, ax in zip(['(a)', '(b)', '(c)', '(d)', '(e)', '(f)'], ax.flatten()):         # label physical distance in and down:         trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,                                               fig.dpi_scale_trans)         ax.text(0.0,                 1.0,                 label,                 transform=ax.transAxes + trans,                 fontsize='medium',                 verticalalignment='top',                 bbox=dict(facecolor='none', edgecolor='none', pad=3.0))      fig.subplots_adjust(wspace=0., hspace=0.55)     fig.align_ylabels() In\u00a0[4]: Copied! <pre>rxx = pd.read_csv('./data/Ta_CoFeB/5360_rxx_hx_h45_hy.csv', sep=',')\nrxy = pd.read_csv('./data/Ta_CoFeB/5360_rxy_hx_h45_hy.csv', sep=',')\n\nwith plt.style.context(['science', 'no-latex']):\n    fig, ax = plt.subplots(3, 2, figsize=(14, 8))\n    orientations = ['hx', 'hy', 'h45']\n    for i, orient in enumerate(orientations):\n        field_x = rxx[f'{orient}'] * OeToAm / 1e3  # to kA/m\n        res_x = rxx[f\"rxx_{orient}\"]\n        field_y = rxy[f'{orient}'] * OeToAm / 1e3  # to kA/m\n        res_y = rxy[f\"rxy_{orient}\"] - rxy[f\"rxy_{orient}\"][0]\n        ax[i, 0].plot(field_x, res_x, 'ro')\n        ax[i, 1].plot(field_y, res_y, 'bo-')\n        ax[i, 0].set_xlabel(\"Field [kA/m]\")\n        ax[i, 0].set_ylabel(f\"Rxx [{orient}]\")\n        ax[i, 1].set_xlabel(\"Field [kA/m]\")\n        ax[i, 1].set_ylabel(f\"Rxy [{orient}]\")\n</pre> rxx = pd.read_csv('./data/Ta_CoFeB/5360_rxx_hx_h45_hy.csv', sep=',') rxy = pd.read_csv('./data/Ta_CoFeB/5360_rxy_hx_h45_hy.csv', sep=',')  with plt.style.context(['science', 'no-latex']):     fig, ax = plt.subplots(3, 2, figsize=(14, 8))     orientations = ['hx', 'hy', 'h45']     for i, orient in enumerate(orientations):         field_x = rxx[f'{orient}'] * OeToAm / 1e3  # to kA/m         res_x = rxx[f\"rxx_{orient}\"]         field_y = rxy[f'{orient}'] * OeToAm / 1e3  # to kA/m         res_y = rxy[f\"rxy_{orient}\"] - rxy[f\"rxy_{orient}\"][0]         ax[i, 0].plot(field_x, res_x, 'ro')         ax[i, 1].plot(field_y, res_y, 'bo-')         ax[i, 0].set_xlabel(\"Field [kA/m]\")         ax[i, 0].set_ylabel(f\"Rxx [{orient}]\")         ax[i, 1].set_xlabel(\"Field [kA/m]\")         ax[i, 1].set_ylabel(f\"Rxy [{orient}]\") In\u00a0[5]: Copied! <pre>### generate data for publication\nfrom collections import defaultdict\nfrom cmtj import CVector, Layer, Junction, ScalarDriver, AxialDriver, NullDriver\nfrom cmtj.utils.linear import FieldScan\nfrom tqdm import tqdm\nimport numpy as np\n\nimport matplotlib as mpl\n\nmpl.rcParams['axes.formatter.useoffset'] = False\nfsize = 20\nlw = 5\n\nRx0 = [304.306]\nRy0 = [1.008]\nSMR = [-0.464]\nAMR = [-0.053]\nAHE = [-5.71]\nw = [3e-5]\nl = [2e-5]\n\nlw = 2.5\ndef get_field_scan_from_angle(experiment_field, theta, phi):\n    st, ct, sp, cp = FieldScan._trig_compute(theta, phi)\n    Hx = st * cp * experiment_field\n    Hy = st * sp * experiment_field\n    Hz = ct * experiment_field\n\n    Hvecs = np.vstack((Hx, Hy, Hz)).T\n    return Hvecs\n\n\ndef calculate_resistance(Rx0, Ry0, AMR, AHE, SMR, m, number_of_layers, l, w):\n    if m.ndim == 2:\n        SxAll = np.zeros((number_of_layers, ))\n        SyAll = np.zeros((number_of_layers, ))\n\n    elif m.ndim == 3:\n        SxAll = np.zeros((number_of_layers, m.shape[2]))\n        SyAll = np.zeros((number_of_layers, m.shape[2]))\n\n    for i in range(0, number_of_layers):\n        w_l = w[i] / l[i]\n        SxAll[i] = 1 / (Rx0[i] + (AMR[i] * m[i, 0]**2 + SMR[i] * m[i, 1]**2))\n        SyAll[i] = 1 / (Ry0[i] + 0.5 * AHE[i] * m[i, 2] + (w_l) *\n                        (SMR[i] - AMR[i]) * m[i, 0] * m[i, 1])\n\n    Rx = 1 / np.sum(SxAll, axis=0)\n    Ry = 1 / np.sum(SyAll, axis=0)\n    return Rx, Ry\n\n\ndef run_simulation(junction: Junction,\n                   Hvecs: np.ndarray,\n                   mode: str,\n                   int_time=1e-12):\n    sim_time = 10e-9\n    layer_str = ['free']\n    mags = [CVector(0, 0, 1) for _ in layer_str]\n    Rxy, Rxx = [], []\n    for Hval in Hvecs:\n        junction.clearLog()\n        HDriver = AxialDriver(ScalarDriver.getConstantDriver(Hval[0]),\n                              ScalarDriver.getConstantDriver(Hval[1]),\n                              ScalarDriver.getConstantDriver(Hval[2]))\n        junction.setLayerExternalFieldDriver(\"all\", HDriver)\n        # set mags for better convergence\n        for i, l_str in enumerate(layer_str):\n            junction.setLayerMagnetisation(l_str, mags[i])\n\n        junction.runSimulation(sim_time, int_time, int_time)\n\n        # set new mags\n        for str_ in layer_str:\n            mags[i] = junction.getLayerMagnetisation(str_)\n\n        log = junction.getLog()\n        m = np.asarray(\n            [[log[f'{str_}_mx'], log[f'{str_}_my'], log[f'{str_}_mz']]\n             for str_ in layer_str])\n        dynamicRx, dynamicRy = calculate_resistance(Rx0, [0],\n                                                    AMR=AMR,\n                                                    AHE=AHE,\n                                                    SMR=SMR,\n                                                    m=m,\n                                                    number_of_layers=1,\n                                                    l=l,\n                                                    w=w)\n\n        Rxy.append(dynamicRy[-1])\n        Rxx.append(dynamicRx[-1])\n    if mode.lower() == 'rxx':\n        return np.asarray(Rxx)\n    else:\n        return np.asarray(Rxy)\n\n\ndef simulate(Ku, Ms, Hvecs, alpha, mode='rxx'):\n    demagTensor = [\n        CVector(0.00024164288391924, 2.71396011566517e-10,\n                5.95503928124313e-14),\n        CVector(2.71396011566517e-10, 0.000160046006320031,\n                1.32504057070646e-14),\n        CVector(5.95503928124313e-14, 1.32504057070646e-14, 0.999598310229469)\n    ]\n\n    thickness = 1.45e-9\n    surface = w[0] * l[0]\n    l1 = Layer(\n        id=\"free\",\n        mag=CVector(0, 0, 1),\n        anis=CVector(0., 0, 1),\n        Ms=Ms,\n        thickness=thickness,\n        cellSurface=surface,  # only for temperature calculation\n        damping=alpha,\n        demagTensor=demagTensor,\n    )\n    junction = Junction([l1])\n\n    HoePulseAmpl = 50\n    HoeDriver = AxialDriver(\n        NullDriver(), NullDriver(),\n        ScalarDriver.getStepDriver(0, HoePulseAmpl, 0.0, 1e-11))\n    junction.setLayerOerstedFieldDriver(\"all\", HoeDriver)\n    junction.setLayerAnisotropyDriver(\"all\",\n                                      ScalarDriver.getConstantDriver(Ku))\n\n    return run_simulation(junction=junction, Hvecs=Hvecs, mode=mode)\n\n\nms = 2\nwith plt.style.context(['science', 'nature']):\n    fig, ax = plt.subplots(2, 2, figsize=(4, 4), dpi=300)\n    resistance_data = defaultdict(list)\n    for i, field in enumerate(('hx', 'h45')):\n        for j, (res_mode, res_mode_data) in enumerate(\n            (('rxx', rxx), ('rxy', rxy))):\n            opt_scan = (res_mode_data[f'{field}'] * OeToAm).dropna()\n            exp_y = res_mode_data[f'{res_mode}_{field}'].dropna()\n            try:\n                assert opt_scan.shape[0] == exp_y.shape[0]\n            except:\n                print(opt_scan.shape, exp_y.shape)\n                print(res_mode, field)\n                continue\n            flabel = field.capitalize()\n            if field == 'hx':\n                phi = 1\n                flabel = r\"H ($\\phi=0^\\circ$)\"\n            elif field == 'hy':\n                phi = 90\n                flabel = r\"H ($\\phi=90^\\circ$)\"\n            elif field == 'h45':\n                phi = 45\n                flabel = r\"H ($\\phi=45^\\circ$)\"\n            else:\n                raise ValueError(\"Unknown field orientation\")\n\n            theta = 92\n            opt_vecs = get_field_scan_from_angle(opt_scan,\n                                                 theta=theta,\n                                                 phi=phi)\n            if res_mode == \"rxx\":\n                Rx0 = [exp_y.max()]\n            simulated = simulate(Ms=0.525,\n                                 Ku=1.54e5,\n                                 alpha=0.03,\n                                 mode=res_mode,\n                                 Hvecs=opt_vecs)\n            if res_mode == 'rxy':\n                exp_y -= np.mean(exp_y)\n                simulated -= np.mean(simulated)\n\n            resistance_data[f'{res_mode}_{field}'] = (opt_scan / 1e3).tolist()\n            resistance_data[f'sim_{field}_{res_mode}'] = (simulated).tolist()\n            ax[i, j].plot(resistance_data[f'{res_mode}_{field}'],\n                          exp_y,\n                          'bo',  \n                          markersize=ms,\n                          label='Exp.')\n            ax[i, j].plot(resistance_data[f'{res_mode}_{field}'],\n                          simulated,\n                          'r-', linewidth=lw,\n                        #   markersize=ms,\n                          label='Sim.')\n            ax[i, j].set_xlabel(f\"{flabel} (kA/m)\")\n            ax[i, j].set_ylabel(f\"{res_mode.capitalize()} $(\\Omega)$\")\n            ax[i, 1].yaxis.tick_right()\n        ax[i, 1].yaxis.set_label_position(\"right\")\n        ax[i, 1].set_ylabel(f\"{res_mode.capitalize()} $(\\Omega)$\",\n                            rotation=270)\n    ax[0, 0].legend(loc=8)\n\n    import matplotlib.transforms as mtransforms\n    for label, ax in zip(['(a)', '(b)', '(c)', '(d)', '(e)', '(f)'], ax.flatten()):\n        # label physical distance in and down:\n        trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,\n                                              fig.dpi_scale_trans)\n        ax.text(0.0,\n                1.0,\n                label,\n                transform=ax.transAxes + trans,\n                fontsize='medium',\n                verticalalignment='top',\n                bbox=dict(facecolor='none', edgecolor='none', pad=3.0))\n\n    fig.align_ylabels()\n    fig.subplots_adjust(wspace=0., hspace=0.45)\n</pre> ### generate data for publication from collections import defaultdict from cmtj import CVector, Layer, Junction, ScalarDriver, AxialDriver, NullDriver from cmtj.utils.linear import FieldScan from tqdm import tqdm import numpy as np  import matplotlib as mpl  mpl.rcParams['axes.formatter.useoffset'] = False fsize = 20 lw = 5  Rx0 = [304.306] Ry0 = [1.008] SMR = [-0.464] AMR = [-0.053] AHE = [-5.71] w = [3e-5] l = [2e-5]  lw = 2.5 def get_field_scan_from_angle(experiment_field, theta, phi):     st, ct, sp, cp = FieldScan._trig_compute(theta, phi)     Hx = st * cp * experiment_field     Hy = st * sp * experiment_field     Hz = ct * experiment_field      Hvecs = np.vstack((Hx, Hy, Hz)).T     return Hvecs   def calculate_resistance(Rx0, Ry0, AMR, AHE, SMR, m, number_of_layers, l, w):     if m.ndim == 2:         SxAll = np.zeros((number_of_layers, ))         SyAll = np.zeros((number_of_layers, ))      elif m.ndim == 3:         SxAll = np.zeros((number_of_layers, m.shape[2]))         SyAll = np.zeros((number_of_layers, m.shape[2]))      for i in range(0, number_of_layers):         w_l = w[i] / l[i]         SxAll[i] = 1 / (Rx0[i] + (AMR[i] * m[i, 0]**2 + SMR[i] * m[i, 1]**2))         SyAll[i] = 1 / (Ry0[i] + 0.5 * AHE[i] * m[i, 2] + (w_l) *                         (SMR[i] - AMR[i]) * m[i, 0] * m[i, 1])      Rx = 1 / np.sum(SxAll, axis=0)     Ry = 1 / np.sum(SyAll, axis=0)     return Rx, Ry   def run_simulation(junction: Junction,                    Hvecs: np.ndarray,                    mode: str,                    int_time=1e-12):     sim_time = 10e-9     layer_str = ['free']     mags = [CVector(0, 0, 1) for _ in layer_str]     Rxy, Rxx = [], []     for Hval in Hvecs:         junction.clearLog()         HDriver = AxialDriver(ScalarDriver.getConstantDriver(Hval[0]),                               ScalarDriver.getConstantDriver(Hval[1]),                               ScalarDriver.getConstantDriver(Hval[2]))         junction.setLayerExternalFieldDriver(\"all\", HDriver)         # set mags for better convergence         for i, l_str in enumerate(layer_str):             junction.setLayerMagnetisation(l_str, mags[i])          junction.runSimulation(sim_time, int_time, int_time)          # set new mags         for str_ in layer_str:             mags[i] = junction.getLayerMagnetisation(str_)          log = junction.getLog()         m = np.asarray(             [[log[f'{str_}_mx'], log[f'{str_}_my'], log[f'{str_}_mz']]              for str_ in layer_str])         dynamicRx, dynamicRy = calculate_resistance(Rx0, [0],                                                     AMR=AMR,                                                     AHE=AHE,                                                     SMR=SMR,                                                     m=m,                                                     number_of_layers=1,                                                     l=l,                                                     w=w)          Rxy.append(dynamicRy[-1])         Rxx.append(dynamicRx[-1])     if mode.lower() == 'rxx':         return np.asarray(Rxx)     else:         return np.asarray(Rxy)   def simulate(Ku, Ms, Hvecs, alpha, mode='rxx'):     demagTensor = [         CVector(0.00024164288391924, 2.71396011566517e-10,                 5.95503928124313e-14),         CVector(2.71396011566517e-10, 0.000160046006320031,                 1.32504057070646e-14),         CVector(5.95503928124313e-14, 1.32504057070646e-14, 0.999598310229469)     ]      thickness = 1.45e-9     surface = w[0] * l[0]     l1 = Layer(         id=\"free\",         mag=CVector(0, 0, 1),         anis=CVector(0., 0, 1),         Ms=Ms,         thickness=thickness,         cellSurface=surface,  # only for temperature calculation         damping=alpha,         demagTensor=demagTensor,     )     junction = Junction([l1])      HoePulseAmpl = 50     HoeDriver = AxialDriver(         NullDriver(), NullDriver(),         ScalarDriver.getStepDriver(0, HoePulseAmpl, 0.0, 1e-11))     junction.setLayerOerstedFieldDriver(\"all\", HoeDriver)     junction.setLayerAnisotropyDriver(\"all\",                                       ScalarDriver.getConstantDriver(Ku))      return run_simulation(junction=junction, Hvecs=Hvecs, mode=mode)   ms = 2 with plt.style.context(['science', 'nature']):     fig, ax = plt.subplots(2, 2, figsize=(4, 4), dpi=300)     resistance_data = defaultdict(list)     for i, field in enumerate(('hx', 'h45')):         for j, (res_mode, res_mode_data) in enumerate(             (('rxx', rxx), ('rxy', rxy))):             opt_scan = (res_mode_data[f'{field}'] * OeToAm).dropna()             exp_y = res_mode_data[f'{res_mode}_{field}'].dropna()             try:                 assert opt_scan.shape[0] == exp_y.shape[0]             except:                 print(opt_scan.shape, exp_y.shape)                 print(res_mode, field)                 continue             flabel = field.capitalize()             if field == 'hx':                 phi = 1                 flabel = r\"H ($\\phi=0^\\circ$)\"             elif field == 'hy':                 phi = 90                 flabel = r\"H ($\\phi=90^\\circ$)\"             elif field == 'h45':                 phi = 45                 flabel = r\"H ($\\phi=45^\\circ$)\"             else:                 raise ValueError(\"Unknown field orientation\")              theta = 92             opt_vecs = get_field_scan_from_angle(opt_scan,                                                  theta=theta,                                                  phi=phi)             if res_mode == \"rxx\":                 Rx0 = [exp_y.max()]             simulated = simulate(Ms=0.525,                                  Ku=1.54e5,                                  alpha=0.03,                                  mode=res_mode,                                  Hvecs=opt_vecs)             if res_mode == 'rxy':                 exp_y -= np.mean(exp_y)                 simulated -= np.mean(simulated)              resistance_data[f'{res_mode}_{field}'] = (opt_scan / 1e3).tolist()             resistance_data[f'sim_{field}_{res_mode}'] = (simulated).tolist()             ax[i, j].plot(resistance_data[f'{res_mode}_{field}'],                           exp_y,                           'bo',                             markersize=ms,                           label='Exp.')             ax[i, j].plot(resistance_data[f'{res_mode}_{field}'],                           simulated,                           'r-', linewidth=lw,                         #   markersize=ms,                           label='Sim.')             ax[i, j].set_xlabel(f\"{flabel} (kA/m)\")             ax[i, j].set_ylabel(f\"{res_mode.capitalize()} $(\\Omega)$\")             ax[i, 1].yaxis.tick_right()         ax[i, 1].yaxis.set_label_position(\"right\")         ax[i, 1].set_ylabel(f\"{res_mode.capitalize()} $(\\Omega)$\",                             rotation=270)     ax[0, 0].legend(loc=8)      import matplotlib.transforms as mtransforms     for label, ax in zip(['(a)', '(b)', '(c)', '(d)', '(e)', '(f)'], ax.flatten()):         # label physical distance in and down:         trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,                                               fig.dpi_scale_trans)         ax.text(0.0,                 1.0,                 label,                 transform=ax.transAxes + trans,                 fontsize='medium',                 verticalalignment='top',                 bbox=dict(facecolor='none', edgecolor='none', pad=3.0))      fig.align_ylabels()     fig.subplots_adjust(wspace=0., hspace=0.45) In\u00a0[6]: Copied! <pre>from cmtj import SolverMode\n\n\ndef run_simulation_temp(\n    junction: Junction, Hvecs: np.ndarray, mode: str, int_time=1e-13\n):\n    sim_time = 10e-9\n    layer_str = [\"free\"]\n    mags = [CVector(0, 0, 1) for _ in layer_str]\n    Rxy, Rxx = [], []\n    # the temperature driver is set to a very large number due to:\n    # - large surface of the cell \n    # - large field\n    junction.setLayerTemperatureDriver(\"all\", ScalarDriver.getConstantDriver(1e6))\n    for Hval in Hvecs:\n        junction.clearLog()\n        HDriver = AxialDriver(\n            ScalarDriver.getConstantDriver(Hval[0]),\n            ScalarDriver.getConstantDriver(Hval[1]),\n            ScalarDriver.getConstantDriver(Hval[2]),\n        )\n        junction.setLayerExternalFieldDriver(\"all\", HDriver)\n        # set mags for better convergence\n        for i, l_str in enumerate(layer_str):\n            junction.setLayerMagnetisation(l_str, mags[i])\n\n        junction.runSimulation(sim_time, int_time, int_time, solverMode=SolverMode.Heun)\n\n        # set new mags\n        for str_ in layer_str:\n            mags[i] = junction.getLayerMagnetisation(str_)\n\n        log = junction.getLog()\n        m = np.asarray(\n            [\n                [log[f\"{str_}_mx\"], log[f\"{str_}_my\"], log[f\"{str_}_mz\"]]\n                for str_ in layer_str\n            ]\n        )\n        dynamicRx, dynamicRy = calculate_resistance(\n            Rx0, [0], AMR=AMR, AHE=AHE, SMR=SMR, m=m, number_of_layers=1, l=l, w=w\n        )\n\n        Rxy.append(dynamicRy[-1])\n        Rxx.append(dynamicRx[-1])\n    return np.asarray(Rxx) if mode.lower() == \"rxx\" else np.asarray(Rxy)\n\n\ndef simulate(Ku, Ms, Hvecs, alpha, mode=\"rxx\"):\n    demagTensor = [\n        CVector(0.00024164288391924, 2.71396011566517e-10, 5.95503928124313e-14),\n        CVector(2.71396011566517e-10, 0.000160046006320031, 1.32504057070646e-14),\n        CVector(5.95503928124313e-14, 1.32504057070646e-14, 0.999598310229469),\n    ]\n\n    thickness = 1.45e-9\n    surface = w[0] * l[0] / 10\n    l1 = Layer(\n        id=\"free\",\n        mag=CVector(0, 0, 1),\n        anis=CVector(0, 0.0, 1),\n        Ms=Ms,\n        thickness=thickness,\n        cellSurface=surface,  # only for temperature calculation\n        damping=alpha,\n        demagTensor=demagTensor,\n    )\n    junction = Junction([l1])\n\n    HoePulseAmpl = 50\n    HoeDriver = AxialDriver(\n        NullDriver(),\n        NullDriver(),\n        ScalarDriver.getStepDriver(0, HoePulseAmpl, 0.0, 1e-11),\n    )\n    junction.setLayerOerstedFieldDriver(\"all\", HoeDriver)\n    junction.setLayerAnisotropyDriver(\"all\", ScalarDriver.getConstantDriver(Ku))\n\n    return run_simulation_temp(junction=junction, Hvecs=Hvecs, mode=mode)\n\n\nms = 2\nwith plt.style.context([\"science\", \"nature\"]):\n    fig, ax = plt.subplots(2, 2, figsize=(4, 4), dpi=300)\n    resistance_data = defaultdict(list)\n    for i, field in enumerate(tqdm((\"hx\", \"h45\"))):\n        for j, (res_mode, res_mode_data) in enumerate(((\"rxx\", rxx), (\"rxy\", rxy))):\n            opt_scan = (res_mode_data[f\"{field}\"] * OeToAm).dropna()\n            exp_y = res_mode_data[f\"{res_mode}_{field}\"].dropna()\n            try:\n                assert opt_scan.shape[0] == exp_y.shape[0]\n            except Exception:\n                print(opt_scan.shape, exp_y.shape)\n                print(res_mode, field)\n                continue\n            flabel = field.capitalize()\n            if field == \"hx\":\n                phi = 1\n                flabel = r\"H ($\\phi=0^\\circ$)\"\n            elif field == \"hy\":\n                phi = 90\n                flabel = r\"H ($\\phi=90^\\circ$)\"\n            elif field == \"h45\":\n                phi = 45\n                flabel = r\"H ($\\phi=45^\\circ$)\"\n            else:\n                raise ValueError(\"Unknown field orientation\")\n\n            theta = 92\n            opt_vecs = get_field_scan_from_angle(opt_scan, theta=theta, phi=phi)\n            if res_mode == \"rxx\":\n                Rx0 = [exp_y.max()]\n            simulated = simulate(\n                Ms=0.525, Ku=1.54e5, alpha=0.03, mode=res_mode, Hvecs=opt_vecs\n            )\n            if res_mode == \"rxy\":\n                exp_y -= np.mean(exp_y)\n                simulated -= np.mean(simulated)\n\n            resistance_data[f\"{res_mode}_{field}\"] = (opt_scan / 1e3).tolist()\n            resistance_data[f\"sim_{field}_{res_mode}\"] = (simulated).tolist()\n            ax[i, j].plot(\n                resistance_data[f\"{res_mode}_{field}\"],\n                exp_y,\n                \"bo-\",\n                markersize=ms,\n                label=\"Exp.\",\n            )\n            ax[i, j].plot(\n                resistance_data[f\"{res_mode}_{field}\"],\n                simulated,\n                \"ro\",\n                markersize=ms,\n                label=\"Sim.\",\n            )\n            ax[i, j].set_xlabel(f\"{flabel} [kA/m]\")\n            ax[i, j].set_ylabel(f\"{res_mode.capitalize()} $[\\Omega]$\")\n            ax[i, 1].yaxis.tick_right()\n        ax[i, 1].yaxis.set_label_position(\"right\")\n        ax[i, 1].set_ylabel(f\"{res_mode.capitalize()} $[\\Omega]$\", rotation=270)\n    ax[0, 0].legend(loc=8)\n\n    import matplotlib.transforms as mtransforms\n\n    for label, ax in zip([\"a)\", \"b)\", \"c)\", \"d)\", \"e)\", \"f)\"], ax.flatten()):\n        # label physical distance in and down:\n        trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72, fig.dpi_scale_trans)\n        ax.text(\n            0.0,\n            1.0,\n            label,\n            transform=ax.transAxes + trans,\n            fontsize=\"medium\",\n            verticalalignment=\"top\",\n            bbox=dict(facecolor=\"none\", edgecolor=\"none\", pad=3.0),\n        )\n\n    fig.align_ylabels()\n    fig.subplots_adjust(wspace=0.0, hspace=0.45)\n</pre> from cmtj import SolverMode   def run_simulation_temp(     junction: Junction, Hvecs: np.ndarray, mode: str, int_time=1e-13 ):     sim_time = 10e-9     layer_str = [\"free\"]     mags = [CVector(0, 0, 1) for _ in layer_str]     Rxy, Rxx = [], []     # the temperature driver is set to a very large number due to:     # - large surface of the cell      # - large field     junction.setLayerTemperatureDriver(\"all\", ScalarDriver.getConstantDriver(1e6))     for Hval in Hvecs:         junction.clearLog()         HDriver = AxialDriver(             ScalarDriver.getConstantDriver(Hval[0]),             ScalarDriver.getConstantDriver(Hval[1]),             ScalarDriver.getConstantDriver(Hval[2]),         )         junction.setLayerExternalFieldDriver(\"all\", HDriver)         # set mags for better convergence         for i, l_str in enumerate(layer_str):             junction.setLayerMagnetisation(l_str, mags[i])          junction.runSimulation(sim_time, int_time, int_time, solverMode=SolverMode.Heun)          # set new mags         for str_ in layer_str:             mags[i] = junction.getLayerMagnetisation(str_)          log = junction.getLog()         m = np.asarray(             [                 [log[f\"{str_}_mx\"], log[f\"{str_}_my\"], log[f\"{str_}_mz\"]]                 for str_ in layer_str             ]         )         dynamicRx, dynamicRy = calculate_resistance(             Rx0, [0], AMR=AMR, AHE=AHE, SMR=SMR, m=m, number_of_layers=1, l=l, w=w         )          Rxy.append(dynamicRy[-1])         Rxx.append(dynamicRx[-1])     return np.asarray(Rxx) if mode.lower() == \"rxx\" else np.asarray(Rxy)   def simulate(Ku, Ms, Hvecs, alpha, mode=\"rxx\"):     demagTensor = [         CVector(0.00024164288391924, 2.71396011566517e-10, 5.95503928124313e-14),         CVector(2.71396011566517e-10, 0.000160046006320031, 1.32504057070646e-14),         CVector(5.95503928124313e-14, 1.32504057070646e-14, 0.999598310229469),     ]      thickness = 1.45e-9     surface = w[0] * l[0] / 10     l1 = Layer(         id=\"free\",         mag=CVector(0, 0, 1),         anis=CVector(0, 0.0, 1),         Ms=Ms,         thickness=thickness,         cellSurface=surface,  # only for temperature calculation         damping=alpha,         demagTensor=demagTensor,     )     junction = Junction([l1])      HoePulseAmpl = 50     HoeDriver = AxialDriver(         NullDriver(),         NullDriver(),         ScalarDriver.getStepDriver(0, HoePulseAmpl, 0.0, 1e-11),     )     junction.setLayerOerstedFieldDriver(\"all\", HoeDriver)     junction.setLayerAnisotropyDriver(\"all\", ScalarDriver.getConstantDriver(Ku))      return run_simulation_temp(junction=junction, Hvecs=Hvecs, mode=mode)   ms = 2 with plt.style.context([\"science\", \"nature\"]):     fig, ax = plt.subplots(2, 2, figsize=(4, 4), dpi=300)     resistance_data = defaultdict(list)     for i, field in enumerate(tqdm((\"hx\", \"h45\"))):         for j, (res_mode, res_mode_data) in enumerate(((\"rxx\", rxx), (\"rxy\", rxy))):             opt_scan = (res_mode_data[f\"{field}\"] * OeToAm).dropna()             exp_y = res_mode_data[f\"{res_mode}_{field}\"].dropna()             try:                 assert opt_scan.shape[0] == exp_y.shape[0]             except Exception:                 print(opt_scan.shape, exp_y.shape)                 print(res_mode, field)                 continue             flabel = field.capitalize()             if field == \"hx\":                 phi = 1                 flabel = r\"H ($\\phi=0^\\circ$)\"             elif field == \"hy\":                 phi = 90                 flabel = r\"H ($\\phi=90^\\circ$)\"             elif field == \"h45\":                 phi = 45                 flabel = r\"H ($\\phi=45^\\circ$)\"             else:                 raise ValueError(\"Unknown field orientation\")              theta = 92             opt_vecs = get_field_scan_from_angle(opt_scan, theta=theta, phi=phi)             if res_mode == \"rxx\":                 Rx0 = [exp_y.max()]             simulated = simulate(                 Ms=0.525, Ku=1.54e5, alpha=0.03, mode=res_mode, Hvecs=opt_vecs             )             if res_mode == \"rxy\":                 exp_y -= np.mean(exp_y)                 simulated -= np.mean(simulated)              resistance_data[f\"{res_mode}_{field}\"] = (opt_scan / 1e3).tolist()             resistance_data[f\"sim_{field}_{res_mode}\"] = (simulated).tolist()             ax[i, j].plot(                 resistance_data[f\"{res_mode}_{field}\"],                 exp_y,                 \"bo-\",                 markersize=ms,                 label=\"Exp.\",             )             ax[i, j].plot(                 resistance_data[f\"{res_mode}_{field}\"],                 simulated,                 \"ro\",                 markersize=ms,                 label=\"Sim.\",             )             ax[i, j].set_xlabel(f\"{flabel} [kA/m]\")             ax[i, j].set_ylabel(f\"{res_mode.capitalize()} $[\\Omega]$\")             ax[i, 1].yaxis.tick_right()         ax[i, 1].yaxis.set_label_position(\"right\")         ax[i, 1].set_ylabel(f\"{res_mode.capitalize()} $[\\Omega]$\", rotation=270)     ax[0, 0].legend(loc=8)      import matplotlib.transforms as mtransforms      for label, ax in zip([\"a)\", \"b)\", \"c)\", \"d)\", \"e)\", \"f)\"], ax.flatten()):         # label physical distance in and down:         trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72, fig.dpi_scale_trans)         ax.text(             0.0,             1.0,             label,             transform=ax.transAxes + trans,             fontsize=\"medium\",             verticalalignment=\"top\",             bbox=dict(facecolor=\"none\", edgecolor=\"none\", pad=3.0),         )      fig.align_ylabels()     fig.subplots_adjust(wspace=0.0, hspace=0.45) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:42&lt;00:00, 21.48s/it]\n</pre> In\u00a0[7]: Copied! <pre>from scipy.fft import fft, fftfreq\n\nRx0 = [304.306]\nRy0 = [3]\nSMR = [-0.464]\nAMR = [-0.053]\nAHE = [-5.71]\nw = [3e-5]\nl = [2e-5]\n\n\ndef compute_vsd(dynamicR, integration_step, dynamicI):\n    SD = dynamicI * dynamicR\n    # SD -= np.mean(SD)\n    # SD *= hann(len(SD))\n    y = fft(SD) * (2 / len(SD))\n    amp = np.abs(y)\n    phase = np.angle(y)\n    freqs = fftfreq(len(y), integration_step)\n    y = y[: len(y) // 2]\n    freqs = freqs[: len(freqs) // 2]\n    return amp, phase, freqs\n\n\ndef calculate_resistance(Rx0, Ry0, AMR, AHE, SMR, m, number_of_layers, l, w):\n    if m.ndim == 2:\n        SxAll = np.zeros((number_of_layers,))\n        SyAll = np.zeros((number_of_layers,))\n\n    elif m.ndim == 3:\n        SxAll = np.zeros((number_of_layers, m.shape[2]))\n        SyAll = np.zeros((number_of_layers, m.shape[2]))\n\n    for i in range(0, number_of_layers):\n        w_l = w[i] / l[i]\n        SxAll[i] = 1 / (Rx0[i] + (AMR[i] * m[i, 0] ** 2 + SMR[i] * m[i, 1] ** 2))\n        SyAll[i] = 1 / (\n            Ry0[i]\n            + 0.5 * AHE[i] * m[i, 2]\n            + (w_l) * (SMR[i] - AMR[i]) * m[i, 0] * m[i, 1]\n        )\n\n    Rx = 1 / np.sum(SxAll, axis=0)\n    Ry = 1 / np.sum(SyAll, axis=0)\n    return Rx, Ry\n\n\ndef find_max_f_frequency(freqs: np.ndarray, values: np.ndarray, frequency: float):\n    # take between 0 and max\n    freq_indx = np.abs(freqs - frequency).argmin()\n    max_value = values[freq_indx]\n    max_freq = freqs[freq_indx]\n    return max_value, max_freq\n\n\ndef compute_harmonics(mode, theta, Ms, Ku, Hdl, Hfl, back=True):\n    if mode == \"hx\":\n        phi = 1\n    elif mode == \"hy\":\n        phi = 87\n    else:\n        raise ValueError(\"Unknown mode\")\n\n    demagTensor = [\n        CVector(0.0, 0.0, 0.0),\n        CVector(0.0, 0.0, 0.0),\n        CVector(0.0, 0.0, 1.0),\n    ]\n\n    thickness = 1.45e-9\n    I_rf = 2.68e-3\n\n    s_time = 100e-9\n    int_step = 1e-12\n\n    l1_params = {\n        \"Ms\": Ms,\n        \"thickness\": thickness,\n        \"anis\": CVector(0.0, 0.0, 1.0),\n        \"mag\": CVector(0, 0, 1.0),\n        \"cellSurface\": 1.0,\n        \"demagTensor\": demagTensor,\n        \"damping\": 0.003,\n    }\n    l1 = Layer(id=\"free\", **l1_params)\n    l1.setReferenceLayer(CVector(0.0, 1.0, 0.0))\n    layer_str = [\"free\"]\n    layers = [l1]\n    junction = Junction(layers=layers)\n    junction.setLayerAnisotropyDriver(\"all\", ScalarDriver.getConstantDriver(Ku))\n\n    frequency = 0.8e9\n\n    his = 300\n    Hscan, Hvecs = FieldScan.amplitude_scan(-400e3, 400e3, his, theta, phi, back=back)\n    amp_diag1f = np.zeros((len(Hscan),))\n    phase_diag2f = np.zeros((len(Hscan),))\n    junction.setLayerDampingLikeTorqueDriver(\n        \"all\", ScalarDriver.getSineDriver(0, Hdl, frequency, 0)\n    )\n    junction.setLayerFieldLikeTorqueDriver(\n        \"all\", ScalarDriver.getSineDriver(0, Hfl, frequency, 0)\n    )\n    mags = [CVector(0, 0, 1) for _ in layer_str]\n    for hi, Hval in enumerate(Hvecs):\n        junction.clearLog()\n        HDriver = AxialDriver(\n            ScalarDriver.getConstantDriver(Hval[0]),\n            ScalarDriver.getConstantDriver(Hval[1]),\n            ScalarDriver.getConstantDriver(Hval[2]),\n        )\n        junction.setLayerExternalFieldDriver(\"all\", HDriver)\n        # set mags for better convergence\n        for i, l_str in enumerate(layer_str):\n            junction.setLayerMagnetisation(l_str, mags[i])\n\n        junction.runSimulation(s_time, int_step, int_step)\n        # set new mags\n        for str_ in layer_str:\n            mags[i] = junction.getLayerMagnetisation(str_)\n\n        log = junction.getLog()\n        m = np.asarray(\n            [\n                [log[f\"{str_}_mx\"], log[f\"{str_}_my\"], log[f\"{str_}_mz\"]]\n                for str_ in layer_str\n            ]\n        )\n\n        dynamicRx, dynamicRy = calculate_resistance(\n            Rx0, Ry0, AMR, AHE, SMR, m, len(layer_str), l, w\n        )\n\n        lt = np.asarray(log[\"time\"])\n        dynamicI = I_rf * np.sin(2 * np.pi * frequency * lt)\n        org_amp, org_phase, freqs_org = compute_vsd(\n            dynamicR=dynamicRy, integration_step=int_step, dynamicI=dynamicI\n        )\n\n        max_phase2f, max_freq = find_max_f_frequency(\n            freqs_org, org_phase, 2 * frequency\n        )\n        max_amp1f, _ = find_max_f_frequency(freqs_org, org_amp, frequency)\n        max_amp2f, _ = find_max_f_frequency(freqs_org, org_amp, 2 * frequency)\n        amp_diag1f[hi] = max_amp1f\n        phase_diag2f[hi] = np.cos(max_phase2f) * max_amp2f\n    return amp_diag1f, phase_diag2f, Hscan\n\n\nMs = 0.525\nKu = 1.54e5\nHdl = -420\nHfl = 574\ntheta_hx = 90.2\ntheta_hy = 90.2\n\namp_diag1f_Hx, phase_diag2f_Hx, Hscan_Hx = compute_harmonics(\n    \"hx\", theta=theta_hx, Ms=Ms, Ku=Ku, Hdl=Hdl, Hfl=Hfl\n)\namp_diag1f_Hy, phase_diag2f_Hy, Hscan_Hy = compute_harmonics(\n    \"hy\", theta=theta_hy, Ms=Ms, Ku=Ku, Hdl=Hdl, Hfl=Hfl\n)\n</pre> from scipy.fft import fft, fftfreq  Rx0 = [304.306] Ry0 = [3] SMR = [-0.464] AMR = [-0.053] AHE = [-5.71] w = [3e-5] l = [2e-5]   def compute_vsd(dynamicR, integration_step, dynamicI):     SD = dynamicI * dynamicR     # SD -= np.mean(SD)     # SD *= hann(len(SD))     y = fft(SD) * (2 / len(SD))     amp = np.abs(y)     phase = np.angle(y)     freqs = fftfreq(len(y), integration_step)     y = y[: len(y) // 2]     freqs = freqs[: len(freqs) // 2]     return amp, phase, freqs   def calculate_resistance(Rx0, Ry0, AMR, AHE, SMR, m, number_of_layers, l, w):     if m.ndim == 2:         SxAll = np.zeros((number_of_layers,))         SyAll = np.zeros((number_of_layers,))      elif m.ndim == 3:         SxAll = np.zeros((number_of_layers, m.shape[2]))         SyAll = np.zeros((number_of_layers, m.shape[2]))      for i in range(0, number_of_layers):         w_l = w[i] / l[i]         SxAll[i] = 1 / (Rx0[i] + (AMR[i] * m[i, 0] ** 2 + SMR[i] * m[i, 1] ** 2))         SyAll[i] = 1 / (             Ry0[i]             + 0.5 * AHE[i] * m[i, 2]             + (w_l) * (SMR[i] - AMR[i]) * m[i, 0] * m[i, 1]         )      Rx = 1 / np.sum(SxAll, axis=0)     Ry = 1 / np.sum(SyAll, axis=0)     return Rx, Ry   def find_max_f_frequency(freqs: np.ndarray, values: np.ndarray, frequency: float):     # take between 0 and max     freq_indx = np.abs(freqs - frequency).argmin()     max_value = values[freq_indx]     max_freq = freqs[freq_indx]     return max_value, max_freq   def compute_harmonics(mode, theta, Ms, Ku, Hdl, Hfl, back=True):     if mode == \"hx\":         phi = 1     elif mode == \"hy\":         phi = 87     else:         raise ValueError(\"Unknown mode\")      demagTensor = [         CVector(0.0, 0.0, 0.0),         CVector(0.0, 0.0, 0.0),         CVector(0.0, 0.0, 1.0),     ]      thickness = 1.45e-9     I_rf = 2.68e-3      s_time = 100e-9     int_step = 1e-12      l1_params = {         \"Ms\": Ms,         \"thickness\": thickness,         \"anis\": CVector(0.0, 0.0, 1.0),         \"mag\": CVector(0, 0, 1.0),         \"cellSurface\": 1.0,         \"demagTensor\": demagTensor,         \"damping\": 0.003,     }     l1 = Layer(id=\"free\", **l1_params)     l1.setReferenceLayer(CVector(0.0, 1.0, 0.0))     layer_str = [\"free\"]     layers = [l1]     junction = Junction(layers=layers)     junction.setLayerAnisotropyDriver(\"all\", ScalarDriver.getConstantDriver(Ku))      frequency = 0.8e9      his = 300     Hscan, Hvecs = FieldScan.amplitude_scan(-400e3, 400e3, his, theta, phi, back=back)     amp_diag1f = np.zeros((len(Hscan),))     phase_diag2f = np.zeros((len(Hscan),))     junction.setLayerDampingLikeTorqueDriver(         \"all\", ScalarDriver.getSineDriver(0, Hdl, frequency, 0)     )     junction.setLayerFieldLikeTorqueDriver(         \"all\", ScalarDriver.getSineDriver(0, Hfl, frequency, 0)     )     mags = [CVector(0, 0, 1) for _ in layer_str]     for hi, Hval in enumerate(Hvecs):         junction.clearLog()         HDriver = AxialDriver(             ScalarDriver.getConstantDriver(Hval[0]),             ScalarDriver.getConstantDriver(Hval[1]),             ScalarDriver.getConstantDriver(Hval[2]),         )         junction.setLayerExternalFieldDriver(\"all\", HDriver)         # set mags for better convergence         for i, l_str in enumerate(layer_str):             junction.setLayerMagnetisation(l_str, mags[i])          junction.runSimulation(s_time, int_step, int_step)         # set new mags         for str_ in layer_str:             mags[i] = junction.getLayerMagnetisation(str_)          log = junction.getLog()         m = np.asarray(             [                 [log[f\"{str_}_mx\"], log[f\"{str_}_my\"], log[f\"{str_}_mz\"]]                 for str_ in layer_str             ]         )          dynamicRx, dynamicRy = calculate_resistance(             Rx0, Ry0, AMR, AHE, SMR, m, len(layer_str), l, w         )          lt = np.asarray(log[\"time\"])         dynamicI = I_rf * np.sin(2 * np.pi * frequency * lt)         org_amp, org_phase, freqs_org = compute_vsd(             dynamicR=dynamicRy, integration_step=int_step, dynamicI=dynamicI         )          max_phase2f, max_freq = find_max_f_frequency(             freqs_org, org_phase, 2 * frequency         )         max_amp1f, _ = find_max_f_frequency(freqs_org, org_amp, frequency)         max_amp2f, _ = find_max_f_frequency(freqs_org, org_amp, 2 * frequency)         amp_diag1f[hi] = max_amp1f         phase_diag2f[hi] = np.cos(max_phase2f) * max_amp2f     return amp_diag1f, phase_diag2f, Hscan   Ms = 0.525 Ku = 1.54e5 Hdl = -420 Hfl = 574 theta_hx = 90.2 theta_hy = 90.2  amp_diag1f_Hx, phase_diag2f_Hx, Hscan_Hx = compute_harmonics(     \"hx\", theta=theta_hx, Ms=Ms, Ku=Ku, Hdl=Hdl, Hfl=Hfl ) amp_diag1f_Hy, phase_diag2f_Hy, Hscan_Hy = compute_harmonics(     \"hy\", theta=theta_hy, Ms=Ms, Ku=Ku, Hdl=Hdl, Hfl=Hfl ) In\u00a0[8]: Copied! <pre>from mpl_toolkits.axes_grid1.inset_locator import inset_axes\n\namp_diag1f_Hy -= amp_diag1f_Hy.mean()\namp_diag1f_Hx -= amp_diag1f_Hx.mean()\nphase_diag2f_Hy -= phase_diag2f_Hy[0]\nphase_diag2f_Hx -= phase_diag2f_Hx[0]\n\ndat = {\n    'Hx': Hscan_Hx,\n    'Hy': Hscan_Hy,\n    'Hx1f': amp_diag1f_Hx,\n    'Hx2f': phase_diag2f_Hx,\n    'Hy1f': amp_diag1f_Hy,\n    'Hy2f': phase_diag2f_Hy\n}\nhar1f = pd.read_csv(\"./data/Ta_CoFeB/5360_1f_hx_hy.csv\", sep=',')\nhar2f = pd.read_csv(\"./data/Ta_CoFeB/5360_2f_hx_hy.csv\", sep=',')\n\nms = 2.5\nsim_ms = 1.5\nscale = 1e3\nwith plt.style.context(['science', 'nature']):\n    fig, ax = plt.subplots(\n        2,\n        2,\n        sharex='col',\n        # sharey='row',\n        dpi=400,\n    )\n    lw = 1.5\n    for i, ho in enumerate(('hx', 'hy')):\n        mode = ho.capitalize()\n        har1f_H = (har1f[f'{mode}'] * OeToAm).dropna() / 1e3\n        har1f_a = har1f[f'{mode}_1f_voltage'].dropna()\n        har1f_a -= har1f_a.mean()\n\n        har2f_H = (har2f[f'{mode}'] * OeToAm).dropna() / 1e3\n        har2f_a = har2f[f'{mode}_2f_voltage'].dropna()\n        har2f_a -= har2f_a[0]\n\n        ax[i, 0].plot(har1f_H,\n                      har1f_a * scale,\n                      \"bo\",\n                      markersize=ms,\n                      label='Exp.')\n        ax[i, 0].plot(dat[mode] / 1e3,\n                      dat[f\"{mode}1f\"] * scale,\n                      \"-\", linewidth=2, color='r',\n                      alpha=1,\n                      markersize=sim_ms,\n                      label='Sim.')\n\n        axins = inset_axes(ax[i, 0],\n                           width=\"50%\",\n                           height=\"50%\",\n                           loc=3,\n                           borderpad=1)\n        axins.tick_params(labelleft=False, labelbottom=False)\n        axins.set_xlim([-400, 400])\n        axins.plot(har1f_H,\n                   har1f_a * scale,\n                   \"bo\",\n                   markersize=ms,\n                   label='Exp.')\n        axins.plot(dat[mode] / 1e3,\n                   dat[f\"{mode}1f\"] * scale,\n                   \"ro\",\n                   alpha=1,\n                   markersize=sim_ms,\n                   label='Sim.')\n        ax[i, 0].set_ylim([4, 8.5])\n        ax[i, 0].set_xlim([-100, 100])\n\n        ax[i, 1].plot(har2f_H,\n                      har2f_a * scale,\n                      \"bo\",\n                      markersize=ms,\n                      label='Exp.')\n        ax[i, 1].plot(dat[mode] / 1e3,\n                      dat[f\"{mode}2f\"] * scale,\n                      \"-\", color='r', linewidth=2,\n                      alpha=1,\n                      markersize=sim_ms,\n                      label='Sim.')\n\n        ax[i, 1].set_xlim([-400, 400])\n        if ho == 'hx':\n            ax[i, 1].set_ylim([-4.5e-4 * scale / 10, 4.5e-4 * scale / 10])\n        else:\n            ax[i, 1].set_ylim([-4.5e-5 * scale / 4, 7.5e-5 * scale / 4])\n    ax[1, 0].set_xlabel(\"H (kA/m)\")\n    ax[1, 1].set_xlabel(\"H (kA/m)\")\n\n    ax[0, 0].set_ylabel(r\"$V_{\\omega}$ at $H_\\textrm{x}$(mV)\")\n    ax[1, 0].set_ylabel(r\"$V_{\\omega}$ at $H_\\textrm{y}$(mV)\")\n\n    ax[0, 1].set_ylabel(r\"$V_{2\\omega}$ at $H_\\textrm{x}$(mV)\",\n                        rotation=270,\n                        labelpad=9.5)\n    ax[1, 1].set_ylabel(r\"$V_{2\\omega}$ at $H_\\textrm{y}$(mV)\",\n                        rotation=270,\n                        labelpad=9.5)\n\n    ax[0, 1].yaxis.tick_right()\n    ax[1, 1].yaxis.tick_right()\n    ax[0, 1].yaxis.set_label_position(\"right\")\n    ax[1, 1].yaxis.set_label_position(\"right\")\n    fig.align_ylabels(ax)\n    fig.subplots_adjust(wspace=0., hspace=0.)\n    ax[0, 1].legend(loc=3)\n    # fig.tight_layout()\n    import matplotlib.transforms as mtransforms\n    for label, ax in zip(['(a)', '(b)', '(c)', '(d)'], ax.flatten()):\n        # label physical distance in and down:\n        trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,\n                                              fig.dpi_scale_trans)\n        ax.text(0.0,\n                1.0,\n                label,\n                transform=ax.transAxes + trans,\n                fontsize='medium',\n                verticalalignment='top',\n                bbox=dict(facecolor='none', edgecolor='none', pad=3.0))\n</pre> from mpl_toolkits.axes_grid1.inset_locator import inset_axes  amp_diag1f_Hy -= amp_diag1f_Hy.mean() amp_diag1f_Hx -= amp_diag1f_Hx.mean() phase_diag2f_Hy -= phase_diag2f_Hy[0] phase_diag2f_Hx -= phase_diag2f_Hx[0]  dat = {     'Hx': Hscan_Hx,     'Hy': Hscan_Hy,     'Hx1f': amp_diag1f_Hx,     'Hx2f': phase_diag2f_Hx,     'Hy1f': amp_diag1f_Hy,     'Hy2f': phase_diag2f_Hy } har1f = pd.read_csv(\"./data/Ta_CoFeB/5360_1f_hx_hy.csv\", sep=',') har2f = pd.read_csv(\"./data/Ta_CoFeB/5360_2f_hx_hy.csv\", sep=',')  ms = 2.5 sim_ms = 1.5 scale = 1e3 with plt.style.context(['science', 'nature']):     fig, ax = plt.subplots(         2,         2,         sharex='col',         # sharey='row',         dpi=400,     )     lw = 1.5     for i, ho in enumerate(('hx', 'hy')):         mode = ho.capitalize()         har1f_H = (har1f[f'{mode}'] * OeToAm).dropna() / 1e3         har1f_a = har1f[f'{mode}_1f_voltage'].dropna()         har1f_a -= har1f_a.mean()          har2f_H = (har2f[f'{mode}'] * OeToAm).dropna() / 1e3         har2f_a = har2f[f'{mode}_2f_voltage'].dropna()         har2f_a -= har2f_a[0]          ax[i, 0].plot(har1f_H,                       har1f_a * scale,                       \"bo\",                       markersize=ms,                       label='Exp.')         ax[i, 0].plot(dat[mode] / 1e3,                       dat[f\"{mode}1f\"] * scale,                       \"-\", linewidth=2, color='r',                       alpha=1,                       markersize=sim_ms,                       label='Sim.')          axins = inset_axes(ax[i, 0],                            width=\"50%\",                            height=\"50%\",                            loc=3,                            borderpad=1)         axins.tick_params(labelleft=False, labelbottom=False)         axins.set_xlim([-400, 400])         axins.plot(har1f_H,                    har1f_a * scale,                    \"bo\",                    markersize=ms,                    label='Exp.')         axins.plot(dat[mode] / 1e3,                    dat[f\"{mode}1f\"] * scale,                    \"ro\",                    alpha=1,                    markersize=sim_ms,                    label='Sim.')         ax[i, 0].set_ylim([4, 8.5])         ax[i, 0].set_xlim([-100, 100])          ax[i, 1].plot(har2f_H,                       har2f_a * scale,                       \"bo\",                       markersize=ms,                       label='Exp.')         ax[i, 1].plot(dat[mode] / 1e3,                       dat[f\"{mode}2f\"] * scale,                       \"-\", color='r', linewidth=2,                       alpha=1,                       markersize=sim_ms,                       label='Sim.')          ax[i, 1].set_xlim([-400, 400])         if ho == 'hx':             ax[i, 1].set_ylim([-4.5e-4 * scale / 10, 4.5e-4 * scale / 10])         else:             ax[i, 1].set_ylim([-4.5e-5 * scale / 4, 7.5e-5 * scale / 4])     ax[1, 0].set_xlabel(\"H (kA/m)\")     ax[1, 1].set_xlabel(\"H (kA/m)\")      ax[0, 0].set_ylabel(r\"$V_{\\omega}$ at $H_\\textrm{x}$(mV)\")     ax[1, 0].set_ylabel(r\"$V_{\\omega}$ at $H_\\textrm{y}$(mV)\")      ax[0, 1].set_ylabel(r\"$V_{2\\omega}$ at $H_\\textrm{x}$(mV)\",                         rotation=270,                         labelpad=9.5)     ax[1, 1].set_ylabel(r\"$V_{2\\omega}$ at $H_\\textrm{y}$(mV)\",                         rotation=270,                         labelpad=9.5)      ax[0, 1].yaxis.tick_right()     ax[1, 1].yaxis.tick_right()     ax[0, 1].yaxis.set_label_position(\"right\")     ax[1, 1].yaxis.set_label_position(\"right\")     fig.align_ylabels(ax)     fig.subplots_adjust(wspace=0., hspace=0.)     ax[0, 1].legend(loc=3)     # fig.tight_layout()     import matplotlib.transforms as mtransforms     for label, ax in zip(['(a)', '(b)', '(c)', '(d)'], ax.flatten()):         # label physical distance in and down:         trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,                                               fig.dpi_scale_trans)         ax.text(0.0,                 1.0,                 label,                 transform=ax.transAxes + trans,                 fontsize='medium',                 verticalalignment='top',                 bbox=dict(facecolor='none', edgecolor='none', pad=3.0))  In\u00a0[9]: Copied! <pre>from scipy.fft import fft, fftshift, fftfreq\nfrom scipy.signal.windows import hann\n\nRx0 = [304.306]\nRy0 = [3]\nSMR = [-0.464]\nAMR = [-0.053]\nAHE = [-5.71]\nw = [3e-5]\nl = [2e-5]\n\nN = 15\neps = 0.05\nMs = 0.525\nKu = 1.54e5\ntheta = 92\n\nHdl = -420\nHfl = 574\n\ntheta_space = np.linspace(\n    90.1, 90.1 * (1 + eps) / (1 - eps), N\n)  # we need to avoid changing sign\nMs_space = np.linspace((1 - eps) * Ms, (1 + eps) * Ms, N)\nKu_space = np.linspace((1 - eps) * Ku, (1 + eps) * Ku, N)\nscans = zip([\"theta\", \"Ms\", \"Ku\"], [theta_space, Ms_space, Ku_space])\n# scans = zip(['Hdl', 'Hfl', 'Ms', 'Ku'],\n#             [Hdl_space, Hfl_space, Ms_space, Ku_space])\nensemble_data = defaultdict(list)\nfor MODE in (\"Hx\", \"Hy\"):\n    mode = MODE.lower()\n    for n, v in zip([\"theta\", \"Ms\", \"Ku\"], [theta_space, Ms_space, Ku_space]):\n        for v_ in tqdm(v, desc=f\"Computing: {n} for {MODE}\"):\n            if n == \"theta\":\n                amp_diag1f, phase_diag2f, Hscan = compute_harmonics(\n                    mode, theta=v_, Ms=Ms, Ku=Ku, Hdl=Hdl, Hfl=Hfl\n                )\n            elif n == \"Ms\":\n                amp_diag1f, phase_diag2f, Hscan = compute_harmonics(\n                    mode, theta=theta, Ms=v_, Ku=Ku, Hdl=Hdl, Hfl=Hfl\n                )\n            elif n == \"Ku\":\n                amp_diag1f, phase_diag2f, Hscan = compute_harmonics(\n                    mode, theta=theta, Ms=Ms, Ku=v_, Hdl=Hdl, Hfl=Hfl\n                )\n            elif n == \"Hdl\":\n                amp_diag1f, phase_diag2f, Hscan = compute_harmonics(\n                    mode, theta=theta, Ms=Ms, Ku=Ku, Hdl=v_, Hfl=Hfl\n                )\n            elif n == \"Hfl\":\n                amp_diag1f, phase_diag2f, Hscan = compute_harmonics(\n                    mode, theta=theta, Ms=Ms, Ku=Ku, Hdl=Hdl, Hfl=v_\n                )\n            else:\n                raise ValueError(\"Unknown parameter\")\n            amp_diag1f -= amp_diag1f.mean()\n            phase_diag2f -= phase_diag2f[0]\n            ensemble_data[f\"{n}_1f_{mode}\"].append(amp_diag1f)\n            ensemble_data[f\"{n}_2f_{mode}\"].append(phase_diag2f)\n            ensemble_data[f\"{n}_field_{mode}\"].append(Hscan / 1e3)\n</pre> from scipy.fft import fft, fftshift, fftfreq from scipy.signal.windows import hann  Rx0 = [304.306] Ry0 = [3] SMR = [-0.464] AMR = [-0.053] AHE = [-5.71] w = [3e-5] l = [2e-5]  N = 15 eps = 0.05 Ms = 0.525 Ku = 1.54e5 theta = 92  Hdl = -420 Hfl = 574  theta_space = np.linspace(     90.1, 90.1 * (1 + eps) / (1 - eps), N )  # we need to avoid changing sign Ms_space = np.linspace((1 - eps) * Ms, (1 + eps) * Ms, N) Ku_space = np.linspace((1 - eps) * Ku, (1 + eps) * Ku, N) scans = zip([\"theta\", \"Ms\", \"Ku\"], [theta_space, Ms_space, Ku_space]) # scans = zip(['Hdl', 'Hfl', 'Ms', 'Ku'], #             [Hdl_space, Hfl_space, Ms_space, Ku_space]) ensemble_data = defaultdict(list) for MODE in (\"Hx\", \"Hy\"):     mode = MODE.lower()     for n, v in zip([\"theta\", \"Ms\", \"Ku\"], [theta_space, Ms_space, Ku_space]):         for v_ in tqdm(v, desc=f\"Computing: {n} for {MODE}\"):             if n == \"theta\":                 amp_diag1f, phase_diag2f, Hscan = compute_harmonics(                     mode, theta=v_, Ms=Ms, Ku=Ku, Hdl=Hdl, Hfl=Hfl                 )             elif n == \"Ms\":                 amp_diag1f, phase_diag2f, Hscan = compute_harmonics(                     mode, theta=theta, Ms=v_, Ku=Ku, Hdl=Hdl, Hfl=Hfl                 )             elif n == \"Ku\":                 amp_diag1f, phase_diag2f, Hscan = compute_harmonics(                     mode, theta=theta, Ms=Ms, Ku=v_, Hdl=Hdl, Hfl=Hfl                 )             elif n == \"Hdl\":                 amp_diag1f, phase_diag2f, Hscan = compute_harmonics(                     mode, theta=theta, Ms=Ms, Ku=Ku, Hdl=v_, Hfl=Hfl                 )             elif n == \"Hfl\":                 amp_diag1f, phase_diag2f, Hscan = compute_harmonics(                     mode, theta=theta, Ms=Ms, Ku=Ku, Hdl=Hdl, Hfl=v_                 )             else:                 raise ValueError(\"Unknown parameter\")             amp_diag1f -= amp_diag1f.mean()             phase_diag2f -= phase_diag2f[0]             ensemble_data[f\"{n}_1f_{mode}\"].append(amp_diag1f)             ensemble_data[f\"{n}_2f_{mode}\"].append(phase_diag2f)             ensemble_data[f\"{n}_field_{mode}\"].append(Hscan / 1e3) <pre>Computing: theta for Hx: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 15/15 [07:50&lt;00:00, 31.38s/it]\nComputing: Ms for Hx: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 15/15 [07:49&lt;00:00, 31.31s/it]\nComputing: Ku for Hx: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 15/15 [07:54&lt;00:00, 31.62s/it]\nComputing: theta for Hy: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 15/15 [08:00&lt;00:00, 32.02s/it]\nComputing: Ms for Hy: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 15/15 [08:04&lt;00:00, 32.33s/it]\nComputing: Ku for Hy: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 15/15 [08:08&lt;00:00, 32.54s/it]\n</pre> In\u00a0[10]: Copied! <pre>Hdl = -420\nHfl = 574\nMs = 0.525\nKu = 1.54e5\ntheta = 92\namp_diag1f_Hx, phase_diag2f_Hx, Hscan_Hx = compute_harmonics('hx',\n                                                             theta=theta,\n                                                             Ms=Ms,\n                                                             Ku=Ku,\n                                                             Hdl=Hdl,\n                                                             Hfl=Hfl)\namp_diag1f_Hy, phase_diag2f_Hy, Hscan_Hy = compute_harmonics('hy',\n                                                             theta=theta,\n                                                             Ms=Ms,\n                                                             Ku=Ku,\n                                                             Hdl=Hdl,\n                                                             Hfl=Hfl)\n\namp_diag1f_Hy -= amp_diag1f_Hy.mean()\namp_diag1f_Hx -= amp_diag1f_Hx.mean()\nphase_diag2f_Hy -= phase_diag2f_Hy[0]\nphase_diag2f_Hx -= phase_diag2f_Hx[0]\n</pre> Hdl = -420 Hfl = 574 Ms = 0.525 Ku = 1.54e5 theta = 92 amp_diag1f_Hx, phase_diag2f_Hx, Hscan_Hx = compute_harmonics('hx',                                                              theta=theta,                                                              Ms=Ms,                                                              Ku=Ku,                                                              Hdl=Hdl,                                                              Hfl=Hfl) amp_diag1f_Hy, phase_diag2f_Hy, Hscan_Hy = compute_harmonics('hy',                                                              theta=theta,                                                              Ms=Ms,                                                              Ku=Ku,                                                              Hdl=Hdl,                                                              Hfl=Hfl)  amp_diag1f_Hy -= amp_diag1f_Hy.mean() amp_diag1f_Hx -= amp_diag1f_Hx.mean() phase_diag2f_Hy -= phase_diag2f_Hy[0] phase_diag2f_Hx -= phase_diag2f_Hx[0] In\u00a0[11]: Copied! <pre>import seaborn as sns\n\nms = 1\nlw = 1.5\nmec = None\nc = 'crimson'\nwith plt.style.context(['science', 'nature']):\n    crest = sns.color_palette('crest', N)\n    fig, ax = plt.subplots(3,\n                           3,\n                           figsize=(6, 4),\n                           dpi=400,\n                           sharey='row',\n                           sharex='col')\n    scale = 1e3\n    galpha = 0.1 \n    for i, n in enumerate(['theta', 'Ms', 'Ku']):\n        for k in range(N):\n            if k == 0 or k == N - 1:\n                galpha = 0.2\n            else:\n                galpha = 0.2\n\n            lwm = 0.5\n            galpham = 0.5\n            hyscale = scale  # * 1e2\n            ax[0][i].plot(ensemble_data[f\"{n}_field_hx\"][k],\n                          ensemble_data[f\"{n}_1f_hx\"][k] * scale,\n                          marker='o',\n                          markersize=ms,\n                          markeredgecolor=mec,\n                          alpha=galpha,\n                          color=crest[k])\n            ax[1][i].plot(ensemble_data[f\"{n}_field_hx\"][k],\n                          ensemble_data[f\"{n}_2f_hx\"][k] * scale,\n                          marker='o',\n                          markersize=ms,\n                          markeredgecolor=mec,\n                          alpha=galpha,\n                          color=crest[k])\n            ax[2][i].plot(ensemble_data[f\"{n}_field_hy\"][k],\n                          ensemble_data[f\"{n}_2f_hy\"][k] * hyscale,\n                          markersize=ms,\n                          marker='o',\n                          markeredgecolor=mec,\n                          alpha=galpha,\n                          color=crest[k])\n\n            ax[0][i].plot(Hscan_Hx / 1e3,\n                          amp_diag1f_Hx * scale,\n                          linewidth=lwm,\n                          alpha=galpham,\n                          color=c)\n            ax[1][i].plot(Hscan_Hx / 1e3,\n                          phase_diag2f_Hx * scale,\n                          linewidth=lwm,\n                          alpha=galpham,\n                          color=c)\n            ax[2][i].plot(Hscan_Hy / 1e3,\n                          phase_diag2f_Hy * hyscale,\n                          linewidth=lwm,\n                          alpha=galpham,\n                          color=c)\n            ax[1][i].set_ylim([-1.e-4 * scale, 1.e-4 * scale])\n            ax[2][i].set_ylim([-4.5e-5 * hyscale, 3.5e-5 * hyscale])\n\n    for i in range(3):\n        ax[2][i].set_xlabel(\"H (kA/m)\")\n\n    ax[0][0].set_ylabel(r\"$V_{\\omega}$ at $H_\\textrm{x}$(mV)\")\n    ax[1][0].set_ylabel(r\"$V_{2\\omega}$ at $H_\\textrm{x}$(mV)\")\n    ax[2][0].set_ylabel(r\"$V_{2\\omega}$ at $H_\\textrm{y}$(mV)\")\n    # names\n    ax[0][0].set_title(r\"$\\theta$ scan\")\n    ax[0][1].set_title(r\"$\\mu_\\mathrm{0}M_\\textrm{s}$ scan\")\n    ax[0][2].set_title(r\"$K_\\textrm{u}$ scan\")\n\n    fig.align_ylabels()\n    fig.tight_layout()\n    fig.subplots_adjust(wspace=0., hspace=0.)\n\n    cmap = sns.color_palette(\"crest\", as_cmap=True)\n    norm = mpl.colors.Normalize(vmin=-eps * 100, vmax=eps * 100)\n\n\n    cbar = fig.colorbar(mpl.cm.ScalarMappable(norm=norm, cmap=cmap),\n                        ax=ax.ravel().tolist(),\n                        orientation='vertical')\n    cbar.ax.set_ylabel(r\"$\\theta, \\mu_\\mathrm{0}M_\\textrm{s}, K_\\textrm{u}$ variation (\\%)\",\n                       rotation=270)\n</pre> import seaborn as sns  ms = 1 lw = 1.5 mec = None c = 'crimson' with plt.style.context(['science', 'nature']):     crest = sns.color_palette('crest', N)     fig, ax = plt.subplots(3,                            3,                            figsize=(6, 4),                            dpi=400,                            sharey='row',                            sharex='col')     scale = 1e3     galpha = 0.1      for i, n in enumerate(['theta', 'Ms', 'Ku']):         for k in range(N):             if k == 0 or k == N - 1:                 galpha = 0.2             else:                 galpha = 0.2              lwm = 0.5             galpham = 0.5             hyscale = scale  # * 1e2             ax[0][i].plot(ensemble_data[f\"{n}_field_hx\"][k],                           ensemble_data[f\"{n}_1f_hx\"][k] * scale,                           marker='o',                           markersize=ms,                           markeredgecolor=mec,                           alpha=galpha,                           color=crest[k])             ax[1][i].plot(ensemble_data[f\"{n}_field_hx\"][k],                           ensemble_data[f\"{n}_2f_hx\"][k] * scale,                           marker='o',                           markersize=ms,                           markeredgecolor=mec,                           alpha=galpha,                           color=crest[k])             ax[2][i].plot(ensemble_data[f\"{n}_field_hy\"][k],                           ensemble_data[f\"{n}_2f_hy\"][k] * hyscale,                           markersize=ms,                           marker='o',                           markeredgecolor=mec,                           alpha=galpha,                           color=crest[k])              ax[0][i].plot(Hscan_Hx / 1e3,                           amp_diag1f_Hx * scale,                           linewidth=lwm,                           alpha=galpham,                           color=c)             ax[1][i].plot(Hscan_Hx / 1e3,                           phase_diag2f_Hx * scale,                           linewidth=lwm,                           alpha=galpham,                           color=c)             ax[2][i].plot(Hscan_Hy / 1e3,                           phase_diag2f_Hy * hyscale,                           linewidth=lwm,                           alpha=galpham,                           color=c)             ax[1][i].set_ylim([-1.e-4 * scale, 1.e-4 * scale])             ax[2][i].set_ylim([-4.5e-5 * hyscale, 3.5e-5 * hyscale])      for i in range(3):         ax[2][i].set_xlabel(\"H (kA/m)\")      ax[0][0].set_ylabel(r\"$V_{\\omega}$ at $H_\\textrm{x}$(mV)\")     ax[1][0].set_ylabel(r\"$V_{2\\omega}$ at $H_\\textrm{x}$(mV)\")     ax[2][0].set_ylabel(r\"$V_{2\\omega}$ at $H_\\textrm{y}$(mV)\")     # names     ax[0][0].set_title(r\"$\\theta$ scan\")     ax[0][1].set_title(r\"$\\mu_\\mathrm{0}M_\\textrm{s}$ scan\")     ax[0][2].set_title(r\"$K_\\textrm{u}$ scan\")      fig.align_ylabels()     fig.tight_layout()     fig.subplots_adjust(wspace=0., hspace=0.)      cmap = sns.color_palette(\"crest\", as_cmap=True)     norm = mpl.colors.Normalize(vmin=-eps * 100, vmax=eps * 100)       cbar = fig.colorbar(mpl.cm.ScalarMappable(norm=norm, cmap=cmap),                         ax=ax.ravel().tolist(),                         orientation='vertical')     cbar.ax.set_ylabel(r\"$\\theta, \\mu_\\mathrm{0}M_\\textrm{s}, K_\\textrm{u}$ variation (\\%)\",                        rotation=270)  In\u00a0[13]: Copied! <pre>N = 10\neps = 0.2\nHdl_space = np.linspace((1 - eps) * Hdl, (1 + eps) * Hdl, N)\nHfl_space = np.linspace((1 - eps) * Hfl, (1 + eps) * Hfl, N)\ntheta = 92 # change here\ntorque_data = defaultdict(list)\nfor MODE in ('Hx', 'Hy'):\n    mode = MODE.lower()\n    for n, v in zip(['Hdl', 'Hfl'], [Hdl_space, Hfl_space]):\n        for v_ in tqdm(v, desc=f'Computing: {n} for {MODE}'):\n            if n == 'Hdl':\n                amp_diag1f, phase_diag2f, Hscan = compute_harmonics(\n                    mode, theta=theta, Ms=Ms, Ku=Ku, Hdl=v_, Hfl=Hfl)\n            elif n == 'Hfl':\n                amp_diag1f, phase_diag2f, Hscan = compute_harmonics(\n                    mode, theta=theta, Ms=Ms, Ku=Ku, Hdl=Hdl, Hfl=v_)\n            else:\n                raise ValueError(\"Unknown parameter\")\n            amp_diag1f -= amp_diag1f.mean()\n            phase_diag2f -= phase_diag2f[0]\n            torque_data[f\"{n}_1f_{mode}\"].append(amp_diag1f)\n            torque_data[f\"{n}_2f_{mode}\"].append(phase_diag2f)\n            torque_data[f\"{n}_field_{mode}\"].append(Hscan / 1e3)\n</pre> N = 10 eps = 0.2 Hdl_space = np.linspace((1 - eps) * Hdl, (1 + eps) * Hdl, N) Hfl_space = np.linspace((1 - eps) * Hfl, (1 + eps) * Hfl, N) theta = 92 # change here torque_data = defaultdict(list) for MODE in ('Hx', 'Hy'):     mode = MODE.lower()     for n, v in zip(['Hdl', 'Hfl'], [Hdl_space, Hfl_space]):         for v_ in tqdm(v, desc=f'Computing: {n} for {MODE}'):             if n == 'Hdl':                 amp_diag1f, phase_diag2f, Hscan = compute_harmonics(                     mode, theta=theta, Ms=Ms, Ku=Ku, Hdl=v_, Hfl=Hfl)             elif n == 'Hfl':                 amp_diag1f, phase_diag2f, Hscan = compute_harmonics(                     mode, theta=theta, Ms=Ms, Ku=Ku, Hdl=Hdl, Hfl=v_)             else:                 raise ValueError(\"Unknown parameter\")             amp_diag1f -= amp_diag1f.mean()             phase_diag2f -= phase_diag2f[0]             torque_data[f\"{n}_1f_{mode}\"].append(amp_diag1f)             torque_data[f\"{n}_2f_{mode}\"].append(phase_diag2f)             torque_data[f\"{n}_field_{mode}\"].append(Hscan / 1e3)  <pre>Computing: Hdl for Hx:   0%|          | 0/10 [00:00&lt;?, ?it/s]Computing: Hdl for Hx: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [05:17&lt;00:00, 31.77s/it]\nComputing: Hfl for Hx: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [05:25&lt;00:00, 32.51s/it]\nComputing: Hdl for Hy: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [05:26&lt;00:00, 32.66s/it]\nComputing: Hfl for Hy: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [05:22&lt;00:00, 32.21s/it]\n</pre> In\u00a0[14]: Copied! <pre>import seaborn as sns\nms = 1\nlw = 1.5\nmec = None\nc = 'crimson'\nwith plt.style.context(['science', 'nature']):\n    crest = sns.color_palette('crest', N)\n    fig, ax = plt.subplots(3,\n                           2,\n                           figsize=(4, 4),\n                           dpi=300,\n                           sharey='row',\n                           sharex='col')\n    scale = 1e3\n    galpha = 0.1\n    for i, n in enumerate(['Hdl', 'Hfl']):\n        for k in range(N):\n            galpha = 0.5\n\n            lwm = 0.5\n            galpham = 0.5\n            hyscale = scale  \n            ax[0][i].plot(\n                torque_data[f\"{n}_field_hx\"][k],\n                torque_data[f\"{n}_1f_hx\"][k] * scale,\n                alpha=galpha,\n                color=crest[k])\n            ax[1][i].plot(\n                torque_data[f\"{n}_field_hx\"][k],\n                torque_data[f\"{n}_2f_hx\"][k] * scale,\n                alpha=galpha,\n                color=crest[k])\n            ax[2][i].plot(\n                torque_data[f\"{n}_field_hy\"][k],\n                torque_data[f\"{n}_2f_hy\"][k] * hyscale,\n\n                alpha=galpha,\n                color=crest[k])\n\n            ax[0][i].plot(Hscan_Hx / 1e3,\n                          amp_diag1f_Hx * scale,\n                          linewidth=lwm,\n                          alpha=galpham,\n                          color=c)\n            ax[1][i].plot(Hscan_Hx / 1e3,\n                          phase_diag2f_Hx * scale,\n                          linewidth=lwm,\n                          alpha=galpham,\n                          color=c)\n            ax[2][i].plot(Hscan_Hy / 1e3,\n                          phase_diag2f_Hy * hyscale,\n                          linewidth=lwm,\n                          alpha=galpham,\n                          color=c)\n\n            ax[1, i].set_ylim([-4.5e-4 * scale / 10, 4.5e-4 * scale / 10])\n            ax[2, i].set_ylim([-4.5e-5 * scale / 4, 7.5e-5 * scale / 4])\n            ax[0, i].set_ylim([4, 8])\n            fx = 130\n            ax[0, i].set_xlim([-fx, fx])\n\n    for i in range(2):\n        ax[2][i].set_xlabel(\"H (kA/m)\")\n\n    ax[0, 0].set_ylabel(r\"$V_{\\omega}$ at $H_\\textrm{x}$ (mV)\")\n    ax[1, 0].set_ylabel(r\"$V_{2\\omega}$ at $H_\\textrm{x}$ (mV)\")\n    ax[2, 0].set_ylabel(r\"$V_{2\\omega}$ at $H_\\textrm{y}$ (mV)\")\n\n    ax[0, 0].set_title(r\"$H_\\textrm{DL}$ scan\")\n    ax[0, 1].set_title(r\"$H_\\textrm{FL}$ scan\")\n    cmap = sns.color_palette(\"crest\", as_cmap=True)\n    norm = mpl.colors.Normalize(vmin=-eps * 100, vmax=eps * 100)\n    fig.subplots_adjust(wspace=0., hspace=0.)\n    fig.align_ylabels()\n    cbar = fig.colorbar(mpl.cm.ScalarMappable(norm=norm, cmap=cmap),\n                        ax=ax.ravel().tolist(),\n                        orientation='vertical')\n    cbar.ax.set_ylabel(r\"$H_\\textrm{DL}, H_\\textrm{FL}$ variation (\\%)\",\n                       rotation=270)\n</pre> import seaborn as sns ms = 1 lw = 1.5 mec = None c = 'crimson' with plt.style.context(['science', 'nature']):     crest = sns.color_palette('crest', N)     fig, ax = plt.subplots(3,                            2,                            figsize=(4, 4),                            dpi=300,                            sharey='row',                            sharex='col')     scale = 1e3     galpha = 0.1     for i, n in enumerate(['Hdl', 'Hfl']):         for k in range(N):             galpha = 0.5              lwm = 0.5             galpham = 0.5             hyscale = scale               ax[0][i].plot(                 torque_data[f\"{n}_field_hx\"][k],                 torque_data[f\"{n}_1f_hx\"][k] * scale,                 alpha=galpha,                 color=crest[k])             ax[1][i].plot(                 torque_data[f\"{n}_field_hx\"][k],                 torque_data[f\"{n}_2f_hx\"][k] * scale,                 alpha=galpha,                 color=crest[k])             ax[2][i].plot(                 torque_data[f\"{n}_field_hy\"][k],                 torque_data[f\"{n}_2f_hy\"][k] * hyscale,                  alpha=galpha,                 color=crest[k])              ax[0][i].plot(Hscan_Hx / 1e3,                           amp_diag1f_Hx * scale,                           linewidth=lwm,                           alpha=galpham,                           color=c)             ax[1][i].plot(Hscan_Hx / 1e3,                           phase_diag2f_Hx * scale,                           linewidth=lwm,                           alpha=galpham,                           color=c)             ax[2][i].plot(Hscan_Hy / 1e3,                           phase_diag2f_Hy * hyscale,                           linewidth=lwm,                           alpha=galpham,                           color=c)              ax[1, i].set_ylim([-4.5e-4 * scale / 10, 4.5e-4 * scale / 10])             ax[2, i].set_ylim([-4.5e-5 * scale / 4, 7.5e-5 * scale / 4])             ax[0, i].set_ylim([4, 8])             fx = 130             ax[0, i].set_xlim([-fx, fx])      for i in range(2):         ax[2][i].set_xlabel(\"H (kA/m)\")      ax[0, 0].set_ylabel(r\"$V_{\\omega}$ at $H_\\textrm{x}$ (mV)\")     ax[1, 0].set_ylabel(r\"$V_{2\\omega}$ at $H_\\textrm{x}$ (mV)\")     ax[2, 0].set_ylabel(r\"$V_{2\\omega}$ at $H_\\textrm{y}$ (mV)\")      ax[0, 0].set_title(r\"$H_\\textrm{DL}$ scan\")     ax[0, 1].set_title(r\"$H_\\textrm{FL}$ scan\")     cmap = sns.color_palette(\"crest\", as_cmap=True)     norm = mpl.colors.Normalize(vmin=-eps * 100, vmax=eps * 100)     fig.subplots_adjust(wspace=0., hspace=0.)     fig.align_ylabels()     cbar = fig.colorbar(mpl.cm.ScalarMappable(norm=norm, cmap=cmap),                         ax=ax.ravel().tolist(),                         orientation='vertical')     cbar.ax.set_ylabel(r\"$H_\\textrm{DL}, H_\\textrm{FL}$ variation (\\%)\",                        rotation=270)"},{"location":"experimental-methods/HarmonicsFits/#harmonic-fits","title":"Harmonic Fits\u00b6","text":"<p>This notebook showcases the fitting procedures used in the work: <code>Numerical Model Of Harmonic Hall Voltage Detection For Spintronic Devices</code></p> <p>The steps below should produce results displayed in the publication given the version of the CMTJ from January 2022 (later versions may be subject to change).</p>"},{"location":"experimental-methods/HarmonicsFits/#resistance-parameter-fits","title":"Resistance parameter fits\u00b6","text":""},{"location":"experimental-methods/HarmonicsFits/#alpha-sample","title":"Alpha sample\u00b6","text":"$$R_{xx} = R_0 + \\frac{1}{2}(\\Delta R_{XX}^{AMR} + \\Delta R_{XX}^{SMR}) + \\frac{1}{2}(\\Delta R_{XX}^{AMR} - \\Delta R_{XX}^{SMR})cos(2\\alpha)$$$$R_{xy} = R_0 + \\frac{1}{2}(\\Delta R_{XY}^{AMR} + \\Delta R_{XY}^{SMR})sin(2\\alpha)$$"},{"location":"experimental-methods/HarmonicsFits/#beta-sample","title":"Beta sample\u00b6","text":"$$R_{xx} = R_0 + \\Delta R_{XX}^{SMR}sin^2(\\beta)$$$$R_{xy} = R_0 + \\frac{1}{2}\\Delta R_{XY}^{AHE}cos(\\beta)$$"},{"location":"experimental-methods/HarmonicsFits/#gamma-sample","title":"Gamma sample\u00b6","text":"$$R_{xx} = R_0 + \\Delta R_{XX}^{AMR}sin^2(\\gamma)$$$$R_{xy} = R_0 + \\frac{1}{2}\\Delta R_{XY}^{AHE}cos(\\gamma)$$"},{"location":"experimental-methods/HarmonicsFits/#layer-parameter-fits","title":"Layer parameter fits\u00b6","text":""},{"location":"experimental-methods/HarmonicsFits/#resistance-measurement-in-non-saturating-field","title":"Resistance measurement in non-saturating field\u00b6","text":""},{"location":"experimental-methods/HarmonicsFits/#qualitative-effect-of-the-temperature-on-the-resistance","title":"Qualitative effect of the temperature on the resistance\u00b6","text":"<p>Since the bar is large, we can either adjust the cell size or the temperature -- that's why we will consider it only qualitatively.</p>"},{"location":"experimental-methods/HarmonicsFits/#influence-of-the-parameter-variation-on-the-harmonic-fits","title":"Influence of the parameter variation on the harmonic fits\u00b6","text":"<p>We will investigate the influence of the variation of the parameters on the harmonic fits: $M_s$, $K_u$, $\\theta_K$ (the theta angle of the anisotropy axis) and the torques $T_{DL}$ and $T_{FL}$.</p>"},{"location":"experimental-methods/MemoryCell/","title":"Memory Cells","text":"In\u00a0[39]: Copied! <pre>from cmtj import (\n    Junction,\n    CVector,\n    Layer,\n    ScalarDriver,\n    constantDriver,\n    stepDriver,\n    NullDriver,\n)\nfrom math import pi\nfrom cmtj.utils import TtoAm\n\ndemag = [CVector(1e-6, 0, 0), CVector(0, 1e-6, 0), CVector(0, 0, 0.9996)]\nalpha = 0.035\nsurface = 150e-9 * 150e-9 * pi\nKdir = CVector(0.1, 0.1, 1)\nMs = 1.08\nd = 1.55e-9\nl1 = Layer(\n    \"free\",\n    mag=CVector(0.1, 0.1, 0.9),\n    anis=Kdir,\n    Ms=Ms,\n    thickness=d,\n    cellSurface=surface,\n    demagTensor=demag,\n    damping=alpha,\n)\nK1 = 8.4e5\nv1 = CVector(0, 1, 0)\nv2 = CVector(1, 0, 0)\nl1.setReferenceLayer(v1)\nl1.setSecondaryReferenceLayer(v2)\njunction = Junction([l1])\njunction.setLayerAnisotropyDriver(\"free\", constantDriver(K1))\njunction.runSimulation(2e-9, 1e-13, 1e-13)\njunction.clearLog()\nsh1 = 0.3 / 100\nsh2 = 0.3 / 100\nsgn = 1\nj1 = sgn * 1e6\nj2 = -sgn * 1e6\n\n\nt1start = 0.1e-9\nt1stop = 0.3e-9\n\nt2start = 0.32e-9\nt2stop = 0.45e-9\n\nt3start = 1.2e-9\nt3stop = 1.4e-9\n\nampl1 = sh1 * j1 / (Ms * TtoAm * d)\nampl2 = sh2 * j2 / (Ms * TtoAm * d)\n\nfl1 = NullDriver()\ndl1 = stepDriver(0, ampl1, t1start, t1stop)\n\n\"\"\"\njust for sport, we define a current impulse \n\"\"\"\n\n\ndef custom_step_impulse(time: float) -&gt; float:\n    if t2start &lt; time &lt; t2stop:\n        return ampl2\n    return 0\n\n\n# Create a driver with this function\ndriver = ScalarDriver.getCustomDriver(custom_step_impulse)\n\n# fl2 = driver * 0\nfl2 = NullDriver()\ndl2 = driver\n\n\njunction.setLayerPrimaryTorqueDrivers(\n    \"free\", fieldLikeTorque=fl1, dampingLikeTorque=dl1\n)\njunction.setLayerSecondaryTorqueDrivers(\n    \"free\", fieldLikeTorque=fl2, dampingLikeTorque=dl2\n)\n\n\njunction.runSimulation(2e-9, 1e-13, 1e-13)\nlog = junction.getLog()\n\ntm = np.asarray(log[\"time\"])\ndriver_values_A = [dl1.getCurrentScalarValue(t)/1e6 for t in tm]\ndriver_values_B = [dl2.getCurrentScalarValue(t)/1e6 for t in tm]\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# with plt.style.context([\"science\", \"nature\"]):\nwith plt.style.context(\"nature\"):\n    # Set figure style with no y-axis offset\n    plt.rcParams[\"axes.formatter.useoffset\"] = False\n    fig, ax = plt.subplots(dpi=300)\n    mz = np.asarray(log[\"free_mz\"])\n    my = np.asarray(log[\"free_my\"])\n    mx = np.asarray(log[\"free_mx\"])\n    ax.plot(tm * 1e9, my, label=\"my\", color=\"navy\")\n    ax.plot(tm * 1e9, mx, label=\"mx\", color=\"forestgreen\")\n    ax.plot(tm * 1e9, mz, label=\"mz\", color=\"crimson\")\n\n    ax2 = ax.twinx()\n    ax2.plot(\n        tm * 1e9,\n        driver_values_A,\n        label=\"pulse A\",\n        color=\"royalblue\",\n        linestyle=\"dashed\",\n    )\n    ax2.plot(\n        tm * 1e9, driver_values_B, label=\"pulse B\", color=\"magenta\", linestyle=\"dashed\"\n    )\n\n    ax.set_ylim(-1.1, 1.1)\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Magnetisation\")\n    ax.set_title(\"Memory cell with two polarisation currents\")\n\n    ax2.set_ylabel(r\"$\\tau \\times 10^6$ (A/m)\", rotation=270, labelpad=10)\n    # Create a legend outside the plot\n    fig.legend(loc='center left', bbox_to_anchor=(1.05, 0.5))\n</pre> from cmtj import (     Junction,     CVector,     Layer,     ScalarDriver,     constantDriver,     stepDriver,     NullDriver, ) from math import pi from cmtj.utils import TtoAm  demag = [CVector(1e-6, 0, 0), CVector(0, 1e-6, 0), CVector(0, 0, 0.9996)] alpha = 0.035 surface = 150e-9 * 150e-9 * pi Kdir = CVector(0.1, 0.1, 1) Ms = 1.08 d = 1.55e-9 l1 = Layer(     \"free\",     mag=CVector(0.1, 0.1, 0.9),     anis=Kdir,     Ms=Ms,     thickness=d,     cellSurface=surface,     demagTensor=demag,     damping=alpha, ) K1 = 8.4e5 v1 = CVector(0, 1, 0) v2 = CVector(1, 0, 0) l1.setReferenceLayer(v1) l1.setSecondaryReferenceLayer(v2) junction = Junction([l1]) junction.setLayerAnisotropyDriver(\"free\", constantDriver(K1)) junction.runSimulation(2e-9, 1e-13, 1e-13) junction.clearLog() sh1 = 0.3 / 100 sh2 = 0.3 / 100 sgn = 1 j1 = sgn * 1e6 j2 = -sgn * 1e6   t1start = 0.1e-9 t1stop = 0.3e-9  t2start = 0.32e-9 t2stop = 0.45e-9  t3start = 1.2e-9 t3stop = 1.4e-9  ampl1 = sh1 * j1 / (Ms * TtoAm * d) ampl2 = sh2 * j2 / (Ms * TtoAm * d)  fl1 = NullDriver() dl1 = stepDriver(0, ampl1, t1start, t1stop)  \"\"\" just for sport, we define a current impulse  \"\"\"   def custom_step_impulse(time: float) -&gt; float:     if t2start &lt; time &lt; t2stop:         return ampl2     return 0   # Create a driver with this function driver = ScalarDriver.getCustomDriver(custom_step_impulse)  # fl2 = driver * 0 fl2 = NullDriver() dl2 = driver   junction.setLayerPrimaryTorqueDrivers(     \"free\", fieldLikeTorque=fl1, dampingLikeTorque=dl1 ) junction.setLayerSecondaryTorqueDrivers(     \"free\", fieldLikeTorque=fl2, dampingLikeTorque=dl2 )   junction.runSimulation(2e-9, 1e-13, 1e-13) log = junction.getLog()  tm = np.asarray(log[\"time\"]) driver_values_A = [dl1.getCurrentScalarValue(t)/1e6 for t in tm] driver_values_B = [dl2.getCurrentScalarValue(t)/1e6 for t in tm]  import matplotlib.pyplot as plt import numpy as np  # with plt.style.context([\"science\", \"nature\"]): with plt.style.context(\"nature\"):     # Set figure style with no y-axis offset     plt.rcParams[\"axes.formatter.useoffset\"] = False     fig, ax = plt.subplots(dpi=300)     mz = np.asarray(log[\"free_mz\"])     my = np.asarray(log[\"free_my\"])     mx = np.asarray(log[\"free_mx\"])     ax.plot(tm * 1e9, my, label=\"my\", color=\"navy\")     ax.plot(tm * 1e9, mx, label=\"mx\", color=\"forestgreen\")     ax.plot(tm * 1e9, mz, label=\"mz\", color=\"crimson\")      ax2 = ax.twinx()     ax2.plot(         tm * 1e9,         driver_values_A,         label=\"pulse A\",         color=\"royalblue\",         linestyle=\"dashed\",     )     ax2.plot(         tm * 1e9, driver_values_B, label=\"pulse B\", color=\"magenta\", linestyle=\"dashed\"     )      ax.set_ylim(-1.1, 1.1)     ax.set_xlabel(\"Time (s)\")     ax.set_ylabel(\"Magnetisation\")     ax.set_title(\"Memory cell with two polarisation currents\")      ax2.set_ylabel(r\"$\\tau \\times 10^6$ (A/m)\", rotation=270, labelpad=10)     # Create a legend outside the plot     fig.legend(loc='center left', bbox_to_anchor=(1.05, 0.5))"},{"location":"experimental-methods/MemoryCell/#memory-cells","title":"Memory Cells\u00b6","text":"<p>In this example, we show to set up a memory cell. In this case, a memory cell consists of one  free layer, and two pinned layer, one on the top and one on the bottom of the free layer which both serve as reference layers and provide different polarisations of the spin current ($x$ and $-y$).  If we time the current impulses through both of those reference layers we can smartly speed up the switching of the perpendicularly magnetised cell from $m_z$ to $-m_z$ without having to apply an external magnetic field.</p> <p>In this example we set field-like torque to 0, through <code>NullDriver</code>, this of course can be done with <code>constantDriver(0)</code> or <code>ScalarDriver.getConstantDriver(0)</code> as well.</p> <p>The simulation can be more realistic in the <code>cmtj</code> through the addition of temperature, non-trivial demagnetisation tensor and <code>dipole</code> tensor.</p>"},{"location":"experimental-methods/MemoryCell/#references","title":"References:\u00b6","text":"<p>[1] de Orio, R. L. et al. Numerical Analysis of Deterministic Switching of a Perpendicularly Magnetized Spin-Orbit Torque Memory Cell. IEEE Journal of the Electron Devices Society 9, 61\u201367 (2021).</p>"},{"location":"experimental-methods/VoltageSpinDiodeFits/","title":"Voltage Spin Diode","text":"In\u00a0[1]: Copied! <pre>from cmtj import CVector, Layer, Junction, ScalarDriver, AxialDriver, NullDriver\nfrom tqdm import tqdm\nimport math\nfrom scipy.signal import butter, lfilter\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n</pre> from cmtj import CVector, Layer, Junction, ScalarDriver, AxialDriver, NullDriver from tqdm import tqdm import math from scipy.signal import butter, lfilter import pandas as pd import numpy as np import matplotlib.pyplot as plt In\u00a0[2]: Copied! <pre>vsd2p = pd.read_csv(\"./VSD/5360_2p.csv\", sep='\\t')\nvsd4p = pd.read_csv(\"./VSD/5360_4p.csv\", sep='\\t')\nOeToAm = 79.57747\n</pre> vsd2p = pd.read_csv(\"./VSD/5360_2p.csv\", sep='\\t') vsd4p = pd.read_csv(\"./VSD/5360_4p.csv\", sep='\\t') OeToAm = 79.57747 In\u00a0[3]: Copied! <pre>import cmtj\n\nRx0 = [304.306]\nRy0 = [1.008]\nSMR = [-0.464]\nAMR = [-0.053]\nAHE = [-5.71]\nw = [3e-5]\nl = [2e-5]\n\n\ndef butter_bandpass_filter(data, pass_freq, fs, order=5):\n    nyq = 0.5 * fs\n    if pass_freq == 0:\n        pass_freq = 0.1\n    try:\n        b, a = butter(order, [0.9 * pass_freq / nyq, pass_freq / nyq],\n                      btype='bandpass',\n                      analog=False)\n    except ValueError:\n        print(fs, pass_freq, nyq, 0.9 * pass_freq / nyq, pass_freq / nyq)\n        raise ValueError(\"Error in filtering\")\n    y = lfilter(b, a, data, zi=None)\n    return y\n\n\ndef butter_lowpass_filter(data, cutoff, fs, order=5):\n    nyq = 0.5 * fs\n    normal_cutoff = cutoff / nyq\n    b, a = butter(order, normal_cutoff, btype='low', analog=False)\n    y = lfilter(b, a, data, zi=None)\n    return y\n\n\ndef calculate_resistance(Rx0, Ry0, AMR, AHE, SMR, m, number_of_layers, l, w):\n    if m.ndim == 2:\n        SxAll = np.zeros((number_of_layers, ))\n        SyAll = np.zeros((number_of_layers, ))\n\n    elif m.ndim == 3:\n        SxAll = np.zeros((number_of_layers, m.shape[2]))\n        SyAll = np.zeros((number_of_layers, m.shape[2]))\n\n    for i in range(0, number_of_layers):\n        w_l = w[i] / l[i]\n        SxAll[i] = 1 / (Rx0[i] + (AMR[i] * m[i, 0]**2 + SMR[i] * m[i, 1]**2))\n        SyAll[i] = 1 / (Ry0[i] + 0.5 * AHE[i] * m[i, 2] + (w_l) *\n                        (SMR[i] - AMR[i]) * m[i, 0] * m[i, 1])\n\n    Rx = 1 / np.sum(SxAll, axis=0)\n    Ry = 1 / np.sum(SyAll, axis=0)\n    return Rx, Ry\n\n\ndef compute_vsd1(stime, resistance, frequency, tstart=2e-9):\n    \"\"\"Time\"\"\"\n    stime = np.asarray(stime)\n    indx = np.argwhere(stime &gt;= tstart).ravel()\n    Rx = np.asarray(resistance)[indx]\n    avg_res = np.mean(Rx)\n    current = np.sqrt(1 / avg_res) * np.sin(\n        2 * np.pi * frequency * stime[indx])\n    return np.mean(current * Rx)\n\n\ndef compute_vsd2(dynamicR, integration_step, dynamicI):\n    \"\"\"Pymag\"\"\"\n    SD = -dynamicI * dynamicR\n    fs = 1.0 / integration_step\n    SD_dc = butter_lowpass_filter(SD, cutoff=10e6, fs=fs, order=3)\n    return np.mean(SD_dc)\n\n\ndef compute_vsd_scan(Ms,\n                     Ku,\n                     orient='4p',\n                     silent=False,\n                     hnum=40,\n                     fstep=0.5,\n                     int_step=4e-12,\n                     stime=20e-9):\n    demagTensor = [\n        CVector(0., 0., 0.),\n        CVector(0., 0., 0.),\n        CVector(0., 0., 1.0)\n    ]\n    damping = 30e-3\n    thickness = 1.45e-9\n    l1 = Layer(id=\"free\",\n               mag=CVector(0., 0., 1.),\n               anis=CVector(0, 0., 1.),\n               Ms=Ms,\n               thickness=thickness,\n               cellSurface=0,\n               demagTensor=demagTensor,\n               damping=damping)\n    junction = Junction([l1])\n\n    junction.setLayerAnisotropyDriver(\"free\",\n                                      ScalarDriver.getConstantDriver(Ku))\n\n    HoeAmpl = 5000  # A/m\n    Hspace = np.linspace(000e3, 600e3, num=hnum)\n    frequencies = np.arange(2, 20, fstep) * 1e9\n    VSD = []\n    Irf = 10e-3\n    theta = np.deg2rad(91)\n    if orient == '4p':\n        phideg = 1\n    elif orient == '2p':\n        phideg = 45\n    else:\n        raise ValueError(\"Unknown orient\")\n\n    phi = np.deg2rad(phideg)\n    for frequency in tqdm(frequencies, disable=silent):\n        H_sweep = []\n        for H in Hspace:\n            junction.clearLog()\n            HDriver = AxialDriver(\n                ScalarDriver.getConstantDriver(H * math.sin(theta) *\n                                               math.cos(phi)),\n                ScalarDriver.getConstantDriver(H * math.sin(theta) *\n                                               math.sin(phi)),\n                ScalarDriver.getConstantDriver(H * math.cos(theta)))\n\n            HoeDriver = AxialDriver(\n                NullDriver(),\n                ScalarDriver.getSineDriver(0, HoeAmpl, frequency, 0),\n                NullDriver())\n            junction.setLayerExternalFieldDriver(\"all\", HDriver)\n            junction.setLayerOerstedFieldDriver(\"all\", HoeDriver)\n            junction.runSimulation(stime,\n                                   int_step,\n                                   int_step,\n                                   solverMode=cmtj.RK4)\n\n            log = junction.getLog()\n            m = np.asarray(\n                [[log[f'{str_}_mx'], log[f'{str_}_my'], log[f'{str_}_mz']]\n                 for str_ in ['free']])\n            dynamicRx, dynamicRy = calculate_resistance(Rx0=Rx0,\n                                                        Ry0=Ry0,\n                                                        AMR=AMR,\n                                                        AHE=AHE,\n                                                        SMR=SMR,\n                                                        m=m,\n                                                        number_of_layers=1,\n                                                        l=l,\n                                                        w=w)\n            if orient == '2p':\n                dynamicR = dynamicRx\n            else:\n                dynamicR = dynamicRy\n            dynamicI = Irf * \\\n                        np.sin(2 * math.pi * frequency * np.asarray(log['time']))\n            vmix = compute_vsd2(dynamicR, int_step, dynamicI)\n            H_sweep.append(vmix)\n        VSD.append(H_sweep)\n    VSD = np.asarray(VSD)\n    return VSD, frequencies, Hspace, phideg\n</pre> import cmtj  Rx0 = [304.306] Ry0 = [1.008] SMR = [-0.464] AMR = [-0.053] AHE = [-5.71] w = [3e-5] l = [2e-5]   def butter_bandpass_filter(data, pass_freq, fs, order=5):     nyq = 0.5 * fs     if pass_freq == 0:         pass_freq = 0.1     try:         b, a = butter(order, [0.9 * pass_freq / nyq, pass_freq / nyq],                       btype='bandpass',                       analog=False)     except ValueError:         print(fs, pass_freq, nyq, 0.9 * pass_freq / nyq, pass_freq / nyq)         raise ValueError(\"Error in filtering\")     y = lfilter(b, a, data, zi=None)     return y   def butter_lowpass_filter(data, cutoff, fs, order=5):     nyq = 0.5 * fs     normal_cutoff = cutoff / nyq     b, a = butter(order, normal_cutoff, btype='low', analog=False)     y = lfilter(b, a, data, zi=None)     return y   def calculate_resistance(Rx0, Ry0, AMR, AHE, SMR, m, number_of_layers, l, w):     if m.ndim == 2:         SxAll = np.zeros((number_of_layers, ))         SyAll = np.zeros((number_of_layers, ))      elif m.ndim == 3:         SxAll = np.zeros((number_of_layers, m.shape[2]))         SyAll = np.zeros((number_of_layers, m.shape[2]))      for i in range(0, number_of_layers):         w_l = w[i] / l[i]         SxAll[i] = 1 / (Rx0[i] + (AMR[i] * m[i, 0]**2 + SMR[i] * m[i, 1]**2))         SyAll[i] = 1 / (Ry0[i] + 0.5 * AHE[i] * m[i, 2] + (w_l) *                         (SMR[i] - AMR[i]) * m[i, 0] * m[i, 1])      Rx = 1 / np.sum(SxAll, axis=0)     Ry = 1 / np.sum(SyAll, axis=0)     return Rx, Ry   def compute_vsd1(stime, resistance, frequency, tstart=2e-9):     \"\"\"Time\"\"\"     stime = np.asarray(stime)     indx = np.argwhere(stime &gt;= tstart).ravel()     Rx = np.asarray(resistance)[indx]     avg_res = np.mean(Rx)     current = np.sqrt(1 / avg_res) * np.sin(         2 * np.pi * frequency * stime[indx])     return np.mean(current * Rx)   def compute_vsd2(dynamicR, integration_step, dynamicI):     \"\"\"Pymag\"\"\"     SD = -dynamicI * dynamicR     fs = 1.0 / integration_step     SD_dc = butter_lowpass_filter(SD, cutoff=10e6, fs=fs, order=3)     return np.mean(SD_dc)   def compute_vsd_scan(Ms,                      Ku,                      orient='4p',                      silent=False,                      hnum=40,                      fstep=0.5,                      int_step=4e-12,                      stime=20e-9):     demagTensor = [         CVector(0., 0., 0.),         CVector(0., 0., 0.),         CVector(0., 0., 1.0)     ]     damping = 30e-3     thickness = 1.45e-9     l1 = Layer(id=\"free\",                mag=CVector(0., 0., 1.),                anis=CVector(0, 0., 1.),                Ms=Ms,                thickness=thickness,                cellSurface=0,                demagTensor=demagTensor,                damping=damping)     junction = Junction([l1])      junction.setLayerAnisotropyDriver(\"free\",                                       ScalarDriver.getConstantDriver(Ku))      HoeAmpl = 5000  # A/m     Hspace = np.linspace(000e3, 600e3, num=hnum)     frequencies = np.arange(2, 20, fstep) * 1e9     VSD = []     Irf = 10e-3     theta = np.deg2rad(91)     if orient == '4p':         phideg = 1     elif orient == '2p':         phideg = 45     else:         raise ValueError(\"Unknown orient\")      phi = np.deg2rad(phideg)     for frequency in tqdm(frequencies, disable=silent):         H_sweep = []         for H in Hspace:             junction.clearLog()             HDriver = AxialDriver(                 ScalarDriver.getConstantDriver(H * math.sin(theta) *                                                math.cos(phi)),                 ScalarDriver.getConstantDriver(H * math.sin(theta) *                                                math.sin(phi)),                 ScalarDriver.getConstantDriver(H * math.cos(theta)))              HoeDriver = AxialDriver(                 NullDriver(),                 ScalarDriver.getSineDriver(0, HoeAmpl, frequency, 0),                 NullDriver())             junction.setLayerExternalFieldDriver(\"all\", HDriver)             junction.setLayerOerstedFieldDriver(\"all\", HoeDriver)             junction.runSimulation(stime,                                    int_step,                                    int_step,                                    solverMode=cmtj.RK4)              log = junction.getLog()             m = np.asarray(                 [[log[f'{str_}_mx'], log[f'{str_}_my'], log[f'{str_}_mz']]                  for str_ in ['free']])             dynamicRx, dynamicRy = calculate_resistance(Rx0=Rx0,                                                         Ry0=Ry0,                                                         AMR=AMR,                                                         AHE=AHE,                                                         SMR=SMR,                                                         m=m,                                                         number_of_layers=1,                                                         l=l,                                                         w=w)             if orient == '2p':                 dynamicR = dynamicRx             else:                 dynamicR = dynamicRy             dynamicI = Irf * \\                         np.sin(2 * math.pi * frequency * np.asarray(log['time']))             vmix = compute_vsd2(dynamicR, int_step, dynamicI)             H_sweep.append(vmix)         VSD.append(H_sweep)     VSD = np.asarray(VSD)     return VSD, frequencies, Hspace, phideg In\u00a0[4]: Copied! <pre>import cmtj\nfrom collections import defaultdict\n\nRx0 = [304.306]\nRy0 = [1.008]\nSMR = [-0.464]\nAMR = [-0.053]\nAHE = [-5.71]\nw = [3e-5]\nl = [2e-5]\n\n\ndef simulate_lorentz(Ms, Ku, frequency, orient, alpha=1e-4, Irf=0.5e-3):\n    demagTensor = [\n        CVector(0., 0., 0.),\n        CVector(0., 0., 0.),\n        CVector(0., 0., 1.0)\n    ]\n    thickness = 1.45e-9\n    l1 = Layer(id=\"free\",\n               mag=CVector(0., 0., 1.),\n               anis=CVector(0, 0., 1.),\n               Ms=Ms,\n               thickness=thickness,\n               cellSurface=0,\n               demagTensor=demagTensor,\n               damping=alpha)\n    junction = Junction([l1])\n\n    junction.setLayerAnisotropyDriver(\"free\",\n                                      ScalarDriver.getConstantDriver(Ku))\n\n    HoeAmpl = 5000  # A/m\n    Hspace = np.linspace(350e3, 630e3, num=100)\n    int_step = 1e-13\n    theta = np.deg2rad(91)\n    if orient == '4p':\n        phideg = 0\n    elif orient == '2p':\n        phideg = 45\n    else:\n        raise ValueError(\"Unknown orient\")\n    phi = np.deg2rad(phideg)\n    Hsweep = np.zeros((Hspace.shape[0]))\n    for i, H in enumerate(Hspace):\n        junction.clearLog()\n        HDriver = AxialDriver(\n            ScalarDriver.getConstantDriver(H * math.sin(theta) *\n                                           math.cos(phi)),\n            ScalarDriver.getConstantDriver(H * math.sin(theta) *\n                                           math.sin(phi)),\n            ScalarDriver.getConstantDriver(H * math.cos(theta)))\n\n        HoeDriver = AxialDriver(\n            NullDriver(), NullDriver(),\n            ScalarDriver.getSineDriver(0, -HoeAmpl, frequency, 0))\n        junction.setLayerExternalFieldDriver(\"all\", HDriver)\n        junction.setLayerOerstedFieldDriver(\"all\", HoeDriver)\n        junction.runSimulation(40e-9, int_step, int_step, solverMode=cmtj.RK4)\n\n        log = junction.getLog()\n        m = np.asarray(\n            [[log[f'{str_}_mx'], log[f'{str_}_my'], log[f'{str_}_mz']]\n             for str_ in ['free']])\n        dynamicRx, dynamicRy = calculate_resistance(Rx0=Rx0,\n                                                    Ry0=Ry0,\n                                                    AMR=AMR,\n                                                    AHE=AHE,\n                                                    SMR=SMR,\n                                                    m=m,\n                                                    number_of_layers=1,\n                                                    l=l,\n                                                    w=w)\n        if orient == '2p':\n            dynamicR = dynamicRx\n        else:\n            dynamicR = dynamicRy\n        dynamicI = Irf * \\\n                    np.sin(2 * math.pi * frequency * np.asarray(log['time']))\n        vmix = compute_vsd2(dynamicR, int_step, dynamicI)\n        Hsweep[i] = vmix\n    return Hspace, Hsweep\n\n\ndata = defaultdict(list)\nhscans = []\nvscans = []\nfscan = np.arange(12, 17)\n# orient = '4p'\nalpha = 30e-3\nfor orient, irf in zip(('4p', '2p'), (0.75e-3, 0.4e-3)):\n    for f in tqdm(fscan):\n        hscan, vscan = simulate_lorentz(0.525,\n                                        1.54e5,\n                                        f * 1e9,\n                                        orient=orient,\n                                        alpha=alpha,\n                                        Irf=irf)\n        if orient == '2p':\n            vscan -= vscan.max()\n        data[f'{orient}'].append(vscan)\n        data[f'{orient}-field'].append(hscan)\n</pre> import cmtj from collections import defaultdict  Rx0 = [304.306] Ry0 = [1.008] SMR = [-0.464] AMR = [-0.053] AHE = [-5.71] w = [3e-5] l = [2e-5]   def simulate_lorentz(Ms, Ku, frequency, orient, alpha=1e-4, Irf=0.5e-3):     demagTensor = [         CVector(0., 0., 0.),         CVector(0., 0., 0.),         CVector(0., 0., 1.0)     ]     thickness = 1.45e-9     l1 = Layer(id=\"free\",                mag=CVector(0., 0., 1.),                anis=CVector(0, 0., 1.),                Ms=Ms,                thickness=thickness,                cellSurface=0,                demagTensor=demagTensor,                damping=alpha)     junction = Junction([l1])      junction.setLayerAnisotropyDriver(\"free\",                                       ScalarDriver.getConstantDriver(Ku))      HoeAmpl = 5000  # A/m     Hspace = np.linspace(350e3, 630e3, num=100)     int_step = 1e-13     theta = np.deg2rad(91)     if orient == '4p':         phideg = 0     elif orient == '2p':         phideg = 45     else:         raise ValueError(\"Unknown orient\")     phi = np.deg2rad(phideg)     Hsweep = np.zeros((Hspace.shape[0]))     for i, H in enumerate(Hspace):         junction.clearLog()         HDriver = AxialDriver(             ScalarDriver.getConstantDriver(H * math.sin(theta) *                                            math.cos(phi)),             ScalarDriver.getConstantDriver(H * math.sin(theta) *                                            math.sin(phi)),             ScalarDriver.getConstantDriver(H * math.cos(theta)))          HoeDriver = AxialDriver(             NullDriver(), NullDriver(),             ScalarDriver.getSineDriver(0, -HoeAmpl, frequency, 0))         junction.setLayerExternalFieldDriver(\"all\", HDriver)         junction.setLayerOerstedFieldDriver(\"all\", HoeDriver)         junction.runSimulation(40e-9, int_step, int_step, solverMode=cmtj.RK4)          log = junction.getLog()         m = np.asarray(             [[log[f'{str_}_mx'], log[f'{str_}_my'], log[f'{str_}_mz']]              for str_ in ['free']])         dynamicRx, dynamicRy = calculate_resistance(Rx0=Rx0,                                                     Ry0=Ry0,                                                     AMR=AMR,                                                     AHE=AHE,                                                     SMR=SMR,                                                     m=m,                                                     number_of_layers=1,                                                     l=l,                                                     w=w)         if orient == '2p':             dynamicR = dynamicRx         else:             dynamicR = dynamicRy         dynamicI = Irf * \\                     np.sin(2 * math.pi * frequency * np.asarray(log['time']))         vmix = compute_vsd2(dynamicR, int_step, dynamicI)         Hsweep[i] = vmix     return Hspace, Hsweep   data = defaultdict(list) hscans = [] vscans = [] fscan = np.arange(12, 17) # orient = '4p' alpha = 30e-3 for orient, irf in zip(('4p', '2p'), (0.75e-3, 0.4e-3)):     for f in tqdm(fscan):         hscan, vscan = simulate_lorentz(0.525,                                         1.54e5,                                         f * 1e9,                                         orient=orient,                                         alpha=alpha,                                         Irf=irf)         if orient == '2p':             vscan -= vscan.max()         data[f'{orient}'].append(vscan)         data[f'{orient}-field'].append(hscan)  <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5/5 [03:04&lt;00:00, 36.96s/it]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5/5 [02:56&lt;00:00, 35.36s/it]\n</pre> In\u00a0[5]: Copied! <pre>from scipy.optimize import curve_fit\nimport seaborn as sns\n\n\ndef lorentz_fit(H, dH, Hr, Va, Vs, Vb):\n    dH2 = (dH**2)\n    HHr = H - Hr\n    denom = 4 * (HHr**2) + dH2\n    nom = Va * HHr * dH + Vs * dH2\n    return Vb + nom / denom\n\n\nOeToAm = 79.57747\nwith plt.style.context(['science', 'nature']):\n    fig, ax = plt.subplots(2, 1, dpi=300, sharex='col')\n    rainbow = sns.color_palette('rainbow', len(fscan))\n    for j, orient in enumerate(('4p', '2p')):\n        for i, f in enumerate(fscan):\n            if orient == '2p':\n                H = (vsd2p[f\"2pf_{f}.0_GHz\"] * OeToAm / 1e3).dropna()\n                V = (vsd2p[f\"2pf_{f}.0_GHz.1\"] * 1e6).dropna().values\n                V = V - V.mean()\n            else:\n                H = (vsd4p[f\"4pf_{f}.0_GHz\"] * OeToAm / 1e3).dropna()\n                V = (vsd4p[f\"4pf_{f}.0_GHz.1\"] * 1e6).dropna().values\n                V = V - V.mean()\n            ax[j].plot(\n                H,\n                V,\n                'o',\n                label=f\"{f} GHz\",\n                alpha=0.6,\n                color=rainbow[i],\n                markersize=3,\n            )\n            Hr = H[V.argmin()]\n            popt, pcov = curve_fit(lorentz_fit,\n                                   xdata=H,\n                                   ydata=V,\n                                   p0=(0.1, Hr, 0, 0, 0))\n            ax[j].plot(H, lorentz_fit(H, *popt), color=rainbow[i], alpha=0.3)\n            ax[j].plot(np.asarray(data[f\"{orient}-field\"][i]) / 1e3,\n                       np.asarray(data[orient][i]) * 1e6,\n                       alpha=1,\n                       linestyle='--',\n                       color='crimson',\n                       linewidth=1)\n        ax[j].set_xlim([300, 630])\n        ax[j].set_ylabel(r\"$V_\\textrm{DC} (\\mu V)$\")\n\n    ax[1].set_xlabel(\"H (kA/m)\")\n    ax[1].legend()\n    import matplotlib.transforms as mtransforms\n    for label, ax in zip(['(a)', '(b)'], ax.flatten()):\n        trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,\n                                              fig.dpi_scale_trans)\n        ax.text(0.0,\n                1.0,\n                label,\n                transform=ax.transAxes + trans,\n                fontsize='medium',\n                verticalalignment='top',\n                bbox=dict(facecolor='none', edgecolor='none', pad=3.0))\n    fig.subplots_adjust(hspace=0)\n    fig.align_ylabels()\n</pre> from scipy.optimize import curve_fit import seaborn as sns   def lorentz_fit(H, dH, Hr, Va, Vs, Vb):     dH2 = (dH**2)     HHr = H - Hr     denom = 4 * (HHr**2) + dH2     nom = Va * HHr * dH + Vs * dH2     return Vb + nom / denom   OeToAm = 79.57747 with plt.style.context(['science', 'nature']):     fig, ax = plt.subplots(2, 1, dpi=300, sharex='col')     rainbow = sns.color_palette('rainbow', len(fscan))     for j, orient in enumerate(('4p', '2p')):         for i, f in enumerate(fscan):             if orient == '2p':                 H = (vsd2p[f\"2pf_{f}.0_GHz\"] * OeToAm / 1e3).dropna()                 V = (vsd2p[f\"2pf_{f}.0_GHz.1\"] * 1e6).dropna().values                 V = V - V.mean()             else:                 H = (vsd4p[f\"4pf_{f}.0_GHz\"] * OeToAm / 1e3).dropna()                 V = (vsd4p[f\"4pf_{f}.0_GHz.1\"] * 1e6).dropna().values                 V = V - V.mean()             ax[j].plot(                 H,                 V,                 'o',                 label=f\"{f} GHz\",                 alpha=0.6,                 color=rainbow[i],                 markersize=3,             )             Hr = H[V.argmin()]             popt, pcov = curve_fit(lorentz_fit,                                    xdata=H,                                    ydata=V,                                    p0=(0.1, Hr, 0, 0, 0))             ax[j].plot(H, lorentz_fit(H, *popt), color=rainbow[i], alpha=0.3)             ax[j].plot(np.asarray(data[f\"{orient}-field\"][i]) / 1e3,                        np.asarray(data[orient][i]) * 1e6,                        alpha=1,                        linestyle='--',                        color='crimson',                        linewidth=1)         ax[j].set_xlim([300, 630])         ax[j].set_ylabel(r\"$V_\\textrm{DC} (\\mu V)$\")      ax[1].set_xlabel(\"H (kA/m)\")     ax[1].legend()     import matplotlib.transforms as mtransforms     for label, ax in zip(['(a)', '(b)'], ax.flatten()):         trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,                                               fig.dpi_scale_trans)         ax.text(0.0,                 1.0,                 label,                 transform=ax.transAxes + trans,                 fontsize='medium',                 verticalalignment='top',                 bbox=dict(facecolor='none', edgecolor='none', pad=3.0))     fig.subplots_adjust(hspace=0)     fig.align_ylabels() In\u00a0[6]: Copied! <pre>def signal_modes(signal):\n    signal_indx = signal.argsort()\n    return signal_indx[:2]\n\n\nmain_line_2p = []\nmain_line_4p = []\nsecond_peak_2p = [150, 141, 95]\nsecond_peak_2p_f = np.arange(3, 6)\nsecond_peak_4p = [150, 110]\nsecond_peak_4p_f = np.arange(4, 6)\nfreqs = np.arange(2, 17)\nfor f in freqs:\n    Hs = vsd2p[f\"2pf_{f}.0_GHz\"] * OeToAm / 1e3\n    minima = signal_modes(vsd2p[f\"2pf_{f}.0_GHz.1\"].values)\n    main_line_2p.append(Hs[minima[0]])\n\n    Hs = vsd4p[f\"4pf_{f}.0_GHz\"] * OeToAm / 1e3\n    minima = signal_modes(vsd4p[f\"4pf_{f}.0_GHz.1\"].values)\n    main_line_4p.append(Hs[minima[0]])\n\nensemble_2p_f = np.concatenate((second_peak_2p_f, freqs))\nensemble_4p_f = np.concatenate((second_peak_4p_f, freqs))\n\nensemble_2p = second_peak_2p + main_line_2p\nensemble_4p = second_peak_4p + main_line_4p\nprint(len(ensemble_2p_f), len(ensemble_2p), len(ensemble_4p),\n      len(ensemble_4p_f))\nwith plt.style.context(['science', 'nature']):\n    fig, ax = plt.subplots(dpi=300)\n    ax.plot(main_line_2p, freqs, marker='.', linestyle='', label='Main-2p')\n    ax.plot(main_line_4p, freqs, marker='.', linestyle='', label='Main-4p')\n    ax.plot(second_peak_2p,\n            second_peak_2p_f,\n            marker='.',\n            linestyle='',\n            label='Secondary-2p')\n    ax.plot(second_peak_4p,\n            second_peak_4p_f,\n            marker='.',\n            linestyle='',\n            label='Secondary-4p')\n    ax.set_xlabel(\"H [kA/m]\")\n    ax.set_ylabel(\"Frequency [GHz]\")\n    ax.legend()\n</pre> def signal_modes(signal):     signal_indx = signal.argsort()     return signal_indx[:2]   main_line_2p = [] main_line_4p = [] second_peak_2p = [150, 141, 95] second_peak_2p_f = np.arange(3, 6) second_peak_4p = [150, 110] second_peak_4p_f = np.arange(4, 6) freqs = np.arange(2, 17) for f in freqs:     Hs = vsd2p[f\"2pf_{f}.0_GHz\"] * OeToAm / 1e3     minima = signal_modes(vsd2p[f\"2pf_{f}.0_GHz.1\"].values)     main_line_2p.append(Hs[minima[0]])      Hs = vsd4p[f\"4pf_{f}.0_GHz\"] * OeToAm / 1e3     minima = signal_modes(vsd4p[f\"4pf_{f}.0_GHz.1\"].values)     main_line_4p.append(Hs[minima[0]])  ensemble_2p_f = np.concatenate((second_peak_2p_f, freqs)) ensemble_4p_f = np.concatenate((second_peak_4p_f, freqs))  ensemble_2p = second_peak_2p + main_line_2p ensemble_4p = second_peak_4p + main_line_4p print(len(ensemble_2p_f), len(ensemble_2p), len(ensemble_4p),       len(ensemble_4p_f)) with plt.style.context(['science', 'nature']):     fig, ax = plt.subplots(dpi=300)     ax.plot(main_line_2p, freqs, marker='.', linestyle='', label='Main-2p')     ax.plot(main_line_4p, freqs, marker='.', linestyle='', label='Main-4p')     ax.plot(second_peak_2p,             second_peak_2p_f,             marker='.',             linestyle='',             label='Secondary-2p')     ax.plot(second_peak_4p,             second_peak_4p_f,             marker='.',             linestyle='',             label='Secondary-4p')     ax.set_xlabel(\"H [kA/m]\")     ax.set_ylabel(\"Frequency [GHz]\")     ax.legend() <pre>18 18 17 17\n</pre> In\u00a0[7]: Copied! <pre>Ms = 0.525\nKu = 1.54e5\nVSD, frequencies, Hspace, phideg = compute_vsd_scan(Ms, Ku, orient='2p')\nVSD4p, frequencies4p, Hspace4p, phideg4p = compute_vsd_scan(Ms,\n                                                            Ku,\n                                                            orient='4p')\n</pre> Ms = 0.525 Ku = 1.54e5 VSD, frequencies, Hspace, phideg = compute_vsd_scan(Ms, Ku, orient='2p') VSD4p, frequencies4p, Hspace4p, phideg4p = compute_vsd_scan(Ms,                                                             Ku,                                                             orient='4p')  <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 36/36 [00:06&lt;00:00,  5.24it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 36/36 [00:06&lt;00:00,  5.53it/s]\n</pre> In\u00a0[8]: Copied! <pre>import seaborn as sns\n\ncrest = sns.color_palette('crest', as_cmap=True)\nwith plt.style.context(['science', 'nature']):\n    fig, (ax1, ax2) = plt.subplots(1, 2, dpi=300, sharey=True)\n    VSD_plot = (VSD.T - np.median(VSD, axis=1).T).T\n    im = ax1.pcolormesh(Hspace / 1e3, frequencies / 1e9, VSD_plot, cmap=crest)\n    im = ax2.pcolormesh(Hspace / 1e3, frequencies / 1e9, VSD4p, cmap=crest)\n    ax1.scatter(ensemble_2p,\n                ensemble_2p_f,\n                label='Experiment',\n                color='crimson')\n    ax2.scatter(ensemble_4p,\n                ensemble_4p_f,\n                label='Experiment',\n                color='crimson')\n    for ax_ in (ax1, ax2):\n        ax_.set_xlabel(\"H (kA/m)\")\n    ax1.set_ylabel(\"Frequency (GHz)\")\n    ax1.legend(facecolor='white', frameon=True)\n    ax1.set_title(\n        r\"$R_{xx} \\textrm{ at } (\\theta, \\phi)=(90^\\circ, 45^\\circ)$\",\n        fontsize=7)\n    ax2.set_title(r\"$R_{xy} \\textrm{ at } (\\theta, \\phi)=(90^\\circ, 0^\\circ$)\",\n                  fontsize=7)\n    import matplotlib.transforms as mtransforms\n    for label, ax in zip(['(a)', '(b)'], (ax1, ax2)):\n        # label physical distance in and down:\n        trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,\n                                              fig.dpi_scale_trans)\n        ax.text(0.0,\n                1.0,\n                label,\n                transform=ax.transAxes + trans,\n                fontsize='medium',\n                verticalalignment='top',\n                bbox=dict(facecolor='none', edgecolor='none', pad=3.0))\n    fig.subplots_adjust(wspace=0)\n</pre> import seaborn as sns  crest = sns.color_palette('crest', as_cmap=True) with plt.style.context(['science', 'nature']):     fig, (ax1, ax2) = plt.subplots(1, 2, dpi=300, sharey=True)     VSD_plot = (VSD.T - np.median(VSD, axis=1).T).T     im = ax1.pcolormesh(Hspace / 1e3, frequencies / 1e9, VSD_plot, cmap=crest)     im = ax2.pcolormesh(Hspace / 1e3, frequencies / 1e9, VSD4p, cmap=crest)     ax1.scatter(ensemble_2p,                 ensemble_2p_f,                 label='Experiment',                 color='crimson')     ax2.scatter(ensemble_4p,                 ensemble_4p_f,                 label='Experiment',                 color='crimson')     for ax_ in (ax1, ax2):         ax_.set_xlabel(\"H (kA/m)\")     ax1.set_ylabel(\"Frequency (GHz)\")     ax1.legend(facecolor='white', frameon=True)     ax1.set_title(         r\"$R_{xx} \\textrm{ at } (\\theta, \\phi)=(90^\\circ, 45^\\circ)$\",         fontsize=7)     ax2.set_title(r\"$R_{xy} \\textrm{ at } (\\theta, \\phi)=(90^\\circ, 0^\\circ$)\",                   fontsize=7)     import matplotlib.transforms as mtransforms     for label, ax in zip(['(a)', '(b)'], (ax1, ax2)):         # label physical distance in and down:         trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,                                               fig.dpi_scale_trans)         ax.text(0.0,                 1.0,                 label,                 transform=ax.transAxes + trans,                 fontsize='medium',                 verticalalignment='top',                 bbox=dict(facecolor='none', edgecolor='none', pad=3.0))     fig.subplots_adjust(wspace=0) <pre>/var/folders/wq/0q9brtfs5rq65q1t_mtgshb00000gn/T/ipykernel_40236/1178458291.py:7: MatplotlibDeprecationWarning: shading='flat' when X and Y have the same dimensions as C is deprecated since 3.3.  Either specify the corners of the quadrilaterals with X and Y, or pass shading='auto', 'nearest' or 'gouraud', or set rcParams['pcolor.shading'].  This will become an error two minor releases later.\n  im = ax1.pcolormesh(Hspace / 1e3, frequencies / 1e9, VSD_plot, cmap=crest)\n/var/folders/wq/0q9brtfs5rq65q1t_mtgshb00000gn/T/ipykernel_40236/1178458291.py:8: MatplotlibDeprecationWarning: shading='flat' when X and Y have the same dimensions as C is deprecated since 3.3.  Either specify the corners of the quadrilaterals with X and Y, or pass shading='auto', 'nearest' or 'gouraud', or set rcParams['pcolor.shading'].  This will become an error two minor releases later.\n  im = ax2.pcolormesh(Hspace / 1e3, frequencies / 1e9, VSD4p, cmap=crest)\n</pre> In\u00a0[9]: Copied! <pre>from cmtj import CVector, Layer, Junction, ScalarDriver, AxialDriver, NullDriver\nfrom tqdm import tqdm\nimport math\nimport time\nfrom scipy.signal import butter, lfilter\nfrom multiprocess import Pool\nfrom functools import partial\n\n\ndef butter_bandpass_filter(data, pass_freq, fs, order=5):\n    nyq = 0.5 * fs\n    if pass_freq == 0:\n        pass_freq = 0.1\n    try:\n        b, a = butter(order, [0.9 * pass_freq / nyq, pass_freq / nyq],\n                      btype='bandpass',\n                      analog=False)\n    except ValueError:\n        print(fs, pass_freq, nyq, 0.9 * pass_freq / nyq, pass_freq / nyq)\n        raise ValueError(\"Error in filtering\")\n    y = lfilter(b, a, data, zi=None)\n    return y\n\n\ndef butter_lowpass_filter(data, cutoff, fs, order=5):\n    nyq = 0.5 * fs\n    normal_cutoff = cutoff / nyq\n    b, a = butter(order, normal_cutoff, btype='low', analog=False)\n    y = lfilter(b, a, data, zi=None)\n    return y\n\n\ndef compute_vsd(dynamicR, integration_step, dynamicI):\n    SD = -dynamicI * dynamicR\n    fs = 1.0 / integration_step\n    SD_dc = butter_lowpass_filter(SD, cutoff=10e6, fs=fs, order=3)\n    return np.mean(SD_dc)\n\n\ndef compute_vsd_scan(Ms, Ku, int_step=1e-11):\n    demagTensor = [\n        CVector(0., 0., 0.),\n        CVector(0., 0., 0.),\n        CVector(0., 0., 1.0)\n    ]\n    damping = 0.03\n    thickness = 1.45e-9\n    l1 = Layer(id=\"free\",\n               mag=CVector(0., 0., 1.),\n               anis=CVector(0, 0., 1.),\n               Ms=Ms,\n               thickness=thickness,\n               cellSurface=0,\n               demagTensor=demagTensor,\n               damping=damping)\n    junction = Junction([l1])\n\n    junction.setLayerAnisotropyDriver(\"free\",\n                                      ScalarDriver.getConstantDriver(Ku))\n\n    HoeAmpl = 1500  # A/m\n    Hspace = np.linspace(000e3, 400e3, num=20)\n    frequencies = np.arange(2, 15, 0.5) * 1e9\n    VSD = []\n    Irf = 10e-3\n    # int_step = 1e-11\n    theta = np.deg2rad(92)\n    phideg = 3\n    phi = np.deg2rad(phideg)\n    for frequency in frequencies:\n        H_sweep = []\n        for H in Hspace:\n            junction.clearLog()\n            HDriver = AxialDriver(\n                ScalarDriver.getConstantDriver(H * math.sin(theta) *\n                                               math.cos(phi)),\n                ScalarDriver.getConstantDriver(H * math.sin(theta) *\n                                               math.sin(phi)),\n                ScalarDriver.getConstantDriver(H * math.cos(theta)))\n\n            HoeDriver = AxialDriver(\n                NullDriver(),\n                ScalarDriver.getSineDriver(0, HoeAmpl, frequency, 0),\n                NullDriver())\n            junction.setLayerExternalFieldDriver(\"all\", HDriver)\n            junction.setLayerOerstedFieldDriver(\"all\", HoeDriver)\n            junction.runSimulation(8e-9, int_step, int_step)\n\n            log = junction.getLog()\n            m = np.asarray(\n                [[log[f'{str_}_mx'], log[f'{str_}_my'], log[f'{str_}_mz']]\n                 for str_ in ['free']])\n            dynamicRx, dynamicRy = calculate_resistance(Rx0=Rx0,\n                                                        Ry0=Ry0,\n                                                        AMR=AMR,\n                                                        AHE=AHE,\n                                                        SMR=SMR,\n                                                        m=m,\n                                                        number_of_layers=1,\n                                                        l=l,\n                                                        w=w)\n            dynamicI = Irf * \\\n                        np.sin(2 * np.pi * frequency * np.asarray(log['time']))\n            vmix = compute_vsd(dynamicRy, int_step, dynamicI)\n            H_sweep.append(vmix)\n        VSD.append(H_sweep)\n\n    return VSD, frequencies, Hspace\n\n\ndef parallel_scan(Kui, Ms_space, VSD_comp, freqs):\n    Ku, ki = Kui\n    VSD_data = []\n    VSD_mse = []\n    for Ms in Ms_space:\n        VSD, _, _ = compute_vsd_scan(Ms, Ku)\n        VSD = np.asarray(VSD)\n        VSD_data.append(VSD)\n        VSD_mse.append(mse_(VSD, VSD_comp, freqs=freqs))\n\n    return np.asarray(VSD_data), np.asarray(VSD_mse), ki\n\n\nN = 200\neps = 0.3\nMs = 0.525\nKu = 1.54e5\n\nmain_line, freqs, hspace = compute_vsd_scan(Ms, Ku)\nmain_line = np.asarray(main_line)\n\n\ndef mse_(lineA, lineB, freqs):\n    freq_line = freqs[lineA.argmin(axis=0)]\n    main_freq_line = freqs[lineB.argmin(axis=0)]\n    return np.power(freq_line - main_freq_line, 2).sum()\n\n\nMs_space = np.linspace((1 - eps) * Ms, (1 + eps) * Ms, N)\nKu_space = np.linspace(0.13e6, 0.18e6, 30)\nVSD_data = np.zeros((len(Ku_space), len(Ms_space), *main_line.shape))\nVSD_mse = np.zeros((len(Ku_space), len(Ms_space)))\n\nwith Pool(8) as pool:\n    with tqdm(total=len(Ku_space)) as pbar:\n        for result in pool.imap_unordered(\n                partial(parallel_scan,\n                        Ms_space=Ms_space,\n                        VSD_comp=main_line,\n                        freqs=freqs), zip(Ku_space, np.arange(len(Ku_space)))):\n            VSD1, VSD2, ki = result\n            VSD_data[ki, :] = VSD1\n            VSD_mse[ki, :] = VSD2\n            pbar.update()\n</pre> from cmtj import CVector, Layer, Junction, ScalarDriver, AxialDriver, NullDriver from tqdm import tqdm import math import time from scipy.signal import butter, lfilter from multiprocess import Pool from functools import partial   def butter_bandpass_filter(data, pass_freq, fs, order=5):     nyq = 0.5 * fs     if pass_freq == 0:         pass_freq = 0.1     try:         b, a = butter(order, [0.9 * pass_freq / nyq, pass_freq / nyq],                       btype='bandpass',                       analog=False)     except ValueError:         print(fs, pass_freq, nyq, 0.9 * pass_freq / nyq, pass_freq / nyq)         raise ValueError(\"Error in filtering\")     y = lfilter(b, a, data, zi=None)     return y   def butter_lowpass_filter(data, cutoff, fs, order=5):     nyq = 0.5 * fs     normal_cutoff = cutoff / nyq     b, a = butter(order, normal_cutoff, btype='low', analog=False)     y = lfilter(b, a, data, zi=None)     return y   def compute_vsd(dynamicR, integration_step, dynamicI):     SD = -dynamicI * dynamicR     fs = 1.0 / integration_step     SD_dc = butter_lowpass_filter(SD, cutoff=10e6, fs=fs, order=3)     return np.mean(SD_dc)   def compute_vsd_scan(Ms, Ku, int_step=1e-11):     demagTensor = [         CVector(0., 0., 0.),         CVector(0., 0., 0.),         CVector(0., 0., 1.0)     ]     damping = 0.03     thickness = 1.45e-9     l1 = Layer(id=\"free\",                mag=CVector(0., 0., 1.),                anis=CVector(0, 0., 1.),                Ms=Ms,                thickness=thickness,                cellSurface=0,                demagTensor=demagTensor,                damping=damping)     junction = Junction([l1])      junction.setLayerAnisotropyDriver(\"free\",                                       ScalarDriver.getConstantDriver(Ku))      HoeAmpl = 1500  # A/m     Hspace = np.linspace(000e3, 400e3, num=20)     frequencies = np.arange(2, 15, 0.5) * 1e9     VSD = []     Irf = 10e-3     # int_step = 1e-11     theta = np.deg2rad(92)     phideg = 3     phi = np.deg2rad(phideg)     for frequency in frequencies:         H_sweep = []         for H in Hspace:             junction.clearLog()             HDriver = AxialDriver(                 ScalarDriver.getConstantDriver(H * math.sin(theta) *                                                math.cos(phi)),                 ScalarDriver.getConstantDriver(H * math.sin(theta) *                                                math.sin(phi)),                 ScalarDriver.getConstantDriver(H * math.cos(theta)))              HoeDriver = AxialDriver(                 NullDriver(),                 ScalarDriver.getSineDriver(0, HoeAmpl, frequency, 0),                 NullDriver())             junction.setLayerExternalFieldDriver(\"all\", HDriver)             junction.setLayerOerstedFieldDriver(\"all\", HoeDriver)             junction.runSimulation(8e-9, int_step, int_step)              log = junction.getLog()             m = np.asarray(                 [[log[f'{str_}_mx'], log[f'{str_}_my'], log[f'{str_}_mz']]                  for str_ in ['free']])             dynamicRx, dynamicRy = calculate_resistance(Rx0=Rx0,                                                         Ry0=Ry0,                                                         AMR=AMR,                                                         AHE=AHE,                                                         SMR=SMR,                                                         m=m,                                                         number_of_layers=1,                                                         l=l,                                                         w=w)             dynamicI = Irf * \\                         np.sin(2 * np.pi * frequency * np.asarray(log['time']))             vmix = compute_vsd(dynamicRy, int_step, dynamicI)             H_sweep.append(vmix)         VSD.append(H_sweep)      return VSD, frequencies, Hspace   def parallel_scan(Kui, Ms_space, VSD_comp, freqs):     Ku, ki = Kui     VSD_data = []     VSD_mse = []     for Ms in Ms_space:         VSD, _, _ = compute_vsd_scan(Ms, Ku)         VSD = np.asarray(VSD)         VSD_data.append(VSD)         VSD_mse.append(mse_(VSD, VSD_comp, freqs=freqs))      return np.asarray(VSD_data), np.asarray(VSD_mse), ki   N = 200 eps = 0.3 Ms = 0.525 Ku = 1.54e5  main_line, freqs, hspace = compute_vsd_scan(Ms, Ku) main_line = np.asarray(main_line)   def mse_(lineA, lineB, freqs):     freq_line = freqs[lineA.argmin(axis=0)]     main_freq_line = freqs[lineB.argmin(axis=0)]     return np.power(freq_line - main_freq_line, 2).sum()   Ms_space = np.linspace((1 - eps) * Ms, (1 + eps) * Ms, N) Ku_space = np.linspace(0.13e6, 0.18e6, 30) VSD_data = np.zeros((len(Ku_space), len(Ms_space), *main_line.shape)) VSD_mse = np.zeros((len(Ku_space), len(Ms_space)))  with Pool(8) as pool:     with tqdm(total=len(Ku_space)) as pbar:         for result in pool.imap_unordered(                 partial(parallel_scan,                         Ms_space=Ms_space,                         VSD_comp=main_line,                         freqs=freqs), zip(Ku_space, np.arange(len(Ku_space)))):             VSD1, VSD2, ki = result             VSD_data[ki, :] = VSD1             VSD_mse[ki, :] = VSD2             pbar.update() <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [09:44&lt;00:00, 19.50s/it]  \n</pre> In\u00a0[11]: Copied! <pre>def fn(x, a, b, c, d):\n    return a * np.power(b, (x / c)) + d\n\n\nmin_line = VSD_mse.argmin(axis=1)  # shape 200\nMs_min = Ms_space[min_line]\ny = Ms_min\nX = Ku_space\npopt, _ = curve_fit(fn, X, y)\n\nmagma = sns.color_palette('magma', as_cmap=True)\nwith plt.style.context(['science', 'nature']):\n    fig, ax = plt.subplots(dpi=300)\n    ax.plot(X / 1e6, y, 'o', color='crimson', alpha=0.3)\n    ax.plot(X / 1e6,\n            fn(X, *popt),\n            color='crimson',\n            alpha=0.8,\n            label='Best fit')\n    im = ax.pcolormesh(Ku_space / 1e6, Ms_space, np.log(VSD_mse.T), cmap=magma)\n    ax.set_title(r\"MSE map\")\n    ax.set_xlabel(r\"$K_\\textrm{u}$\")\n    ax.set_ylabel(r\"$M_\\textrm{s}$\")\n    ax.legend(frameon=True)\n    fig.tight_layout()\n</pre> def fn(x, a, b, c, d):     return a * np.power(b, (x / c)) + d   min_line = VSD_mse.argmin(axis=1)  # shape 200 Ms_min = Ms_space[min_line] y = Ms_min X = Ku_space popt, _ = curve_fit(fn, X, y)  magma = sns.color_palette('magma', as_cmap=True) with plt.style.context(['science', 'nature']):     fig, ax = plt.subplots(dpi=300)     ax.plot(X / 1e6, y, 'o', color='crimson', alpha=0.3)     ax.plot(X / 1e6,             fn(X, *popt),             color='crimson',             alpha=0.8,             label='Best fit')     im = ax.pcolormesh(Ku_space / 1e6, Ms_space, np.log(VSD_mse.T), cmap=magma)     ax.set_title(r\"MSE map\")     ax.set_xlabel(r\"$K_\\textrm{u}$\")     ax.set_ylabel(r\"$M_\\textrm{s}$\")     ax.legend(frameon=True)     fig.tight_layout() <pre>/var/folders/wq/0q9brtfs5rq65q1t_mtgshb00000gn/T/ipykernel_40236/1829402565.py:20: RuntimeWarning: divide by zero encountered in log\n  im = ax.pcolormesh(Ku_space / 1e6, Ms_space, np.log(VSD_mse.T), cmap=magma)\n/var/folders/wq/0q9brtfs5rq65q1t_mtgshb00000gn/T/ipykernel_40236/1829402565.py:20: MatplotlibDeprecationWarning: shading='flat' when X and Y have the same dimensions as C is deprecated since 3.3.  Either specify the corners of the quadrilaterals with X and Y, or pass shading='auto', 'nearest' or 'gouraud', or set rcParams['pcolor.shading'].  This will become an error two minor releases later.\n  im = ax.pcolormesh(Ku_space / 1e6, Ms_space, np.log(VSD_mse.T), cmap=magma)\n</pre> In\u00a0[12]: Copied! <pre>Ku_ = np.asarray([0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18]) * 1e6\nMs_ = fn(Ku_, *popt)\nlines = []\nfor K_, M_ in zip(tqdm(Ku_), Ms_):\n    ML, freqs, hspace = compute_vsd_scan(M_, K_, int_step=4e-12)\n    lines.append(np.asarray(ML))\n</pre> Ku_ = np.asarray([0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18]) * 1e6 Ms_ = fn(Ku_, *popt) lines = [] for K_, M_ in zip(tqdm(Ku_), Ms_):     ML, freqs, hspace = compute_vsd_scan(M_, K_, int_step=4e-12)     lines.append(np.asarray(ML)) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 7/7 [00:07&lt;00:00,  1.03s/it]\n</pre> In\u00a0[16]: Copied! <pre>from mpl_toolkits.axes_grid1 import make_axes_locatable\n\nwith plt.style.context(['science', 'nature']):\n    magma = sns.color_palette('magma', len(lines))\n    crest = sns.color_palette('crest', as_cmap=True)\n    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(4, 3), dpi=300)\n\n    ax1.plot(X / 1e6, y, 'o', color='crimson', alpha=0.3, label='Minimal MSE')\n    ax1.plot(X / 1e6,\n             fn(X, *popt),\n             color='crimson',\n             alpha=0.9,\n             label='Best fit')\n    im = ax1.pcolormesh(Ku_space / 1e6,\n                        Ms_space,\n                        np.log(VSD_mse.T),\n                        cmap=crest)\n\n    ax1.set_title(r\"MSE\")\n    ax1.set_xlabel(\"Ku ($\\mathregular{MJ/m^3}$)\", usetex=False)\n    ax1.set_ylabel(r\"$\\mathdefault{\\mu_\\mathrm{0}} M_\\textrm{s}$ (T)\")\n\n    for i, (line, K, M) in enumerate(zip(lines, Ku_, Ms_)):\n        min_line = freqs[line.argmin(axis=0)]\n        ax2.plot(hspace / 1e3,\n                 min_line / 1e9,\n                 '.--',\n                 color=magma[i],\n                 alpha=0.5,\n                 markersize=5,\n                 label=r\"$\\mathdefault{K}_\\textrm{u}$:\" + f\"{K/1e6:.2f},\" +\n                 r\"$\\mu_\\textrm{0}\\mathdefault{M}_\\textrm{s}$:\" + f\"{M:.2f}\")\n        ax2.pcolor(hspace / 1e3, freqs / 1e9, line, cmap=crest, shading='auto')\n    ax2.set_xlabel(\"H (kA/m)\")\n    ax2.set_xlim([85, 400])\n    ax2.set_ylabel(\"Frequency (GHz)\")\n    ax2.set_title(\"Dispersion relation\")\n\n    import matplotlib.transforms as mtransforms\n    for label, ax in zip(['(a)', '(b)'], (ax1, ax2)):\n        # label physical distance in and down:\n        trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,\n                                              fig.dpi_scale_trans)\n        ax.text(\n            0.0,\n            1.0,\n            label,\n            transform=ax.transAxes + trans,\n            fontsize='medium',\n            verticalalignment='top',\n            # fontfamily='serif',\n            bbox=dict(facecolor='none', edgecolor='none', pad=3.0))\n    ax1.legend(frameon=True, loc=0)\n    ax2.legend(frameon=True, facecolor='w', prop={'size': 5}, loc=1)\n\n    fig.tight_layout()\n    # fig.align_ylabels()\n</pre> from mpl_toolkits.axes_grid1 import make_axes_locatable  with plt.style.context(['science', 'nature']):     magma = sns.color_palette('magma', len(lines))     crest = sns.color_palette('crest', as_cmap=True)     fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(4, 3), dpi=300)      ax1.plot(X / 1e6, y, 'o', color='crimson', alpha=0.3, label='Minimal MSE')     ax1.plot(X / 1e6,              fn(X, *popt),              color='crimson',              alpha=0.9,              label='Best fit')     im = ax1.pcolormesh(Ku_space / 1e6,                         Ms_space,                         np.log(VSD_mse.T),                         cmap=crest)      ax1.set_title(r\"MSE\")     ax1.set_xlabel(\"Ku ($\\mathregular{MJ/m^3}$)\", usetex=False)     ax1.set_ylabel(r\"$\\mathdefault{\\mu_\\mathrm{0}} M_\\textrm{s}$ (T)\")      for i, (line, K, M) in enumerate(zip(lines, Ku_, Ms_)):         min_line = freqs[line.argmin(axis=0)]         ax2.plot(hspace / 1e3,                  min_line / 1e9,                  '.--',                  color=magma[i],                  alpha=0.5,                  markersize=5,                  label=r\"$\\mathdefault{K}_\\textrm{u}$:\" + f\"{K/1e6:.2f},\" +                  r\"$\\mu_\\textrm{0}\\mathdefault{M}_\\textrm{s}$:\" + f\"{M:.2f}\")         ax2.pcolor(hspace / 1e3, freqs / 1e9, line, cmap=crest, shading='auto')     ax2.set_xlabel(\"H (kA/m)\")     ax2.set_xlim([85, 400])     ax2.set_ylabel(\"Frequency (GHz)\")     ax2.set_title(\"Dispersion relation\")      import matplotlib.transforms as mtransforms     for label, ax in zip(['(a)', '(b)'], (ax1, ax2)):         # label physical distance in and down:         trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,                                               fig.dpi_scale_trans)         ax.text(             0.0,             1.0,             label,             transform=ax.transAxes + trans,             fontsize='medium',             verticalalignment='top',             # fontfamily='serif',             bbox=dict(facecolor='none', edgecolor='none', pad=3.0))     ax1.legend(frameon=True, loc=0)     ax2.legend(frameon=True, facecolor='w', prop={'size': 5}, loc=1)      fig.tight_layout()     # fig.align_ylabels()  <pre>/var/folders/wq/0q9brtfs5rq65q1t_mtgshb00000gn/T/ipykernel_40236/3796855095.py:16: RuntimeWarning: divide by zero encountered in log\n  np.log(VSD_mse.T),\n/var/folders/wq/0q9brtfs5rq65q1t_mtgshb00000gn/T/ipykernel_40236/3796855095.py:14: MatplotlibDeprecationWarning: shading='flat' when X and Y have the same dimensions as C is deprecated since 3.3.  Either specify the corners of the quadrilaterals with X and Y, or pass shading='auto', 'nearest' or 'gouraud', or set rcParams['pcolor.shading'].  This will become an error two minor releases later.\n  im = ax1.pcolormesh(Ku_space / 1e6,\n</pre>"},{"location":"experimental-methods/VoltageSpinDiodeFits/#voltage-spin-diode","title":"Voltage Spin Diode\u00b6","text":"<p>In this notebook we fit and simulate the voltage spin diode experiment.</p> <p>First, we fit the symmetric and asymmetric resonance curves which is pretty standard. Then, we simulate the entire spectrum and finally, we extrapolate to see how the  fitting error depends on our parameter choice</p>"},{"location":"experimental-methods/VoltageSpinDiodeFits/#lorentz-curve-simulation","title":"Lorentz curve simulation\u00b6","text":""},{"location":"experimental-methods/VoltageSpinDiodeFits/#fitting-the-vsd-maps","title":"Fitting the VSD maps\u00b6","text":""},{"location":"experimental-methods/VoltageSpinDiodeFits/#mse-analysis","title":"MSE analysis\u00b6","text":"<p>Here we analyse what other possible sets of parameters yield the same MSE (mean squared error) as the one we found. It turns out that there is a family of $M_s$ and $K_u$ parameters we can find for the same system that will yield the same MSE to the experimental spectrum.  Meaning, we can't really trust the parameters we found! It is always good to have a look at the MSE analysis and verify with the experimental data that the  parameters we found make sense for our sample</p>"},{"location":"experimental-methods/examples/","title":"Advanced examples","text":"In\u00a0[1]: Copied! <pre>import math\nfrom collections import defaultdict\n\nimport matplotlib as mpl\nimport matplotlib.cm as cm\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as mtransforms\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom matplotlib.lines import Line2D\nfrom mpl_toolkits.axes_grid1.inset_locator import inset_axes\nfrom scipy.fft import fft, fftfreq\nfrom scipy.ndimage import uniform_filter, uniform_filter1d\nfrom scipy.optimize import curve_fit\nfrom tqdm import tqdm\n\nfrom cmtj import *\nfrom cmtj import SolverMode\nfrom cmtj.models.ensemble import meinert_model\nfrom cmtj.stack import ParallelStack, SeriesStack\nfrom cmtj.utils import (FieldScan, Filters, OetoAm, TtoAm,\n                        calculate_resistance_parallel,\n                        calculate_resistance_series, compute_sd, echarge, hbar,\n                        mu0)\nfrom cmtj.utils.parallel import distribute\n\ngyromagnetic_ratio = 2.211e5\n</pre> import math from collections import defaultdict  import matplotlib as mpl import matplotlib.cm as cm import matplotlib.pyplot as plt import matplotlib.transforms as mtransforms import numpy as np import pandas as pd import seaborn as sns from matplotlib.lines import Line2D from mpl_toolkits.axes_grid1.inset_locator import inset_axes from scipy.fft import fft, fftfreq from scipy.ndimage import uniform_filter, uniform_filter1d from scipy.optimize import curve_fit from tqdm import tqdm  from cmtj import * from cmtj import SolverMode from cmtj.models.ensemble import meinert_model from cmtj.stack import ParallelStack, SeriesStack from cmtj.utils import (FieldScan, Filters, OetoAm, TtoAm,                         calculate_resistance_parallel,                         calculate_resistance_series, compute_sd, echarge, hbar,                         mu0) from cmtj.utils.parallel import distribute  gyromagnetic_ratio = 2.211e5  In\u00a0[2]: Copied! <pre>loops0 = {}\nloops90 = {}\n\nloop_Hrange = np.linspace(-500 * OetoAm, 500 * OetoAm, 100)\nloop_Hrange = np.concatenate((loop_Hrange, loop_Hrange[:-1][::-1]))\nlabels = ('2.37', '2.14', '1.90')\nHJs = (30, 10, -40)\n# a way of recomputing the Js from the data\nJs = [HJ * OetoAm * 6e-9 * 1.05 for HJ in HJs]\n# approximate demagnetisation tensor\ndemag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)]\nsurf = 15e-9 * 15e-9 * np.pi\nfor angle in (90, 0):\n    for th, J in zip(labels, tqdm(Js)):\n        Ku = 0.8e3\n        alpha = 0.024\n        l1 = Layer(\n            \"free\",\n            mag=CVector(1, 0.1, 0.1),\n            anis=CVector(1, 0., 0.),  # direction of the anisotropy\n            Ms=1.03,\n            thickness=2.1e-9,\n            cellSurface=surf,\n            demagTensor=demag,\n            damping=alpha)\n\n        l2 = Layer(\n            \"bottom\",\n            mag=CVector(1, 0.1, 0.1),\n            anis=CVector(1, 0, 0),  # direction of the anisotropy\n            Ms=1.65,\n            thickness=6e-9,\n            cellSurface=surf,\n            demagTensor=demag,\n            damping=alpha)\n\n        j1 = Junction([l1, l2], 163.5, 176)\n        j1.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(Ku))\n        j1.setLayerAnisotropyDriver(\"bottom\",\n                                    ScalarDriver.getConstantDriver(1e12))\n        j1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J))\n\n        Rs = []\n        for H in loop_Hrange:\n            j1.clearLog()\n            hangle = FieldScan.angle2vector(90, angle, H)\n            j1.setLayerExternalFieldDriver(\n                \"all\",\n                AxialDriver(ScalarDriver.getConstantDriver(hangle.x),\n                            ScalarDriver.getConstantDriver(hangle.y),\n                            ScalarDriver.getConstantDriver(hangle.z)))\n\n            j1.runSimulation(20e-9, 1e-12, 1e-12)\n            log = j1.getLog()\n            R = np.mean(log['R_free_bottom'][-100:])\n            Rs.append(R)\n        if angle == 0:\n            loops0[th] = Rs\n        if angle == 90:\n            loops90[th] = Rs\n</pre> loops0 = {} loops90 = {}  loop_Hrange = np.linspace(-500 * OetoAm, 500 * OetoAm, 100) loop_Hrange = np.concatenate((loop_Hrange, loop_Hrange[:-1][::-1])) labels = ('2.37', '2.14', '1.90') HJs = (30, 10, -40) # a way of recomputing the Js from the data Js = [HJ * OetoAm * 6e-9 * 1.05 for HJ in HJs] # approximate demagnetisation tensor demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)] surf = 15e-9 * 15e-9 * np.pi for angle in (90, 0):     for th, J in zip(labels, tqdm(Js)):         Ku = 0.8e3         alpha = 0.024         l1 = Layer(             \"free\",             mag=CVector(1, 0.1, 0.1),             anis=CVector(1, 0., 0.),  # direction of the anisotropy             Ms=1.03,             thickness=2.1e-9,             cellSurface=surf,             demagTensor=demag,             damping=alpha)          l2 = Layer(             \"bottom\",             mag=CVector(1, 0.1, 0.1),             anis=CVector(1, 0, 0),  # direction of the anisotropy             Ms=1.65,             thickness=6e-9,             cellSurface=surf,             demagTensor=demag,             damping=alpha)          j1 = Junction([l1, l2], 163.5, 176)         j1.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(Ku))         j1.setLayerAnisotropyDriver(\"bottom\",                                     ScalarDriver.getConstantDriver(1e12))         j1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J))          Rs = []         for H in loop_Hrange:             j1.clearLog()             hangle = FieldScan.angle2vector(90, angle, H)             j1.setLayerExternalFieldDriver(                 \"all\",                 AxialDriver(ScalarDriver.getConstantDriver(hangle.x),                             ScalarDriver.getConstantDriver(hangle.y),                             ScalarDriver.getConstantDriver(hangle.z)))              j1.runSimulation(20e-9, 1e-12, 1e-12)             log = j1.getLog()             R = np.mean(log['R_free_bottom'][-100:])             Rs.append(R)         if angle == 0:             loops0[th] = Rs         if angle == 90:             loops90[th] = Rs <pre> 67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 2/3 [00:07&lt;00:03,  3.97s/it]\n 67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 2/3 [00:08&lt;00:04,  4.01s/it]\n</pre> In\u00a0[3]: Copied! <pre>def simulate_vsd(J, H, frequency):\n    int_step = 5e-13\n    demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)]\n\n    Ku = 0.8e3\n    alpha = 0.024  # 0.024\n    l1 = Layer(\n        \"free\",\n        mag=CVector(1, 0.1, 0.1),\n        anis=CVector(0, 1., 0.),  # direction of the anisotropy\n        Ms=1.03,\n        thickness=2.1e-9,\n        cellSurface=surf,\n        demagTensor=demag,\n        damping=alpha)\n\n    l2 = Layer(\n        \"bottom\",\n        mag=CVector(1, 0.1, 0.1),\n        anis=CVector(1, 0, 0),  # direction of the anisotropy\n        Ms=1.65,\n        thickness=6e-9,\n        cellSurface=surf,\n        demagTensor=demag,\n        damping=alpha)\n    j1 = Junction([l1, l2], 163.5, 176)\n    j1.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(Ku))\n    j1.setLayerAnisotropyDriver(\"bottom\", ScalarDriver.getConstantDriver(1e12))\n    j1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J))\n    hangle = FieldScan.angle2vector(90, 90, H)\n    j1.clearLog()\n    j1.setLayerExternalFieldDriver(\n        \"all\",\n        AxialDriver(ScalarDriver.getConstantDriver(hangle.x),\n                    ScalarDriver.getConstantDriver(hangle.y),\n                    ScalarDriver.getConstantDriver(hangle.z)))\n    j1.setLayerOerstedFieldDriver(\n        \"free\",\n        AxialDriver(\n            NullDriver(),\n            ScalarDriver.getSineDriver(0, 5, frequency, 0),\n            NullDriver(),\n        ))\n    j1.runSimulation(60e-9, int_step, int_step, solverMode=SolverMode.RK4)\n    log = j1.getLog()\n    dynamicR = log['R_free_bottom']\n\n    dynamicI = np.sin(2 * math.pi * frequency * np.asarray(log['time']))\n    vmix = compute_sd(dynamicR, dynamicI, int_step)\n    return vmix\n\n\nHJs = (25, 15, -29)\nJs = [HJ * OetoAm * 6e-9 * 1.05 for HJ in HJs]\nHrange = np.linspace(-15e3, 15e3, 50, endpoint=True)\nfscan = np.arange(1e9, 6.2e9, 0.2e9)\nVSD = np.zeros((len(Js), len(fscan), len(Hrange)), dtype=np.float32)\nJs = np.around(Js, decimals=7)\nfor res in distribute(simulate_vsd, [Js, Hrange, fscan]):\n    (k, i, j), out = res\n    VSD[k, j, i] = out\n\n# uncomment for serial\n# import time\n\n# start = time.time()\n# for k, J in enumerate(tqdm(Js)):\n#     for i, H in enumerate(Hrange):\n#         for j, f in enumerate(fscan):\n#             VSD[k, j, i] = simulate_vsd(J, H, f)\n# end = time.time()\n# print(f\"Time elapsed: {end - start:.3f}s\")\n</pre> def simulate_vsd(J, H, frequency):     int_step = 5e-13     demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)]      Ku = 0.8e3     alpha = 0.024  # 0.024     l1 = Layer(         \"free\",         mag=CVector(1, 0.1, 0.1),         anis=CVector(0, 1., 0.),  # direction of the anisotropy         Ms=1.03,         thickness=2.1e-9,         cellSurface=surf,         demagTensor=demag,         damping=alpha)      l2 = Layer(         \"bottom\",         mag=CVector(1, 0.1, 0.1),         anis=CVector(1, 0, 0),  # direction of the anisotropy         Ms=1.65,         thickness=6e-9,         cellSurface=surf,         demagTensor=demag,         damping=alpha)     j1 = Junction([l1, l2], 163.5, 176)     j1.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(Ku))     j1.setLayerAnisotropyDriver(\"bottom\", ScalarDriver.getConstantDriver(1e12))     j1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J))     hangle = FieldScan.angle2vector(90, 90, H)     j1.clearLog()     j1.setLayerExternalFieldDriver(         \"all\",         AxialDriver(ScalarDriver.getConstantDriver(hangle.x),                     ScalarDriver.getConstantDriver(hangle.y),                     ScalarDriver.getConstantDriver(hangle.z)))     j1.setLayerOerstedFieldDriver(         \"free\",         AxialDriver(             NullDriver(),             ScalarDriver.getSineDriver(0, 5, frequency, 0),             NullDriver(),         ))     j1.runSimulation(60e-9, int_step, int_step, solverMode=SolverMode.RK4)     log = j1.getLog()     dynamicR = log['R_free_bottom']      dynamicI = np.sin(2 * math.pi * frequency * np.asarray(log['time']))     vmix = compute_sd(dynamicR, dynamicI, int_step)     return vmix   HJs = (25, 15, -29) Js = [HJ * OetoAm * 6e-9 * 1.05 for HJ in HJs] Hrange = np.linspace(-15e3, 15e3, 50, endpoint=True) fscan = np.arange(1e9, 6.2e9, 0.2e9) VSD = np.zeros((len(Js), len(fscan), len(Hrange)), dtype=np.float32) Js = np.around(Js, decimals=7) for res in distribute(simulate_vsd, [Js, Hrange, fscan]):     (k, i, j), out = res     VSD[k, j, i] = out  # uncomment for serial # import time  # start = time.time() # for k, J in enumerate(tqdm(Js)): #     for i, H in enumerate(Hrange): #         for j, f in enumerate(fscan): #             VSD[k, j, i] = simulate_vsd(J, H, f) # end = time.time() # print(f\"Time elapsed: {end - start:.3f}s\") <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3900/3900 [01:37&lt;00:00, 39.94it/s]\n</pre> In\u00a0[4]: Copied! <pre>def kittel_relation(H_iec, H_ext, H_ku, Ms):\n    B_ = (abs(H_iec) + H_ext + H_ku) * mu0\n    f = 28024e6 * np.sqrt(B_ * (B_ + Ms))\n    return f\n\n\ndf = pd.read_csv('./data/dispersion_relation.csv', skiprows=[0], sep=',')\ndf_magen_237 = pd.read_csv('./data/J237.dat', sep='\\t', header=None)\ndf_magen_214 = pd.read_csv('./data/J214.dat', sep='\\t', header=None)\ndf_magen_190 = pd.read_csv('./data/magen3190.dat', sep='\\t', header=None)\ncmap = sns.color_palette('inferno', len(loops0))\nHJs = (25, 15, -29)\nfreq_indx = (4, 8, 14)\nmagens = [df_magen_237, df_magen_214, df_magen_190]\nwith plt.style.context(['science', 'nature']):\n    fig = plt.figure(constrained_layout=True, figsize=(3.4, 8), dpi=300)\n    gs = plt.GridSpec(4, 6)\n    ax1 = fig.add_subplot(gs[0, :2])\n    ax2 = fig.add_subplot(gs[0, 2:4])\n    ax3 = fig.add_subplot(gs[0, 4:])\n    axs = [ax1, ax2, ax3]\n    ax4 = fig.add_subplot(gs[1, :3])\n    ax5 = fig.add_subplot(gs[1, 3:])\n\n    for i, th in enumerate(loops0):\n        ax4.plot(loop_Hrange / 1e3,\n                 loops0[th],\n                 label=f\"{th} nm\",\n                 color=cmap[i])\n        ax5.plot(loop_Hrange / 1e3,\n                 loops90[th],\n                 label=f\"{th} nm\",\n                 color=cmap[i])\n\n    ax4.set_xlabel(\"H [kA/m]\")\n    ax5.set_xlabel(\"H [kA/m]\")\n    ax4.set_ylabel(r\"Resistance [$\\Omega$]\")\n    ax5.legend(frameon=True, loc=5)\n\n    Ms = 1.03\n    H_ku = 2 * 0.8e3 / (Ms)\n    HJsAm = [H_  * OetoAm for H_ in HJs]\n    Hpos_mask = np.argwhere(Hrange &gt;= -10e3).flatten()\n    for i, J in enumerate(Js):\n        VSD2 = Filters.detrend_axis(VSD[i], 1)\n        axs[i].pcolor(\n            Hrange / 1e3,\n            fscan / 1e9,\n            VSD2,\n            shading='auto',\n            cmap=cm.get_cmap(\"magma\"),\n        )\n        krel = kittel_relation(HJsAm[i], Hrange[Hpos_mask], H_ku, Ms) / 1e9\n        axs[i].plot(Hrange[~Hpos_mask] / 1e3, krel, color='turquoise', lw=2.)\n        col = 'ivory'\n        mult = 1\n        if i == 2:\n            colid = 11\n            mult = -1.\n        else:\n            colid = 13\n        axs[i].plot(mult * magens[i][0] / 1e3,\n                    magens[i][colid] / 1e9,\n                    label='Smit-Beljers',\n                    lw=1.5,\n                    linestyle='--',\n                    color=col)\n\n        if labels[i] + \"nm\" in df.columns:\n            axs[i].plot(df[labels[i] + \"nmH\"] * OetoAm / 1e3,\n                        df[labels[i] + \"nm\"],\n                        '.',\n                        markeredgecolor='lime',\n                        markerfacecolor='none',\n                        markersize=6,\n                        mew=1)\n        if J &gt; 0:\n            jlabel = r'$J &gt; 0$'\n        elif J &lt; 0:\n            jlabel = r'$J &lt; 0$'\n        if labels[i] == '2.14':\n            jlabel = r'$J \\approx 0$'\n        axs[i].set_title(labels[i] + \" nm, \" + jlabel)\n        axs[i].set_xlabel(\"$\\mathregular{H}_\\mathrm{y}$ [kA/m]\", usetex=False)\n        axs[i].set_ylim([1, 5.5])\n        axs[i].set_xlim([-15, 15])\n        if i &gt; 0:\n            continue\n\n    axs[0].set_ylabel(r\"f [GHz]\")\n    for label, ax in zip(('(a)', '(b)', '(c)', '(d)', '(e)'),\n                         (ax1, ax2, ax3, ax4, ax5)):\n        # label physical distance in and down:\n        trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,\n                                              fig.dpi_scale_trans)\n        ax.text(0.0,\n                1.0,\n                label,\n                transform=ax.transAxes + trans,\n                fontsize='medium',\n                verticalalignment='top',\n                bbox=dict(facecolor='none', edgecolor='none', pad=3.0))\n    fig.subplots_adjust(wspace=0, hspace=0.4)\n\n    for ax in (ax2, ax3, ax5):\n        ax.set_yticklabels([])\n    fig.align_ylabels()\n</pre> def kittel_relation(H_iec, H_ext, H_ku, Ms):     B_ = (abs(H_iec) + H_ext + H_ku) * mu0     f = 28024e6 * np.sqrt(B_ * (B_ + Ms))     return f   df = pd.read_csv('./data/dispersion_relation.csv', skiprows=[0], sep=',') df_magen_237 = pd.read_csv('./data/J237.dat', sep='\\t', header=None) df_magen_214 = pd.read_csv('./data/J214.dat', sep='\\t', header=None) df_magen_190 = pd.read_csv('./data/magen3190.dat', sep='\\t', header=None) cmap = sns.color_palette('inferno', len(loops0)) HJs = (25, 15, -29) freq_indx = (4, 8, 14) magens = [df_magen_237, df_magen_214, df_magen_190] with plt.style.context(['science', 'nature']):     fig = plt.figure(constrained_layout=True, figsize=(3.4, 8), dpi=300)     gs = plt.GridSpec(4, 6)     ax1 = fig.add_subplot(gs[0, :2])     ax2 = fig.add_subplot(gs[0, 2:4])     ax3 = fig.add_subplot(gs[0, 4:])     axs = [ax1, ax2, ax3]     ax4 = fig.add_subplot(gs[1, :3])     ax5 = fig.add_subplot(gs[1, 3:])      for i, th in enumerate(loops0):         ax4.plot(loop_Hrange / 1e3,                  loops0[th],                  label=f\"{th} nm\",                  color=cmap[i])         ax5.plot(loop_Hrange / 1e3,                  loops90[th],                  label=f\"{th} nm\",                  color=cmap[i])      ax4.set_xlabel(\"H [kA/m]\")     ax5.set_xlabel(\"H [kA/m]\")     ax4.set_ylabel(r\"Resistance [$\\Omega$]\")     ax5.legend(frameon=True, loc=5)      Ms = 1.03     H_ku = 2 * 0.8e3 / (Ms)     HJsAm = [H_  * OetoAm for H_ in HJs]     Hpos_mask = np.argwhere(Hrange &gt;= -10e3).flatten()     for i, J in enumerate(Js):         VSD2 = Filters.detrend_axis(VSD[i], 1)         axs[i].pcolor(             Hrange / 1e3,             fscan / 1e9,             VSD2,             shading='auto',             cmap=cm.get_cmap(\"magma\"),         )         krel = kittel_relation(HJsAm[i], Hrange[Hpos_mask], H_ku, Ms) / 1e9         axs[i].plot(Hrange[~Hpos_mask] / 1e3, krel, color='turquoise', lw=2.)         col = 'ivory'         mult = 1         if i == 2:             colid = 11             mult = -1.         else:             colid = 13         axs[i].plot(mult * magens[i][0] / 1e3,                     magens[i][colid] / 1e9,                     label='Smit-Beljers',                     lw=1.5,                     linestyle='--',                     color=col)          if labels[i] + \"nm\" in df.columns:             axs[i].plot(df[labels[i] + \"nmH\"] * OetoAm / 1e3,                         df[labels[i] + \"nm\"],                         '.',                         markeredgecolor='lime',                         markerfacecolor='none',                         markersize=6,                         mew=1)         if J &gt; 0:             jlabel = r'$J &gt; 0$'         elif J &lt; 0:             jlabel = r'$J &lt; 0$'         if labels[i] == '2.14':             jlabel = r'$J \\approx 0$'         axs[i].set_title(labels[i] + \" nm, \" + jlabel)         axs[i].set_xlabel(\"$\\mathregular{H}_\\mathrm{y}$ [kA/m]\", usetex=False)         axs[i].set_ylim([1, 5.5])         axs[i].set_xlim([-15, 15])         if i &gt; 0:             continue      axs[0].set_ylabel(r\"f [GHz]\")     for label, ax in zip(('(a)', '(b)', '(c)', '(d)', '(e)'),                          (ax1, ax2, ax3, ax4, ax5)):         # label physical distance in and down:         trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,                                               fig.dpi_scale_trans)         ax.text(0.0,                 1.0,                 label,                 transform=ax.transAxes + trans,                 fontsize='medium',                 verticalalignment='top',                 bbox=dict(facecolor='none', edgecolor='none', pad=3.0))     fig.subplots_adjust(wspace=0, hspace=0.4)      for ax in (ax2, ax3, ax5):         ax.set_yticklabels([])     fig.align_ylabels() <pre>/var/folders/wq/0q9brtfs5rq65q1t_mtgshb00000gn/T/ipykernel_81600/632190011.py:3: RuntimeWarning: invalid value encountered in sqrt\n  f = 28024e6 * np.sqrt(B_ * (B_ + Ms))\n/var/folders/wq/0q9brtfs5rq65q1t_mtgshb00000gn/T/ipykernel_81600/632190011.py:3: RuntimeWarning: invalid value encountered in sqrt\n  f = 28024e6 * np.sqrt(B_ * (B_ + Ms))\n/var/folders/wq/0q9brtfs5rq65q1t_mtgshb00000gn/T/ipykernel_81600/632190011.py:3: RuntimeWarning: invalid value encountered in sqrt\n  f = 28024e6 * np.sqrt(B_ * (B_ + Ms))\n/var/folders/wq/0q9brtfs5rq65q1t_mtgshb00000gn/T/ipykernel_81600/632190011.py:103: UserWarning: This figure was using constrained_layout, but that is incompatible with subplots_adjust and/or tight_layout; disabling constrained_layout.\n  fig.subplots_adjust(wspace=0, hspace=0.4)\n</pre> In\u00a0[5]: Copied! <pre>def simulate_pimm(J: float, stepsH: int = 100):\n    int_step = 5e-13\n    demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)]\n\n    Ku = 0.8e3\n    alpha = 0.024  # 0.024\n    Ms1 = 1.03\n    Ms2 = 1.65\n    surf = 0.1\n    l1 = Layer(\n        \"free\",\n        mag=CVector(1, 0.1, 0.1),\n        anis=CVector(0, 1., 0.),  # direction of the anisotropy\n        Ms=Ms1,\n        thickness=2e-9,\n        cellSurface=surf,\n        demagTensor=demag,\n        damping=alpha)\n\n    l2 = Layer(\n        \"bottom\",\n        mag=CVector(1, 0.1, 0.1),\n        anis=CVector(1, 0, 0),  # direction of the anisotropy\n        Ms=Ms2,\n        thickness=6e-9,\n        cellSurface=surf,\n        demagTensor=demag,\n        damping=alpha)\n    j1 = Junction([l1, l2], 163.5, 176)\n    j1.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(Ku))\n    j1.setLayerAnisotropyDriver(\"bottom\", ScalarDriver.getConstantDriver(1e12))\n    j1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J))\n    spectrum = []\n    Hscan, Hvecs = FieldScan.amplitude_scan(-800e3, 800e3, stepsH, 90, 45)\n    div = 10\n    j1.setLayerExternalFieldDriver(\n        \"all\",\n        AxialDriver(ScalarDriver.getConstantDriver(Hvecs[0][0]),\n                    ScalarDriver.getConstantDriver(Hvecs[0][1]),\n                    ScalarDriver.getConstantDriver(Hvecs[0][2])))\n    j1.runSimulation(5e-9, int_step, int_step, solverMode=SolverMode.RK4)\n    for hangle in Hvecs:\n        j1.clearLog()\n        j1.setLayerExternalFieldDriver(\n            \"all\",\n            AxialDriver(ScalarDriver.getConstantDriver(hangle[0]),\n                        ScalarDriver.getConstantDriver(hangle[1]),\n                        ScalarDriver.getConstantDriver(hangle[2])))\n        HoeDriver = AxialDriver(\n            NullDriver(), NullDriver(),\n            ScalarDriver.getStepDriver(0, 50, 0.0, int_step * 5))\n        j1.setLayerOerstedFieldDriver(\"all\", HoeDriver)\n        j1.runSimulation(15e-9, int_step, int_step, solverMode=SolverMode.RK4)\n        log = j1.getLog()\n\n        mixed = np.mean([\n            np.asarray(log[f\"{layer}_mz\"]) * Ms\n            for layer, Ms in zip(('free', 'bottom'), (Ms1, Ms2))\n        ],\n                        axis=0)\n        mixed = np.squeeze(mixed)\n        yf = np.abs(fft(mixed))\n        frequencies = fftfreq(len(yf), int_step)\n        frequencies = frequencies[:len(yf) // div]\n        yf = yf[1:len(yf) // div]\n        spectrum.append(yf)\n\n    return np.asarray(spectrum), frequencies, Hscan\n\n\nJrange = np.linspace(-1e-3, 1e-3, 30)\n\ndata = defaultdict(list)\nfor J in tqdm(Jrange, desc=\"simulating J\"):\n    spectrum, frequencies, Hvecs = simulate_pimm(J)\n    data['J'].append(J)\n    data['spec'].append(spectrum)\n    data['f'].append(frequencies)\n    data['H'].append(Hvecs)\n</pre> def simulate_pimm(J: float, stepsH: int = 100):     int_step = 5e-13     demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)]      Ku = 0.8e3     alpha = 0.024  # 0.024     Ms1 = 1.03     Ms2 = 1.65     surf = 0.1     l1 = Layer(         \"free\",         mag=CVector(1, 0.1, 0.1),         anis=CVector(0, 1., 0.),  # direction of the anisotropy         Ms=Ms1,         thickness=2e-9,         cellSurface=surf,         demagTensor=demag,         damping=alpha)      l2 = Layer(         \"bottom\",         mag=CVector(1, 0.1, 0.1),         anis=CVector(1, 0, 0),  # direction of the anisotropy         Ms=Ms2,         thickness=6e-9,         cellSurface=surf,         demagTensor=demag,         damping=alpha)     j1 = Junction([l1, l2], 163.5, 176)     j1.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(Ku))     j1.setLayerAnisotropyDriver(\"bottom\", ScalarDriver.getConstantDriver(1e12))     j1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J))     spectrum = []     Hscan, Hvecs = FieldScan.amplitude_scan(-800e3, 800e3, stepsH, 90, 45)     div = 10     j1.setLayerExternalFieldDriver(         \"all\",         AxialDriver(ScalarDriver.getConstantDriver(Hvecs[0][0]),                     ScalarDriver.getConstantDriver(Hvecs[0][1]),                     ScalarDriver.getConstantDriver(Hvecs[0][2])))     j1.runSimulation(5e-9, int_step, int_step, solverMode=SolverMode.RK4)     for hangle in Hvecs:         j1.clearLog()         j1.setLayerExternalFieldDriver(             \"all\",             AxialDriver(ScalarDriver.getConstantDriver(hangle[0]),                         ScalarDriver.getConstantDriver(hangle[1]),                         ScalarDriver.getConstantDriver(hangle[2])))         HoeDriver = AxialDriver(             NullDriver(), NullDriver(),             ScalarDriver.getStepDriver(0, 50, 0.0, int_step * 5))         j1.setLayerOerstedFieldDriver(\"all\", HoeDriver)         j1.runSimulation(15e-9, int_step, int_step, solverMode=SolverMode.RK4)         log = j1.getLog()          mixed = np.mean([             np.asarray(log[f\"{layer}_mz\"]) * Ms             for layer, Ms in zip(('free', 'bottom'), (Ms1, Ms2))         ],                         axis=0)         mixed = np.squeeze(mixed)         yf = np.abs(fft(mixed))         frequencies = fftfreq(len(yf), int_step)         frequencies = frequencies[:len(yf) // div]         yf = yf[1:len(yf) // div]         spectrum.append(yf)      return np.asarray(spectrum), frequencies, Hscan   Jrange = np.linspace(-1e-3, 1e-3, 30)  data = defaultdict(list) for J in tqdm(Jrange, desc=\"simulating J\"):     spectrum, frequencies, Hvecs = simulate_pimm(J)     data['J'].append(J)     data['spec'].append(spectrum)     data['f'].append(frequencies)     data['H'].append(Hvecs) <pre>simulating J: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [01:11&lt;00:00,  2.38s/it]\n</pre> In\u00a0[6]: Copied! <pre>with plt.style.context(['science', 'nature']):\n    fig, (ax1, ax2) = plt.subplots(1,\n                                   2,\n                                   figsize=(4.5, 2.5),\n                                   sharey=True,\n                                   dpi=300)\n    ax2.set_ylim([0, 30.5])\n    vmax = max(spectrum.max(), spectrum.min())\n    # argmaxline\n    lw = 1.5\n    palette = sns.color_palette(\"inferno\", len(Jrange))\n    spectrum = np.zeros_like(data['spec'][0])\n    for i in range(Jrange.shape[0]):\n        max_freqs = np.argmax(data['spec'][i], axis=1)\n        ax2.plot(data['H'][0] / 1e3,\n                 data['f'][0][max_freqs] / 1e9,\n                 linewidth=lw,\n                 color=palette[i],\n                 alpha=.9)\n        spectrum += data['spec'][i]\n    ax2.pcolor(Hvecs / 1e3,\n               frequencies / 1e9,\n               spectrum.T,\n               shading='auto',\n               cmap='inferno')\n    ax2.set_xlabel(\"H [kA/m]\")\n\n    ax1.set_xlabel(\"H [kA/m]\")\n    ax1.set_ylabel(\"f [GHz]\")\n    ax1.set_ylim([0, 30.5])\n    ax1.pcolor(Hvecs / 1e3,\n               frequencies / 1e9,\n               spectrum.T,\n               shading='auto',\n               cmap='inferno')\n\n    cmap = sns.color_palette(\"inferno\", as_cmap=True)\n    cmap = sns.color_palette(\"inferno\", as_cmap=True)\n    norm = mpl.colors.Normalize(vmin=spectrum.min(), vmax=spectrum.max())\n    cbar = fig.colorbar(mpl.cm.ScalarMappable(norm=norm, cmap=cmap),\n                        ax=ax1,\n                        orientation='vertical')\n    cbar.ax.set_ylabel(r\"Ampl. [a.u.]\", rotation=270, usetex=False)\n    cbar.ax.get_yaxis().labelpad = 9.5\n    cmap = sns.color_palette(\"inferno\", as_cmap=True)\n    norm = mpl.colors.Normalize(vmin=Jrange.min() * 1e3,\n                                vmax=Jrange.max() * 1e3)\n    cbar = fig.colorbar(mpl.cm.ScalarMappable(norm=norm, cmap=cmap),\n                        ax=ax2,\n                        orientation='vertical')\n    cbar.ax.set_ylabel(r\"J [$\\mathregular{mJ/m^2}$]\",\n                       rotation=270,\n                       usetex=False)\n    cbar.ax.get_yaxis().labelpad = 9.5\n\n    fig.subplots_adjust(wspace=0.15)\n    for label, ax in zip(('(a)', '(b)'), (ax1, ax2)):\n        trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,\n                                              fig.dpi_scale_trans)\n\n        fc = 'none'\n        ec = 'none'\n        ax.text(0,\n                1,\n                label,\n                color='azure',\n                transform=ax.transAxes + trans,\n                verticalalignment='top',\n                bbox=dict(facecolor=fc, edgecolor=ec, pad=3.0))\n</pre> with plt.style.context(['science', 'nature']):     fig, (ax1, ax2) = plt.subplots(1,                                    2,                                    figsize=(4.5, 2.5),                                    sharey=True,                                    dpi=300)     ax2.set_ylim([0, 30.5])     vmax = max(spectrum.max(), spectrum.min())     # argmaxline     lw = 1.5     palette = sns.color_palette(\"inferno\", len(Jrange))     spectrum = np.zeros_like(data['spec'][0])     for i in range(Jrange.shape[0]):         max_freqs = np.argmax(data['spec'][i], axis=1)         ax2.plot(data['H'][0] / 1e3,                  data['f'][0][max_freqs] / 1e9,                  linewidth=lw,                  color=palette[i],                  alpha=.9)         spectrum += data['spec'][i]     ax2.pcolor(Hvecs / 1e3,                frequencies / 1e9,                spectrum.T,                shading='auto',                cmap='inferno')     ax2.set_xlabel(\"H [kA/m]\")      ax1.set_xlabel(\"H [kA/m]\")     ax1.set_ylabel(\"f [GHz]\")     ax1.set_ylim([0, 30.5])     ax1.pcolor(Hvecs / 1e3,                frequencies / 1e9,                spectrum.T,                shading='auto',                cmap='inferno')      cmap = sns.color_palette(\"inferno\", as_cmap=True)     cmap = sns.color_palette(\"inferno\", as_cmap=True)     norm = mpl.colors.Normalize(vmin=spectrum.min(), vmax=spectrum.max())     cbar = fig.colorbar(mpl.cm.ScalarMappable(norm=norm, cmap=cmap),                         ax=ax1,                         orientation='vertical')     cbar.ax.set_ylabel(r\"Ampl. [a.u.]\", rotation=270, usetex=False)     cbar.ax.get_yaxis().labelpad = 9.5     cmap = sns.color_palette(\"inferno\", as_cmap=True)     norm = mpl.colors.Normalize(vmin=Jrange.min() * 1e3,                                 vmax=Jrange.max() * 1e3)     cbar = fig.colorbar(mpl.cm.ScalarMappable(norm=norm, cmap=cmap),                         ax=ax2,                         orientation='vertical')     cbar.ax.set_ylabel(r\"J [$\\mathregular{mJ/m^2}$]\",                        rotation=270,                        usetex=False)     cbar.ax.get_yaxis().labelpad = 9.5      fig.subplots_adjust(wspace=0.15)     for label, ax in zip(('(a)', '(b)'), (ax1, ax2)):         trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,                                               fig.dpi_scale_trans)          fc = 'none'         ec = 'none'         ax.text(0,                 1,                 label,                 color='azure',                 transform=ax.transAxes + trans,                 verticalalignment='top',                 bbox=dict(facecolor=fc, edgecolor=ec, pad=3.0)) <pre>/var/folders/wq/0q9brtfs5rq65q1t_mtgshb00000gn/T/ipykernel_81600/218232615.py:21: MatplotlibDeprecationWarning: shading='flat' when X and Y have the same dimensions as C is deprecated since 3.3.  Either specify the corners of the quadrilaterals with X and Y, or pass shading='auto', 'nearest' or 'gouraud', or set rcParams['pcolor.shading'].  This will become an error two minor releases later.\n  ax2.pcolor(Hvecs / 1e3,\n/var/folders/wq/0q9brtfs5rq65q1t_mtgshb00000gn/T/ipykernel_81600/218232615.py:31: MatplotlibDeprecationWarning: shading='flat' when X and Y have the same dimensions as C is deprecated since 3.3.  Either specify the corners of the quadrilaterals with X and Y, or pass shading='auto', 'nearest' or 'gouraud', or set rcParams['pcolor.shading'].  This will become an error two minor releases later.\n  ax1.pcolor(Hvecs / 1e3,\n</pre> In\u00a0[7]: Copied! <pre>def simulate_cims(H_ext: float, impulses: np.ndarray):\n    w = 10e-6\n    l = 75e-6\n\n    Ms = 0.5\n    Hk = 2508 * OetoAm\n    K = Ms * Hk / 2\n    jden = 6.94e10\n    Hdl = 6.23e2 / jden * 1.35\n    Hfl = 1.43e2 / jden * 1.35\n    # surface is required for temperature calculation\n    surf = w * l\n    # approximate demagnetisation tensor\n    demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 0)]\n    ### Create MTJ ###\n    # we use the .createSTTLayer to indicate the STT contributions\n    # we can also create SOT layers for other experiments.\n    alpha = 0.03\n    l1 = Layer.createSOTLayer(\n        \"free\",\n        mag=CVector(0.1, 0.1, 1.),\n        anis=CVector(0, 0., 1.),  # direction of the anisotropy\n        Ms=Ms,\n        thickness=4e-9,\n        cellSurface=surf,\n        demagTensor=demag,\n        damping=alpha,\n        dampingLikeTorque=Hdl,\n        fieldLikeTorque=Hfl)\n\n    j = Junction([l1])\n    j.setLayerAnisotropyDriver(\"all\", ScalarDriver.getConstantDriver(K))\n    j.setLayerReferenceLayer(\"all\", CVector(0, 1, 0))\n\n    tstep = 1e-13\n\n    hysteresis = []\n    data = {}\n\n    hangle = FieldScan.angle2vector(90, 0, H_ext)\n    j.setLayerExternalFieldDriver(\n        \"free\",\n        AxialDriver(ScalarDriver.getConstantDriver(hangle.x),\n                    ScalarDriver.getConstantDriver(hangle.y),\n                    ScalarDriver.getConstantDriver(hangle.z)))\n    for current in impulses:\n        j.clearLog()\n        j.setLayerMagnetisation(\"free\", CVector(0, 0, -1))\n        pulse = ScalarDriver.getTrapezoidDriver(0, current, 0, 1e-9, 3e-9)\n        j.setLayerCurrentDriver(\"all\", pulse)\n        j.runSimulation(15e-9, tstep, tstep)\n\n        log = j.getLog()\n        str_ = \"free\"\n        m = np.asarray(\n            [[log[f'{str_}_mx'], log[f'{str_}_my'], log[f'{str_}_mz']]])\n        Rx0 = [100]\n        Ry0 = [1]\n        SMR = [1.11]\n        AMR = [0.41]\n        AHE = [2.23]\n        _, Rxy = calculate_resistance_series(Rx0,\n                                             Ry0,\n                                             AMR=AMR,\n                                             AHE=AHE,\n                                             SMR=SMR,\n                                             m=m,\n                                             l=[l],\n                                             w=[w])\n\n        Rstable = Rxy[-100:].mean()\n        hysteresis.append(Rstable)\n\n    data['hysteresis'] = hysteresis\n    critical_current = 0\n    for i in range(1, len(hysteresis)):\n        if abs(hysteresis[i] - hysteresis[i - 1]) &gt; 0.1:\n            critical_current = impulses[i]\n    data['critical_current'] = critical_current\n    return data\n\n\nHspace = np.linspace(-1200, 1200, 50, endpoint=True) * OetoAm\nImax = 1.4e13\nimpulses = np.linspace(-Imax, Imax, num=250)\n\n\ndef sim_warp(H_ext):\n    return simulate_cims(H_ext, impulses)\n\n\ncritical_currents = np.zeros(len(Hspace))\n\nfor res in distribute(sim_warp, [Hspace]):\n    indx, output = res\n    critical_currents[indx] = output['critical_current']\n\n# uncomment for serial\n# import time\n# start = time.time()\n# for i, H_ext in enumerate(tqdm(Hspace)):\n#     output = sim_warp(H_ext)\n#     critical_currents[i] = output['critical_current']\n#     # print(f'{i} / {len(Hspace)}')\n# end = time.time()\n# print(f'Elapsed time: {end - start}')\n</pre> def simulate_cims(H_ext: float, impulses: np.ndarray):     w = 10e-6     l = 75e-6      Ms = 0.5     Hk = 2508 * OetoAm     K = Ms * Hk / 2     jden = 6.94e10     Hdl = 6.23e2 / jden * 1.35     Hfl = 1.43e2 / jden * 1.35     # surface is required for temperature calculation     surf = w * l     # approximate demagnetisation tensor     demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 0)]     ### Create MTJ ###     # we use the .createSTTLayer to indicate the STT contributions     # we can also create SOT layers for other experiments.     alpha = 0.03     l1 = Layer.createSOTLayer(         \"free\",         mag=CVector(0.1, 0.1, 1.),         anis=CVector(0, 0., 1.),  # direction of the anisotropy         Ms=Ms,         thickness=4e-9,         cellSurface=surf,         demagTensor=demag,         damping=alpha,         dampingLikeTorque=Hdl,         fieldLikeTorque=Hfl)      j = Junction([l1])     j.setLayerAnisotropyDriver(\"all\", ScalarDriver.getConstantDriver(K))     j.setLayerReferenceLayer(\"all\", CVector(0, 1, 0))      tstep = 1e-13      hysteresis = []     data = {}      hangle = FieldScan.angle2vector(90, 0, H_ext)     j.setLayerExternalFieldDriver(         \"free\",         AxialDriver(ScalarDriver.getConstantDriver(hangle.x),                     ScalarDriver.getConstantDriver(hangle.y),                     ScalarDriver.getConstantDriver(hangle.z)))     for current in impulses:         j.clearLog()         j.setLayerMagnetisation(\"free\", CVector(0, 0, -1))         pulse = ScalarDriver.getTrapezoidDriver(0, current, 0, 1e-9, 3e-9)         j.setLayerCurrentDriver(\"all\", pulse)         j.runSimulation(15e-9, tstep, tstep)          log = j.getLog()         str_ = \"free\"         m = np.asarray(             [[log[f'{str_}_mx'], log[f'{str_}_my'], log[f'{str_}_mz']]])         Rx0 = [100]         Ry0 = [1]         SMR = [1.11]         AMR = [0.41]         AHE = [2.23]         _, Rxy = calculate_resistance_series(Rx0,                                              Ry0,                                              AMR=AMR,                                              AHE=AHE,                                              SMR=SMR,                                              m=m,                                              l=[l],                                              w=[w])          Rstable = Rxy[-100:].mean()         hysteresis.append(Rstable)      data['hysteresis'] = hysteresis     critical_current = 0     for i in range(1, len(hysteresis)):         if abs(hysteresis[i] - hysteresis[i - 1]) &gt; 0.1:             critical_current = impulses[i]     data['critical_current'] = critical_current     return data   Hspace = np.linspace(-1200, 1200, 50, endpoint=True) * OetoAm Imax = 1.4e13 impulses = np.linspace(-Imax, Imax, num=250)   def sim_warp(H_ext):     return simulate_cims(H_ext, impulses)   critical_currents = np.zeros(len(Hspace))  for res in distribute(sim_warp, [Hspace]):     indx, output = res     critical_currents[indx] = output['critical_current']  # uncomment for serial # import time # start = time.time() # for i, H_ext in enumerate(tqdm(Hspace)): #     output = sim_warp(H_ext) #     critical_currents[i] = output['critical_current'] #     # print(f'{i} / {len(Hspace)}') # end = time.time() # print(f'Elapsed time: {end - start}') <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 50/50 [03:21&lt;00:00,  4.03s/it]\n</pre> In\u00a0[13]: Copied! <pre>def compute_j(Hx):\n    Hk = 2508 * OetoAm\n    Ms = 0.5\n    thetaSH = 13.5\n    tfm = 4e-9\n    jc = -(2 * echarge * Ms * tfm / hbar * thetaSH) * (Hk / 2 -\n                                                      Hx / math.sqrt(2))\n    return jc\n\n\ncric_c = compute_j(Hx=np.abs(Hspace))\n\nwith plt.style.context(['science', 'nature']):\n    fig, ax = plt.subplots(dpi=300)\n    ax.set_ylim([4.4, 8.5])\n    #     ax.set_xlim([-75, 75])\n    ax.plot(Hspace / 1e3,\n            np.abs(critical_currents) / 1e12,\n            'o',\n            markersize=5,\n            label='Simulation',\n            color='crimson',\n            markeredgecolor='k')\n    ax.plot(Hspace / 1e3,\n            cric_c / 1e12,\n            lw=2,\n            label='Analytical',\n            color='royalblue')\n    ax.set_xlabel(r\"$\\mathregular{H}_\\mathrm{x}$ [$\\mathdefault{kA/m}$]\",\n                  usetex=False)\n    ax.set_ylabel(r\"$j_\\mathrm{crit}$ [$\\mathdefault{TA/m^2}$]\", usetex=False)\n\n    ax.legend()\n</pre> def compute_j(Hx):     Hk = 2508 * OetoAm     Ms = 0.5     thetaSH = 13.5     tfm = 4e-9     jc = -(2 * echarge * Ms * tfm / hbar * thetaSH) * (Hk / 2 -                                                       Hx / math.sqrt(2))     return jc   cric_c = compute_j(Hx=np.abs(Hspace))  with plt.style.context(['science', 'nature']):     fig, ax = plt.subplots(dpi=300)     ax.set_ylim([4.4, 8.5])     #     ax.set_xlim([-75, 75])     ax.plot(Hspace / 1e3,             np.abs(critical_currents) / 1e12,             'o',             markersize=5,             label='Simulation',             color='crimson',             markeredgecolor='k')     ax.plot(Hspace / 1e3,             cric_c / 1e12,             lw=2,             label='Analytical',             color='royalblue')     ax.set_xlabel(r\"$\\mathregular{H}_\\mathrm{x}$ [$\\mathdefault{kA/m}$]\",                   usetex=False)     ax.set_ylabel(r\"$j_\\mathrm{crit}$ [$\\mathdefault{TA/m^2}$]\", usetex=False)      ax.legend() In\u00a0[9]: Copied! <pre># approximate demagnetisation tensor\ndemag = [\n    CVector(0.00116298, 0, 0),\n    CVector(0, 0.000227086, 0),\n    CVector(0, 0, 0.99861)\n]\nalpha = 0.005\nKdir = CVector(1, 0, 0)\nMs = 1.65\n# Ms = 1.8\nl1 = Layer(\"free\",\n           mag=CVector(0, 0, 1),\n           anis=Kdir,\n           Ms=Ms,\n           thickness=3.99e-9,\n           cellSurface=0,\n           demagTensor=demag,\n           damping=alpha)\n\nl2 = Layer(\"bottom\",\n           mag=CVector(0, 0, 1),\n           anis=Kdir,\n           Ms=Ms,\n           thickness=4e-9,\n           cellSurface=0,\n           demagTensor=demag,\n           damping=alpha)\n# J1 = -1.78e-3\n# J2 = -1.69e-4\nJ1 = -1.8e-3\nJ2 = -1.74e-4\n\nK1 = K2 = 1.05e3\n# K1 = K2 = 0.55e3\nint_step = 4e-14\n\nj1 = Junction([l1, l2], 100, 102)\n\nj1.setLayerAnisotropyDriver(\"all\", ScalarDriver.getConstantDriver(K1))\nj1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J1))\nj1.setQuadIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J2))\nHscan, Hvecs = FieldScan.amplitude_scan(-1200e3, 1200e3, 200, 89, 90)\nmagnetisations = defaultdict(list)\nspectrum = []\nsim_time = 4e-9\nfor indx, H in enumerate(tqdm(Hvecs)):\n    j1.clearLog()\n    j1.setLayerExternalFieldDriver(\n        \"all\",\n        AxialDriver(ScalarDriver.getConstantDriver(H[0]),\n                    ScalarDriver.getConstantDriver(H[1]),\n                    ScalarDriver.getConstantDriver(H[2])))\n    j1.setLayerOerstedFieldDriver(\n        \"all\",\n        AxialDriver(NullDriver(), NullDriver(),\n                    ScalarDriver.getStepDriver(0, 50, 0, int_step * 3)))\n    # if (H)\n    j1.runSimulation(sim_time, int_step, int_step)\n    log = j1.getLog()\n\n    org_layer_strs = ('free', 'bottom')\n    m_traj = np.asarray([[\n        log[f'{org_layer_strs[i]}_mx'], log[f'{org_layer_strs[i]}_my'],\n        log[f'{org_layer_strs[i]}_mz']\n    ] for i in range(2)])\n\n    m = m_traj[:, :, -100:]  # all layers, all x, y, z, last timestamp\n    m_avg = np.mean(m_traj[:, :, -1], 0)\n\n    mixed = [np.asarray(log[f\"{org_layer_strs[i]}_mz\"]) for i in range(2)]\n    # mixed = np.mean(np.squeeze(mixed), axis=0)\n    yf = np.abs(\n        fft(log[f\"{org_layer_strs[0]}_mz\"]) +\n        fft(log[f\"{org_layer_strs[1]}_mz\"]))\n    freqs = fftfreq(len(yf), int_step)\n    freqs = freqs[:len(freqs) // 2]\n    yf = yf[:len(yf) // 2]\n\n    findx = np.argwhere(freqs &lt;= 65e9)\n    freqs = freqs[findx]\n    yf = yf[findx]\n\n    spectrum.append(yf)\n    Rx, Ry = calculate_resistance_series([100, 100], [1, 1], [-0.046, -0.046],\n                                         [-2.7, -2.7], [-0.24, -0.24],\n                                         m,\n                                         l=[30, 30],\n                                         w=[20, 20])\n    magnetisations['H'].append(Hscan[indx])\n    magnetisations['m1'].append(m[0].mean(axis=1))\n    magnetisations['m2'].append(m[1].mean(axis=1))\n    magnetisations['m'].append(m_avg)\n    magnetisations['Rxx'].append(Rx.mean())\n    magnetisations['Rxy'].append(Ry.mean())\n    magnetisations['Rz'].append(log['R_free_bottom'][-1])\n    magnetisations['traj'].append(m_traj)\n\nspectrum = np.asarray(spectrum).squeeze()\n\n# phase computation\ntraj = np.asarray(magnetisations['traj'])\ntime = np.asarray(log['time']) * 1e9\nstart = 3.5  # pick a time\nstop = 4.5\nphases = defaultdict(list)\nindx = 1\nfor traj_h in traj:\n    eps = np.deg2rad(0.01)  # we allow 5 deg variation\n    rtime = np.argwhere((time &lt;= stop) &amp; (time &gt;= start))\n    for label, indx in zip('xyz', range(3)):\n        a = traj_h[0, indx, rtime].squeeze()\n        b = traj_h[1, indx, rtime].squeeze()\n        af = fft(a)\n        bf = fft(b)\n        freqs2 = fftfreq(len(af), int_step)\n        freqs2 = freqs2[:len(freqs2) // 2]\n        af = af[:len(af) // 2]\n        bf = bf[:len(bf) // 2]\n\n        findx = np.argwhere(freqs2 &lt;= 65e9)\n        af = af[findx]\n        bf = bf[findx]\n\n        angle_af = np.angle(af)\n        angle_bf = np.angle(bf)\n        max_freq = np.argmax(np.abs(af[1:]))\n        phase = np.abs(angle_af[1:][max_freq] - angle_bf[1:][max_freq])\n        phases[label].append(phase)\n</pre> # approximate demagnetisation tensor demag = [     CVector(0.00116298, 0, 0),     CVector(0, 0.000227086, 0),     CVector(0, 0, 0.99861) ] alpha = 0.005 Kdir = CVector(1, 0, 0) Ms = 1.65 # Ms = 1.8 l1 = Layer(\"free\",            mag=CVector(0, 0, 1),            anis=Kdir,            Ms=Ms,            thickness=3.99e-9,            cellSurface=0,            demagTensor=demag,            damping=alpha)  l2 = Layer(\"bottom\",            mag=CVector(0, 0, 1),            anis=Kdir,            Ms=Ms,            thickness=4e-9,            cellSurface=0,            demagTensor=demag,            damping=alpha) # J1 = -1.78e-3 # J2 = -1.69e-4 J1 = -1.8e-3 J2 = -1.74e-4  K1 = K2 = 1.05e3 # K1 = K2 = 0.55e3 int_step = 4e-14  j1 = Junction([l1, l2], 100, 102)  j1.setLayerAnisotropyDriver(\"all\", ScalarDriver.getConstantDriver(K1)) j1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J1)) j1.setQuadIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J2)) Hscan, Hvecs = FieldScan.amplitude_scan(-1200e3, 1200e3, 200, 89, 90) magnetisations = defaultdict(list) spectrum = [] sim_time = 4e-9 for indx, H in enumerate(tqdm(Hvecs)):     j1.clearLog()     j1.setLayerExternalFieldDriver(         \"all\",         AxialDriver(ScalarDriver.getConstantDriver(H[0]),                     ScalarDriver.getConstantDriver(H[1]),                     ScalarDriver.getConstantDriver(H[2])))     j1.setLayerOerstedFieldDriver(         \"all\",         AxialDriver(NullDriver(), NullDriver(),                     ScalarDriver.getStepDriver(0, 50, 0, int_step * 3)))     # if (H)     j1.runSimulation(sim_time, int_step, int_step)     log = j1.getLog()      org_layer_strs = ('free', 'bottom')     m_traj = np.asarray([[         log[f'{org_layer_strs[i]}_mx'], log[f'{org_layer_strs[i]}_my'],         log[f'{org_layer_strs[i]}_mz']     ] for i in range(2)])      m = m_traj[:, :, -100:]  # all layers, all x, y, z, last timestamp     m_avg = np.mean(m_traj[:, :, -1], 0)      mixed = [np.asarray(log[f\"{org_layer_strs[i]}_mz\"]) for i in range(2)]     # mixed = np.mean(np.squeeze(mixed), axis=0)     yf = np.abs(         fft(log[f\"{org_layer_strs[0]}_mz\"]) +         fft(log[f\"{org_layer_strs[1]}_mz\"]))     freqs = fftfreq(len(yf), int_step)     freqs = freqs[:len(freqs) // 2]     yf = yf[:len(yf) // 2]      findx = np.argwhere(freqs &lt;= 65e9)     freqs = freqs[findx]     yf = yf[findx]      spectrum.append(yf)     Rx, Ry = calculate_resistance_series([100, 100], [1, 1], [-0.046, -0.046],                                          [-2.7, -2.7], [-0.24, -0.24],                                          m,                                          l=[30, 30],                                          w=[20, 20])     magnetisations['H'].append(Hscan[indx])     magnetisations['m1'].append(m[0].mean(axis=1))     magnetisations['m2'].append(m[1].mean(axis=1))     magnetisations['m'].append(m_avg)     magnetisations['Rxx'].append(Rx.mean())     magnetisations['Rxy'].append(Ry.mean())     magnetisations['Rz'].append(log['R_free_bottom'][-1])     magnetisations['traj'].append(m_traj)  spectrum = np.asarray(spectrum).squeeze()  # phase computation traj = np.asarray(magnetisations['traj']) time = np.asarray(log['time']) * 1e9 start = 3.5  # pick a time stop = 4.5 phases = defaultdict(list) indx = 1 for traj_h in traj:     eps = np.deg2rad(0.01)  # we allow 5 deg variation     rtime = np.argwhere((time &lt;= stop) &amp; (time &gt;= start))     for label, indx in zip('xyz', range(3)):         a = traj_h[0, indx, rtime].squeeze()         b = traj_h[1, indx, rtime].squeeze()         af = fft(a)         bf = fft(b)         freqs2 = fftfreq(len(af), int_step)         freqs2 = freqs2[:len(freqs2) // 2]         af = af[:len(af) // 2]         bf = bf[:len(bf) // 2]          findx = np.argwhere(freqs2 &lt;= 65e9)         af = af[findx]         bf = bf[findx]          angle_af = np.angle(af)         angle_bf = np.angle(bf)         max_freq = np.argmax(np.abs(af[1:]))         phase = np.abs(angle_af[1:][max_freq] - angle_bf[1:][max_freq])         phases[label].append(phase) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 200/200 [00:21&lt;00:00,  9.49it/s]\n</pre> In\u00a0[10]: Copied! <pre>pimm_data = pd.read_csv('./data/4804_35.csv', sep=';')\npimm_data['f'] = pd.to_numeric(pimm_data['f'].str.replace(',', '.')).astype(float)\npimm_data['H'] = pd.to_numeric(pimm_data['H'].str.replace(',', '.')).astype(float)\npimm_data = pimm_data.loc[pimm_data['H'].between(-550e3/OetoAm, 550e3/OetoAm)]\nwith plt.style.context(['science', 'nature']):\n    fig, axs = plt.subplots(3, 2, figsize=(5, 2), dpi=300, sharex=True)\n    # hindx = 55\n    hindx = 57\n    traj = np.asarray(magnetisations['traj'])[hindx]\n    time = np.asarray(log['time']) * 1e9\n    start = 3.5\n    stop = 4.5\n    rtime = np.argwhere((time &lt;= stop) &amp; (time &gt;= start))\n    for i, label in enumerate('xyz'):\n        axs[i, 0].plot(time[rtime],\n                       traj[0, i, rtime],\n                       color='royalblue',\n                       label=rf\"$m_1$\")\n        axs[i, 0].plot(time[rtime],\n                       traj[1, i, rtime],\n                       color='crimson',\n                       label=rf\"$m_2$\")\n        axs[i, 0].set_ylabel(rf'$m_{label}$')\n    fig.subplots_adjust(hspace=0, wspace=0.25)\n    fig.align_labels()\n\n    gs = axs[1, -1].get_gridspec()\n    axs[0, 0].legend()\n    axbig = fig.add_subplot(gs[:, -1])\n    axbig.pcolor(Hscan[1:] / 1e3,\n                 freqs / 1e9,\n                 np.log10(spectrum[1:].T),\n                 shading='auto',\n                 cmap='magma')\n    axbig.axvline(x=Hscan[hindx] / 1e3,\n                  color='lavender',\n                  linestyle='--',\n                  label=f\"{Hscan[hindx] / 1e3:.0f} kA/m\")\n    axbig.set_xlabel(\"$\\mathrm{H}_\\mathrm{y}$ [kA/m]\", usetex=False)\n    axbig.set_ylabel(\"f [GHz]\")\n    axbig2 = axbig.twinx()\n    axbig.plot(pimm_data['H'] * OetoAm / 1e3,\n               pimm_data['f'],\n               'o',\n               markerfacecolor='royalblue',\n               markeredgecolor='black')\n    p = uniform_filter1d(phases['z'][1:], 5)\n\n    axbig2.plot(Hscan[1:] / 1e3, p, color='azure', label=rf'$\\phi_{label}$')\n    axbig2.set_ylabel(r'$\\Delta\\phi_z$ [rad]', rotation=270, labelpad=15)\n\n    for ax in axs[:, -1]:\n        # ax.remove()\n        ax.set_axis_off()\n    axs[-1, 0].set_xlabel(\"Time [ns]\")\n    axbig.legend(frameon=False, labelcolor='lavender', loc=10)\n    # axbig.legend(frameon=False, labelcolor='lavender', loc=1, fontsize='x-small')\n    for label, ax in zip(('(a)', '(b)', '(c)', '(d)'), [*axs[:, 0], axbig]):\n        trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,\n                                              fig.dpi_scale_trans)\n        if label == '(d)':\n            fc = 'none'\n            ec = 'none'\n        else:\n            fc = 'white'\n            ec = 'lavender'\n        ax.text(0,\n                1,\n                label,\n                color='black',\n                transform=ax.transAxes + trans,\n                verticalalignment='top',\n                bbox=dict(facecolor=fc, edgecolor=ec, pad=3.0))\n</pre> pimm_data = pd.read_csv('./data/4804_35.csv', sep=';') pimm_data['f'] = pd.to_numeric(pimm_data['f'].str.replace(',', '.')).astype(float) pimm_data['H'] = pd.to_numeric(pimm_data['H'].str.replace(',', '.')).astype(float) pimm_data = pimm_data.loc[pimm_data['H'].between(-550e3/OetoAm, 550e3/OetoAm)] with plt.style.context(['science', 'nature']):     fig, axs = plt.subplots(3, 2, figsize=(5, 2), dpi=300, sharex=True)     # hindx = 55     hindx = 57     traj = np.asarray(magnetisations['traj'])[hindx]     time = np.asarray(log['time']) * 1e9     start = 3.5     stop = 4.5     rtime = np.argwhere((time &lt;= stop) &amp; (time &gt;= start))     for i, label in enumerate('xyz'):         axs[i, 0].plot(time[rtime],                        traj[0, i, rtime],                        color='royalblue',                        label=rf\"$m_1$\")         axs[i, 0].plot(time[rtime],                        traj[1, i, rtime],                        color='crimson',                        label=rf\"$m_2$\")         axs[i, 0].set_ylabel(rf'$m_{label}$')     fig.subplots_adjust(hspace=0, wspace=0.25)     fig.align_labels()      gs = axs[1, -1].get_gridspec()     axs[0, 0].legend()     axbig = fig.add_subplot(gs[:, -1])     axbig.pcolor(Hscan[1:] / 1e3,                  freqs / 1e9,                  np.log10(spectrum[1:].T),                  shading='auto',                  cmap='magma')     axbig.axvline(x=Hscan[hindx] / 1e3,                   color='lavender',                   linestyle='--',                   label=f\"{Hscan[hindx] / 1e3:.0f} kA/m\")     axbig.set_xlabel(\"$\\mathrm{H}_\\mathrm{y}$ [kA/m]\", usetex=False)     axbig.set_ylabel(\"f [GHz]\")     axbig2 = axbig.twinx()     axbig.plot(pimm_data['H'] * OetoAm / 1e3,                pimm_data['f'],                'o',                markerfacecolor='royalblue',                markeredgecolor='black')     p = uniform_filter1d(phases['z'][1:], 5)      axbig2.plot(Hscan[1:] / 1e3, p, color='azure', label=rf'$\\phi_{label}$')     axbig2.set_ylabel(r'$\\Delta\\phi_z$ [rad]', rotation=270, labelpad=15)      for ax in axs[:, -1]:         # ax.remove()         ax.set_axis_off()     axs[-1, 0].set_xlabel(\"Time [ns]\")     axbig.legend(frameon=False, labelcolor='lavender', loc=10)     # axbig.legend(frameon=False, labelcolor='lavender', loc=1, fontsize='x-small')     for label, ax in zip(('(a)', '(b)', '(c)', '(d)'), [*axs[:, 0], axbig]):         trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,                                               fig.dpi_scale_trans)         if label == '(d)':             fc = 'none'             ec = 'none'         else:             fc = 'white'             ec = 'lavender'         ax.text(0,                 1,                 label,                 color='black',                 transform=ax.transAxes + trans,                 verticalalignment='top',                 bbox=dict(facecolor=fc, edgecolor=ec, pad=3.0))  In\u00a0[11]: Copied! <pre>with plt.style.context(['science', 'nature']):\n    fig, ax = plt.subplots(3, 2, dpi=300, sharex=True)\n    m1 = np.asarray(magnetisations['m1'])\n    m2 = np.asarray(magnetisations['m2'])\n    Rx = np.asarray(magnetisations['Rxx'])\n    Ry = np.asarray(magnetisations['Rxy'])\n    Rz = np.asarray(magnetisations['Rz'])\n    m = np.asarray(magnetisations['m'])\n    H = np.asarray(magnetisations['H']) / 1e3\n    w = 3\n    for label, i in zip('xyz', range(3)):\n        ax[i, 0].plot(H[1:], m[1:, i], lw=2, color='k', alpha=1)\n        ax[i, 0].set_ylabel(rf\"$m_{label}$\")\n\n    ax[0, 0].legend()\n    for i, (label, R) in enumerate(zip(('xx', 'xy', 'zz'), (Rx, Ry, Rz))):\n        ax[i, 1].plot(H[1:], R[1:], lw=2, color='k')\n        ax[i, 1].set_ylabel(r\"$R_{\" f\"{label}\" r\"}$\")\n    fig.subplots_adjust(wspace=0.6, hspace=0)\n    fig.align_ylabels()\n    ax[-1, 0].set_xlabel(\"$\\mathrm{H}_\\mathrm{y}$ [kA/m]\", usetex=False)\n    ax[-1, 1].set_xlabel(\"$\\mathrm{H}_\\mathrm{y}$ [kA/m]\", usetex=False)\n    for label, ax in zip(('(a)', '(d)', '(b)', '(e)', '(c)', '(f)'),\n                         ax.flatten()):\n        # label physical distance in and down:\n        trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,\n                                              fig.dpi_scale_trans)\n        ax.text(0.0,\n                1.0,\n                label,\n                transform=ax.transAxes + trans,\n                fontsize='medium',\n                verticalalignment='top',\n                bbox=dict(facecolor='none', edgecolor='none', pad=3.0))\n</pre> with plt.style.context(['science', 'nature']):     fig, ax = plt.subplots(3, 2, dpi=300, sharex=True)     m1 = np.asarray(magnetisations['m1'])     m2 = np.asarray(magnetisations['m2'])     Rx = np.asarray(magnetisations['Rxx'])     Ry = np.asarray(magnetisations['Rxy'])     Rz = np.asarray(magnetisations['Rz'])     m = np.asarray(magnetisations['m'])     H = np.asarray(magnetisations['H']) / 1e3     w = 3     for label, i in zip('xyz', range(3)):         ax[i, 0].plot(H[1:], m[1:, i], lw=2, color='k', alpha=1)         ax[i, 0].set_ylabel(rf\"$m_{label}$\")      ax[0, 0].legend()     for i, (label, R) in enumerate(zip(('xx', 'xy', 'zz'), (Rx, Ry, Rz))):         ax[i, 1].plot(H[1:], R[1:], lw=2, color='k')         ax[i, 1].set_ylabel(r\"$R_{\" f\"{label}\" r\"}$\")     fig.subplots_adjust(wspace=0.6, hspace=0)     fig.align_ylabels()     ax[-1, 0].set_xlabel(\"$\\mathrm{H}_\\mathrm{y}$ [kA/m]\", usetex=False)     ax[-1, 1].set_xlabel(\"$\\mathrm{H}_\\mathrm{y}$ [kA/m]\", usetex=False)     for label, ax in zip(('(a)', '(d)', '(b)', '(e)', '(c)', '(f)'),                          ax.flatten()):         # label physical distance in and down:         trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,                                               fig.dpi_scale_trans)         ax.text(0.0,                 1.0,                 label,                 transform=ax.transAxes + trans,                 fontsize='medium',                 verticalalignment='top',                 bbox=dict(facecolor='none', edgecolor='none', pad=3.0)) <pre>No handles with labels found to put in legend.\n</pre> In\u00a0[15]: Copied! <pre>data = pd.read_csv('./data/V10325_Ptb_85_thin_cross.txt',\n                   sep='\\t',\n                   skiprows=[1, 2])\nHrange = np.arange(100, 5000, 100)\nHrange_red = [4000., 100.]\njhm = 1.33e11\nl = 3e-5\nw = 1e-5\nrhohm = 2.5e-7\nrhofm = 2.5e-7\nthm = 9.9e-9\ntfm = 2e-9\nahm = thm * w\nafm = tfm * w\nRhm = rhohm * l / ahm\nRfm = rhofm * l / afm\nIrf = jhm * ahm\n\nR0 = 1\nRx0 = [0]\nRy0 = [3]\nSMR = [-0.125 * R0]\nAMR = [-1e-4 * R0]\nAHE = [1.36]\nw = [w]\nl = [l]\n\n\ndef compute_vsd(dynamic_r, integration_step, dynamic_i):\n    SD = dynamic_i * dynamic_r\n    y = fft(SD) * (2 / len(SD))\n    amp = np.abs(y)\n    phase = np.angle(y)\n    freqs = fftfreq(len(y), integration_step)\n    y = y[:len(y) // 2]\n    freqs = freqs[:len(freqs) // 2]\n    return amp, phase, freqs\n\n\ndef find_max_f_frequency(freqs: np.ndarray, values: np.ndarray,\n                         frequency: float):\n    # take between 0 and max\n    freq_indx = np.abs(freqs - frequency).argmin()\n    max_value = values[freq_indx]\n    max_freq = freqs[freq_indx]\n    return max_value, max_freq\n\n\ndef compute_harmonics(theta, Hampl, Ms, Ku, Hdl, Hfl, steps):\n\n    demagTensor = [\n        CVector(0., 0., 0.),\n        CVector(0., 0., 0.),\n        CVector(0., 0., 1.)\n    ]\n\n    thickness = 2e-9\n    s_time = 200e-9\n    int_step = 1e-12\n\n    l1_params = {\n        \"Ms\": Ms,\n        \"thickness\": thickness,\n        \"anis\": CVector(0.1, 0.1, 1.),\n        \"mag\": CVector(0, 0, 1.),\n        \"cellSurface\": 1.0,\n        \"demagTensor\": demagTensor,\n        \"damping\": 0.003,\n    }\n    l1 = Layer(id=\"free\", **l1_params)\n    l1.setReferenceLayer(CVector(0., 1., 0.))\n    layer_str = [\"free\"]\n    layers = [l1]\n    junction = Junction(layers=layers)\n    junction.setLayerAnisotropyDriver(\"all\",\n                                      ScalarDriver.getConstantDriver(Ku))\n\n    frequency = 0.01e9\n    Hscan, Hvecs = FieldScan.phi_scan(-190, 190, steps, Hampl, theta=theta)\n    amp_diag1f = np.zeros((len(Hscan), ))\n    phase_diag2f = np.zeros((len(Hscan), ))\n    junction.setLayerDampingLikeTorqueDriver(\n        \"all\", ScalarDriver.getSineDriver(0, Hdl, frequency, 0))\n    junction.setLayerFieldLikeTorqueDriver(\n        \"all\", ScalarDriver.getSineDriver(0, Hfl, frequency, 0))\n\n    Hval = Hvecs[0]\n\n    HDriver = AxialDriver(ScalarDriver.getConstantDriver(Hval[0]),\n                          ScalarDriver.getConstantDriver(Hval[1]),\n                          ScalarDriver.getConstantDriver(Hval[2]))\n    junction.runSimulation(s_time, int_step, int_step)\n    mags = [junction.getLayerMagnetisation(\"free\")]\n    for hi, Hval in enumerate(Hvecs):\n        junction.clearLog()\n        HDriver = AxialDriver(ScalarDriver.getConstantDriver(Hval[0]),\n                              ScalarDriver.getConstantDriver(Hval[1]),\n                              ScalarDriver.getConstantDriver(Hval[2]))\n        junction.setLayerExternalFieldDriver(\"all\", HDriver)\n        # set mags for better convergence\n        for i, l_str in enumerate(layer_str):\n            junction.setLayerMagnetisation(l_str, mags[i])\n\n        junction.runSimulation(s_time, int_step, int_step)\n        # set new mags\n        for str_ in layer_str:\n            mags[i] = junction.getLayerMagnetisation(str_)\n\n        log = junction.getLog()\n        m = np.asarray(\n            [[log[f'{str_}_mx'], log[f'{str_}_my'], log[f'{str_}_mz']]\n             for str_ in layer_str])\n\n        _, dynamic_ry = calculate_resistance_parallel(Rx0, Ry0, AMR, AHE, SMR,\n                                                      m, l, w)\n\n        lt = np.asarray(log['time'])\n        dynamic_i = Irf * np.sin(2 * np.pi * frequency * lt)\n        org_amp, org_phase, freqs_org = compute_vsd(dynamic_r=dynamic_ry,\n                                                    integration_step=int_step,\n                                                    dynamic_i=dynamic_i)\n\n        max_phase2f, _ = find_max_f_frequency(freqs_org, org_phase,\n                                              2 * frequency)\n        max_amp1f, _ = find_max_f_frequency(freqs_org, org_amp, frequency)\n        max_amp2f, _ = find_max_f_frequency(freqs_org, org_amp, 2 * frequency)\n        amp_diag1f[hi] = max_amp1f\n        phase_diag2f[hi] = np.cos(max_phase2f) * max_amp2f\n    return amp_diag1f, phase_diag2f, Hscan\n\n\ndef compute_harmonics_distributed(H):\n    \"\"\"Insert layer parameters here\"\"\"\n    theta = 92\n    Ms = 1.2\n    Ku = 0.00313 * TtoAm * Ms / 2\n    Hdl = 1.325e-3 * TtoAm\n    Hfl = -2.06e-04 * TtoAm\n    _, phase_diag2f, phi_scan = compute_harmonics(theta=theta,\n                                                  steps=50,\n                                                  Ms=Ms,\n                                                  Ku=Ku,\n                                                  Hampl=H * OetoAm,\n                                                  Hdl=Hdl,\n                                                  Hfl=Hfl)\n    return phase_diag2f, phi_scan\n\n\n# we distribute over all fields\nresult = distribute(compute_harmonics_distributed, [Hrange_red], n_cores=2)\n\nres = []\nfor r in result:\n    (i), out = r\n    phase_diag2f, scan = out\n    res.append(phase_diag2f)\n    phi_scan = scan\n\nres_max = np.max(res)\nwith plt.style.context(['science', 'nature']):\n    fig, ax = plt.subplots(dpi=300)\n    ms = 8\n    cmap = sns.color_palette(\"crest\", as_cmap=True)\n    cmap_disc = sns.color_palette(\"crest\", len(Hrange))\n    norm = mpl.colors.Normalize(vmin=min(Hrange / 1e3), vmax=max(Hrange / 1e3))\n    indx = (2, 10)\n    patches = []\n    labels = []\n    for i in range(len(res)):\n        r = np.asarray(res[i])\n        R = (r - r.min()) / (r.max() - r.min())\n        ax.plot(phi_scan,\n                R,\n                lw=2,\n                color=cmap(norm(Hrange_red[i] / 1e3)),\n                label=\"Sim.\")\n        labels.append(f\"Sim. - {np.round(Hrange_red[i]*OetoAm/1e3):.0f} kAm/m\")\n        line_exp = Line2D(range(1),\n                          range(1),\n                          color=cmap(norm(Hrange_red[i] / 1e3)))\n\n        patches.append(line_exp)\n        patches.append(\n            Line2D([], [],\n                   linestyle='none',\n                   color=cmap(norm(Hrange_red[i] / 1e3)),\n                   marker='o',\n                   markerfacecolor='none',\n                   markersize=ms // 2))\n        labels.append(f\"Exp. - {np.round(Hrange_red[i]*OetoAm/1e3):.0f} kA/m\")\n    patches.append(\n        Line2D(range(1), range(1), linestyle='dashed', color=\"crimson\"))\n    labels.append(\"Fit\")\n\n    for i in indx:\n        V = (data[f'Phase.{i}'] /\n             data[f'Phase.{i}'].max()).rolling(window=5).mean()\n        V = (V - V.min()) / (V.max() - V.min())\n        # remove NaNs\n        x = data[f'F. Angle Azim..{i}'] - 12\n        mask = pd.isna(V)\n        x = x.loc[~mask]\n        V = V.loc[~mask]\n        ax.plot(x,\n                V,\n                '.',\n                markersize=ms,\n                markerfacecolor='none',\n                markeredgecolor=cmap(norm(data[f'Field.{i}'][0] / 1e3)),\n                label='Exp.')\n\n        popt, _ = curve_fit(\n            f=meinert_model,\n            xdata=x,\n            ydata=V,\n        )\n        ax.plot(x, meinert_model(x, *popt), '--', color='crimson', label='Fit')\n\n    ax.set_xlim([-180, 180])\n\n    ax.legend(handles=patches, labels=labels)\n    ax.set_xlabel(r\"$\\phi$ [deg]\")\n    ax.set_ylabel(r\"$V_{2\\omega} [norm.]$\")\n</pre> data = pd.read_csv('./data/V10325_Ptb_85_thin_cross.txt',                    sep='\\t',                    skiprows=[1, 2]) Hrange = np.arange(100, 5000, 100) Hrange_red = [4000., 100.] jhm = 1.33e11 l = 3e-5 w = 1e-5 rhohm = 2.5e-7 rhofm = 2.5e-7 thm = 9.9e-9 tfm = 2e-9 ahm = thm * w afm = tfm * w Rhm = rhohm * l / ahm Rfm = rhofm * l / afm Irf = jhm * ahm  R0 = 1 Rx0 = [0] Ry0 = [3] SMR = [-0.125 * R0] AMR = [-1e-4 * R0] AHE = [1.36] w = [w] l = [l]   def compute_vsd(dynamic_r, integration_step, dynamic_i):     SD = dynamic_i * dynamic_r     y = fft(SD) * (2 / len(SD))     amp = np.abs(y)     phase = np.angle(y)     freqs = fftfreq(len(y), integration_step)     y = y[:len(y) // 2]     freqs = freqs[:len(freqs) // 2]     return amp, phase, freqs   def find_max_f_frequency(freqs: np.ndarray, values: np.ndarray,                          frequency: float):     # take between 0 and max     freq_indx = np.abs(freqs - frequency).argmin()     max_value = values[freq_indx]     max_freq = freqs[freq_indx]     return max_value, max_freq   def compute_harmonics(theta, Hampl, Ms, Ku, Hdl, Hfl, steps):      demagTensor = [         CVector(0., 0., 0.),         CVector(0., 0., 0.),         CVector(0., 0., 1.)     ]      thickness = 2e-9     s_time = 200e-9     int_step = 1e-12      l1_params = {         \"Ms\": Ms,         \"thickness\": thickness,         \"anis\": CVector(0.1, 0.1, 1.),         \"mag\": CVector(0, 0, 1.),         \"cellSurface\": 1.0,         \"demagTensor\": demagTensor,         \"damping\": 0.003,     }     l1 = Layer(id=\"free\", **l1_params)     l1.setReferenceLayer(CVector(0., 1., 0.))     layer_str = [\"free\"]     layers = [l1]     junction = Junction(layers=layers)     junction.setLayerAnisotropyDriver(\"all\",                                       ScalarDriver.getConstantDriver(Ku))      frequency = 0.01e9     Hscan, Hvecs = FieldScan.phi_scan(-190, 190, steps, Hampl, theta=theta)     amp_diag1f = np.zeros((len(Hscan), ))     phase_diag2f = np.zeros((len(Hscan), ))     junction.setLayerDampingLikeTorqueDriver(         \"all\", ScalarDriver.getSineDriver(0, Hdl, frequency, 0))     junction.setLayerFieldLikeTorqueDriver(         \"all\", ScalarDriver.getSineDriver(0, Hfl, frequency, 0))      Hval = Hvecs[0]      HDriver = AxialDriver(ScalarDriver.getConstantDriver(Hval[0]),                           ScalarDriver.getConstantDriver(Hval[1]),                           ScalarDriver.getConstantDriver(Hval[2]))     junction.runSimulation(s_time, int_step, int_step)     mags = [junction.getLayerMagnetisation(\"free\")]     for hi, Hval in enumerate(Hvecs):         junction.clearLog()         HDriver = AxialDriver(ScalarDriver.getConstantDriver(Hval[0]),                               ScalarDriver.getConstantDriver(Hval[1]),                               ScalarDriver.getConstantDriver(Hval[2]))         junction.setLayerExternalFieldDriver(\"all\", HDriver)         # set mags for better convergence         for i, l_str in enumerate(layer_str):             junction.setLayerMagnetisation(l_str, mags[i])          junction.runSimulation(s_time, int_step, int_step)         # set new mags         for str_ in layer_str:             mags[i] = junction.getLayerMagnetisation(str_)          log = junction.getLog()         m = np.asarray(             [[log[f'{str_}_mx'], log[f'{str_}_my'], log[f'{str_}_mz']]              for str_ in layer_str])          _, dynamic_ry = calculate_resistance_parallel(Rx0, Ry0, AMR, AHE, SMR,                                                       m, l, w)          lt = np.asarray(log['time'])         dynamic_i = Irf * np.sin(2 * np.pi * frequency * lt)         org_amp, org_phase, freqs_org = compute_vsd(dynamic_r=dynamic_ry,                                                     integration_step=int_step,                                                     dynamic_i=dynamic_i)          max_phase2f, _ = find_max_f_frequency(freqs_org, org_phase,                                               2 * frequency)         max_amp1f, _ = find_max_f_frequency(freqs_org, org_amp, frequency)         max_amp2f, _ = find_max_f_frequency(freqs_org, org_amp, 2 * frequency)         amp_diag1f[hi] = max_amp1f         phase_diag2f[hi] = np.cos(max_phase2f) * max_amp2f     return amp_diag1f, phase_diag2f, Hscan   def compute_harmonics_distributed(H):     \"\"\"Insert layer parameters here\"\"\"     theta = 92     Ms = 1.2     Ku = 0.00313 * TtoAm * Ms / 2     Hdl = 1.325e-3 * TtoAm     Hfl = -2.06e-04 * TtoAm     _, phase_diag2f, phi_scan = compute_harmonics(theta=theta,                                                   steps=50,                                                   Ms=Ms,                                                   Ku=Ku,                                                   Hampl=H * OetoAm,                                                   Hdl=Hdl,                                                   Hfl=Hfl)     return phase_diag2f, phi_scan   # we distribute over all fields result = distribute(compute_harmonics_distributed, [Hrange_red], n_cores=2)  res = [] for r in result:     (i), out = r     phase_diag2f, scan = out     res.append(phase_diag2f)     phi_scan = scan  res_max = np.max(res) with plt.style.context(['science', 'nature']):     fig, ax = plt.subplots(dpi=300)     ms = 8     cmap = sns.color_palette(\"crest\", as_cmap=True)     cmap_disc = sns.color_palette(\"crest\", len(Hrange))     norm = mpl.colors.Normalize(vmin=min(Hrange / 1e3), vmax=max(Hrange / 1e3))     indx = (2, 10)     patches = []     labels = []     for i in range(len(res)):         r = np.asarray(res[i])         R = (r - r.min()) / (r.max() - r.min())         ax.plot(phi_scan,                 R,                 lw=2,                 color=cmap(norm(Hrange_red[i] / 1e3)),                 label=\"Sim.\")         labels.append(f\"Sim. - {np.round(Hrange_red[i]*OetoAm/1e3):.0f} kAm/m\")         line_exp = Line2D(range(1),                           range(1),                           color=cmap(norm(Hrange_red[i] / 1e3)))          patches.append(line_exp)         patches.append(             Line2D([], [],                    linestyle='none',                    color=cmap(norm(Hrange_red[i] / 1e3)),                    marker='o',                    markerfacecolor='none',                    markersize=ms // 2))         labels.append(f\"Exp. - {np.round(Hrange_red[i]*OetoAm/1e3):.0f} kA/m\")     patches.append(         Line2D(range(1), range(1), linestyle='dashed', color=\"crimson\"))     labels.append(\"Fit\")      for i in indx:         V = (data[f'Phase.{i}'] /              data[f'Phase.{i}'].max()).rolling(window=5).mean()         V = (V - V.min()) / (V.max() - V.min())         # remove NaNs         x = data[f'F. Angle Azim..{i}'] - 12         mask = pd.isna(V)         x = x.loc[~mask]         V = V.loc[~mask]         ax.plot(x,                 V,                 '.',                 markersize=ms,                 markerfacecolor='none',                 markeredgecolor=cmap(norm(data[f'Field.{i}'][0] / 1e3)),                 label='Exp.')          popt, _ = curve_fit(             f=meinert_model,             xdata=x,             ydata=V,         )         ax.plot(x, meinert_model(x, *popt), '--', color='crimson', label='Fit')      ax.set_xlim([-180, 180])      ax.legend(handles=patches, labels=labels)     ax.set_xlabel(r\"$\\phi$ [deg]\")     ax.set_ylabel(r\"$V_{2\\omega} [norm.]$\") <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:05&lt;00:00,  2.90s/it]\n</pre> In\u00a0[16]: Copied! <pre>damping = 0.005\nMs = 1.6\nthickness = 1.8e-9\nSLP = 0.69\nbeta = 1\nspin_polarisation = 1.\nsurf = 70e-9 * 70e-9 * np.pi\ndemag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)]\n### Create MTJ ###\n# we use the .createSTTLayer to indicate the STT contributions\n# we can also create SOT layers for other experiments.\nl1 = Layer.createSTTLayer(\"free\",\n                          mag=CVector(0, 0, .9),\n                          anis=CVector(0, 0, 1),\n                          Ms=Ms,\n                          thickness=thickness,\n                          cellSurface=surf,\n                          demagTensor=demag,\n                          damping=damping,\n                          SlonczewskiSpacerLayerParameter=SLP,\n                          beta=beta,\n                          spinPolarisation=spin_polarisation)\nl2 = Layer.createSTTLayer(\"free\",\n                          mag=CVector(0, 0, 1),\n                          anis=CVector(0., 0., 1),\n                          Ms=Ms * 1.11,\n                          thickness=thickness,\n                          cellSurface=surf,\n                          demagTensor=demag,\n                          damping=damping,\n                          SlonczewskiSpacerLayerParameter=SLP,\n                          beta=beta,\n                          spinPolarisation=spin_polarisation)\n\n# we use pinning layers for the bottom layer\nl1.setReferenceLayer(CVector(1, 0, 0))\nl2.setReferenceLayer(CVector(1, 0, 0))\n\nj1 = Junction([l1], 100, 200)\nj2 = Junction([l2], 110, 220)\nj1.setLayerAlternativeSTT(\"all\", True)\nj2.setLayerAlternativeSTT(\"all\", True)\nj1.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(7e4))\nj2.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(10e4))\nstack = ParallelStack([j1, j2])\n\nint_time = 1e-12\nsim_time = 100e-9\nstack.setCoupledCurrentDriver(ScalarDriver.getConstantDriver(6e10))\n\nk = 20\nHspan, Hrange = FieldScan.amplitude_scan(-100e3, 400e3, 100, 5, 0)\ncouplings = defaultdict(list)\nfor label, coupling in zip(('pos', 'zero', 'neg'), (0.1, 0, -0.12)):\n    stack.setCouplingStrength(coupling)\n    spectrum = []\n    for Hvector in tqdm(Hrange):\n        stack.clearLogs()\n        stack.setExternalFieldDriver(\n            AxialDriver(ScalarDriver.getConstantDriver(Hvector[0]),\n                        ScalarDriver.getConstantDriver(Hvector[1]),\n                        ScalarDriver.getConstantDriver(Hvector[2])))\n        stack.runSimulation(sim_time, int_time, int_time)\n\n        log = stack.getLog()\n        y = fft(log['Resistance'])\n        yk = np.abs(y[:len(y) // k])\n        spectrum.append(yk)\n\n        if label == 'neg':\n            log0 = stack.getLog(0)\n            log1 = stack.getLog(1)\n            fft1 = fft(log0['R'])\n            freqs = fftfreq(len(fft1), d=int_time)\n            freqs = freqs[1:len(freqs) // k]\n            fft1 = fft1[1:len(fft1) // k]\n            fft2 = fft(log1['R'])\n            fft2 = fft2[1:len(fft2) // k]\n            amp1 = np.abs(fft1)\n            amp2 = np.abs(fft2)\n            fmax1 = np.argmax(amp1)\n            fmax2 = np.argmax(amp2)\n            phase1 = np.angle(fft1)[fmax1]\n            phase2 = np.angle(fft2)[fmax2]\n\n            couplings['resonance1'].append(freqs[fmax1])\n            couplings['resonance2'].append(freqs[fmax2])\n\n    spectrum = np.asarray(spectrum)\n    spectrum = uniform_filter(spectrum, size=7)\n    freqs = fftfreq(len(y), d=int_time)\n    freqs = freqs[:len(freqs) // k]\n    couplings[f'{label}_freqs'] = freqs\n    couplings[f'{label}_spectrum'] = spectrum\n</pre> damping = 0.005 Ms = 1.6 thickness = 1.8e-9 SLP = 0.69 beta = 1 spin_polarisation = 1. surf = 70e-9 * 70e-9 * np.pi demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)] ### Create MTJ ### # we use the .createSTTLayer to indicate the STT contributions # we can also create SOT layers for other experiments. l1 = Layer.createSTTLayer(\"free\",                           mag=CVector(0, 0, .9),                           anis=CVector(0, 0, 1),                           Ms=Ms,                           thickness=thickness,                           cellSurface=surf,                           demagTensor=demag,                           damping=damping,                           SlonczewskiSpacerLayerParameter=SLP,                           beta=beta,                           spinPolarisation=spin_polarisation) l2 = Layer.createSTTLayer(\"free\",                           mag=CVector(0, 0, 1),                           anis=CVector(0., 0., 1),                           Ms=Ms * 1.11,                           thickness=thickness,                           cellSurface=surf,                           demagTensor=demag,                           damping=damping,                           SlonczewskiSpacerLayerParameter=SLP,                           beta=beta,                           spinPolarisation=spin_polarisation)  # we use pinning layers for the bottom layer l1.setReferenceLayer(CVector(1, 0, 0)) l2.setReferenceLayer(CVector(1, 0, 0))  j1 = Junction([l1], 100, 200) j2 = Junction([l2], 110, 220) j1.setLayerAlternativeSTT(\"all\", True) j2.setLayerAlternativeSTT(\"all\", True) j1.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(7e4)) j2.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(10e4)) stack = ParallelStack([j1, j2])  int_time = 1e-12 sim_time = 100e-9 stack.setCoupledCurrentDriver(ScalarDriver.getConstantDriver(6e10))  k = 20 Hspan, Hrange = FieldScan.amplitude_scan(-100e3, 400e3, 100, 5, 0) couplings = defaultdict(list) for label, coupling in zip(('pos', 'zero', 'neg'), (0.1, 0, -0.12)):     stack.setCouplingStrength(coupling)     spectrum = []     for Hvector in tqdm(Hrange):         stack.clearLogs()         stack.setExternalFieldDriver(             AxialDriver(ScalarDriver.getConstantDriver(Hvector[0]),                         ScalarDriver.getConstantDriver(Hvector[1]),                         ScalarDriver.getConstantDriver(Hvector[2])))         stack.runSimulation(sim_time, int_time, int_time)          log = stack.getLog()         y = fft(log['Resistance'])         yk = np.abs(y[:len(y) // k])         spectrum.append(yk)          if label == 'neg':             log0 = stack.getLog(0)             log1 = stack.getLog(1)             fft1 = fft(log0['R'])             freqs = fftfreq(len(fft1), d=int_time)             freqs = freqs[1:len(freqs) // k]             fft1 = fft1[1:len(fft1) // k]             fft2 = fft(log1['R'])             fft2 = fft2[1:len(fft2) // k]             amp1 = np.abs(fft1)             amp2 = np.abs(fft2)             fmax1 = np.argmax(amp1)             fmax2 = np.argmax(amp2)             phase1 = np.angle(fft1)[fmax1]             phase2 = np.angle(fft2)[fmax2]              couplings['resonance1'].append(freqs[fmax1])             couplings['resonance2'].append(freqs[fmax2])      spectrum = np.asarray(spectrum)     spectrum = uniform_filter(spectrum, size=7)     freqs = fftfreq(len(y), d=int_time)     freqs = freqs[:len(freqs) // k]     couplings[f'{label}_freqs'] = freqs     couplings[f'{label}_spectrum'] = spectrum <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:09&lt;00:00, 11.06it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:09&lt;00:00, 10.93it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:11&lt;00:00,  8.98it/s]\n</pre> In\u00a0[\u00a0]: Copied! <pre>cmap = sns.color_palette(\"magma\", as_cmap=True)\nwith plt.style.context(['science', 'nature']):\n    fig, axs = plt.subplots(1, 3, dpi=300, sharey=True)\n    for i, (ax, label, chval) in enumerate(\n            zip(axs, (\n                'neg',\n                'pos',\n                'zero',\n            ), (-0.12, 0.1, 0))):\n        ax.set_ylim([10, 40])\n        ax.pcolor(Hspan / 1e3,\n                  freqs / 1e9,\n                  np.log10(couplings[f\"{label}_spectrum\"].T),\n                  cmap=cmap,\n                  shading='auto')\n        if label == 'neg':\n            ax.plot(Hspan / 1e3,\n                    np.asarray(couplings['resonance1']) / 1e9,\n                    color='royalblue',\n                    alpha=1)\n            ax.plot(Hspan / 1e3,\n                    np.asarray(couplings['resonance2']) / 1e9,\n                    color='crimson',\n                    alpha=1)\n        ax.set_xlabel(\"H [$\\mathrm{kA/m}$]\", usetex=False)\n        ax.set_title(rf\"$\\chi = {chval}$\")\n    axs[0].set_ylabel(\"Frequency [GHz]\")\n    fig.subplots_adjust(wspace=0.05)\n    for label, ax in zip(['(a)', '(b)', '(c)'], axs):\n        # label physical distance in and down:\n        trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,\n                                              fig.dpi_scale_trans)\n        ax.text(0.0,\n                1.0,\n                label,\n                color='w',\n                transform=ax.transAxes + trans,\n                fontsize='medium',\n                verticalalignment='top',\n                bbox=dict(facecolor='none', edgecolor='none', pad=3.0))\n</pre> cmap = sns.color_palette(\"magma\", as_cmap=True) with plt.style.context(['science', 'nature']):     fig, axs = plt.subplots(1, 3, dpi=300, sharey=True)     for i, (ax, label, chval) in enumerate(             zip(axs, (                 'neg',                 'pos',                 'zero',             ), (-0.12, 0.1, 0))):         ax.set_ylim([10, 40])         ax.pcolor(Hspan / 1e3,                   freqs / 1e9,                   np.log10(couplings[f\"{label}_spectrum\"].T),                   cmap=cmap,                   shading='auto')         if label == 'neg':             ax.plot(Hspan / 1e3,                     np.asarray(couplings['resonance1']) / 1e9,                     color='royalblue',                     alpha=1)             ax.plot(Hspan / 1e3,                     np.asarray(couplings['resonance2']) / 1e9,                     color='crimson',                     alpha=1)         ax.set_xlabel(\"H [$\\mathrm{kA/m}$]\", usetex=False)         ax.set_title(rf\"$\\chi = {chval}$\")     axs[0].set_ylabel(\"Frequency [GHz]\")     fig.subplots_adjust(wspace=0.05)     for label, ax in zip(['(a)', '(b)', '(c)'], axs):         # label physical distance in and down:         trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72,                                               fig.dpi_scale_trans)         ax.text(0.0,                 1.0,                 label,                 color='w',                 transform=ax.transAxes + trans,                 fontsize='medium',                 verticalalignment='top',                 bbox=dict(facecolor='none', edgecolor='none', pad=3.0)) In\u00a0[17]: Copied! <pre>from cmtj.utils import calculate_resistance_series\nimport matplotlib.pyplot as plt\nfrom cmtj.utils.linear import FieldScan\nfrom cmtj.utils.procedures import ResistanceParameters, PIMM_procedure\n\nrp = ResistanceParameters(Rxx0=100,\n                          Rxy0=1,\n                          Rsmr=-0.46,\n                          Rahe=-2.7,\n                          Ramr=-0.24,\n                          l=30,\n                          w=20)\n\n# approximate demagnetisation tensor\ndemag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)]\nalpha = 0.005\nKdir = CVector(1, 0, 0)\nMs = 1.65\nl1 = Layer(\"free\",\n           mag=CVector(0, 0, 1),\n           anis=Kdir,\n           Ms=Ms,\n           thickness=3.99e-9,\n           cellSurface=0,\n           demagTensor=demag,\n           damping=alpha)\n\nl2 = Layer(\"bottom\",\n           mag=CVector(0, 0, 1),\n           anis=Kdir,\n           Ms=Ms,\n           thickness=4e-9,\n           cellSurface=0,\n           demagTensor=demag,\n           damping=alpha)\nJ1 = -1.78e-3\nJ2 = -1.69e-4\n\nK1 = K2 = 1.05e3\nint_step = 4e-14\n\nj1 = Junction([l1, l2], 100, 102)\n\nj1.setLayerAnisotropyDriver(\"all\", ScalarDriver.getConstantDriver(K1))\nj1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J1))\nj1.setQuadIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J2))\n# j1.runSimulation(5e-9, 1e-13, 1e-12)\nHscan, Hvecs = FieldScan.amplitude_scan(-1200e3, 1200e3, 200, 89, 90)\n\nspectrum, freqs, output = PIMM_procedure(j1,\n                                         Hvecs=Hvecs,\n                                         int_step=int_step,\n                                         resistance_params=[rp, rp],\n                                         max_frequency=60e9)\nwith plt.style.context(['science', 'nature']):\n    fig, ax = plt.subplots(dpi=300)\n    ax.pcolor(Hscan / 1e3,\n              freqs / 1e9,\n              np.log10(np.squeeze(spectrum.T)),\n              cmap='viridis')\n    ax.set_xlabel(\"H [$\\mathrm{kA/m}$]\", usetex=False)\n    ax.set_ylabel(\"Frequency [GHz]\")\n</pre> from cmtj.utils import calculate_resistance_series import matplotlib.pyplot as plt from cmtj.utils.linear import FieldScan from cmtj.utils.procedures import ResistanceParameters, PIMM_procedure  rp = ResistanceParameters(Rxx0=100,                           Rxy0=1,                           Rsmr=-0.46,                           Rahe=-2.7,                           Ramr=-0.24,                           l=30,                           w=20)  # approximate demagnetisation tensor demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)] alpha = 0.005 Kdir = CVector(1, 0, 0) Ms = 1.65 l1 = Layer(\"free\",            mag=CVector(0, 0, 1),            anis=Kdir,            Ms=Ms,            thickness=3.99e-9,            cellSurface=0,            demagTensor=demag,            damping=alpha)  l2 = Layer(\"bottom\",            mag=CVector(0, 0, 1),            anis=Kdir,            Ms=Ms,            thickness=4e-9,            cellSurface=0,            demagTensor=demag,            damping=alpha) J1 = -1.78e-3 J2 = -1.69e-4  K1 = K2 = 1.05e3 int_step = 4e-14  j1 = Junction([l1, l2], 100, 102)  j1.setLayerAnisotropyDriver(\"all\", ScalarDriver.getConstantDriver(K1)) j1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J1)) j1.setQuadIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J2)) # j1.runSimulation(5e-9, 1e-13, 1e-12) Hscan, Hvecs = FieldScan.amplitude_scan(-1200e3, 1200e3, 200, 89, 90)  spectrum, freqs, output = PIMM_procedure(j1,                                          Hvecs=Hvecs,                                          int_step=int_step,                                          resistance_params=[rp, rp],                                          max_frequency=60e9) with plt.style.context(['science', 'nature']):     fig, ax = plt.subplots(dpi=300)     ax.pcolor(Hscan / 1e3,               freqs / 1e9,               np.log10(np.squeeze(spectrum.T)),               cmap='viridis')     ax.set_xlabel(\"H [$\\mathrm{kA/m}$]\", usetex=False)     ax.set_ylabel(\"Frequency [GHz]\") <pre>Computing PIMM: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 200/200 [00:24&lt;00:00,  8.24it/s]\n/var/folders/wq/0q9brtfs5rq65q1t_mtgshb00000gn/T/ipykernel_81600/2057453406.py:57: MatplotlibDeprecationWarning: shading='flat' when X and Y have the same dimensions as C is deprecated since 3.3.  Either specify the corners of the quadrilaterals with X and Y, or pass shading='auto', 'nearest' or 'gouraud', or set rcParams['pcolor.shading'].  This will become an error two minor releases later.\n  ax.pcolor(Hscan / 1e3,\n</pre>"},{"location":"experimental-methods/examples/#advanced-examples","title":"Advanced examples\u00b6","text":"<p>This is a set of more advanced examples along with some explanations of how they work. The examples are accompanied by a dataset in the <code>examples/data</code> folder.</p>"},{"location":"experimental-methods/examples/#spin-valve-system","title":"Spin valve system\u00b6","text":"<p>For the GMR system we will take a look at the Spin-Diode maps as well as on the PIMM maps in function of variable IEC. First, we are going to compute Voltage Spin Diode effect. See the function <code>simulate_vsd</code> and note how the DC mixing voltage is computed for each value of the field, frequency and a scanning parameter, in this case J -- the IEC constant. At the same time, we will note the resistance at two different field arrangements -- one where the field is applied 0 phi in plane angle, and then rotated at 90 degrees in plane. Having those two values of the field will result in drastically different R(H) loops.</p>"},{"location":"experimental-methods/examples/#spin-diode-fmr","title":"Spin-Diode FMR\u00b6","text":""},{"location":"experimental-methods/examples/#pimm","title":"PIMM\u00b6","text":"<p>In this experiment we will excite the system with a slight pulse of Oersted field in z direction. This simulates the experimental excitement by a current pulse along the y axis of the sample. The pulse should be very short and also rather weak, so that the system is not driven out of the harmonic regime. The pulse is applied at the beginning of the simulation and the system is allowed to relax to a steady state. The steady state is then used as initial condition for the next simulation. This is repeated for different pulse strengths. The resulting PIMM maps are shown below.</p>"},{"location":"experimental-methods/examples/#cims","title":"CIMS\u00b6","text":"<p>In this section we focus on generating switching currents. We are going to excite the system with a range of different pulse strengths. In this case, unlike in the PIMM, we excite the system directly with the current density pulse (which takes on the form of trapezoidal impulse) in order to evoke the torque response. After each simulation the system is allowed to relax to a steady state. We then pick up the steady state to see in which state (up/down) the magnetisation has settled. Based on the change of the hysteresis change, we can infer the critical current for a given value of the external field.</p>"},{"location":"experimental-methods/examples/#mh-and-rh-loops","title":"M(H) and R(H) loops\u00b6","text":"<p>Here we will generate the M(H) and R(H) loops for the system. We will use the same method as in the PIMM section. We will then apply a range of different external fields and record the magnetisation and the resistance at a steady state. This shows that the PIMM, M(H) and R(H) may be collected from the same range of simulations!</p>"},{"location":"experimental-methods/examples/#angular-harmonics","title":"Angular harmonics\u00b6","text":"<p>Here, we can simulate a system where we can analyse the influence of damping like and field like torques. The sweep is now with the angle of the field (in-plane angle) and not its magnitude.</p>"},{"location":"experimental-methods/examples/#stack-system","title":"Stack system\u00b6","text":"<p>In this section we will simulate a simple parallel structure of two MTJs. We are interested in how the two magnetic tunnel junctions will synchronised if we couple them electrically. Here, we use some example electrical coupling (via the current) values and we scan over the external field values, at a constant current density value. You could easily try to scan with the current density instead of the external field and see how the system behaves then.</p>"},{"location":"experimental-methods/examples/#convenice-procedures","title":"Convenice procedures\u00b6","text":"<p>Certain procedures such as PIMM or VSD are provided in their basic form via <code>cmtj.utils.procedures</code> submodule. See below for an example usage.</p>"},{"location":"experimental-methods/introduction/","title":"Experiment modelling","text":"<p><code>cmtj</code> is a versatile tool for simulating a wide range of experiments. It's possible to simulate a variety of experiments, from simple to complex, below is the list of the things we've tried so far and verified:</p> <ul> <li>R(H) and M(H) loops</li> <li>FMR -- ferromagnetic resonance, both field, current and frequency sweeps.</li> <li>SD-FMR -- spin diode FMR (VSD)</li> <li>STT-FMR -- spin transfer torque FMR</li> <li>SOT-FMR -- spin orbit torque FMR</li> <li>PIMM -- pulse induced magnetometry</li> <li>Harmonic Hall voltage (HHV) measurements</li> <li>Field magnitude HHV (at a set angle)</li> <li>Angular HHV (a function of field angle)</li> <li>CIMS -- current induced magnetisation switching</li> </ul> <p>For those experiments we have many examples, along with some data to compare to:</p> <ul> <li>R(H) and M(H) loops</li> <li>Angular Harmonic Hall voltage and Field magnitude Harmonic Hall voltage</li> <li>CIMS and here</li> <li>Spin Diode FMR and here</li> </ul> <p>Note</p> <p>These are the ones we use in our lab, but that does not mean that you can't simulate other experiments. Let us know if you have a specific experiment in mind to replicate and fit and we'll try to help you out.</p>"},{"location":"physics/contributions/","title":"Introduction","text":"<p>In the macromagnetic simulations we distinguish between the following contributions that constitute the \\(\\mathbf{H}_\\textrm{eff}\\):</p> \\[     \\mathbf{H}_\\textrm{eff} = \\mathbf{H}_\\textrm{ext} + \\mathbf{H}_\\textrm{IEC} +     \\mathbf{H}_\\textrm{Oe} +     \\mathbf{H}_\\textrm{K} +     \\mathbf{H}_\\textrm{demag} +     \\mathbf{H}_\\textrm{dipole} +     \\mathbf{H}_\\textrm{th}^* +     \\mathbf{H}_\\textrm{1/f}^* \\] <p>where each component corresponds, respectively, to the applied external field, interlayer exchange coupling (IEC), Oersted field, anisotropy field, demagnetising, dipole, thermal, and \\(1/f\\) noise field. The \\(^*\\) superscripts denote the stochastic contributions (those require a stochastic solver, more on that in the Macromagnetic models section).</p>"},{"location":"physics/contributions/#in-api-classification","title":"In-API classification","text":"<p>We will go through the contributions step by step. However, before we do that, it is useful to mention that the contributions can be divided into 3 categories with respect to their relationship with a <code>Driver</code> system:</p> <ol> <li><code>ScalarDriver</code> driven contributions: \\(\\mathbf{H}_\\textrm{K}\\), \\(\\mathbf{H}_\\textrm{th}\\), and \\(\\mathbf{H}_\\textrm{IEC}\\)    Those contributions have their magnitude changed only. The exception is \\(\\mathbf{H}_\\textrm{K}\\) which has a constant axis passed in the constructor of a <code>Layer</code> object. Other than that, only the magnitude of those effect may be controlled, their direction is computed internally, as it depends on the \\(\\mathbf{m}\\) vectors.</li> <li><code>AxialDriver</code> driven contributions: \\(\\mathbf{H}_\\textrm{ext}\\), \\(\\mathbf{H}_\\textrm{Oe}\\).    Axial contributions can have magntidue controllers in any of the 3 directions, along x, y and z axis. Since <code>AxialDriver</code> consists of 3 <code>ScalarDrivers</code> (one for each axis), it is easy to manipulate each axis independently, magnitudewise.</li> <li>static contributions \\({H}_\\textrm{dipole}\\), and \\(\\mathbf{H}_\\textrm{demag}\\).    Static contributions are not driven by any <code>Driver</code> system, they are simply added to the \\(\\mathbf{H}_\\textrm{eff}\\) field. This may be subject to change in future API versions.</li> </ol> <p>Note</p> <p>Almost every contribution may be set either using <code>Layer</code> api or <code>Junction</code> api. They both have the same set of arguments, and the naming convention is such that if e.g. <code>Layer</code> has a method <code>setContribution</code>, then <code>Junction</code> has a method <code>setLayerContribution</code> and requires one additional argument specyfing the layer id (or <code>all</code> if it is to be set for all layers in the <code>Junction</code>). There are some exceptions to this, e.g. <code>setLayerIEC</code>, which is only defined for two or more layers, therefore it cannot be set from a <code>Layer</code> object.</p>"},{"location":"physics/contributions/#external-field","title":"External field","text":"<p>The external field is the simplest contribution to the effective field. It is the sum of the applied fields.</p> Name Unit Description \\(H_\\textrm{x}\\) A/m Value of field in x direction \\(H_\\textrm{y}\\) A/m Value of field in y direction \\(H_\\textrm{z}\\) A/m Value of field in y direction <pre><code>layer.setExternalFieldDriver(\n    AxialDriver(\n        ScalarDriver.getConstantDriver(100),\n        ScalarDriver.getConstantDriver(0),\n        ScalarDriver.getSineDriver(0, 300, 20e39, 0)\n    )\n)\n</code></pre> <p>or for the <code>Junctions</code> api:</p> <pre><code>device.setLayerExternalFieldDriver(\n    \"free\", # this value of course depends on the layer id\n    AxialDriver(\n        ScalarDriver.getConstantDriver(100),\n        ScalarDriver.getConstantDriver(0),\n        ScalarDriver.getSineDriver(0, 300, 20e39, 0)\n    )\n)\n</code></pre>"},{"location":"physics/contributions/#oersted-field","title":"Oersted field","text":"<p>The Oersted field is the field generated by the flow of current. Currently it is separated from the external field, but it is set the same way, irrespective of the actual current setting in the API. This may be subject to change.</p> Name Unit Description \\(H_\\textrm{x}\\) A/m Value of field in x direction \\(H_\\textrm{y}\\) A/m Value of field in y direction \\(H_\\textrm{z}\\) A/m Value of field in y direction <pre><code>layer.setOerstedFieldDriver(\n    AxialDriver(\n        ScalarDriver.getConstantDriver(100),\n        ScalarDriver.getConstantDriver(0),\n        ScalarDriver.getSineDriver(0, 300, 20e39, 0)\n    )\n)\n</code></pre> <p>or for the <code>Junctions</code> api:</p> <pre><code>device.setLayerOerstedFieldDriver(\n    \"free\", # this value of course depends on the layer id\n    AxialDriver(\n        ScalarDriver.getConstantDriver(100),\n        ScalarDriver.getConstantDriver(0),\n        ScalarDriver.getSineDriver(0, 300, 20e39, 0)\n    )\n)\n</code></pre>"},{"location":"physics/contributions/#exchange-field-iec","title":"Exchange field -- IEC","text":"<p>Interlayer exchange coupling is a scalar driven field contribution. It governs the RKKY-like interaction between magnetic layers.</p> Name Unit Description \\(J_\\textrm{linear}\\) \\(J/m^2\\) Linear value of the IEC contribution \\(J_\\textrm{quad}\\) \\(J/m^2\\) Linear value of the IEC contribution layerA <code>str</code> Layer id of a participating layer layerB <code>str</code> Layer id of other participating layer <p>Linear layer is being set with:</p> <pre><code>device.setIECDriver(\n    \"free\" # this value of course depends on the layer id\n    \"bottom\", # this value of course depends on the layer id\n    ScalarDriver.getConstantDriver(1e-4)\n)\n</code></pre> <p>and quadratic:</p> <pre><code>device.setQuadIECDriver(\n    \"free\" # this value of course depends on the layer id\n    \"bottom\", # this value of course depends on the layer id\n    ScalarDriver.getConstantDriver(1e-6)\n)\n</code></pre> <p>The resulting interaction field for layer 1 \\(\\mathbf{m}_1\\) is computed as:</p> \\[  \\mathbf{H}_{IEC,1} = -\\frac{1}{t_{FM} M_s}\\frac{\\partial E_{d, int}}{\\partial \\mathbf{m}_1} =     \\frac{1}{t_{FM} M_s}[J_\\textrm{linear}\\mathbf{m}_2 + 2J_\\textrm{quad} (\\mathbf{m}_1 \\cdot \\mathbf{m}_1)\\mathbf{m}_2] \\]"},{"location":"physics/contributions/#dipole-and-demag","title":"Dipole and demag","text":"<p>Those two contributions have different origins, but in <code>CMTJ</code> they share a similar api and way of computation. Both are given by tensors, and may be computed externally.</p> \\[     \\mathbf{H}_\\textrm{dipole} = -\\frac{M_\\textrm{s}}{\\mu_0}\\mathbf{N}_\\textrm{dipole}\\mathbf{m} \\] <p>where \\(\\mathbf{N}_\\textrm{dipole}\\) is the dipole tensor of the layer. The demag field is the same way, but with the tensor \\(\\mathbf{N}_\\textrm{demag}\\) of the layer. Since <code>demag</code> tensor is inherent to the geometry (shape) of the system, it is passed in the <code>Layer</code> object.</p> Name Unit Description \\(\\mathbf{N}_{inter}\\) - Tensor of the interaction for dipole or demag <p>The <code>dipole</code> depends on the external interaction and may be due any magnetic interaction a device or layer has with any other magnetic object. Therefore, it is passed in the <code>Layer</code> API as:</p> <pre><code>layer.setTopDipoleTensor(\n    [\n        CVector(0, 5e-8, 1e-24),\n        CVector(5e-8, -2e-6, 0),\n        CVector(1e-23, 0, 1e-23),\n    ]\n)\nlayer.setBottomDipoleTensor(\n    [\n        CVector(0, 5e-8, 1e-24),\n        CVector(5e-8, -2e-6, 0),\n        CVector(1e-23, 0, 1e-23),\n    ]\n)\n</code></pre> <p>Under the hood we simply sum the contributions from both:</p> \\[     \\mathbf{H}_\\textrm{dipole} = \\mathbf{H}_\\textrm{dipole, top} + \\mathbf{H}_\\textrm{dipole, bottom} \\] <p>We set for <code>top</code> and <code>bottom</code> separately since it may come for instance from top and bottom layer and thus top or bottom may be different. Effectively, you can just pass either, where you sum the dipole tensors and it'll have the same effect. However, API makes this convenient separation to logically separate those contributions.</p> <p>Note</p> <p>Dipole tensor for now is only set from the Layer API. We may add a function for adding it in the Junction API as well in near future.</p>"},{"location":"physics/contributions/#anisotropy","title":"Anisotropy","text":"<p>Anisotropy computation has two components -- axis \\(\\mathbf{a}\\) which is in CMTJ a vector, and value \\(K_\\textrm{u}\\) which is a scalar. The axis is passed in the <code>Layer</code> constructor under <code>anis</code> parameter. The scalar value, however, is driven with a <code>ScalarDriver</code> object and can be dynamically operated from either <code>Layer</code> or <code>Junction</code> API.</p> Name Unit Description \\(\\mathbf{K}_\\textrm{u}\\) \\(J/m^3\\) Value of the anisotropy constant <pre><code>layer.setAnisotropyDriver(\n    ScalarDriver.getConstantDriver(1e6)\n)\n</code></pre> <p>or <code>Junction</code> API:</p> <pre><code>device.setLayerAnisotropyDriver(\n    \"free\", # this value of course depends on the layer id\n    ScalarDriver.getConstantDriver(1e6)\n)\n</code></pre> <p>The resulting anisotropy field is computed as:</p> \\[     \\mathbf{H}_{\\textrm{anis}} = \\frac{2K_\\textrm{u}}{M_s}(\\mathbf{m}\\cdot\\mathbf{a})\\mathbf{a} \\]"},{"location":"physics/linearisation/","title":"Introduction","text":"<p>In certain systems that exhibit stiffness or known stable states we can omit computing the equilibrium and compute the oscillation modes directly thanks to the linearisation procedure.</p>"},{"location":"physics/linearisation/#short-derivation","title":"Short derivation","text":"<p>Here we assume a 2-layer FM system that is stable along \\(z\\) axis with \\(m_z = \\pm 1\\).</p> <p>We start out with the effective field:</p> \\[ \\mathbf{H}_j = \\frac{1}{\\mu_0\\mathrm{M}_\\mathrm{s} t}\\nabla_\\mathbf{m} \\mathcal{F} \\tag{1} \\] <p>where \\(t\\) is the thickness, \\(\\mathrm{M}_\\mathrm{s}\\) is the magnetisation saturation and \\(\\mathcal{F}\\) is the energy expression. For details on how to construct \\(F\\) you can check out Smit-Beljers model description. Index \\(j\\) denotes the layer.</p> <p>The stable oscillation LLG form is given by:</p> \\[ \\mathrm{d}_t \\mathbf{m}_j = - \\mu_0 \\gamma \\mathbf{m}_j \\times \\mathbf{H}_j \\tag{2} \\] <p>In the linearisation procedure for stable \\(z\\) axis we need to assume that \\(m_x &lt;&lt; 1\\) and \\(m_y &lt;&lt; 1\\), meaning that non \\(z\\) components experience small variation. In effect, this is a picture of a tiny conical oscillation about the \\(z\\)-axis. This small precession assumption allows us to drop second order approximations later from expanding \\(\\mathbf{m}_j\\).</p> <p>Therefore, we linearise both \\(\\mathbf{m}_j\\) and \\(\\mathbf{H}_j\\) as follows:</p> \\[ \\mathbf{m}_j = \\mathbf{m}_{j,0} + \\delta \\mathbf{m}_j \\] <p>and</p> \\[ \\mathbf{H}_j = \\mathbf{H}_{j,0} + \\delta \\mathbf{H}_j \\] <p>and we have</p> \\[  \\delta \\mathbf{m}_j = (m_{x,j}, m_{y,j}, 0) \\\\ \\mathbf{m}_{j,0} = (0, 0, s) \\] <p>with \\(s = \\pm 1\\).</p> <p>To expand the \\(\\mathrm{d}_t \\mathbf{m}_j\\) we can compute the Jacobian matrix. So, for a single layer, again, we have, using a differential of a cross product rule at equilibrium:</p> \\[   \\partial\\,(\\mathbf{m}_j \\times \\mathbf{H}_j) =  (     \\,\\partial\\mathbf{m}_j \\times \\mathbf{H}_j +  \\mathbf{m}_{j,0} \\times \\left(\\frac{\\partial\\mathbf{H}_{j,0}}{\\partial\\mathbf{m_j}}\\right)_0 \\partial \\mathbf{m}_j ) \\tag{3} \\] <p>We can define the corresponding Jacobian operator with the help of 3x3 \\(\\mathcal{E}(x)\\) matrix which means \"cross with x\" and later substitutions which cause the higher olders to be neglected.</p> \\[ -\\mu_0\\gamma J_\\mathbf{m} = -\\mu_0\\gamma (\\mathcal{E}(\\mathbf{H_0}) + \\mathcal{E}(\\mathbf{m_0})\\left(\\partial \\mathbf{H}/\\partial\\mathbf{m}\\right)_{\\mathbf{m}_0}) \\tag{4} \\] <p>so when we do</p> \\[ -\\mu_0\\gamma J_\\mathbf{m} \\mathbf{m} \\tag{5} \\] <p>it gives us the expression \\((3)\\) in matrix form. In practice, we compute, per each layer, the RHS of the above LLG equation (\\((2)\\)), and create a Jacobian matrix from that RHS side, component-wise:</p> \\[ - \\mu_0 \\gamma J_\\mathbf{m}\\begin{pmatrix} \\mathbf{m}_1 \\times \\mathbf{H}_1 \\\\ \\mathbf{m}_2 \\times \\mathbf{H}_2 \\end{pmatrix}  = - \\mu_0 \\gamma J_\\mathbf{m}\\begin{pmatrix}     f_1(\\mathbf{m}_1, \\mathbf{H}_1) \\\\     f_2(\\mathbf{m}_2, \\mathbf{H}_2) \\end{pmatrix} = \\\\ - \\mu_0 \\gamma J_\\mathbf{m} \\begin{pmatrix}     f_{x,1}(\\mathbf{m}_1, \\mathbf{H}_1) \\\\     f_{y,1}(\\mathbf{m}_1, \\mathbf{H}_1) \\\\     f_{z,1}(\\mathbf{m}_1, \\mathbf{H}_1) \\\\     f_{x,2}(\\mathbf{m}_2, \\mathbf{H}_2) \\\\     f_{y,2}(\\mathbf{m}_2, \\mathbf{H}_2) \\\\     f_{z,2}(\\mathbf{m}_2, \\mathbf{H}_2) \\\\ \\end{pmatrix} = - \\mu_0 \\gamma\\begin{pmatrix}     \\frac{d}{dm_{x,1}} f_{x,1} &amp;&amp; \\frac{d}{dm_{y,1}} f_{x,1} &amp;&amp; \\frac{d}{dm_{z,1}} f_{x,1} \\\\     ... &amp;&amp; ... &amp;&amp; ...\\\\     \\frac{d}{dm_{x,2}} f_{z,2} &amp;&amp; \\frac{d}{dm_{y,2}} f_{z,2} &amp;&amp; \\frac{d}{dm_{z,2}} f_{z,2} \\\\ \\end{pmatrix} = \\mu_0\\gamma \\mathcal{J} \\tag{6} \\] <p>which in fact is a 6x6 matrix because \\(f_1\\) and \\(f_2\\) are expanded per each of 3 cross product components. To make that matrix follow the linearisation approximations we the following subsitutions: \\(m_{x, i} = 0, m_{y, i}= 0\\). This causes the entries of \\(\\mathcal{J}\\) non-dependent solely on \\(m_z\\) vanish (the entries, not the corresponding rows and columns). Crucially, field terms in \\(\\mathbf{H}_1\\) depend on both \\(\\mathbf{m}_1\\) and \\(\\mathbf{m}_2\\) due to presence of coupling terms.</p> <p>The substitution allows us to drop the rank of the matrix \\(\\mathcal{J}\\) from 6 to 4, because 3rd and 6th row and column will disappear since the \\(z\\) component of \\(m \\times H\\) cross product does not contain dependency on \\(m_z\\) (due to the nature of said cross product), hence they surely vanish. This new matrix we call \\(\\mathcal{J}_0\\).</p> <p>Up to the first order, we make the following substiution: \\(\\mathrm{d}_t \\mathbf{m} = i \\omega \\mathbf{m}\\), hence after collecting terms with:</p> \\[ \\mathcal{C} = i \\omega \\mathbf{m} + \\mu_0\\gamma \\mathcal{J}_0 = \\rightarrow i\\omega \\begin{pmatrix} m_{x,1} \\\\ m_{y,1} \\\\ m_{x,2} \\\\ m_{y,2} \\\\ \\end{pmatrix} +  \\mu_0\\gamma \\mathcal{J}_0 \\begin{pmatrix} m_{x,1} \\\\ m_{y,1} \\\\ m_{x,2} \\\\ m_{y,2} \\\\ \\end{pmatrix} \\tag{7} \\] <p>where \\(\\mathbf{m}\\) contains the leftover \\(x, y\\) components of \\(m\\). Finally, we substute \\(m_z \\pm 1\\) depending on the state in \\(J_0\\), leading to fully determined matrix. In \\((7)\\) we applied the operator \\((6)\\) to \\(\\mathbf{m}\\). The only thing left is to compute the eigenvalues of the characteristic matrix \\(\\mathcal{C}\\) which would be the frequencies of the system.</p>"},{"location":"physics/linearisation/#tldr","title":"TL;DR","text":"<p>Steps we do in code:</p> <ol> <li>Magnetisation vector of all layers is defined as \\(\\mathbf{M} = (m_{x,1}, m_{y,1}, m_{z,1}, m_{x,2}, m_{y,2}, m_{z,2})^T\\)</li> <li>We compute the effective field per layer as:    $$    \\mathbf{H}i = -\\nabla{\\mathbf{m}_i} \\mathcal{F}_i    $$</li> <li>LLG given by (note how the fields will depend on entire \\(\\mathbf{M}\\), not just its layers \\(m_i\\)):    $$    \\frac{d\\mathbf{m}}{dt} = -\\mu_0 \\gamma \\begin{pmatrix} \\mathbf{m}_1 \\times \\mathbf{H}_1(\\mathbf{M}) \\ \\mathbf{m}_2 \\times \\mathbf{H}_2(\\mathbf{M}) \\end{pmatrix} = \\mathbf{T}(\\mathbf{M})    $$</li> <li>We take Jacobian \\(\\mathcal{J} = \\partial \\mathbf{T}/\\partial \\mathbf{M}\\)</li> <li>We substitute \\(m_{i, x} = m_{i, y} = 0\\) and \\(m_{i, z} = \\pm 1\\) in \\(\\mathcal{J}\\) to make \\(\\mathcal{J}_0\\)</li> <li>We drop columns and rows corresponding to \\(m_z\\) component (it's not moving and it's zero). This is due first order approximation \\(\\delta m_{z,i} = 0\\)</li> <li>Characteristic equation: \\(\\mathcal{C} = i\\omega I - \\mathcal{J}_0\\)</li> <li>Compute the determinant</li> </ol>"},{"location":"physics/macromagnetic_models/","title":"Introduction","text":"<p>In this section we will walk through the basics of the LLG equation and the transformation to the LL-form of the LLG equation. The LLG equation is a proper equation in physical sense (derived from actual mechanics), whereas LL is simply a transformed approximation of the LLG equation that allows us to solve it numerically (no implicit term on \\(\\frac{dm}{dt}\\)).</p>"},{"location":"physics/macromagnetic_models/#landau-lifshitz-form-of-landau-lifshitz-gilbert-equation","title":"Landau Lifshitz form of Landau Lifshitz-Gilbert equation","text":"<p>Standard form of the LLG-SOT equation:</p> \\[\\frac{d\\textbf{m}}{dt} = -\\gamma \\textbf{m} \\times \\textbf{H}_{\\mathrm{eff}} + \\alpha \\textbf{m}\\times \\frac{d\\textbf{m}}{dt} -\\gamma\\tau_{fl}\\textbf{m} \\times \\sigma-\\gamma\\tau_{dl}\\textbf{m}\\times\\textbf{m}\\times \\sigma\\] <p>Multiply that equation \\(\\times m\\):</p> \\[ \\begin{gathered}        \\textbf{m} \\times \\frac{d\\textbf{m}}{dt} = -\\gamma  \\textbf{m} \\times\\textbf{m} \\times \\textbf{H}_{\\mathrm{eff}} + \\alpha \\textbf{m} \\times \\textbf{m}\\times \\frac{d\\textbf{m}}{dt}  -   \\gamma\\tau_{fl} \\textbf{m} \\times \\textbf{m} \\times \\sigma-   \\gamma\\tau_{dl}\\textbf{m} \\times \\textbf{m}\\times\\textbf{m}\\times \\sigma \\\\    \\textbf{m} \\times \\frac{d\\textbf{m}}{dt} = -\\gamma  \\textbf{m} \\times\\textbf{m} \\times \\textbf{H}_{\\mathrm{eff}} - \\alpha \\frac{d\\textbf{m}}{dt}  -  \\gamma\\tau_{fl} (\\textbf{m}(\\textbf{m}\\cdot\\sigma) - \\sigma) +   \\gamma\\tau_{dl}\\textbf{m}\\times \\sigma\\end{gathered} \\] <p>Substitute RHS of the derived equation above into \\(\\textbf{m}\\times \\frac{d\\textbf{m}}{dt}\\):</p> \\[ \\begin{gathered}   \\frac{d\\textbf{m}}{dt} = -\\gamma \\textbf{m} \\times \\textbf{H}_{\\mathrm{eff}} + \\alpha [-\\gamma  \\textbf{m} \\times\\textbf{m} \\times \\textbf{H}_{\\mathrm{eff}} - \\alpha \\frac{d\\textbf{m}}{dt}  -  \\gamma\\tau_{fl} (\\textbf{m}(\\textbf{m}\\cdot\\sigma) - \\sigma) +   \\gamma\\tau_{dl}\\textbf{m}\\times \\sigma] \\\\ -    \\gamma\\tau_{fl}\\textbf{m} \\times \\sigma \\\\ -     \\gamma\\tau_{dl}\\textbf{m}\\times\\textbf{m}\\times \\sigma \\\\      \\frac{d\\textbf{m}}{dt}(1 + \\alpha^2)  = -\\gamma \\textbf{m} \\times \\textbf{H}_{\\mathrm{eff}} - \\alpha\\gamma\\textbf{m}\\times\\textbf{m}\\times\\textbf{H}_{\\mathrm{eff}} \\\\      - \\gamma\\tau_{fl}[\\textbf{m} \\times \\sigma  + \\alpha (\\textbf{m}(\\textbf{m}\\cdot\\sigma) - \\sigma) ] \\\\      -  \\gamma\\tau_{dl}[\\textbf{m}\\times\\textbf{m}\\times \\sigma - \\alpha\\textbf{m}\\times \\sigma]\\end{gathered} \\] <p>Rearranging the terms gives:</p> \\[ \\begin{aligned}     \\frac{d\\textbf{m}}{dt} = \\frac{-\\gamma}{1 + \\alpha^2}[\\textbf{m} \\times \\textbf{H}_{\\mathrm{eff}} + \\alpha\\textbf{m}\\times\\textbf{m}\\times\\textbf{H}_{\\mathrm{eff}} &amp;\\\\      + \\tau_{fl}[\\textbf{m} \\times \\sigma  + \\alpha (\\textbf{m}(\\textbf{m}\\cdot\\sigma) - \\sigma) ] &amp;\\\\      +  \\tau_{dl}[\\textbf{m}\\times\\textbf{m}\\times \\sigma - \\alpha\\textbf{m}\\times \\sigma]]\\end{aligned} \\] <p>In this form, \\(\\gamma\\) is the gyromagnetic ratio and is equal to \\(\\gamma \\approx 2.2e5 \\frac{m}{As}\\). The last part can be re-arranged to:</p> \\[ \\begin{aligned} \\frac{d\\textbf{m}}{dt} = \\frac{-\\gamma}{1 + \\alpha^2}[\\textbf{m} \\times \\textbf{H}_{\\mathrm{eff}} + \\alpha\\textbf{m}\\times\\textbf{m}\\times\\textbf{H}_{\\mathrm{eff}} ]&amp;\\\\ + \\tau_{fl}[\\textbf{m} \\times \\sigma  + \\alpha (\\textbf{m}(\\textbf{m}\\cdot\\sigma) - \\sigma) ] + \\tau_{dl}[\\textbf{m}\\times\\textbf{m}\\times\\sigma - \\alpha\\textbf{m}\\times \\sigma]&amp;\\\\ \\frac{d\\textbf{m}}{dt} = \\frac{-\\gamma}{1 + \\alpha^2}[\\textbf{m} \\times \\textbf{H}_{\\mathrm{eff}} + \\alpha\\textbf{m}\\times\\textbf{m}\\times\\textbf{H}_{\\mathrm{eff}}  + \\textbf{m} \\times \\sigma(\\tau_{fl} - \\alpha\\tau_{dl}) + \\textbf{m}\\times\\textbf{m}\\times\\sigma(\\tau_{dl} + \\alpha\\tau_{fl})] \\end{aligned} \\] <p>What is evident in this form of LL form of the LLG equation is the mixing of the torques with damping as the scaling factor (the field-like term for instance now becomes \\(\\tau_{fl} - \\alpha\\tau_{dl}\\)). Proper LL-form of the LLGS equation is:</p> \\[ (...)+ \\frac{-\\gamma}{1 + \\alpha^2}[     \\tau'_1 \\textbf{m}\\times(\\textbf{m}\\times \\sigma)     + \\tau'_2 \\textbf{m}\\times \\sigma] \\] <p>It is worth nothing that eliminating the field-like torque magnitude, \\(\\tau_{fl}\\) does not eliminate the field-like term in the equation. See below for \\(\\tau_{fl} = 0\\):</p> \\[ \\begin{aligned} \\frac{d\\textbf{m}}{dt} = \\frac{-\\gamma}{1 + \\alpha^2}[\\textbf{m} \\times \\textbf{H}_{\\mathrm{eff}} + \\alpha\\textbf{m}\\times\\textbf{m}\\times\\textbf{H}_{\\mathrm{eff}}  - \\alpha\\textbf{m} \\times \\sigma\\tau_{dl} + \\textbf{m}\\times\\textbf{m}\\times\\sigma\\tau_{dl}] \\end{aligned} \\] <p>Note that in this case, since there's no \\(\\tau_{fl}\\) competing with \\(\\tau_{dl}\\), the field-like torque changes sign in effect.</p> <p>Similarly, when \\(\\tau_{dl} = 0\\) there is still field-like part:</p> \\[ \\begin{aligned} \\frac{d\\textbf{m}}{dt} = \\frac{-\\gamma}{1 + \\alpha^2}[\\textbf{m} \\times \\textbf{H}_{\\mathrm{eff}} + \\alpha\\textbf{m}\\times\\textbf{m}\\times\\textbf{H}_{\\mathrm{eff}}  + \\textbf{m} \\times \\sigma\\tau_{fl} + \\alpha\\textbf{m}\\times\\textbf{m}\\times\\sigma\\tau_{fl}] \\end{aligned} \\]"},{"location":"physics/macromagnetic_models/#stt-interaction","title":"STT interaction","text":"<p>The origin of STT is different, thus, we use a different set of quantities:</p> \\[ \\begin{gathered}     |H_{dl}| = \\beta |H_{fl}|, \\quad \\beta \\in [0, 1] \\\\     a_j = \\frac{\\hbar j_e}{eM_s t_{FM}} \\\\     \\eta = \\frac{\\sigma \\Lambda^2}{\\Lambda^2 + 1 + (\\Lambda^2 -1)\\textbf{m}\\cdot\\sigma}\\end{gathered} \\] <p>Given those two terms above, the non-torque part remains the same:</p> \\[... +  a_j\\eta\\beta\\textbf{m} \\times \\sigma + a_j\\eta\\textbf{m}\\times\\textbf{m}\\times \\sigma\\] <p>Then, equation only changes the coefficients scaling the damping-like and field-like torques.</p> <p>The LL form of the STT equation is:</p> \\[ \\begin{aligned} \\frac{d\\textbf{m}}{dt} = \\frac{-\\gamma}{1 + \\alpha^2}[\\textbf{m} \\times \\textbf{H}_{\\mathrm{eff}} + \\alpha\\textbf{m}\\times\\textbf{m}\\times\\textbf{H}_{\\mathrm{eff}} &amp;\\\\ + (-a_j (\\mathbf{m}\\times\\mathbf{p})  + a_j\\beta (\\mathbf{m}\\times\\mathbf{m}\\times\\mathbf{p})] \\end{aligned} \\] <p>where \\(\\(a_j =  \\gamma_0 \\eta \\frac{\\hbar j}{e M_\\mathrm{s} t_\\mathrm{FM}}\\)\\)</p>"},{"location":"physics/macromagnetic_models/#stochastic-llgs","title":"Stochastic LLGS","text":""},{"location":"physics/macromagnetic_models/#stratonovich-formulation-of-the-s-llgs-sde","title":"Stratonovich formulation of the s-LLGS SDE","text":"<p>A stochastic formulation of LLGS will take the form of a Stratonovich SDE:</p> \\[\\mathrm{d}X_t = f(X_t, t)dt + g(X_t, t)\\circ \\mathrm{d}W_t\\sqrt{\\Delta t}\\] <p>where \\(f(X_t, t)\\) is the deterministic part of the equation and \\(g(X_t, t)\\) is the stochastic part of the equation. \\(\\mathrm{d}W\\) is \\\"derivative-like\\\" of the Brownian motion. The symbol \\(\\circ\\) denotes the Stratonovich product which distinguishes it from Ito's SDE. By assuming that the effective field contains thermal fluctuations \\(\\mathbf{H}_{\\mathrm{eff}} \\rightarrow \\mathbf{H}_{\\mathrm{eff}} + \\mathbf{H}_{\\mathrm{T}}\\) we transform the standard LLGS equation into the form that fits Stratonovich SDE. The thermal fluctuations have zero mean and a preset standard deviation:</p> \\[\\sigma(t) = \\sqrt{\\frac{4\\alpha k_bT(t)}{\\mu_0 M_s V\\gamma_0}}    \\quad (1)\\] <p>where \\(V\\) is the volume of the cell (layer), and \\(k_bT(t)\\) is the thermal energy of the system. As a result, \\(\\sigma(t)\\) should be dimensionless.</p> <p>To convince ourselves that this is the correct form, one can take a look at the units. In the standard LLG, let's take a term \\(\\frac{dm}{dt} = -\\gamma\\mathbf{m}\\times\\mathbf{H}_{\\mathrm{eff}}\\). We take \\(\\mathbf{m}\\) to be unit and \\(\\mathbf{H}_{\\mathrm{eff}}\\) to be in units of A/m. Then, we have\"</p> \\[ \\left[\\frac{1}{s}\\right] = \\left[\\frac{m}{As}\\right]\\left[\\frac{A}{m}\\right] \\] <p>and thus we multiply by the time step \\(\\Delta t\\) to get the unit again.</p> <p>We now take a look at the equation \\((1)\\). We have (we take the sqrt off for now):</p> \\[     \\frac{         \\left[J\\right]     }{         \\left[\\frac{N}{A^2}\\right] \\left[\\frac{A}{m}\\right] \\left[m^3\\right] \\left[\\frac{m}{A s}\\right]     } =         \\frac{         \\left[Nm\\right]     }{         \\left[\\frac{N}{A^2}\\right] \\left[m^2\\right] \\left[\\frac{1}{s}\\right]     } =     \\frac{         \\left[A^2\\right]     }{         \\left[m^2\\right] \\left[\\frac{1}{s}\\right]     }  =     \\frac{         \\left[A^2 s\\right]     }{         \\left[m^2\\right]     } \\] <p>So, instead of \\(\\frac{A}{m}\\) we get \\(\\frac{A s^{1/2}}{m}\\) after taking the square root. But, in the end for stochastic torque we have:</p> \\[     RHS = \\left[\\frac{m}{As}\\right]\\left[\\frac{A}{m}\\right]\\left[\\sqrt{s}\\right] = \\left[\\frac{\\sqrt{s}}{s}\\right] \\] <p>but we multiply the RHS by \\(\\sqrt{\\Delta t}\\) to get the unit back \\(\\rightarrow \\left[\\frac{\\sqrt{s}}{s}\\right] [\\sqrt{s}] = 1\\).</p> <p>Finally, we set \\(\\mathbf{f}(\\mathbf{m}_t, t)\\) to LL form where \\(\\mathbf{H}_{\\mathrm{eff}}\\) contains no stochastic (thermal) parts and the \\(g\\), the stochastic part, to the following:</p> \\[ \\mathbf{g}(\\mathbf{m}_t, t)\\circ\\mathrm{d}W  =     - \\frac{\\sigma\\gamma}{1+\\alpha^2}[\\mathbf{m}\\times\\mathrm{d}W + \\alpha\\mathbf{m}\\times(\\mathbf{m}\\times\\mathrm{d}W)] \\] <p>with \\(\\mathrm{d}W \\in \\mathbf{R}^3 \\sim \\sqrt{t}\\mathcal{N}(0, 1)\\), a multinomial Gaussian distributed random vector (here we make a transition from \\(W\\) being a generalised Brownian process to a Wiener process). For numerical solutions, we have have \\(\\Delta W\\) instead of \\(\\mathrm{d}W\\). \\(\\Delta W(t) = W(t + \\Delta t) - W(t)\\), where the stochastic vector is being drrawn from a normal distriubtion, with zero mean and unit variance: \\(\\xi_t \\in \\mathbf{R}^3 \\sim \\mathcal{N}(0, 1)\\). The form above follows from the distributive properties of cross-product over addition. Furthermore, there is some evidence that the second term in that equation should be skipped if the noise is sufficiently small which seems to be the case for up to room temperature experiments.</p>"},{"location":"physics/macromagnetic_models/#numerical-solutions","title":"Numerical solutions","text":"<p>We generally solve the stochastic model by either with Euler-Heun or Heun method.</p>"},{"location":"physics/macromagnetic_models/#euler-heun-method","title":"Euler-Heun method","text":"<p>This is in fact first order-method in the limit of 0 K. Euler-Heun method is suitable for Stratonovich SDEs as Euler-Maruyama can only be applied to Ito's SDEs. The update of the step is:</p> \\[Y_{n+1} = Y_n + f_n \\Delta t + \\frac{1}{2}[g_n + g_n(\\hat{Y}_n)]\\Delta W_n\\sqrt{\\Delta t}\\] <p>where \\(\\hat{Y}_n = Y_n + g_n\\Delta W_n\\). Contrary to the Milstein method, it is easier to the user the Euler-Heun due to the lack of quadratic terms of \\(\\Delta W_n\\). The cost is in the convergence order which is 0.5 for strong convergence and 1 for weak convergence. For the solution, we substitute \\(Y_n = \\mathbf{m_t}\\), \\(f_n = \\mathbf{f}_n(\\mathbf{m_t}, t)\\), \\(g_n= \\mathbf{g}_n(\\mathbf{m_t}, t)\\).</p>"},{"location":"physics/macromagnetic_models/#heun-method","title":"Heun method","text":"<p>Now preferred method to solve stochastic form of the LLG equation is the Heun method. It introduces second order correction to the non-stochastic part as well and therefore is deemed a better method.</p> \\[Y_{n+1} = Y_n + \\frac{1}{2}\\left[f_n(\\hat{Y}_{n+1}, t_{n+1}) + f_n(Y_n, t_n)\\right] + \\frac{1}{2}\\left[g_n(\\hat{Y}_{n+1}, g_{n+1}) + g_n(Y_n, t_n)\\right]\\Delta W_n\\] <p>where \\(\\hat{Y}_{n+1} = Y_n + f_n(Y_n, t_n)\\Delta t + g_n(Y_n, t_n)\\Delta W_n\\sqrt{\\Delta t}\\).</p>"},{"location":"physics/macromagnetic_models/#references","title":"References","text":"<p>Numerical Integration of SDEs: A Short Tutorial, Thomas Schaffter, January 19, 2010</p>"},{"location":"physics/paralellism/","title":"Parallelism in CMTJ","text":""},{"location":"physics/paralellism/#overview","title":"Overview","text":"<p><code>cmtj</code> provides a simple way to parallelise simulation sweeps. For instance, while performing the Voltage Spin Diode (VSD) experiments, we need to sweep the frequency and for each frequency value we further need to sweep with the field. For each field and frequency pair we need to compute the VSD DC resistance. Normally, this scales as \\(O(NK)\\) where \\(N\\) is the number of field values and \\(K\\) is the number of frequency values. However, with parallelism, we can reduce this to \\(O(K)\\) if we would be able to process each frequency value in parallel.</p> <p>In practice, we use worker pools which are approximately equal to the number of threads in the CPU. Each worker is assigned a frequency value and it computes the VSD DC resistance for all the field values. Whenever the worker is finished, it is assigned another frequency value.</p>"},{"location":"physics/paralellism/#general-caveats","title":"General caveats","text":"<p>Note</p> <p>Keep in mind that these issues are not specific to CMTJ, but are a general problem of any parallelisation.</p> <p>Before we move on to a specific example, let's discuss when we should be careful with simulating in parallel. When we sweep with an external field, which in the experiment is usually continously swept, we need to realise that if we were to compute the experiment for each separate field in a separate process, we would not carry the relaxed state of magnetisation computed in the previous field step to the next. This is of course a natural consequence of putting things in parallel and can be easily remedided by the following precautions:</p> <ul> <li>relax the magnetisation the magentisation in each parallel process by calling <code>runSimulation</code> for a short time, say between 1-5ns (depending on the complexity of the system),</li> <li>increase the simulation time, since reaching the stable state may take a little longer,</li> <li>decrease the time step (integration step) -- this is more costly computationally, but it is also ensuring absolute convergence.</li> </ul> <p>We generally recommend to use the <code>runSimulation</code> function to relax the magnetisation in each parallel process, and then to use the <code>runSimulation</code> function to compute the experiment in parallel. This is the most efficient way to do it, since short relaxation period does not incur a large computational cost, and because we paralellise the experiment anyway, that cost is offset by running on multiple threads.</p> <p>With this in mind, let's move on to a specific example.</p>"},{"location":"physics/paralellism/#problem-description","title":"Problem description","text":"<p>Suppose we want to compute the VSD DC resistance for a given frequency and field value, but also check how the VSD spectra differ for different values of the interlayer exchange coupling (IEC) constant <code>J</code>. What we want to effectively do is we want to fun a VSD experiment for each of the <code>J</code> values, wherein each experiment is a function of the frequency and field. Below, we outline the steps to parallelise such a problem.</p>"},{"location":"physics/paralellism/#parallelising-the-vsd-experiment","title":"Parallelising the VSD experiment","text":"<p>Here's what we need:</p> <ul> <li>A function that computes the VSD DC resistance for a given frequency and field value.</li> <li>A range of frequencies and fields.</li> <li>A distributing function that assigns the frequency and field values to the workers.</li> </ul> <p>The last point is taken care of by importing the <code>distribute</code> function from <code>cmtj.utils.parallel</code>. The <code>distribute</code> function takes a function and a list of arguments and distributes the arguments to the workers.</p> <p>An example function that computes the VSD DC resistance for a given system with a IEC constant <code>J</code> and for a specific frequency and field value:</p> <pre><code>def simulate_vsd(J, H, frequency):\n    \"\"\"\n    This function computes the VSD DC resistance for a\n    given frequency f and field value H.\n    It also takes the current coupling value J as an argument.\n    \"\"\"\n    int_step = 5e-13\n    demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)]\n\n    Ku = 0.8e3\n    alpha = 0.024  # 0.024\n    l1 = Layer(\n        \"free\",\n        mag=CVector(1, 0.1, 0.1),\n        anis=CVector(0, 1., 0.),  # direction of the anisotropy\n        Ms=1.03,\n        thickness=2.1e-9,\n        cellSurface=surf,\n        demagTensor=demag,\n        damping=alpha)\n\n    l2 = Layer(\n        \"bottom\",\n        mag=CVector(1, 0.1, 0.1),\n        anis=CVector(1, 0, 0),  # direction of the anisotropy\n        Ms=1.65,\n        thickness=6e-9,\n        cellSurface=surf,\n        demagTensor=demag,\n        damping=alpha)\n    j1 = Junction([l1, l2], 163.5, 176)\n    j1.setLayerAnisotropyDriver(\"free\", ScalarDriver.getConstantDriver(Ku))\n    j1.setLayerAnisotropyDriver(\"bottom\", ScalarDriver.getConstantDriver(1e12))\n    j1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J))\n    hangle = FieldScan.angle2vector(90, 90, H)\n    j1.clearLog()\n    j1.setLayerExternalFieldDriver(\n        \"all\",\n        AxialDriver(ScalarDriver.getConstantDriver(hangle.x),\n                    ScalarDriver.getConstantDriver(hangle.y),\n                    ScalarDriver.getConstantDriver(hangle.z)))\n    j1.setLayerOerstedFieldDriver(\n        \"free\",\n        AxialDriver(\n            NullDriver(),\n            ScalarDriver.getSineDriver(0, 5, frequency, 0),\n            NullDriver(),\n        ))\n    j1.runSimulation(60e-9, int_step, int_step, solverMode=SolverMode.RK4)\n    log = j1.getLog()\n    dynamicR = log['R_free_bottom']\n\n    dynamicI = np.sin(2 * math.pi * frequency * np.asarray(log['time']))\n    vmix = compute_sd(dynamicR, dynamicI, int_step)\n    return vmix\n</code></pre> <p>Writing such functions is a good idea in general, since they can be also used in the normal serial processing as well. So a good practice is to write such a function first, test it in serial/iterative sweep and then use <code>distribute</code> to parallelise it easily. Here's how we would use the <code>distribute</code> function to parallelise the VSD experiment:</p> <pre><code>from cmtj.utils.parallel import distribute\n\nJs = np.linspace(1e-4, 1e-3, 10)\nHrange = np.linspace(-15e3, 15e3, 100, endpoint=True)\nfscan = np.arange(1e9, 6.2e9, 0.2e9)\nVSD = np.zeros((len(Js), len(fscan), len(Hrange)), dtype=np.float32)\nJs = np.around(Js, decimals=7)\nfor res in distribute(simulate_vsd, [Js, Hrange, fscan]):\n    (k, i, j), out = res\n    VSD[k, j, i] = out\n</code></pre> <p>The <code>distribute</code> function returns a generator, which we can iterate over to get the results. The results are returned as a tuple of two elements: the first element is a tuple of the indices of the result, and the second element is the result itself. In our case, the result is the VSD DC resistance, and the indices are the indices of the <code>J</code>, <code>H</code> and <code>f</code> values (in that order specifically, we need to match the function signature of <code>simulate_vsd</code> with the second argument to <code>distribute</code> function). We can use these indices to assign the result to the correct place in the <code>VSD</code> array.</p> <p>Very simple! Now we can plot the VSD spectra for different values of the IEC constant <code>J</code>:</p> <pre><code>fig, axs = plt.subplots(len(Js), 1, figsize=(8, 6), dpi=300)\nfor k in range(len(Js)):\n    axs[k].pcolor( Hrange/1e3, fscan / 1e9, VSD[k], shading='auto')\n    axs[k].set_xlabel(\"H (kA/m)\")\n    axs[k].set_ylabel(\"Frequency (GHz)\")\n    axs[k].set_title(\"J = {}\".format(Js[k]))\n</code></pre>"},{"location":"physics/sb-model/","title":"Smit-Beljers model","text":""},{"location":"physics/sb-model/#introduction","title":"Introduction","text":"<p>The basic model was introduced by Smit and Beljers 1955. However, there were nice extensions of the model, notably, by L. Baselgia, M. Warden, and F. Waldner in the Derivation of the resonance frequency from the free energy of ferromagnets, 1988. One of more recent ones by R. L. Rodr\u00edguez-Su\u00e1rez, S. M. Rezende, and A. Azevedo from Ferromagnetic resonance investigation of the residual coupling in spin-valve systems, PRB 2005 is the one I prefer to use for explanation.</p>"},{"location":"physics/sb-model/#the-model","title":"The model","text":"<p>The model is capable of simulating the magnetisation in equilibrium and the resonance frequency mode (fmr = ferromagnetic resonance). The former basically allows us to reproduce the hysteresis M(H) or R(H) loops etc. The latter gives use the frequency of the oscillations of the magnetisation in the presence of an external magnetic field.</p> <p>For the full model we need:</p> <ol> <li>Create energy expression of the system.</li> <li>Obtain equilibirum magnetisation position of the system.</li> <li>Compute the hessian matrix \\(H\\) of the energy expression.</li> <li>Find the roots of the \\(\\det H\\).</li> </ol> <p>Each layer is described by the following parameters:</p>"},{"location":"physics/sb-model/#parameter-table","title":"Parameter table","text":"Parameter Description Units \\(\\theta\\) Polar angle of magnetisation vector rad \\(\\phi\\) Azimuthal angle of magnetisation vector rad \\(t_\\textrm{FM}\\) Thickness of the FM layer m \\(M_s\\) Magnetisation saturation \\(\\frac{A}{m}\\) \\(K_s\\) Shape anisotropy (perpendicular, out of plane) \\(\\frac{J}{m^3}\\) \\(K_v\\) Volume anisotropy (in-plane) \\(\\frac{J}{m^3}\\) \\(\\alpha\\) Azimuthal angle of in-plane anisotropy rad \\(J_1\\) Interlayer exchange coupling value (linear) \\(\\frac{J}{m^2}\\) \\(J_2\\) Interlayer exchange coupling value (quadratic) \\(\\frac{J}{m^2}\\) <p>And the external field is also given by it's own (\\(\\theta\\), \\(\\phi\\), \\(H\\)) where \\(H\\) is the magnitude of the field.</p> <p>Note</p> <p>This assumes physical, not mathematical spherical coordinates! Here, polar angle \\(\\theta\\) is measured from the positive \\(z\\) axis, and azimuthal angle \\(\\phi\\) is measured from the positive \\(x\\) axis.</p> <p>The energy expression per layer is given by the following:</p> \\[     \\varepsilon_i = - \\mu_0 M_s \\vec{m}_i \\cdot \\vec{H} +         (- K_s + \\frac{1}{2}\\mu_0 M_s^2) m_z^2         - K_v (\\vec{m} \\cdot \\vec{K}_{dir})^2         - J_1 \\vec{m}_i \\cdot \\vec{m}_{i+1}         - J_2 (\\vec{m}_i \\cdot \\vec{m}_{i+1})^2 \\] <p>where \\(\\vec{m}\\) is in the spherical coordinates, and \\(\\vec{K}_{dir}\\) is the direction of the in-plane anisotropy.</p> \\[     \\vec{m} = \\begin{bmatrix}         \\sin\\theta\\cos\\phi \\\\         \\sin\\theta\\sin\\phi \\\\         \\cos\\theta          \\\\     \\end{bmatrix} \\] <p>Similarly, \\(H\\) for its respective coordinates. Finally, \\(\\vec{K}_{dir}\\) is given by:</p> \\[ \\vec{K}_{dir} = \\begin{bmatrix}     \\cos\\alpha \\\\     \\sin\\alpha \\\\     0          \\\\ \\end{bmatrix} \\]"},{"location":"physics/sb-model/#solution","title":"Solution","text":""},{"location":"physics/sb-model/#equilibrium-magnetisation","title":"Equilibrium magnetisation","text":"<p>The solution for equilibrium magnetisation is solved using the Adam gradient descent. It is a quick and reliable algorithm for finding energy minima. It operates on the first derivative of the \\(\\varepsilon_i\\) expression, i.e. \\(\\frac{\\partial\\varepsilon}{\\partial\\theta}\\) and \\(\\frac{\\partial\\varepsilon}{\\partial\\phi}\\). If the gradient is found within a certain tolerance, the algorithm stops. Otherwise, it continues to iterate until the maximum number of iterations is reached.</p>"},{"location":"physics/sb-model/#resonance-frequency","title":"Resonance frequency","text":"<p>The equilibrium magnetisation, \\((\\theta^*, \\phi^*)\\), is then used to compute the hessian matrix of the energy expression. The hessian matrix is a matrix of second derivatives of the energy expression. We use it to find the roots of the \\(\\det H\\)(hessian) expression. Those roots designate the frequencies of the resonance mode.</p>"},{"location":"physics/sb-model/#root-finding","title":"Root finding","text":"<p>Root finding algorithm is a naive greedy search, but for GHz or MHz frequencies it's pretty fast and precise enough (you can set the tolerance in the parameters).</p>"},{"location":"physics/sb-model/#runnning-the-model","title":"Runnning the model","text":"<p>The same example can be found in the <code>Examples</code> section, expanded with dynamic spherical approach. Below is an example of how the model can be used, based on a system with 2 ferromagnetic layers:</p> <pre><code>import numpy as np\n\nfrom collections import defaultdict\nfrom cmtj.models import LayerSB, VectorObj, Solver\nfrom cmtj.utils import mu0\nfrom tqdm import tqdm\n\nMs1 = 1. / mu0 # here we pass the saturation magnetisation in A/m, but in the dynamic model we use T!\nMs2 = 1.2 / mu0\nlayerA = LayerSB(\n    _id=0,\n    thickness=1e-9,\n    Kv=VectorObj(np.deg2rad(0.), np.deg2rad(0), 1e1), # for the Kv only phi angle counts !\n    Ks=3e4,\n    Ms=Ms1,\n)\nlayerB = LayerSB(\n    _id=1,\n    thickness=1.3e-9,\n    Kv=VectorObj(np.deg2rad(0.), np.deg2rad(0), 1e4),\n    Ks=1e1,\n    Ms=Ms2,\n)\n\n# we indicate the \"guess\" of the initial position\n# it's generally good to align it with the field, but it's not necessary\ncurrent_position = [\n    np.deg2rad(89),\n    np.deg2rad(0.1),\n    np.deg2rad(180),\n    np.deg2rad(0.1)\n]\nHspace = np.linspace(-400e3, 400e3, 100)\nresult_dictionary = defaultdict(list)\n# we perform a sweep over the field magnitude\nfor Hmag in tqdm(Hspace):\n    solver = Solver(\n        layers=[layerA, layerB],\n        J1=[1e-4],\n        J2=[0.],\n        H=VectorObj(np.deg2rad(89), np.deg2rad(0.1), Hmag)\n    )\n    # check for additional parameters in the solver\n    # such as gradient convergence tolerance, max iterations, etc.\n    # also in the solver there are root finding parameters\n    (t1, p1, t2, p2), frequencies = solver.solve(init_position=current_position)\n    # frequencies are already in GHz\n    for frequency in frequencies:\n        result_dictionary[\"frequency\"].append(frequency)\n        result_dictionary[\"Hmag\"].append(Hmag)\n\n    # we note the final position of the magnetisation in spherical coordinates\n    result_dictionary[\"theta_1\"].append(t1)\n    result_dictionary[\"phi_1\"].append(p1)\n    result_dictionary[\"theta_2\"].append(t2)\n    result_dictionary[\"phi_2\"].append(p2)\n    # we reuse the previous solution as the initial guess for the next iteration\n    current_position = [t1, p1, t2, p2]\n</code></pre>"},{"location":"physics/sb-model/#references","title":"References","text":"<ol> <li>Rodr\u00edguez-Su\u00e1rez, R. L., Rezende, S. M. &amp; Azevedo, A. Ferromagnetic resonance investigation of the residual coupling in spin-valve systems. Phys. Rev. B 71, 224406 (2005).</li> <li>Baselgia, L. et al. Derivation of the resonance frequency from the free energy of ferromagnets. Phys. Rev. B 38, 2237\u20132242 (1988).</li> </ol>"},{"location":"tutorials/CMTJBindingsTutorial/","title":"Library introduction","text":"<p>We start with the definition of our Junction, which in turn is composed from two layers. Here are some key parameters:</p> <ul> <li>mag - magnetisation vector</li> <li>anis - the vector (axis) of the magnetic anisotoropy </li> <li>K - magnetic anisotropy $[J/m^3]$</li> <li>Ms - magnetisation saturation $[T]$</li> <li>thickness - thickness of the layer $[m]$</li> <li>J - the IEC coupling with the other layers $[J/m^2]$</li> </ul> In\u00a0[1]: Copied! <pre>import numpy as np\nimport time\nfrom cmtj import Junction, Layer, CVector, ScalarDriver, AxialDriver, NullDriver\n</pre> import numpy as np import time from cmtj import Junction, Layer, CVector, ScalarDriver, AxialDriver, NullDriver In\u00a0[2]: Copied! <pre>N = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)]\ndamping = 0.01\ncl1 = Layer(id=\"free\",\n            mag=CVector(0, 0, 1),\n            anis=CVector(0, -0.0871557, 0.996195),\n            Ms=1.07,\n            thickness=1e-9,\n            cellSurface=0,\n            demagTensor=N,\n            damping=damping)\n\ncl2 = Layer(id=\"bottom\",\n            mag=CVector(0, 0, 1),\n            anis=CVector(0.34071865, -0.08715574, 0.936116),\n            Ms=1.07,\n            thickness=1e-9,\n            cellSurface=0,\n            demagTensor=N,\n            damping=damping)\n</pre> N = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)] damping = 0.01 cl1 = Layer(id=\"free\",             mag=CVector(0, 0, 1),             anis=CVector(0, -0.0871557, 0.996195),             Ms=1.07,             thickness=1e-9,             cellSurface=0,             demagTensor=N,             damping=damping)  cl2 = Layer(id=\"bottom\",             mag=CVector(0, 0, 1),             anis=CVector(0.34071865, -0.08715574, 0.936116),             Ms=1.07,             thickness=1e-9,             cellSurface=0,             demagTensor=N,             damping=damping) In\u00a0[3]: Copied! <pre>from collections import defaultdict\nfrom cmtj.utils import compute_sd\nfrom tqdm import tqdm\nimport math\n\ndata = defaultdict(list)\n\n\ndef compute_vsd(simulation_log, frequency, offset=0, tstart=1e-9):\n    stime = np.asarray(simulation_log['time'])\n    indx = np.argwhere(stime &gt;= tstart).ravel()\n    Rx = np.asarray(simulation_log['Rx'])[indx]\n    avg_res = np.mean(Rx)\n    current = np.sqrt(\n        10e-6 / avg_res) * np.sin(2 * np.pi * frequency * stime[indx] + offset)\n    return np.mean(current * Rx)\n\n\nstart = time.time()\njunction = Junction(layers=[cl1, cl2],\n                    Rx0=[100, 100],\n                    Ry0=[0, 0],\n                    AMR_X=[10, 10],\n                    AMR_Y=[30 / 2, 30 / 2],\n                    SMR_X=[0, 0],\n                    SMR_Y=[0, 0],\n                    AHE=[0, 0])\n\njunction.setLayerAnisotropyDriver(\"free\",\n                                  ScalarDriver.getConstantDriver((305e3)))\njunction.setLayerAnisotropyDriver(\"bottom\",\n                                  ScalarDriver.getConstantDriver((728e3)))\njunction.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(4e-5))\n\nHoeAmpl = 5e2  # A/m\nHspace = np.linspace(-800e3, 800e3, 100)\nfrequencies = [1e9 * i for i in range(48)]\nmag_free = CVector(1, 1, 0)\nmag_bottom = CVector(1, 1, 0)\nVSD = []\nIampl = 1e-3\nint_step = 1e-12\n\nfor frequency in tqdm(frequencies):\n    H_sweep = []\n    for H in Hspace:\n        junction.clearLog()\n        junction.setLayerMagnetisation(\"free\", mag_free)\n        junction.setLayerMagnetisation(\"bottom\", mag_bottom)\n\n        HDriver = AxialDriver(\n            ScalarDriver.getConstantDriver(H * np.sqrt(2) / 2),\n            ScalarDriver.getConstantDriver(H * np.sqrt(2) / 2), NullDriver())\n\n        HoeDriver = AxialDriver(\n            NullDriver(), ScalarDriver.getSineDriver(0, HoeAmpl, frequency, 0),\n            NullDriver())\n        junction.setLayerExternalFieldDriver(\"all\", HDriver)\n        junction.setLayerOerstedFieldDriver(\"all\", HoeDriver)\n        junction.runSimulation(10e-9, int_step, int_step)\n\n        mag_free = junction.getLayerMagnetisation(\"free\")\n        mag_bottom = junction.getLayerMagnetisation(\"bottom\")\n        log = junction.getLog()\n        dynamicI = Iampl * np.sin(\n            2 * math.pi * frequency * np.asarray(log['time']))\n        vmix = compute_sd(log[\"Rx\"], dynamicI, int_step)\n\n        H_sweep.append(vmix)\n    VSD.append(H_sweep)\n\nend = time.time()\nprint(f\"Simulation time: {end-start:.2f}\")\n</pre> from collections import defaultdict from cmtj.utils import compute_sd from tqdm import tqdm import math  data = defaultdict(list)   def compute_vsd(simulation_log, frequency, offset=0, tstart=1e-9):     stime = np.asarray(simulation_log['time'])     indx = np.argwhere(stime &gt;= tstart).ravel()     Rx = np.asarray(simulation_log['Rx'])[indx]     avg_res = np.mean(Rx)     current = np.sqrt(         10e-6 / avg_res) * np.sin(2 * np.pi * frequency * stime[indx] + offset)     return np.mean(current * Rx)   start = time.time() junction = Junction(layers=[cl1, cl2],                     Rx0=[100, 100],                     Ry0=[0, 0],                     AMR_X=[10, 10],                     AMR_Y=[30 / 2, 30 / 2],                     SMR_X=[0, 0],                     SMR_Y=[0, 0],                     AHE=[0, 0])  junction.setLayerAnisotropyDriver(\"free\",                                   ScalarDriver.getConstantDriver((305e3))) junction.setLayerAnisotropyDriver(\"bottom\",                                   ScalarDriver.getConstantDriver((728e3))) junction.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(4e-5))  HoeAmpl = 5e2  # A/m Hspace = np.linspace(-800e3, 800e3, 100) frequencies = [1e9 * i for i in range(48)] mag_free = CVector(1, 1, 0) mag_bottom = CVector(1, 1, 0) VSD = [] Iampl = 1e-3 int_step = 1e-12  for frequency in tqdm(frequencies):     H_sweep = []     for H in Hspace:         junction.clearLog()         junction.setLayerMagnetisation(\"free\", mag_free)         junction.setLayerMagnetisation(\"bottom\", mag_bottom)          HDriver = AxialDriver(             ScalarDriver.getConstantDriver(H * np.sqrt(2) / 2),             ScalarDriver.getConstantDriver(H * np.sqrt(2) / 2), NullDriver())          HoeDriver = AxialDriver(             NullDriver(), ScalarDriver.getSineDriver(0, HoeAmpl, frequency, 0),             NullDriver())         junction.setLayerExternalFieldDriver(\"all\", HDriver)         junction.setLayerOerstedFieldDriver(\"all\", HoeDriver)         junction.runSimulation(10e-9, int_step, int_step)          mag_free = junction.getLayerMagnetisation(\"free\")         mag_bottom = junction.getLayerMagnetisation(\"bottom\")         log = junction.getLog()         dynamicI = Iampl * np.sin(             2 * math.pi * frequency * np.asarray(log['time']))         vmix = compute_sd(log[\"Rx\"], dynamicI, int_step)          H_sweep.append(vmix)     VSD.append(H_sweep)  end = time.time() print(f\"Simulation time: {end-start:.2f}\") <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 48/48 [00:48&lt;00:00,  1.00s/it]</pre> <pre>Simulation time: 48.16\n</pre> <pre>\n</pre> <p>Now, we may plot our Voltage Spin Diode curve, which is a ferromagnetic resonance curve -- the FMR (fitting the antisymmetric Lorentz curve), being a Vmix function of the field applied to the junction.</p> In\u00a0[4]: Copied! <pre>from mpl_toolkits.axes_grid1 import make_axes_locatable\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom cmtj.utils import Filters\n\nVSD = np.asarray(VSD, dtype=np.float32)\n\nwith plt.style.context(['science', 'nature']):\n    fig, ax = plt.subplots(dpi=300)\n    im = ax.pcolor(\n        Hspace / 1e3,\n        frequencies,\n        Filters.detrend_axis(VSD, axis=1),\n        shading='auto',\n        cmap='inferno',\n    )\n    divider = make_axes_locatable(ax)\n    cax = divider.append_axes('right', size='5%', pad=0.05)\n    fig.colorbar(im, cax=cax, orientation='vertical')\n    ax.set_xlabel(\"Field [A/m]\")\n    ax.set_ylabel(\"Vmix [mV]\")\n    ax.set_title(\"FMR curve for the Voltage Spin Diode Effect\")\nplt.show()\n</pre> from mpl_toolkits.axes_grid1 import make_axes_locatable import matplotlib.pyplot as plt import numpy as np from cmtj.utils import Filters  VSD = np.asarray(VSD, dtype=np.float32)  with plt.style.context(['science', 'nature']):     fig, ax = plt.subplots(dpi=300)     im = ax.pcolor(         Hspace / 1e3,         frequencies,         Filters.detrend_axis(VSD, axis=1),         shading='auto',         cmap='inferno',     )     divider = make_axes_locatable(ax)     cax = divider.append_axes('right', size='5%', pad=0.05)     fig.colorbar(im, cax=cax, orientation='vertical')     ax.set_xlabel(\"Field [A/m]\")     ax.set_ylabel(\"Vmix [mV]\")     ax.set_title(\"FMR curve for the Voltage Spin Diode Effect\") plt.show() In\u00a0[5]: Copied! <pre>import matplotlib.pyplot as plt\nfrom cmtj.utils.linear import FieldScan\nfrom cmtj.utils.procedures import ResistanceParameters, PIMM_procedure\n\nrp = ResistanceParameters(Rxx0=100,\n                          Rxy0=1,\n                          Rsmr=-0.46,\n                          Rahe=-2.7,\n                          Ramr=-0.24,\n                          l=30,\n                          w=20)\n\n# approximate demagnetisation tensor\ndemag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)]\nalpha = 0.005\nKdir = CVector(1, 0, 0)\nMs = 1.65\nl1 = Layer(\"free\",\n           mag=CVector(0, 0, 1),\n           anis=Kdir,\n           Ms=Ms,\n           thickness=3.99e-9,\n           cellSurface=0,\n           demagTensor=demag,\n           damping=alpha)\n\nl2 = Layer(\"bottom\",\n           mag=CVector(0, 0, 1),\n           anis=Kdir,\n           Ms=Ms,\n           thickness=4e-9,\n           cellSurface=0,\n           demagTensor=demag,\n           damping=alpha)\nJ1 = -1.78e-3\nJ2 = -1.69e-4\n\nK1 = K2 = 1.05e3\nint_step = 4e-14\n\nj1 = Junction([l1, l2], 100, 102)\n\nj1.setLayerAnisotropyDriver(\"all\", ScalarDriver.getConstantDriver(K1))\nj1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J1))\nj1.setQuadIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J2))\nHscan, Hvecs = FieldScan.amplitude_scan(-1200e3, 1200e3, 200, 89, 90)\n\nspectrum, freqs, output = PIMM_procedure(j1,\n                                         Hvecs=Hvecs,\n                                         int_step=int_step,\n                                         resistance_params=[rp, rp],\n                                         max_frequency=60e9)\nwith plt.style.context(['science', 'nature']):\n    fig, ax = plt.subplots(dpi=300)\n    ax.pcolor(Hscan / 1e3,\n              freqs / 1e9,\n              np.log10(np.squeeze(spectrum.T)),\n              shading='auto',\n              cmap='viridis')\n    ax.set_xlabel(\"Field [A/m]\")\n    ax.set_ylabel(\"Frequency [GHz]\")\n</pre> import matplotlib.pyplot as plt from cmtj.utils.linear import FieldScan from cmtj.utils.procedures import ResistanceParameters, PIMM_procedure  rp = ResistanceParameters(Rxx0=100,                           Rxy0=1,                           Rsmr=-0.46,                           Rahe=-2.7,                           Ramr=-0.24,                           l=30,                           w=20)  # approximate demagnetisation tensor demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)] alpha = 0.005 Kdir = CVector(1, 0, 0) Ms = 1.65 l1 = Layer(\"free\",            mag=CVector(0, 0, 1),            anis=Kdir,            Ms=Ms,            thickness=3.99e-9,            cellSurface=0,            demagTensor=demag,            damping=alpha)  l2 = Layer(\"bottom\",            mag=CVector(0, 0, 1),            anis=Kdir,            Ms=Ms,            thickness=4e-9,            cellSurface=0,            demagTensor=demag,            damping=alpha) J1 = -1.78e-3 J2 = -1.69e-4  K1 = K2 = 1.05e3 int_step = 4e-14  j1 = Junction([l1, l2], 100, 102)  j1.setLayerAnisotropyDriver(\"all\", ScalarDriver.getConstantDriver(K1)) j1.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J1)) j1.setQuadIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(J2)) Hscan, Hvecs = FieldScan.amplitude_scan(-1200e3, 1200e3, 200, 89, 90)  spectrum, freqs, output = PIMM_procedure(j1,                                          Hvecs=Hvecs,                                          int_step=int_step,                                          resistance_params=[rp, rp],                                          max_frequency=60e9) with plt.style.context(['science', 'nature']):     fig, ax = plt.subplots(dpi=300)     ax.pcolor(Hscan / 1e3,               freqs / 1e9,               np.log10(np.squeeze(spectrum.T)),               shading='auto',               cmap='viridis')     ax.set_xlabel(\"Field [A/m]\")     ax.set_ylabel(\"Frequency [GHz]\") <pre>Computing PIMM: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 200/200 [00:27&lt;00:00,  7.38it/s]\n</pre> In\u00a0[6]: Copied! <pre>from typing import List, Dict\nfrom cmtj.utils.plotting import get_sphere\nx, y, z = get_sphere()\n\ndef plot_trajectories(log: Dict[str, List[float]], title: str):\n    with plt.style.context(['science', 'nature']):\n        fig = plt.figure(figsize=(4, 3), dpi=250)\n        ax = fig.add_subplot(1, 2, 1, projection='3d')\n        m = np.asarray([log[f'free_mx'], log[f'free_my'], log[f'free_mz']])\n        ax.plot3D(m[0], m[1], m[2], color='blue')\n        ax.set_axis_off()\n        ax.plot_surface(x,\n                        y,\n                        z,\n                        rstride=2,\n                        cstride=2,\n                        color='c',\n                        alpha=0.3,\n                        linewidth=0.1)\n        ax.scatter([0], [0], [1], color='crimson', alpha=1.0, s=50)\n        ax2 = fig.add_subplot(1, 2, 2)\n        ax2.plot(log['time'], log['R_free_bottom'])\n        ax2.set_xlabel(\"Time [s]\")\n        ax2.set_ylabel(\"Resistance [Ohm]\")\n        fig.suptitle(title)\n        fig.tight_layout()\n</pre> from typing import List, Dict from cmtj.utils.plotting import get_sphere x, y, z = get_sphere()  def plot_trajectories(log: Dict[str, List[float]], title: str):     with plt.style.context(['science', 'nature']):         fig = plt.figure(figsize=(4, 3), dpi=250)         ax = fig.add_subplot(1, 2, 1, projection='3d')         m = np.asarray([log[f'free_mx'], log[f'free_my'], log[f'free_mz']])         ax.plot3D(m[0], m[1], m[2], color='blue')         ax.set_axis_off()         ax.plot_surface(x,                         y,                         z,                         rstride=2,                         cstride=2,                         color='c',                         alpha=0.3,                         linewidth=0.1)         ax.scatter([0], [0], [1], color='crimson', alpha=1.0, s=50)         ax2 = fig.add_subplot(1, 2, 2)         ax2.plot(log['time'], log['R_free_bottom'])         ax2.set_xlabel(\"Time [s]\")         ax2.set_ylabel(\"Resistance [Ohm]\")         fig.suptitle(title)         fig.tight_layout() In\u00a0[7]: Copied! <pre>demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.0)]\n\ndamping = 0.3\ncurrentDensity = 5e10\nbeta = 1\nspinPolarisation = 1.0\n\nl1 = Layer.createSTTLayer(id=\"free\",\n                          mag=CVector(0., 0., 1.),\n                          anis=CVector(0, 0., 1.),\n                          Ms=1.,\n                          thickness=1.4e-9,\n                          cellSurface=7e-10 * 7e-10,\n                          demagTensor=demagTensor,\n                          damping=damping,\n                          SlonczewskiSpacerLayerParameter=1.0,\n                          spinPolarisation=spinPolarisation,\n                          beta=beta)\nl2 = Layer(id=\"bottom\",\n           mag=CVector(0., 1., 1.),\n           anis=CVector(0, 1., 1.),\n           Ms=1.2,\n           thickness=3e-9,\n           cellSurface=7e-10 * 7e-10,\n           demagTensor=demagTensor)\n\nl1.setReferenceLayer(CVector(0, 1., 1.))\njunction = Junction([l1, l2], 100, 200)\n\njunction.setLayerAnisotropyDriver(\"free\",\n                                  ScalarDriver.getConstantDriver(300e3))\njunction.setLayerAnisotropyDriver(\"bottom\",\n                                  ScalarDriver.getConstantDriver(1500e3))\njunction.setIECDriver(\"free\", \"bottom\",\n                      ScalarDriver.getConstantDriver(-2.5e-6))\n# current driver\njunction.setLayerCurrentDriver(\"free\",\n                               ScalarDriver.getConstantDriver(currentDensity))\n\njunction.runSimulation(20e-9, 1e-12, 1e-12, True, False)\nlog = junction.getLog()\nplot_trajectories(log, title=\"STO with STT on\")\n</pre> demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.0)]  damping = 0.3 currentDensity = 5e10 beta = 1 spinPolarisation = 1.0  l1 = Layer.createSTTLayer(id=\"free\",                           mag=CVector(0., 0., 1.),                           anis=CVector(0, 0., 1.),                           Ms=1.,                           thickness=1.4e-9,                           cellSurface=7e-10 * 7e-10,                           demagTensor=demagTensor,                           damping=damping,                           SlonczewskiSpacerLayerParameter=1.0,                           spinPolarisation=spinPolarisation,                           beta=beta) l2 = Layer(id=\"bottom\",            mag=CVector(0., 1., 1.),            anis=CVector(0, 1., 1.),            Ms=1.2,            thickness=3e-9,            cellSurface=7e-10 * 7e-10,            demagTensor=demagTensor)  l1.setReferenceLayer(CVector(0, 1., 1.)) junction = Junction([l1, l2], 100, 200)  junction.setLayerAnisotropyDriver(\"free\",                                   ScalarDriver.getConstantDriver(300e3)) junction.setLayerAnisotropyDriver(\"bottom\",                                   ScalarDriver.getConstantDriver(1500e3)) junction.setIECDriver(\"free\", \"bottom\",                       ScalarDriver.getConstantDriver(-2.5e-6)) # current driver junction.setLayerCurrentDriver(\"free\",                                ScalarDriver.getConstantDriver(currentDensity))  junction.runSimulation(20e-9, 1e-12, 1e-12, True, False) log = junction.getLog() plot_trajectories(log, title=\"STO with STT on\") <pre>Steps in simulation: 20000\nWrite every: 1\nSimulation time = 0[s]\n</pre> <p>We will also run the same simulation but with the STT turned off, to see if the spin polarised current flow actually helps to sustain the oscillations. We see that the magnetisation stays still -- as becomes evident in the 3D plot -- we can only see a single dot.</p> In\u00a0[8]: Copied! <pre>l1 = Layer(id=\"free\",\n           mag=CVector(0., 0., -1.),\n           anis=CVector(0, 0., 1.),\n           Ms=1.2,\n           thickness=1.4e-9,\n           cellSurface=7e-10 * 7e-10,\n           demagTensor=demagTensor)\nl2 = Layer(id=\"bottom\",\n           mag=CVector(0., 1., 1.),\n           anis=CVector(0, 1., 1.),\n           Ms=1.2,\n           thickness=3e-9,\n           cellSurface=7e-10 * 7e-10,\n           demagTensor=demagTensor)\n\njunction = Junction([l1, l2], 100, 200)\njunction.setLayerAnisotropyDriver(\"free\",\n                                  ScalarDriver.getConstantDriver(800e3))\njunction.setLayerAnisotropyDriver(\"bottom\",\n                                  ScalarDriver.getConstantDriver(1500e3))\njunction.setIECDriver(\"free\", \"bottom\",\n                      ScalarDriver.getConstantDriver(-2.5e-6))\n# current driver\njunction.setLayerCurrentDriver(\"free\",\n                               ScalarDriver.getConstantDriver(currentDensity))\njunction.runSimulation(20e-9, 1e-12, 1e-12, True, False)\nlog = junction.getLog()\nplot_trajectories(log, title=\"Setup with STT off\")\n</pre> l1 = Layer(id=\"free\",            mag=CVector(0., 0., -1.),            anis=CVector(0, 0., 1.),            Ms=1.2,            thickness=1.4e-9,            cellSurface=7e-10 * 7e-10,            demagTensor=demagTensor) l2 = Layer(id=\"bottom\",            mag=CVector(0., 1., 1.),            anis=CVector(0, 1., 1.),            Ms=1.2,            thickness=3e-9,            cellSurface=7e-10 * 7e-10,            demagTensor=demagTensor)  junction = Junction([l1, l2], 100, 200) junction.setLayerAnisotropyDriver(\"free\",                                   ScalarDriver.getConstantDriver(800e3)) junction.setLayerAnisotropyDriver(\"bottom\",                                   ScalarDriver.getConstantDriver(1500e3)) junction.setIECDriver(\"free\", \"bottom\",                       ScalarDriver.getConstantDriver(-2.5e-6)) # current driver junction.setLayerCurrentDriver(\"free\",                                ScalarDriver.getConstantDriver(currentDensity)) junction.runSimulation(20e-9, 1e-12, 1e-12, True, False) log = junction.getLog() plot_trajectories(log, title=\"Setup with STT off\") <pre>Steps in simulation: 20000\nWrite every: 1\nSimulation time = 0[s]\n</pre>"},{"location":"tutorials/CMTJBindingsTutorial/#library-introduction","title":"Library introduction\u00b6","text":"<p>This notebook is a walkthorugh the basic concepts in the PyMTJ library and covers the basics of using the C++ bindings in Python. In the first section, we will run the basic voltage spin diode experiment using the IEC (Interlayer Exchange Coupling) excitation. In the second section, we are going to construct the Spin Torque Oscillator (STO) using the STT (Slonczewski Spin Torque) addition to our LLG equations. STO is able to sustain the magnetisation precession for a prolonged period of time, since the spin-polarised current flowing through the junction compensates the energy losses from the Gilbert's damping contribution.</p>"},{"location":"tutorials/CMTJBindingsTutorial/#voltage-spin-diode-effect","title":"Voltage Spin Diode effect\u00b6","text":"<p>As we have defined the Junction, we now proceed to running the Voltage Spin Diode experiment.</p> <p>To perform the VSD the external magnetic field is swept in some range, in this case we picked 30 points in range from 0 to 600 mT. For each field point we solve the LLG under the specific excitation and frequency.</p> <p>In this example we will be exciting the system with its resonant frequency which is given a priori but you may find it with the FFT analysis included in the PyMTJ package as well. We skipped that part for clarity. For each of the points we will calculate the constant voltage (Vmix, the diode voltage) arising from the interaction between the sinusoidal current flowing throught the MTJ (of 0 phase and frequency equal to that of the resonant frequency) and also oscillating magnetoresistance, which in turn is invoked by the oscillating magnetisation in response to the effective field contributions.</p> <p>Other parameters were fixed so that we get a nice result, but feel free to tinker with the options and see what happens.</p>"},{"location":"tutorials/CMTJBindingsTutorial/#convenience-procedure","title":"Convenience procedure\u00b6","text":"<p>You can also use the functions provided in the <code>cmtj.utils.procedures</code> package to perform the VSD experiment. The function <code>VSD_procedure</code> takes the junction, the field range, the frequency and the number of points in the field range as arguments. It returns the field and the Vmix values. Another procedure -- PIMM, illustrated below -- is the one that performs the PIMM experiment. It takes the junction, the field range, and resistance parameter object as an input.</p> <p>In that way, you don't have to write PIMM or VSD procedures each time yourself.</p>"},{"location":"tutorials/CMTJBindingsTutorial/#stt","title":"STT\u00b6","text":"<p>We may now transition to simulating Spin Torque Oscillators. As mentioned before, these are called the oscillators because they can sustain the oscillating magnetisation.</p> <p>This experiment is much simpler than the previous one. Like before, we will set up our layers, but this time, we will enable the STT contributions and we will invoke the critical current densities.</p> <p>Note, we turn the STT in the free layer, which has now the magnetisation in the -z direction. Additionally, we lower the free layer anisotropy and we turn off the coupling (for simplicity).</p> <p>We also slightly tilt the bottom layer's magnetisation in order to invoke the torque on the spin torque.</p>"},{"location":"tutorials/SBModel/","title":"Smit-Beljers model for ferromagnetic resonance","text":"In\u00a0[1]: Copied! <pre>import numpy as np\n\nfrom collections import defaultdict\nfrom cmtj.models import LayerSB, VectorObj, Solver\nfrom cmtj.utils import mu0\nfrom tqdm import tqdm\n\nMs1 = (\n    1.0 / mu0\n)  # here we pass the saturation magnetisation in A/m, but in the dynamic model we use T!\nMs2 = 1.2 / mu0\nlayerA = LayerSB(\n    _id=0,\n    thickness=1e-9,\n    Kv=VectorObj(\n        np.deg2rad(0.0), np.deg2rad(0), 1e1\n    ),  # for the Kv only phi angle counts !\n    Ks=3e4,\n    Ms=Ms1,\n)\nlayerB = LayerSB(\n    _id=1,\n    thickness=1.3e-9,\n    Kv=VectorObj(np.deg2rad(0.0), np.deg2rad(0), 1e4),\n    Ks=1e1,\n    Ms=Ms2,\n)\n\n# we indicate the \"guess\" of the initial position\n# it's generally good to align it with the field, but it's not necessary\ncurrent_position = [np.deg2rad(89), np.deg2rad(0.1), np.deg2rad(180), np.deg2rad(0.1)]\nHspace = np.linspace(-400e3, 400e3, 50)\nresult_dictionary = defaultdict(list)\n# we perform a sweep over the field magnitude\nfor Hmag in tqdm(Hspace):\n    solver = Solver(\n        layers=[layerA, layerB],\n        J1=[1e-4],\n        J2=[0.0],\n        H=VectorObj(np.deg2rad(89), np.deg2rad(0.1), Hmag),\n    )\n    # check for additional parameters in the solver\n    # such as gradient convergence tolerance, max iterations, etc.\n    # also in the solver there are root finding parameters\n    (t1, p1, t2, p2), frequencies = solver.solve(\n        init_position=current_position,\n        perturbation=0,\n    )\n    # frequencies are already in GHz\n    for frequency in frequencies:\n        result_dictionary[\"frequency\"].append(frequency)\n        result_dictionary[\"Hmag\"].append(Hmag)\n\n    # we note the final position of the magnetisation in spherical coordinates\n    result_dictionary[\"theta_1\"].append(t1)\n    result_dictionary[\"phi_1\"].append(p1)\n    result_dictionary[\"theta_2\"].append(t2)\n    result_dictionary[\"phi_2\"].append(p2)\n    # we reuse the previous solution as the initial guess for the next iteration\n    current_position = [t1, p1, t2, p2]\n</pre> import numpy as np  from collections import defaultdict from cmtj.models import LayerSB, VectorObj, Solver from cmtj.utils import mu0 from tqdm import tqdm  Ms1 = (     1.0 / mu0 )  # here we pass the saturation magnetisation in A/m, but in the dynamic model we use T! Ms2 = 1.2 / mu0 layerA = LayerSB(     _id=0,     thickness=1e-9,     Kv=VectorObj(         np.deg2rad(0.0), np.deg2rad(0), 1e1     ),  # for the Kv only phi angle counts !     Ks=3e4,     Ms=Ms1, ) layerB = LayerSB(     _id=1,     thickness=1.3e-9,     Kv=VectorObj(np.deg2rad(0.0), np.deg2rad(0), 1e4),     Ks=1e1,     Ms=Ms2, )  # we indicate the \"guess\" of the initial position # it's generally good to align it with the field, but it's not necessary current_position = [np.deg2rad(89), np.deg2rad(0.1), np.deg2rad(180), np.deg2rad(0.1)] Hspace = np.linspace(-400e3, 400e3, 50) result_dictionary = defaultdict(list) # we perform a sweep over the field magnitude for Hmag in tqdm(Hspace):     solver = Solver(         layers=[layerA, layerB],         J1=[1e-4],         J2=[0.0],         H=VectorObj(np.deg2rad(89), np.deg2rad(0.1), Hmag),     )     # check for additional parameters in the solver     # such as gradient convergence tolerance, max iterations, etc.     # also in the solver there are root finding parameters     (t1, p1, t2, p2), frequencies = solver.solve(         init_position=current_position,         perturbation=0,     )     # frequencies are already in GHz     for frequency in frequencies:         result_dictionary[\"frequency\"].append(frequency)         result_dictionary[\"Hmag\"].append(Hmag)      # we note the final position of the magnetisation in spherical coordinates     result_dictionary[\"theta_1\"].append(t1)     result_dictionary[\"phi_1\"].append(p1)     result_dictionary[\"theta_2\"].append(t2)     result_dictionary[\"phi_2\"].append(p2)     # we reuse the previous solution as the initial guess for the next iteration     current_position = [t1, p1, t2, p2] <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 50/50 [00:25&lt;00:00,  1.93it/s]\n</pre> In\u00a0[2]: Copied! <pre>import matplotlib.pyplot as plt\n\nwith plt.style.context([\"science\", \"nature\"]):\n    w, h = plt.figaspect(0.5)\n    fig, (ax1, ax2) = plt.subplots(1, 2, dpi=200, figsize=(w, h))\n    Hvals = np.asarray(result_dictionary[\"Hmag\"]) / 1e3\n    ax1.plot(\n        Hvals,\n        result_dictionary[\"frequency\"],\n        \"ro\",\n        label=\"frequency\",\n    )\n    ax1.set_xlabel(\"H (kA/m)\")\n    ax1.set_ylabel(\"f (GHz)\")\n\n    ax2.plot(\n        Hspace / 1e3,\n        np.rad2deg(result_dictionary[\"phi_1\"]),\n        color=\"forestgreen\",\n        label=r\"$\\phi_1$\",\n    )\n    ax2.plot(\n        Hspace / 1e3,\n        np.rad2deg(result_dictionary[\"theta_1\"]),\n        color=\"navy\",\n        label=r\"$\\theta_1$\",\n    )\n\n    ax2.plot(\n        Hspace / 1e3,\n        np.rad2deg(result_dictionary[\"phi_2\"]),\n        color=\"forestgreen\",\n        label=r\"$\\phi_2$\",\n        marker=\"o\",\n        markersize=1,\n    )\n    ax2.plot(\n        Hspace / 1e3,\n        np.rad2deg(result_dictionary[\"theta_2\"]),\n        color=\"navy\",\n        label=r\"$\\theta_2$\",\n        marker=\"o\",\n        markersize=1,\n    )\n    ax2.legend()\n    ax2.set_xlabel(\"H (kA/m)\")\n    ax2.set_ylabel(\"angle (deg)\")\n    fig.tight_layout()\nfig\n</pre> import matplotlib.pyplot as plt  with plt.style.context([\"science\", \"nature\"]):     w, h = plt.figaspect(0.5)     fig, (ax1, ax2) = plt.subplots(1, 2, dpi=200, figsize=(w, h))     Hvals = np.asarray(result_dictionary[\"Hmag\"]) / 1e3     ax1.plot(         Hvals,         result_dictionary[\"frequency\"],         \"ro\",         label=\"frequency\",     )     ax1.set_xlabel(\"H (kA/m)\")     ax1.set_ylabel(\"f (GHz)\")      ax2.plot(         Hspace / 1e3,         np.rad2deg(result_dictionary[\"phi_1\"]),         color=\"forestgreen\",         label=r\"$\\phi_1$\",     )     ax2.plot(         Hspace / 1e3,         np.rad2deg(result_dictionary[\"theta_1\"]),         color=\"navy\",         label=r\"$\\theta_1$\",     )      ax2.plot(         Hspace / 1e3,         np.rad2deg(result_dictionary[\"phi_2\"]),         color=\"forestgreen\",         label=r\"$\\phi_2$\",         marker=\"o\",         markersize=1,     )     ax2.plot(         Hspace / 1e3,         np.rad2deg(result_dictionary[\"theta_2\"]),         color=\"navy\",         label=r\"$\\theta_2$\",         marker=\"o\",         markersize=1,     )     ax2.legend()     ax2.set_xlabel(\"H (kA/m)\")     ax2.set_ylabel(\"angle (deg)\")     fig.tight_layout() fig Out[2]: In\u00a0[3]: Copied! <pre>import numpy as np\n\nfrom collections import defaultdict\nfrom cmtj.models import LayerDynamic, VectorObj, Solver\nfrom cmtj.utils import mu0\nfrom tqdm import tqdm\n\nMs1 = (\n    1.0 / mu0\n)  # here we pass the saturation magnetisation in A/m, but in the dynamic model we use T!\nMs2 = 1.2 / mu0\nalpha = 1e-3\nlayerA = LayerDynamic(\n    _id=0,\n    thickness=1e-9,\n    Kv=VectorObj(\n        np.deg2rad(0.0), np.deg2rad(0), 1e1\n    ),  # for the Kv only phi angle counts !\n    Ks=3e4,\n    Ms=Ms1,\n    alpha=alpha,\n)\nlayerB = LayerDynamic(\n    _id=1,\n    thickness=1.3e-9,\n    Kv=VectorObj(np.deg2rad(0.0), np.deg2rad(0), 1e4),\n    Ks=1e1,\n    Ms=Ms2,\n    alpha=alpha,\n)\n\n# we indicate the \"guess\" of the initial position\n# it's generally good to align it with the field, but it's not necessary\ncurrent_position = [np.deg2rad(89), np.deg2rad(0.1), np.deg2rad(180), np.deg2rad(0.1)]\nHspace = np.linspace(-400e3, 400e3, 50)\nresult_dictionary_dynamic = defaultdict(list)\n# we perform a sweep over the field magnitude\nfor Hmag in tqdm(Hspace):\n    solver = Solver(\n        layers=[layerA, layerB],\n        J1=[1e-4],\n        J2=[0.0],\n        H=VectorObj(np.deg2rad(89), np.deg2rad(0.1), Hmag),\n    )\n    # check for additional parameters in the solver\n    # such as gradient convergence tolerance, max iterations, etc.\n    # also in the solver there are root finding parameters\n    # the last param here is an eigenvector\n    (t1, p1, t2, p2), frequencies, _ = solver.solve(init_position=current_position)\n    # frequencies are already in GHz\n    for frequency in frequencies:\n        result_dictionary_dynamic[\"frequency\"].append(frequency)\n        result_dictionary_dynamic[\"Hmag\"].append(Hmag)\n\n    # we note the final position of the magnetisation in spherical coordinates\n    result_dictionary_dynamic[\"theta_1\"].append(t1)\n    result_dictionary_dynamic[\"phi_1\"].append(p1)\n    result_dictionary_dynamic[\"theta_2\"].append(t2)\n    result_dictionary_dynamic[\"phi_2\"].append(p2)\n    # we reuse the previous solution as the initial guess for the next iteration\n    current_position = [t1, p1, t2, p2]\n</pre> import numpy as np  from collections import defaultdict from cmtj.models import LayerDynamic, VectorObj, Solver from cmtj.utils import mu0 from tqdm import tqdm  Ms1 = (     1.0 / mu0 )  # here we pass the saturation magnetisation in A/m, but in the dynamic model we use T! Ms2 = 1.2 / mu0 alpha = 1e-3 layerA = LayerDynamic(     _id=0,     thickness=1e-9,     Kv=VectorObj(         np.deg2rad(0.0), np.deg2rad(0), 1e1     ),  # for the Kv only phi angle counts !     Ks=3e4,     Ms=Ms1,     alpha=alpha, ) layerB = LayerDynamic(     _id=1,     thickness=1.3e-9,     Kv=VectorObj(np.deg2rad(0.0), np.deg2rad(0), 1e4),     Ks=1e1,     Ms=Ms2,     alpha=alpha, )  # we indicate the \"guess\" of the initial position # it's generally good to align it with the field, but it's not necessary current_position = [np.deg2rad(89), np.deg2rad(0.1), np.deg2rad(180), np.deg2rad(0.1)] Hspace = np.linspace(-400e3, 400e3, 50) result_dictionary_dynamic = defaultdict(list) # we perform a sweep over the field magnitude for Hmag in tqdm(Hspace):     solver = Solver(         layers=[layerA, layerB],         J1=[1e-4],         J2=[0.0],         H=VectorObj(np.deg2rad(89), np.deg2rad(0.1), Hmag),     )     # check for additional parameters in the solver     # such as gradient convergence tolerance, max iterations, etc.     # also in the solver there are root finding parameters     # the last param here is an eigenvector     (t1, p1, t2, p2), frequencies, _ = solver.solve(init_position=current_position)     # frequencies are already in GHz     for frequency in frequencies:         result_dictionary_dynamic[\"frequency\"].append(frequency)         result_dictionary_dynamic[\"Hmag\"].append(Hmag)      # we note the final position of the magnetisation in spherical coordinates     result_dictionary_dynamic[\"theta_1\"].append(t1)     result_dictionary_dynamic[\"phi_1\"].append(p1)     result_dictionary_dynamic[\"theta_2\"].append(t2)     result_dictionary_dynamic[\"phi_2\"].append(p2)     # we reuse the previous solution as the initial guess for the next iteration     current_position = [t1, p1, t2, p2] <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 50/50 [00:19&lt;00:00,  2.54it/s]\n</pre> <p>You see that we get the same result in the end -- even though the dynamic method seems to be a bit faster! There can be still some differences in the results due to the differences in the solver, let us know if and when that happens!</p> In\u00a0[4]: Copied! <pre>import matplotlib.pyplot as plt\n\nwith plt.style.context([\"science\", \"nature\"]):\n    w, h = plt.figaspect(0.5)\n    fig, (ax1, ax2) = plt.subplots(1, 2, dpi=200, figsize=(w, h))\n    Hvals = np.asarray(result_dictionary_dynamic[\"Hmag\"]) / 1e3\n    ax1.plot(\n        Hvals,\n        result_dictionary_dynamic[\"frequency\"],\n        \"bo\",\n        label=\"dynamic\",\n    )\n    ax1.plot(\n        Hvals,\n        result_dictionary[\"frequency\"],\n        \"ro\",\n        markersize=0.9,\n        label=\"classical\",\n    )\n    ax1.set_xlabel(\"H (kA/m)\")\n    ax1.set_ylabel(\"f (GHz)\")\n\n    ax2.plot(\n        Hspace / 1e3,\n        np.rad2deg(result_dictionary_dynamic[\"phi_1\"]),\n        color=\"forestgreen\",\n        label=r\"$\\phi_1$\",\n    )\n    ax2.plot(\n        Hspace / 1e3,\n        np.rad2deg(result_dictionary_dynamic[\"theta_1\"]),\n        color=\"navy\",\n        label=r\"$\\theta_1$\",\n    )\n\n    ax2.plot(\n        Hspace / 1e3,\n        np.rad2deg(result_dictionary_dynamic[\"phi_2\"]),\n        color=\"forestgreen\",\n        label=r\"$\\phi_2$\",\n        marker=\"o\",\n        markersize=1,\n    )\n    ax2.plot(\n        Hspace / 1e3,\n        np.rad2deg(result_dictionary_dynamic[\"theta_2\"]),\n        color=\"navy\",\n        label=r\"$\\theta_2$\",\n        marker=\"o\",\n        markersize=1,\n    )\n    ax1.legend()\n    ax2.legend()\n    ax2.set_xlabel(\"H (kA/m)\")\n    ax2.set_ylabel(\"angle (deg)\")\n    fig.tight_layout()\n</pre> import matplotlib.pyplot as plt  with plt.style.context([\"science\", \"nature\"]):     w, h = plt.figaspect(0.5)     fig, (ax1, ax2) = plt.subplots(1, 2, dpi=200, figsize=(w, h))     Hvals = np.asarray(result_dictionary_dynamic[\"Hmag\"]) / 1e3     ax1.plot(         Hvals,         result_dictionary_dynamic[\"frequency\"],         \"bo\",         label=\"dynamic\",     )     ax1.plot(         Hvals,         result_dictionary[\"frequency\"],         \"ro\",         markersize=0.9,         label=\"classical\",     )     ax1.set_xlabel(\"H (kA/m)\")     ax1.set_ylabel(\"f (GHz)\")      ax2.plot(         Hspace / 1e3,         np.rad2deg(result_dictionary_dynamic[\"phi_1\"]),         color=\"forestgreen\",         label=r\"$\\phi_1$\",     )     ax2.plot(         Hspace / 1e3,         np.rad2deg(result_dictionary_dynamic[\"theta_1\"]),         color=\"navy\",         label=r\"$\\theta_1$\",     )      ax2.plot(         Hspace / 1e3,         np.rad2deg(result_dictionary_dynamic[\"phi_2\"]),         color=\"forestgreen\",         label=r\"$\\phi_2$\",         marker=\"o\",         markersize=1,     )     ax2.plot(         Hspace / 1e3,         np.rad2deg(result_dictionary_dynamic[\"theta_2\"]),         color=\"navy\",         label=r\"$\\theta_2$\",         marker=\"o\",         markersize=1,     )     ax1.legend()     ax2.legend()     ax2.set_xlabel(\"H (kA/m)\")     ax2.set_ylabel(\"angle (deg)\")     fig.tight_layout() In\u00a0[5]: Copied! <pre>import numpy as np\n\nfrom collections import defaultdict\nfrom cmtj.models import VectorObj, Solver\nfrom cmtj.utils import mu0\nfrom tqdm import tqdm\n\n\ndef compose_dipole_tensor(V, pos, other):\n    r = np.asarray(pos) - np.asarray(other)  # vector from other to pos\n    dr = np.linalg.norm(r)  # euclidean distance\n    norm = V / (4 * np.pi * dr**5)  # normalization factor\n    return [\n        norm\n        * VectorObj.from_cartesian(\n            3 * r[0] ** 2 - dr**2, 3 * r[0] * r[1], 3 * r[0] * r[2]\n        ),\n        norm\n        * VectorObj.from_cartesian(\n            3 * r[0] * r[1], 3 * r[1] ** 2 - dr**2, 3 * r[1] * r[2]\n        ),\n        norm\n        * VectorObj.from_cartesian(\n            3 * r[0] * r[2], 3 * r[1] * r[2], 3 * r[2] ** 2 - dr**2\n        ),\n    ]\n\n\nMs1 = (\n    1.0 / mu0\n)  # here we pass the saturation magnetisation in A/m, but in the dynamic model we use T!\nMs2 = 1.2 / mu0\nalpha = 1e-3\nlayerA = LayerSB(\n    _id=0,\n    thickness=1e-9,\n    Kv=VectorObj(\n        np.deg2rad(0.0), np.deg2rad(0), 1e1\n    ),  # for the Kv only phi angle counts !\n    Ks=3e4,\n    Ms=Ms1,\n)\nlayerB = LayerSB(\n    _id=1,\n    thickness=1.3e-9,\n    Kv=VectorObj(np.deg2rad(0.0), np.deg2rad(0), 1e4),\n    Ks=1e1,\n    Ms=Ms2,\n)\n\n# we indicate the \"guess\" of the initial position\n# it's generally good to align it with the field, but it's not necessary\ncurrent_position = [np.deg2rad(89), np.deg2rad(0.1), np.deg2rad(180), np.deg2rad(0.1)]\nHspace = np.linspace(-400e3, 400e3, 30)\nresult_dict_dipole = defaultdict(list)\n# we perform a sweep over the field magnitude\nr = 300e-9\nsurf = r**2 * np.pi\n\ndipoleA = compose_dipole_tensor(surf * 1e-9, [0, 0, 0], [100e-9, 0, 0])\nfor Hmag in tqdm(Hspace):\n    solver = Solver(\n        layers=[layerA, layerB],\n        J1=[1e-4],\n        J2=[0.0],\n        H=VectorObj(np.deg2rad(89), np.deg2rad(0.1), Hmag),\n        Ndipole=[dipoleA],\n    )\n    # check for additional parameters in the solver\n    # such as gradient convergence tolerance, max iterations, etc.\n    # also in the solver there are root finding parameters\n    # the last param here is an eigenvector\n    (t1, p1, t2, p2), frequencies = solver.solve(init_position=current_position)\n    # frequencies are already in GHz\n    for frequency in frequencies:\n        result_dict_dipole[\"frequency\"].append(frequency)\n        result_dict_dipole[\"Hmag\"].append(Hmag)\n\n    # we note the final position of the magnetisation in spherical coordinates\n    result_dict_dipole[\"theta_1\"].append(t1)\n    result_dict_dipole[\"phi_1\"].append(p1)\n    result_dict_dipole[\"theta_2\"].append(t2)\n    result_dict_dipole[\"phi_2\"].append(p2)\n    # we reuse the previous solution as the initial guess for the next iteration\n    current_position = [t1, p1, t2, p2]\n</pre> import numpy as np  from collections import defaultdict from cmtj.models import VectorObj, Solver from cmtj.utils import mu0 from tqdm import tqdm   def compose_dipole_tensor(V, pos, other):     r = np.asarray(pos) - np.asarray(other)  # vector from other to pos     dr = np.linalg.norm(r)  # euclidean distance     norm = V / (4 * np.pi * dr**5)  # normalization factor     return [         norm         * VectorObj.from_cartesian(             3 * r[0] ** 2 - dr**2, 3 * r[0] * r[1], 3 * r[0] * r[2]         ),         norm         * VectorObj.from_cartesian(             3 * r[0] * r[1], 3 * r[1] ** 2 - dr**2, 3 * r[1] * r[2]         ),         norm         * VectorObj.from_cartesian(             3 * r[0] * r[2], 3 * r[1] * r[2], 3 * r[2] ** 2 - dr**2         ),     ]   Ms1 = (     1.0 / mu0 )  # here we pass the saturation magnetisation in A/m, but in the dynamic model we use T! Ms2 = 1.2 / mu0 alpha = 1e-3 layerA = LayerSB(     _id=0,     thickness=1e-9,     Kv=VectorObj(         np.deg2rad(0.0), np.deg2rad(0), 1e1     ),  # for the Kv only phi angle counts !     Ks=3e4,     Ms=Ms1, ) layerB = LayerSB(     _id=1,     thickness=1.3e-9,     Kv=VectorObj(np.deg2rad(0.0), np.deg2rad(0), 1e4),     Ks=1e1,     Ms=Ms2, )  # we indicate the \"guess\" of the initial position # it's generally good to align it with the field, but it's not necessary current_position = [np.deg2rad(89), np.deg2rad(0.1), np.deg2rad(180), np.deg2rad(0.1)] Hspace = np.linspace(-400e3, 400e3, 30) result_dict_dipole = defaultdict(list) # we perform a sweep over the field magnitude r = 300e-9 surf = r**2 * np.pi  dipoleA = compose_dipole_tensor(surf * 1e-9, [0, 0, 0], [100e-9, 0, 0]) for Hmag in tqdm(Hspace):     solver = Solver(         layers=[layerA, layerB],         J1=[1e-4],         J2=[0.0],         H=VectorObj(np.deg2rad(89), np.deg2rad(0.1), Hmag),         Ndipole=[dipoleA],     )     # check for additional parameters in the solver     # such as gradient convergence tolerance, max iterations, etc.     # also in the solver there are root finding parameters     # the last param here is an eigenvector     (t1, p1, t2, p2), frequencies = solver.solve(init_position=current_position)     # frequencies are already in GHz     for frequency in frequencies:         result_dict_dipole[\"frequency\"].append(frequency)         result_dict_dipole[\"Hmag\"].append(Hmag)      # we note the final position of the magnetisation in spherical coordinates     result_dict_dipole[\"theta_1\"].append(t1)     result_dict_dipole[\"phi_1\"].append(p1)     result_dict_dipole[\"theta_2\"].append(t2)     result_dict_dipole[\"phi_2\"].append(p2)     # we reuse the previous solution as the initial guess for the next iteration     current_position = [t1, p1, t2, p2] <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [00:21&lt;00:00,  1.37it/s]\n</pre> In\u00a0[6]: Copied! <pre>import matplotlib.pyplot as plt\n\nwith plt.style.context([\"science\", \"nature\"]):\n    w, h = plt.figaspect(0.5)\n    fig, (ax1, ax2) = plt.subplots(1, 2, dpi=200, figsize=(w, h))\n    ax1.plot(\n        np.asarray(result_dict_dipole[\"Hmag\"]) / 1e3,\n        result_dict_dipole[\"frequency\"],\n        \"bo\",\n        label=\"classical+dipole\",\n    )\n    ax1.plot(\n        np.asarray(result_dictionary[\"Hmag\"]) / 1e3,\n        result_dictionary[\"frequency\"],\n        \"ro\",\n        markersize=0.9,\n        label=\"classical\",\n    )\n    ax1.set_xlabel(\"H (kA/m)\")\n    ax1.set_ylabel(\"f (GHz)\")\n\n    ax2.plot(\n        Hspace / 1e3,\n        np.rad2deg(result_dict_dipole[\"phi_1\"]),\n        color=\"forestgreen\",\n        label=r\"$\\phi_1$\",\n    )\n    ax2.plot(\n        Hspace / 1e3,\n        np.rad2deg(result_dict_dipole[\"theta_1\"]),\n        color=\"navy\",\n        label=r\"$\\theta_1$\",\n    )\n\n    ax2.plot(\n        Hspace / 1e3,\n        np.rad2deg(result_dict_dipole[\"phi_2\"]),\n        color=\"orange\",\n        label=r\"$\\phi_2$\",\n        marker=\"o\",\n        markersize=1,\n    )\n    ax2.plot(\n        Hspace / 1e3,\n        np.rad2deg(result_dict_dipole[\"theta_2\"]),\n        color=\"yellow\",\n        label=r\"$\\theta_2$\",\n        marker=\"o\",\n        markersize=1,\n    )\n    ax1.legend()\n    ax2.legend()\n    ax2.set_xlabel(\"H (kA/m)\")\n    ax2.set_ylabel(\"angle (deg)\")\n    fig.tight_layout()\n</pre> import matplotlib.pyplot as plt  with plt.style.context([\"science\", \"nature\"]):     w, h = plt.figaspect(0.5)     fig, (ax1, ax2) = plt.subplots(1, 2, dpi=200, figsize=(w, h))     ax1.plot(         np.asarray(result_dict_dipole[\"Hmag\"]) / 1e3,         result_dict_dipole[\"frequency\"],         \"bo\",         label=\"classical+dipole\",     )     ax1.plot(         np.asarray(result_dictionary[\"Hmag\"]) / 1e3,         result_dictionary[\"frequency\"],         \"ro\",         markersize=0.9,         label=\"classical\",     )     ax1.set_xlabel(\"H (kA/m)\")     ax1.set_ylabel(\"f (GHz)\")      ax2.plot(         Hspace / 1e3,         np.rad2deg(result_dict_dipole[\"phi_1\"]),         color=\"forestgreen\",         label=r\"$\\phi_1$\",     )     ax2.plot(         Hspace / 1e3,         np.rad2deg(result_dict_dipole[\"theta_1\"]),         color=\"navy\",         label=r\"$\\theta_1$\",     )      ax2.plot(         Hspace / 1e3,         np.rad2deg(result_dict_dipole[\"phi_2\"]),         color=\"orange\",         label=r\"$\\phi_2$\",         marker=\"o\",         markersize=1,     )     ax2.plot(         Hspace / 1e3,         np.rad2deg(result_dict_dipole[\"theta_2\"]),         color=\"yellow\",         label=r\"$\\theta_2$\",         marker=\"o\",         markersize=1,     )     ax1.legend()     ax2.legend()     ax2.set_xlabel(\"H (kA/m)\")     ax2.set_ylabel(\"angle (deg)\")     fig.tight_layout() In\u00a0[7]: Copied! <pre>import numpy as np\nfrom collections import defaultdict\nfrom cmtj.utils.parallel import parallel_vsd_sb_model\nfrom cmtj.models import LayerDynamic, VectorObj, Solver\nfrom cmtj.utils import mu0, FieldScan\n\n\ndef process_frequency(args):\n    # this is a fixed function, so we can use it in parallel\n    f, Hvecs, layerA, layerB, J1, J2, _ = args\n    data = defaultdict(list)\n    current_position = [\n        np.deg2rad(90),\n        np.deg2rad(0.1),\n        np.deg2rad(90),\n        np.deg2rad(0.1),\n    ]\n    for H in Hvecs:\n        solver = Solver(\n            layers=[layerA, layerB],\n            J1=J1,\n            J2=J2,\n            H=VectorObj.from_cartesian(*H),\n        )\n        current_position = solver.adam_gradient_descent(\n            init_position=current_position, max_steps=1e6\n        )\n        res = solver.linearised_N_spin_diode(\n            H=H,\n            frequency=f * 1e9,\n            Vdc_ex_variable=LayerDynamic.get_Vp_symbol(),\n            Vdc_ex_value=1e6,\n            zero_pos=current_position,\n            phase_shift=0,\n            cache_var=\"H\",\n        )\n        data[\"lineshape\"].append(res)\n        data[\"pos\"].append(current_position)\n    return data\n\n\nMs1 = 1.0 / mu0\nMs2 = 1.2 / mu0\nalpha = 1e-3\ntpar = 0.2\ntperp = -0.2\nlayerA = LayerDynamic(\n    _id=0,\n    thickness=1e-9,\n    Kv=VectorObj(np.deg2rad(0.0), np.deg2rad(0), 1e1),\n    Ks=3e4,\n    Ms=Ms1,\n    alpha=alpha,\n    torque_par=tpar,\n    torque_perp=tperp,\n)\nlayerB = LayerDynamic(\n    _id=1,\n    thickness=1.3e-9,\n    Kv=VectorObj(np.deg2rad(0.0), np.deg2rad(0), 1e4),\n    Ks=1e1,\n    Ms=Ms2,\n    alpha=alpha,\n    torque_par=-tpar,\n    torque_perp=-tperp,\n)\nhmin = 200e3\nN = 70\nHscan, Hvecs = FieldScan.amplitude_scan(\n    start=-hmin, stop=hmin, steps=N, theta=89, phi=0.1, back=False\n)\nfmax = 18\nfspace = np.arange(0, fmax, 1)\nspin_diode_data = parallel_vsd_sb_model(\n    process_frequency,\n    frequencies=fspace,\n    layers=[layerA, layerB],\n    Hvecs=Hvecs,\n    J1=[1e-4],\n    J2=[0.0],\n    n_cores=4,\n)\n</pre> import numpy as np from collections import defaultdict from cmtj.utils.parallel import parallel_vsd_sb_model from cmtj.models import LayerDynamic, VectorObj, Solver from cmtj.utils import mu0, FieldScan   def process_frequency(args):     # this is a fixed function, so we can use it in parallel     f, Hvecs, layerA, layerB, J1, J2, _ = args     data = defaultdict(list)     current_position = [         np.deg2rad(90),         np.deg2rad(0.1),         np.deg2rad(90),         np.deg2rad(0.1),     ]     for H in Hvecs:         solver = Solver(             layers=[layerA, layerB],             J1=J1,             J2=J2,             H=VectorObj.from_cartesian(*H),         )         current_position = solver.adam_gradient_descent(             init_position=current_position, max_steps=1e6         )         res = solver.linearised_N_spin_diode(             H=H,             frequency=f * 1e9,             Vdc_ex_variable=LayerDynamic.get_Vp_symbol(),             Vdc_ex_value=1e6,             zero_pos=current_position,             phase_shift=0,             cache_var=\"H\",         )         data[\"lineshape\"].append(res)         data[\"pos\"].append(current_position)     return data   Ms1 = 1.0 / mu0 Ms2 = 1.2 / mu0 alpha = 1e-3 tpar = 0.2 tperp = -0.2 layerA = LayerDynamic(     _id=0,     thickness=1e-9,     Kv=VectorObj(np.deg2rad(0.0), np.deg2rad(0), 1e1),     Ks=3e4,     Ms=Ms1,     alpha=alpha,     torque_par=tpar,     torque_perp=tperp, ) layerB = LayerDynamic(     _id=1,     thickness=1.3e-9,     Kv=VectorObj(np.deg2rad(0.0), np.deg2rad(0), 1e4),     Ks=1e1,     Ms=Ms2,     alpha=alpha,     torque_par=-tpar,     torque_perp=-tperp, ) hmin = 200e3 N = 70 Hscan, Hvecs = FieldScan.amplitude_scan(     start=-hmin, stop=hmin, steps=N, theta=89, phi=0.1, back=False ) fmax = 18 fspace = np.arange(0, fmax, 1) spin_diode_data = parallel_vsd_sb_model(     process_frequency,     frequencies=fspace,     layers=[layerA, layerB],     Hvecs=Hvecs,     J1=[1e-4],     J2=[0.0],     n_cores=4, ) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18/18 [01:53&lt;00:00,  6.30s/it]\n</pre> In\u00a0[8]: Copied! <pre>import matplotlib.pyplot as plt\nfrom cmtj.utils.resistance import Rxx_parallel_bilayer_expr\n\nGMR = 0.1\nSMR = 0.01\nAMR = 0.1\nVdc = 1\nRlin_func, R_func = Rxx_parallel_bilayer_expr()\nwith plt.style.context([\"science\", \"nature\"]):\n    fig, ax = plt.subplots(dpi=200)\n    for findx, fdata in enumerate(spin_diode_data):\n        V = []\n        for linearised, stationary in zip(fdata[\"lineshape\"], fdata[\"pos\"]):\n            Rparallel = R_func(GMR, AMR, SMR, AMR, SMR, stationary)\n            dRparallel = Rlin_func(GMR, AMR, SMR, AMR, SMR, stationary, linearised)\n            Vline = (Vdc / Rparallel) * dRparallel\n            V.append(Vline)\n        V = np.asarray(V)\n        V = (V - V.min()) / (V.max() - V.min()) / 2\n        ax.plot(Hscan / 1e3, V + findx, color=\"gray\")\n    ax.scatter(\n        Hvals,\n        result_dictionary[\"frequency\"],\n        color=\"crimson\",\n        label=r\"f\",\n    )\n    ax.set_xlabel(\"H (kA/m)\")\n    ax.set_ylabel(\"V (a.u.)\")\n    ax.set_title(\"Voltage FMR\")\n    ax.set_xlim(-hmin / 1e3, hmin / 1e3)\n    ax.set_ylim(-0.1, fmax)\n</pre> import matplotlib.pyplot as plt from cmtj.utils.resistance import Rxx_parallel_bilayer_expr  GMR = 0.1 SMR = 0.01 AMR = 0.1 Vdc = 1 Rlin_func, R_func = Rxx_parallel_bilayer_expr() with plt.style.context([\"science\", \"nature\"]):     fig, ax = plt.subplots(dpi=200)     for findx, fdata in enumerate(spin_diode_data):         V = []         for linearised, stationary in zip(fdata[\"lineshape\"], fdata[\"pos\"]):             Rparallel = R_func(GMR, AMR, SMR, AMR, SMR, stationary)             dRparallel = Rlin_func(GMR, AMR, SMR, AMR, SMR, stationary, linearised)             Vline = (Vdc / Rparallel) * dRparallel             V.append(Vline)         V = np.asarray(V)         V = (V - V.min()) / (V.max() - V.min()) / 2         ax.plot(Hscan / 1e3, V + findx, color=\"gray\")     ax.scatter(         Hvals,         result_dictionary[\"frequency\"],         color=\"crimson\",         label=r\"f\",     )     ax.set_xlabel(\"H (kA/m)\")     ax.set_ylabel(\"V (a.u.)\")     ax.set_title(\"Voltage FMR\")     ax.set_xlim(-hmin / 1e3, hmin / 1e3)     ax.set_ylim(-0.1, fmax) In\u00a0[9]: Copied! <pre>import numpy as np\n\nfrom collections import defaultdict\nfrom cmtj.models import LayerSB, VectorObj, Solver\nfrom cmtj.utils import mu0\nfrom tqdm import tqdm\n\nMs1 = (\n    1.0 / mu0\n)  # here we pass the saturation magnetisation in A/m, but in the dynamic model we use T!\nMs2 = 1.2 / mu0\nlayerA = LayerSB(\n    _id=0,\n    thickness=1e-9,\n    Kv=VectorObj(\n        np.deg2rad(0.0), np.deg2rad(0), 1e1\n    ),  # for the Kv only phi angle counts !\n    Ks=3e4,\n    Ms=Ms1,\n)\nlayerB = LayerSB(\n    _id=1,\n    thickness=1.3e-9,\n    Kv=VectorObj(np.deg2rad(0.0), np.deg2rad(0), 1e4),\n    Ks=1e1,\n    Ms=Ms2,\n)\n\n# we indicate the \"guess\" of the initial position\n# it's generally good to align it with the field, but it's not necessary\ncurrent_position = [np.deg2rad(89), np.deg2rad(0.1), np.deg2rad(180), np.deg2rad(0.1)]\nHspace = np.linspace(-400e3, 400e3, 50)\nresult_dictionary = defaultdict(list)\n# we perform a sweep over the field magnitude\nfor Hmag in tqdm(Hspace):\n    solver = Solver(\n        layers=[layerA, layerB],\n        J1=[1e-4],\n        J2=[0.0],\n        H=VectorObj(np.deg2rad(89), np.deg2rad(0.1), Hmag),\n        prefer_numerical_roots=False,\n    )\n    # check for additional parameters in the solver\n    # such as gradient convergence tolerance, max iterations, etc.\n    # also in the solver there are root finding parameters\n    (t1, p1, t2, p2), frequencies = solver.solve(init_position=current_position)\n    # frequencies are already in GHz\n    for frequency in frequencies:\n        result_dictionary[\"frequency\"].append(frequency)\n        result_dictionary[\"Hmag\"].append(Hmag)\n\n    # we note the final position of the magnetisation in spherical coordinates\n    result_dictionary[\"theta_1\"].append(t1)\n    result_dictionary[\"phi_1\"].append(p1)\n    result_dictionary[\"theta_2\"].append(t2)\n    result_dictionary[\"phi_2\"].append(p2)\n    # we reuse the previous solution as the initial guess for the next iteration\n    current_position = [t1, p1, t2, p2]\n</pre> import numpy as np  from collections import defaultdict from cmtj.models import LayerSB, VectorObj, Solver from cmtj.utils import mu0 from tqdm import tqdm  Ms1 = (     1.0 / mu0 )  # here we pass the saturation magnetisation in A/m, but in the dynamic model we use T! Ms2 = 1.2 / mu0 layerA = LayerSB(     _id=0,     thickness=1e-9,     Kv=VectorObj(         np.deg2rad(0.0), np.deg2rad(0), 1e1     ),  # for the Kv only phi angle counts !     Ks=3e4,     Ms=Ms1, ) layerB = LayerSB(     _id=1,     thickness=1.3e-9,     Kv=VectorObj(np.deg2rad(0.0), np.deg2rad(0), 1e4),     Ks=1e1,     Ms=Ms2, )  # we indicate the \"guess\" of the initial position # it's generally good to align it with the field, but it's not necessary current_position = [np.deg2rad(89), np.deg2rad(0.1), np.deg2rad(180), np.deg2rad(0.1)] Hspace = np.linspace(-400e3, 400e3, 50) result_dictionary = defaultdict(list) # we perform a sweep over the field magnitude for Hmag in tqdm(Hspace):     solver = Solver(         layers=[layerA, layerB],         J1=[1e-4],         J2=[0.0],         H=VectorObj(np.deg2rad(89), np.deg2rad(0.1), Hmag),         prefer_numerical_roots=False,     )     # check for additional parameters in the solver     # such as gradient convergence tolerance, max iterations, etc.     # also in the solver there are root finding parameters     (t1, p1, t2, p2), frequencies = solver.solve(init_position=current_position)     # frequencies are already in GHz     for frequency in frequencies:         result_dictionary[\"frequency\"].append(frequency)         result_dictionary[\"Hmag\"].append(Hmag)      # we note the final position of the magnetisation in spherical coordinates     result_dictionary[\"theta_1\"].append(t1)     result_dictionary[\"phi_1\"].append(p1)     result_dictionary[\"theta_2\"].append(t2)     result_dictionary[\"phi_2\"].append(p2)     # we reuse the previous solution as the initial guess for the next iteration     current_position = [t1, p1, t2, p2] <pre>  0%|          | 0/50 [00:00&lt;?, ?it/s]&lt;string&gt;:11: UserWarning: LU sometimes causes slow numerical convergence for analytical solve. Setting use_LU_decomposition to False.\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 50/50 [00:16&lt;00:00,  3.06it/s]\n</pre> In\u00a0[10]: Copied! <pre>import matplotlib.pyplot as plt\n\nwith plt.style.context([\"science\", \"nature\"]):\n    w, h = plt.figaspect(0.5)\n    fig, (ax1, ax2) = plt.subplots(1, 2, dpi=200, figsize=(w, h))\n    Hvals = np.asarray(result_dictionary[\"Hmag\"]) / 1e3\n    ax1.plot(\n        Hvals,\n        result_dictionary[\"frequency\"],\n        \"ro\",\n        label=\"frequency\",\n    )\n    ax1.set_xlabel(\"H (kA/m)\")\n    ax1.set_ylabel(\"f (GHz)\")\n\n    ax2.plot(\n        Hspace / 1e3,\n        np.rad2deg(result_dictionary[\"phi_1\"]),\n        color=\"forestgreen\",\n        label=r\"$\\phi_1$\",\n    )\n    ax2.plot(\n        Hspace / 1e3,\n        np.rad2deg(result_dictionary[\"theta_1\"]),\n        color=\"navy\",\n        label=r\"$\\theta_1$\",\n    )\n\n    ax2.plot(\n        Hspace / 1e3,\n        np.rad2deg(result_dictionary[\"phi_2\"]),\n        color=\"forestgreen\",\n        label=r\"$\\phi_2$\",\n        marker=\"o\",\n        markersize=1,\n    )\n    ax2.plot(\n        Hspace / 1e3,\n        np.rad2deg(result_dictionary[\"theta_2\"]),\n        color=\"navy\",\n        label=r\"$\\theta_2$\",\n        marker=\"o\",\n        markersize=1,\n    )\n    ax2.legend()\n    ax2.set_xlabel(\"H (kA/m)\")\n    ax2.set_ylabel(\"angle (deg)\")\n    fig.tight_layout()\n</pre> import matplotlib.pyplot as plt  with plt.style.context([\"science\", \"nature\"]):     w, h = plt.figaspect(0.5)     fig, (ax1, ax2) = plt.subplots(1, 2, dpi=200, figsize=(w, h))     Hvals = np.asarray(result_dictionary[\"Hmag\"]) / 1e3     ax1.plot(         Hvals,         result_dictionary[\"frequency\"],         \"ro\",         label=\"frequency\",     )     ax1.set_xlabel(\"H (kA/m)\")     ax1.set_ylabel(\"f (GHz)\")      ax2.plot(         Hspace / 1e3,         np.rad2deg(result_dictionary[\"phi_1\"]),         color=\"forestgreen\",         label=r\"$\\phi_1$\",     )     ax2.plot(         Hspace / 1e3,         np.rad2deg(result_dictionary[\"theta_1\"]),         color=\"navy\",         label=r\"$\\theta_1$\",     )      ax2.plot(         Hspace / 1e3,         np.rad2deg(result_dictionary[\"phi_2\"]),         color=\"forestgreen\",         label=r\"$\\phi_2$\",         marker=\"o\",         markersize=1,     )     ax2.plot(         Hspace / 1e3,         np.rad2deg(result_dictionary[\"theta_2\"]),         color=\"navy\",         label=r\"$\\theta_2$\",         marker=\"o\",         markersize=1,     )     ax2.legend()     ax2.set_xlabel(\"H (kA/m)\")     ax2.set_ylabel(\"angle (deg)\")     fig.tight_layout()"},{"location":"tutorials/SBModel/#smit-beljers-model-for-ferromagnetic-resonance","title":"Smit-Beljers model for ferromagnetic resonance\u00b6","text":"<p>In this notebook you can see how to run a FMR calculation with a theoretical Smit-Beljers model.</p> <p>Compared to standard CMTJ here we work in Ms of the A/m units instead of T, and also spherical coordinates. Use <code>VectorObj</code> reference to create objects in convenient frame of reference for you. Here's the reference</p>"},{"location":"tutorials/SBModel/#dynamic-llg-from-smit-beljers-model-spherical-model","title":"Dynamic LLG from Smit-Beljers model, spherical model\u00b6","text":"<p>Here, we can also return eigenvectors in addition to eigenvalues (frequencies). Under the hood the solver is a bit different,  hence we use a slightly different input object.</p>"},{"location":"tutorials/SBModel/#adding-dipole-interaction","title":"Adding dipole interaction\u00b6","text":"<p>You can also add dipole interaction to the model. This is done by setting the <code>Ndipole</code> parameter to a list of dipole tensors which are 3x3 matrices each. Each dipole tensor should describe the interaction between the corresponding layer and the next one. This is WIP feature and any feedback is appreciated.</p>"},{"location":"tutorials/SBModel/#voltage-fmr","title":"Voltage FMR\u00b6","text":"<p>The dynamic model can be used to compute the voltage FMR. This is done by computing the linearised resistance of the system and then using the voltage drop across the system to compute the frequency shift.</p> <p>We need both the stationary and linearised angles to compute the linearised resistance, so we find the energy minimum first, and then compute the linearisation using standard Jacobian method.</p> <p>We will also use parallelisation to speed up the computation which normally can be pretty slow.</p>"},{"location":"tutorials/SBModel/#extra-optimizations","title":"Extra optimizations\u00b6","text":"<p>Sometimes computing the roots analytically is not necessarily slower -- as in the example below. To enable semi-analytical solve we need to pass <code>prefer_numerical_roots=False</code>.</p> <p>Best is to check from example to example if this gives us any speedup.</p> <pre>solver = Solver(\n    layers=[layerA, layerB],\n    J1=[1e-4],\n    J2=[0.0],\n    H=VectorObj(np.deg2rad(89), np.deg2rad(0.1), Hmag),\n    prefer_numerical_roots=False,\n)\n</pre>"},{"location":"tutorials/interactions/","title":"Group interactions","text":"In\u00a0[1]: Copied! <pre>from cmtj.reservoir import (\n    GroupInteraction,\n    nullDipoleInteraction,\n    computeDipoleInteraction,\n)\n\nfrom cmtj import *\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.fft import fftfreq, fft\n\n\nimport matplotlib.pyplot as plt\n\nBETA = 0.1\n\nfontsize = 5\n\ndef create_junction(Ms, Ku):\n    damping = 1e-2\n    surface = np.pi * 50e-9 * 50e-9\n    thickness = 3e-9\n    spinPolarisation = 0.54\n    SLP = spinPolarisation**2\n    spinPolarisation = 1\n    demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)]\n    # generate a random start position for the magnetization\n    start_m = CVector(\n        np.random.uniform(-1, 1), np.random.uniform(-1, 1), np.random.uniform(-1, 1)\n    )\n    start_m.normalize()\n    start_m = CVector(0, 0, 1)\n    layer = Layer.createSTTLayer(\n        \"free\",\n        start_m,\n        CVector(1.0, 0.0, 0.0),\n        Ms,\n        thickness,\n        surface,\n        demag,\n        damping,\n        SLP,\n        BETA,\n        spinPolarisation,\n    )\n    layer.setReferenceLayer(CVector(1, 0.0, 0))\n    layer.setAnisotropyDriver(constantDriver(Ku))\n    return Junction(\n        [layer],\n        100,\n        200,\n    )\n\n\nint_time = 1e-13\nMs = 1.2\nKu = 1e2\nm1 = create_junction(Ms, Ku)\nm2 = create_junction(\n    Ms, Ku * (1 + 0.5)\n)  # we slightly modify the anisotropy of the second junction, so they are not identical\njdc = constantDriver(-7e11)\nm1.setLayerCurrentDriver(\"free\", jdc)\nm1.setLayerExternalFieldDriver(\"all\", AxialDriver(0, 0, 10e3))\nm2.setLayerExternalFieldDriver(\"all\", AxialDriver(0, 0, 10e3))\ncoordinate_matrix = [\n    CVector(0, 0, 0),\n    CVector(\n        200e-9, 0, 0\n    ),  # we place the second junction 200 nm away from the first junction in the x direction\n]\n\n\ndef customDipoleInteraction(\n    r1: CVector, r2: CVector, layer1: Layer, layer2: Layer\n) -&gt; CVector:\n    dist: CVector = np.power((r1 - r2).length(), 3) * (layer2.Ms / layer1.Ms) * 0.01\n    return CVector(dist, 0, 0)\n\n\ncolors = [\"crimson\", \"navy\"]\nlinestyles = [\"-\", \"--\"]\nfstrs = [\"null\", \"Kanao\", \"custom\"]\nlcolors = [\"crimson\", \"navy\", \"forestgreen\"]\nfns = [nullDipoleInteraction, computeDipoleInteraction, customDipoleInteraction]\nwith plt.style.context([\"science\", \"nature\"]):\n    w, h = plt.figaspect(len(fns) / 3)\n    fig, axs = plt.subplots(len(fns), 3, dpi=300, figsize=(w, h))\n    for fi, (fn, fstr) in enumerate(zip(fns, fstrs)):\n        gi = GroupInteraction(coordinate_matrix, [m1, m2])\n\n        gi.setInteractionFunction(fn)\n        gi.runSimulation(30e-9, int_time, int_time)\n        c_is = []\n        plot_time = 1\n        tm_wait = 10\n        for i in range(len(coordinate_matrix)):\n            log = gi.getLog(i)\n            tm = np.asarray(log[\"time\"]) * 1e9\n            R = np.asarray(log[\"R\"])\n            des_tm = tm.max() - plot_time\n            N = np.argwhere(tm &gt; des_tm).ravel().min()\n            axs[fi, 0].plot(tm[N:], R[N:], label=f\"Junction {i}\", color=colors[i])\n            # compute fft of R\n\n            idx = np.argwhere(tm &gt; tm_wait).ravel()\n            # print(idx)\n            R = R[idx]\n            fft_R = fft(R)\n            freq = fftfreq(len(R), int_time)\n            fft_R = np.abs(fft_R)\n            fft_R = fft_R[: len(fft_R) // 2]\n            freq = freq[: len(freq) // 2]\n            axs[fi, 1].plot(freq, fft_R, label=f\"Junction {i}\", color=colors[i])\n            for kl, l in enumerate(\"xyz\"):\n                m_l = np.asarray(log[f\"free_m{l}\"])\n                axs[fi, 2].plot(\n                    tm[N:],\n                    m_l[N:],\n                    label=f\"Junction {i} {l}\",\n                    color=lcolors[kl],\n                    linestyle=linestyles[i],\n                    linewidth=0.3,\n                )\n        axs[fi, 0].set_xlabel(\"Time [ns]\", fontsize=fontsize)\n        axs[fi, -1].set_xlabel(\"Time [ns]\", fontsize=fontsize)\n        axs[fi, 0].set_ylabel(\"Resistance [Ohm]\", fontsize=fontsize)\n        axs[fi, 1].legend(fontsize=fontsize)\n        axs[fi, 1].set_xlabel(\"Frequency [GHz]\", fontsize=fontsize)\n        axs[fi, 1].set_ylabel(\"Amplitude\", fontsize=fontsize)\n        axs[fi, 2].set_ylabel(\"Magnetization\", fontsize=fontsize)\n        axs[fi, 1].set_xscale(\"log\")\n        axs[fi, 1].set_yscale(\"log\")\n\n        axs[fi, 0].set_title(\"Resistance\", fontsize=fontsize)\n        axs[fi, 1].set_title(f\"Dipole interaction: {fstr}\", fontsize=fontsize)\n        axs[fi, 2].set_title(\"(solid: $m_1$, dashed: $m_2$)\", fontsize=fontsize)\n        fig.subplots_adjust(hspace=0.85)\n        fig.tight_layout()\n</pre> from cmtj.reservoir import (     GroupInteraction,     nullDipoleInteraction,     computeDipoleInteraction, )  from cmtj import * import matplotlib.pyplot as plt import numpy as np from scipy.fft import fftfreq, fft   import matplotlib.pyplot as plt  BETA = 0.1  fontsize = 5  def create_junction(Ms, Ku):     damping = 1e-2     surface = np.pi * 50e-9 * 50e-9     thickness = 3e-9     spinPolarisation = 0.54     SLP = spinPolarisation**2     spinPolarisation = 1     demag = [CVector(0, 0, 0), CVector(0, 0, 0), CVector(0, 0, 1)]     # generate a random start position for the magnetization     start_m = CVector(         np.random.uniform(-1, 1), np.random.uniform(-1, 1), np.random.uniform(-1, 1)     )     start_m.normalize()     start_m = CVector(0, 0, 1)     layer = Layer.createSTTLayer(         \"free\",         start_m,         CVector(1.0, 0.0, 0.0),         Ms,         thickness,         surface,         demag,         damping,         SLP,         BETA,         spinPolarisation,     )     layer.setReferenceLayer(CVector(1, 0.0, 0))     layer.setAnisotropyDriver(constantDriver(Ku))     return Junction(         [layer],         100,         200,     )   int_time = 1e-13 Ms = 1.2 Ku = 1e2 m1 = create_junction(Ms, Ku) m2 = create_junction(     Ms, Ku * (1 + 0.5) )  # we slightly modify the anisotropy of the second junction, so they are not identical jdc = constantDriver(-7e11) m1.setLayerCurrentDriver(\"free\", jdc) m1.setLayerExternalFieldDriver(\"all\", AxialDriver(0, 0, 10e3)) m2.setLayerExternalFieldDriver(\"all\", AxialDriver(0, 0, 10e3)) coordinate_matrix = [     CVector(0, 0, 0),     CVector(         200e-9, 0, 0     ),  # we place the second junction 200 nm away from the first junction in the x direction ]   def customDipoleInteraction(     r1: CVector, r2: CVector, layer1: Layer, layer2: Layer ) -&gt; CVector:     dist: CVector = np.power((r1 - r2).length(), 3) * (layer2.Ms / layer1.Ms) * 0.01     return CVector(dist, 0, 0)   colors = [\"crimson\", \"navy\"] linestyles = [\"-\", \"--\"] fstrs = [\"null\", \"Kanao\", \"custom\"] lcolors = [\"crimson\", \"navy\", \"forestgreen\"] fns = [nullDipoleInteraction, computeDipoleInteraction, customDipoleInteraction] with plt.style.context([\"science\", \"nature\"]):     w, h = plt.figaspect(len(fns) / 3)     fig, axs = plt.subplots(len(fns), 3, dpi=300, figsize=(w, h))     for fi, (fn, fstr) in enumerate(zip(fns, fstrs)):         gi = GroupInteraction(coordinate_matrix, [m1, m2])          gi.setInteractionFunction(fn)         gi.runSimulation(30e-9, int_time, int_time)         c_is = []         plot_time = 1         tm_wait = 10         for i in range(len(coordinate_matrix)):             log = gi.getLog(i)             tm = np.asarray(log[\"time\"]) * 1e9             R = np.asarray(log[\"R\"])             des_tm = tm.max() - plot_time             N = np.argwhere(tm &gt; des_tm).ravel().min()             axs[fi, 0].plot(tm[N:], R[N:], label=f\"Junction {i}\", color=colors[i])             # compute fft of R              idx = np.argwhere(tm &gt; tm_wait).ravel()             # print(idx)             R = R[idx]             fft_R = fft(R)             freq = fftfreq(len(R), int_time)             fft_R = np.abs(fft_R)             fft_R = fft_R[: len(fft_R) // 2]             freq = freq[: len(freq) // 2]             axs[fi, 1].plot(freq, fft_R, label=f\"Junction {i}\", color=colors[i])             for kl, l in enumerate(\"xyz\"):                 m_l = np.asarray(log[f\"free_m{l}\"])                 axs[fi, 2].plot(                     tm[N:],                     m_l[N:],                     label=f\"Junction {i} {l}\",                     color=lcolors[kl],                     linestyle=linestyles[i],                     linewidth=0.3,                 )         axs[fi, 0].set_xlabel(\"Time [ns]\", fontsize=fontsize)         axs[fi, -1].set_xlabel(\"Time [ns]\", fontsize=fontsize)         axs[fi, 0].set_ylabel(\"Resistance [Ohm]\", fontsize=fontsize)         axs[fi, 1].legend(fontsize=fontsize)         axs[fi, 1].set_xlabel(\"Frequency [GHz]\", fontsize=fontsize)         axs[fi, 1].set_ylabel(\"Amplitude\", fontsize=fontsize)         axs[fi, 2].set_ylabel(\"Magnetization\", fontsize=fontsize)         axs[fi, 1].set_xscale(\"log\")         axs[fi, 1].set_yscale(\"log\")          axs[fi, 0].set_title(\"Resistance\", fontsize=fontsize)         axs[fi, 1].set_title(f\"Dipole interaction: {fstr}\", fontsize=fontsize)         axs[fi, 2].set_title(\"(solid: $m_1$, dashed: $m_2$)\", fontsize=fontsize)         fig.subplots_adjust(hspace=0.85)         fig.tight_layout() <pre>/opt/homebrew/Caskroom/miniforge/base/envs/.cmtj/lib/python3.9/site-packages/scipy/__init__.py:138: UserWarning: A NumPy version &gt;=1.16.5 and &lt;1.23.0 is required for this version of SciPy (detected version 1.26.4)\n  warnings.warn(f\"A NumPy version &gt;={np_minversion} and &lt;{np_maxversion} is required for this version of \"\n</pre>"},{"location":"tutorials/interactions/#group-interactions","title":"Group interactions\u00b6","text":""},{"location":"tutorials/interactions/#introduction","title":"Introduction\u00b6","text":"<p>In this tutorial, we will explore the interaction between any number of junctions.  We will limit ourselves to the interaction between two junctions, but the code can be easily extended to more junctions.</p> <p>We will use the <code>GroupInteraction</code> class to simulate the interaction between the junctions. It allows us to define the interaction between the junctions based on the distance between the junctions.</p> <p>For documentation, see the API reference.</p>"},{"location":"tutorials/interactions/#interaction-functions","title":"Interaction functions\u00b6","text":"<p>There are three available interaction functions:</p> <ol> <li><code>nullDipoleInteraction</code>: This is the default interaction function. It does not take into account the interaction between the junctions.</li> <li><code>computeDipoleInteraction</code>: Simulates dipole interactions, see [1] for more details.</li> <li><code>computeDipoleInteractionNoumra</code>: Similar to 2., also dipole interactions, see [2] for more details.</li> </ol> <p>[1] Kanao et al., Reservoir Computing on Spin-Torque Oscillator Array (2019), https://link.aps.org/doi/10.1103/PhysRevApplied.12.024052</p> <p>[2] Nomura et al., Reservoir computing with dipole-coupled nanomagnets (2019), https://iopscience.iop.org/article/10.7567/1347-4065/ab2406</p>"},{"location":"tutorials/interactions/#experiment","title":"Experiment\u00b6","text":"<p>The experiment we will simulate is a two-junction system with a current flowing only through the first junction. What we want to see is some oscillation in the second junction that is induced by the current flowing through the first junction and the interaction between the junctions.</p> <p>The coordinate matrix is defined as a list of position vectors, where each position vector represents the position of a junction with respect to (0, 0, 0) origin.</p>"},{"location":"tutorials/interactions/#conclusions","title":"Conclusions\u00b6","text":"<p>In the first row, we see null dipole interaction (no dipole interaction), and as expected, the resistance is of the second junction is constant.</p> <p>In the second row, we see the dipole interaction computed by Kanao et al. (2019), and we see that the resistance of the second junction oscillates, even though the current is only flowing through the first junction.</p> <p>For the third row, we defined a simple function that computes the interaction based on the distance between the junctions:</p> <pre>def customDipoleInteraction(\n    r1: CVector, r2: CVector, layer1: Layer, layer2: Layer\n) -&gt; CVector:\n    dist: CVector = np.power((r1 - r2).length(), 3) * (layer2.Ms / layer1.Ms) * 0.01\n    return CVector(dist, 0, 0)\n</pre> <p>The interaction definition is quite simple, and flexible.</p> <p>We just need to remember that interaction should return a CVector, and that the interaction is defined for each pair of junctions. In this case, the interaction is asymmetric because:</p> <ol> <li>We have the 3rd power of the distance in the formula.</li> <li>We have a scalar factor that depends on whether we are computing the impact of the first junction on the second or the second on the first, (layer1.Ms / layer2.Ms) will differ depending on that.</li> </ol>"},{"location":"tutorials/simpler_harmonics/","title":"Simple harmonic Hall voltage detection","text":"In\u00a0[71]: Copied! <pre>from cmtj import CVector, Layer, Junction, AxialDriver, NullDriver\nfrom cmtj.utils.resistance import calculate_resistance_parallel\nfrom cmtj import constantDriver, sineDriver\nfrom collections import defaultdict\nfrom cmtj.utils import Filters\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport cmtj\nimport math\n\n\nOeToAm = 79.57747\n\n\nRx0 = 304.306  # @param {type: \"number\"}\nRy0 = 1.008  # @param {type: \"number\"}\nSMR = -0.464  # @param {type: \"number\"}\nAMR = -0.053  # @param {type: \"number\"}\nAHE = -5.71  # @param {type: \"number\"}\nw = 3e-5  # @param {type: \"number\"}\nl = 2e-5  # @param {type: \"number\"}\nINT_STEP = 1e-13  # @param {type: \"number\"}\nHMIN = 250e3  # @param {type: \"number\"}\nHMAX = 830e3  # @param {type: \"number\"}\nHSTEPS = 100  # @param {type: \"number\"}\n\n\ndef compute_vsd1(stime, resistance, frequency, tstart=2e-9):\n    \"\"\"Time\"\"\"\n    stime = np.asarray(stime)\n    indx = np.argwhere(stime &gt;= tstart).ravel()\n    Rx = np.asarray(resistance)[indx]\n    avg_res = np.mean(Rx)\n    current = np.sqrt(1 / avg_res) * np.sin(2 * np.pi * frequency * stime[indx])\n    return np.mean(current * Rx)\n\n\ndef compute_vsd2(dynamicR, integration_step, dynamicI):\n    \"\"\"Pymag\"\"\"\n    SD = -dynamicI * dynamicR\n    fs = 1.0 / integration_step\n    SD_dc = Filters.butter_lowpass_filter(SD, cutoff=10e6, fs=fs, order=3)\n    return np.mean(SD_dc)\n\n\ndef simulate_lorentz(Ms, Ku, frequency, orient, alpha=1e-4, Irf=0.5e-3):\n    demagTensor = [\n        CVector(0.0, 0.0, 0.0),\n        CVector(0.0, 0.0, 0.0),\n        CVector(0.0, 0.0, 1.0),\n    ]\n    thickness = 1.45e-9\n    l1 = Layer(\n        id=\"free\",\n        mag=CVector(0.0, 0.0, 1.0),\n        anis=CVector(0, 0.0, 1.0),\n        Ms=Ms,\n        thickness=thickness,\n        cellSurface=0,\n        demagTensor=demagTensor,\n        damping=alpha,\n    )\n    junction = Junction([l1])\n\n    junction.setLayerAnisotropyDriver(\"free\", constantDriver(Ku))\n\n    HoeAmpl = 5000  # A/m\n    Hspace = np.linspace(HMIN, HMAX, num=HSTEPS)\n    theta = np.deg2rad(91)\n    if orient == \"4p\":\n        phideg = 0\n    elif orient == \"2p\":\n        phideg = 45\n    else:\n        raise ValueError(\"Unknown orient\")\n    phi = np.deg2rad(phideg)\n    Hsweep = np.zeros((Hspace.shape[0]))\n    for i, H in enumerate(Hspace):\n        junction.clearLog()\n        HDriver = AxialDriver(\n            constantDriver(H * math.sin(theta) * math.cos(phi)),\n            constantDriver(H * math.sin(theta) * math.sin(phi)),\n            constantDriver(H * math.cos(theta)),\n        )\n\n        HoeDriver = AxialDriver(\n            NullDriver(),\n            NullDriver(),\n            sineDriver(0, -HoeAmpl, frequency, 0),\n        )\n        junction.setLayerExternalFieldDriver(\"all\", HDriver)\n        junction.setLayerOerstedFieldDriver(\"all\", HoeDriver)\n        junction.runSimulation(40e-9, INT_STEP, INT_STEP, solverMode=cmtj.RK4)\n\n        log = junction.getLog()\n        m = np.asarray(\n            [\n                [log[f\"{str_}_mx\"], log[f\"{str_}_my\"], log[f\"{str_}_mz\"]]\n                for str_ in [\"free\"]\n            ]\n        )\n        dynamicRx, dynamicRy = calculate_resistance_parallel(\n            Rx0=[Rx0],\n            Ry0=[Ry0],\n            AMR=[AMR],\n            AHE=[AHE],\n            SMR=[SMR],\n            m=m,\n            l=[l],\n            w=[w],\n        )\n        dynamicR = dynamicRx if orient == \"4p\" else dynamicRy\n        dynamicI = Irf * np.sin(2 * math.pi * frequency * np.asarray(log[\"time\"]))\n        vmix = compute_vsd2(dynamicR, INT_STEP, dynamicI)\n        Hsweep[i] = vmix\n    return Hspace, Hsweep\n\n\ndef simulate_lorentz_freq_scan(Ms, Ku, Hvalue, orient, alpha=1e-4, Irf=0.5e-3):\n    demagTensor = [\n        CVector(0.0, 0.0, 0.0),\n        CVector(0.0, 0.0, 0.0),\n        CVector(0.0, 0.0, 1.0),\n    ]\n    thickness = 1.45e-9\n    l1 = Layer(\n        id=\"free\",\n        mag=CVector(0.0, 0.0, 1.0),\n        anis=CVector(0, 0.0, 1.0),\n        Ms=Ms,\n        thickness=thickness,\n        cellSurface=0,\n        demagTensor=demagTensor,\n        damping=alpha,\n    )\n    junction = Junction([l1])\n\n    junction.setLayerAnisotropyDriver(\"free\", constantDriver(Ku))\n\n    HoeAmpl = 5000  # A/m\n    theta = np.deg2rad(91)\n    if orient == \"4p\":\n        phideg = 0\n    elif orient == \"2p\":\n        phideg = 45\n    else:\n        raise ValueError(\"Unknown orient\")\n    phi = np.deg2rad(phideg)\n    fspace = np.arange(2, 18, 0.1) * 1e9\n    fsweep = np.zeros((fspace.shape[0]))\n    for i, f in enumerate(fspace):\n        junction.clearLog()\n        HDriver = AxialDriver(\n            constantDriver(Hvalue * math.sin(theta) * math.cos(phi)),\n            constantDriver(Hvalue * math.sin(theta) * math.sin(phi)),\n            constantDriver(Hvalue * math.cos(theta)),\n        )\n\n        HoeDriver = AxialDriver(\n            NullDriver(),\n            NullDriver(),\n            sineDriver(0, -HoeAmpl, f, 0),\n        )\n        junction.setLayerExternalFieldDriver(\"all\", HDriver)\n        junction.setLayerOerstedFieldDriver(\"all\", HoeDriver)\n        junction.runSimulation(40e-9, INT_STEP, INT_STEP, solverMode=cmtj.RK4)\n\n        log = junction.getLog()\n        m = np.asarray(\n            [\n                [log[f\"{str_}_mx\"], log[f\"{str_}_my\"], log[f\"{str_}_mz\"]]\n                for str_ in [\"free\"]\n            ]\n        )\n        dynamicRx, dynamicRy = calculate_resistance_parallel(\n            Rx0=[Rx0],\n            Ry0=[Ry0],\n            AMR=[AMR],\n            AHE=[AHE],\n            SMR=[SMR],\n            m=m,\n            l=[l],\n            w=[w],\n        )\n        dynamicR = dynamicRx if orient == \"4p\" else dynamicRy\n        dynamicI = Irf * np.sin(2 * math.pi * f * np.asarray(log[\"time\"]))\n        vmix = compute_vsd2(dynamicR, INT_STEP, dynamicI)\n        fsweep[i] = vmix\n    return fspace, fsweep\n</pre> from cmtj import CVector, Layer, Junction, AxialDriver, NullDriver from cmtj.utils.resistance import calculate_resistance_parallel from cmtj import constantDriver, sineDriver from collections import defaultdict from cmtj.utils import Filters  import matplotlib.pyplot as plt import numpy as np import cmtj import math   OeToAm = 79.57747   Rx0 = 304.306  # @param {type: \"number\"} Ry0 = 1.008  # @param {type: \"number\"} SMR = -0.464  # @param {type: \"number\"} AMR = -0.053  # @param {type: \"number\"} AHE = -5.71  # @param {type: \"number\"} w = 3e-5  # @param {type: \"number\"} l = 2e-5  # @param {type: \"number\"} INT_STEP = 1e-13  # @param {type: \"number\"} HMIN = 250e3  # @param {type: \"number\"} HMAX = 830e3  # @param {type: \"number\"} HSTEPS = 100  # @param {type: \"number\"}   def compute_vsd1(stime, resistance, frequency, tstart=2e-9):     \"\"\"Time\"\"\"     stime = np.asarray(stime)     indx = np.argwhere(stime &gt;= tstart).ravel()     Rx = np.asarray(resistance)[indx]     avg_res = np.mean(Rx)     current = np.sqrt(1 / avg_res) * np.sin(2 * np.pi * frequency * stime[indx])     return np.mean(current * Rx)   def compute_vsd2(dynamicR, integration_step, dynamicI):     \"\"\"Pymag\"\"\"     SD = -dynamicI * dynamicR     fs = 1.0 / integration_step     SD_dc = Filters.butter_lowpass_filter(SD, cutoff=10e6, fs=fs, order=3)     return np.mean(SD_dc)   def simulate_lorentz(Ms, Ku, frequency, orient, alpha=1e-4, Irf=0.5e-3):     demagTensor = [         CVector(0.0, 0.0, 0.0),         CVector(0.0, 0.0, 0.0),         CVector(0.0, 0.0, 1.0),     ]     thickness = 1.45e-9     l1 = Layer(         id=\"free\",         mag=CVector(0.0, 0.0, 1.0),         anis=CVector(0, 0.0, 1.0),         Ms=Ms,         thickness=thickness,         cellSurface=0,         demagTensor=demagTensor,         damping=alpha,     )     junction = Junction([l1])      junction.setLayerAnisotropyDriver(\"free\", constantDriver(Ku))      HoeAmpl = 5000  # A/m     Hspace = np.linspace(HMIN, HMAX, num=HSTEPS)     theta = np.deg2rad(91)     if orient == \"4p\":         phideg = 0     elif orient == \"2p\":         phideg = 45     else:         raise ValueError(\"Unknown orient\")     phi = np.deg2rad(phideg)     Hsweep = np.zeros((Hspace.shape[0]))     for i, H in enumerate(Hspace):         junction.clearLog()         HDriver = AxialDriver(             constantDriver(H * math.sin(theta) * math.cos(phi)),             constantDriver(H * math.sin(theta) * math.sin(phi)),             constantDriver(H * math.cos(theta)),         )          HoeDriver = AxialDriver(             NullDriver(),             NullDriver(),             sineDriver(0, -HoeAmpl, frequency, 0),         )         junction.setLayerExternalFieldDriver(\"all\", HDriver)         junction.setLayerOerstedFieldDriver(\"all\", HoeDriver)         junction.runSimulation(40e-9, INT_STEP, INT_STEP, solverMode=cmtj.RK4)          log = junction.getLog()         m = np.asarray(             [                 [log[f\"{str_}_mx\"], log[f\"{str_}_my\"], log[f\"{str_}_mz\"]]                 for str_ in [\"free\"]             ]         )         dynamicRx, dynamicRy = calculate_resistance_parallel(             Rx0=[Rx0],             Ry0=[Ry0],             AMR=[AMR],             AHE=[AHE],             SMR=[SMR],             m=m,             l=[l],             w=[w],         )         dynamicR = dynamicRx if orient == \"4p\" else dynamicRy         dynamicI = Irf * np.sin(2 * math.pi * frequency * np.asarray(log[\"time\"]))         vmix = compute_vsd2(dynamicR, INT_STEP, dynamicI)         Hsweep[i] = vmix     return Hspace, Hsweep   def simulate_lorentz_freq_scan(Ms, Ku, Hvalue, orient, alpha=1e-4, Irf=0.5e-3):     demagTensor = [         CVector(0.0, 0.0, 0.0),         CVector(0.0, 0.0, 0.0),         CVector(0.0, 0.0, 1.0),     ]     thickness = 1.45e-9     l1 = Layer(         id=\"free\",         mag=CVector(0.0, 0.0, 1.0),         anis=CVector(0, 0.0, 1.0),         Ms=Ms,         thickness=thickness,         cellSurface=0,         demagTensor=demagTensor,         damping=alpha,     )     junction = Junction([l1])      junction.setLayerAnisotropyDriver(\"free\", constantDriver(Ku))      HoeAmpl = 5000  # A/m     theta = np.deg2rad(91)     if orient == \"4p\":         phideg = 0     elif orient == \"2p\":         phideg = 45     else:         raise ValueError(\"Unknown orient\")     phi = np.deg2rad(phideg)     fspace = np.arange(2, 18, 0.1) * 1e9     fsweep = np.zeros((fspace.shape[0]))     for i, f in enumerate(fspace):         junction.clearLog()         HDriver = AxialDriver(             constantDriver(Hvalue * math.sin(theta) * math.cos(phi)),             constantDriver(Hvalue * math.sin(theta) * math.sin(phi)),             constantDriver(Hvalue * math.cos(theta)),         )          HoeDriver = AxialDriver(             NullDriver(),             NullDriver(),             sineDriver(0, -HoeAmpl, f, 0),         )         junction.setLayerExternalFieldDriver(\"all\", HDriver)         junction.setLayerOerstedFieldDriver(\"all\", HoeDriver)         junction.runSimulation(40e-9, INT_STEP, INT_STEP, solverMode=cmtj.RK4)          log = junction.getLog()         m = np.asarray(             [                 [log[f\"{str_}_mx\"], log[f\"{str_}_my\"], log[f\"{str_}_mz\"]]                 for str_ in [\"free\"]             ]         )         dynamicRx, dynamicRy = calculate_resistance_parallel(             Rx0=[Rx0],             Ry0=[Ry0],             AMR=[AMR],             AHE=[AHE],             SMR=[SMR],             m=m,             l=[l],             w=[w],         )         dynamicR = dynamicRx if orient == \"4p\" else dynamicRy         dynamicI = Irf * np.sin(2 * math.pi * f * np.asarray(log[\"time\"]))         vmix = compute_vsd2(dynamicR, INT_STEP, dynamicI)         fsweep[i] = vmix     return fspace, fsweep In\u00a0[72]: Copied! <pre>from tqdm import tqdm\nimport multiprocess as mp\nfrom functools import partial\n\n\ndef process_h(h, orient, irf, Ms, Ku, alpha):\n    fscan, fsweep = simulate_lorentz_freq_scan(\n        Ms, Ku, h, orient=orient, alpha=alpha, Irf=irf\n    )\n    if orient == \"2p\":\n        fsweep -= fsweep.max()\n    return fscan, fsweep\n\n\ndata = defaultdict(list)\nhscans = []\nvscans = []\n\nhscan = np.arange(150, 650, 50) * 1e3\nalpha = 30e-3  # @param {type: \"number\"}\nMs = 0.525  # @param {type: \"number\"}\nKu = 1.54e5  # @param {type: \"number\"}\norient = \"2p\"\nirf = 0.4e-3\nwith mp.Pool() as pool:\n    process_func = partial(process_h, orient=orient, irf=irf, Ms=Ms, Ku=Ku, alpha=alpha)\n    results = list(tqdm(pool.imap(process_func, hscan), total=len(hscan)))\n\nfor fscan, fsweep in results:\n    data[f\"{orient}\"].append(fsweep)\n    data[f\"{orient}-freq\"].append(fscan)\n</pre> from tqdm import tqdm import multiprocess as mp from functools import partial   def process_h(h, orient, irf, Ms, Ku, alpha):     fscan, fsweep = simulate_lorentz_freq_scan(         Ms, Ku, h, orient=orient, alpha=alpha, Irf=irf     )     if orient == \"2p\":         fsweep -= fsweep.max()     return fscan, fsweep   data = defaultdict(list) hscans = [] vscans = []  hscan = np.arange(150, 650, 50) * 1e3 alpha = 30e-3  # @param {type: \"number\"} Ms = 0.525  # @param {type: \"number\"} Ku = 1.54e5  # @param {type: \"number\"} orient = \"2p\" irf = 0.4e-3 with mp.Pool() as pool:     process_func = partial(process_h, orient=orient, irf=irf, Ms=Ms, Ku=Ku, alpha=alpha)     results = list(tqdm(pool.imap(process_func, hscan), total=len(hscan)))  for fscan, fsweep in results:     data[f\"{orient}\"].append(fsweep)     data[f\"{orient}-freq\"].append(fscan) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [01:56&lt;00:00, 11.62s/it]\n</pre> In\u00a0[73]: Copied! <pre># import scienceplots\n\nwith plt.style.context([\"nature\"]):\n    fig, ax = plt.subplots(dpi=300)\n\n    colors = plt.get_cmap(\"rainbow\")(np.linspace(0, 1, len(hscan)))\n    for i, h in enumerate(hscan):\n        ax.plot(\n            np.asarray(data[f\"{orient}-freq\"][i]) / 1e9,\n            np.asarray(data[orient][i]) * 1e6,\n            alpha=1,\n            linestyle=\"--\", \n            label=f\"{h/1e3:.2f} kA/m\" if orient == \"4p\" else None,\n            color=colors[i],\n            linewidth=1,\n        )\n    # ax.set_xlim([300, 630])\n    ax.set_ylabel(r\"$V_\\mathrm{DC} (\\mathrm{\\mu V})$\")\n    ax.set_xlabel(\"f (GHz)\")\n\n    # add a colorbar\n    norm = plt.Normalize(min(hscan) / 1e3, max(hscan) / 1e3)\n    sm = plt.cm.ScalarMappable(cmap=\"rainbow\", norm=norm)\n    sm.set_array([])\n    cbar = fig.colorbar(sm, ax=ax, label=\"H (kA/m)\")\n    cbar.ax.set_ylabel(\"H (kA/m)\", rotation=90, labelpad=10)\n\n    fig.align_ylabels([ax])\n    # fig.legend()\n    # fig.tight_layout()\n</pre> # import scienceplots  with plt.style.context([\"nature\"]):     fig, ax = plt.subplots(dpi=300)      colors = plt.get_cmap(\"rainbow\")(np.linspace(0, 1, len(hscan)))     for i, h in enumerate(hscan):         ax.plot(             np.asarray(data[f\"{orient}-freq\"][i]) / 1e9,             np.asarray(data[orient][i]) * 1e6,             alpha=1,             linestyle=\"--\",              label=f\"{h/1e3:.2f} kA/m\" if orient == \"4p\" else None,             color=colors[i],             linewidth=1,         )     # ax.set_xlim([300, 630])     ax.set_ylabel(r\"$V_\\mathrm{DC} (\\mathrm{\\mu V})$\")     ax.set_xlabel(\"f (GHz)\")      # add a colorbar     norm = plt.Normalize(min(hscan) / 1e3, max(hscan) / 1e3)     sm = plt.cm.ScalarMappable(cmap=\"rainbow\", norm=norm)     sm.set_array([])     cbar = fig.colorbar(sm, ax=ax, label=\"H (kA/m)\")     cbar.ax.set_ylabel(\"H (kA/m)\", rotation=90, labelpad=10)      fig.align_ylabels([ax])     # fig.legend()     # fig.tight_layout() In\u00a0[10]: Copied! <pre>from tqdm import tqdm\n\ndata = defaultdict(list)\nhscans = []\nvscans = []\nfmin = 12  # @param {type: \"number\"}\nfmax = 17  # @param {type: \"number\"}\nfscan = [9, 12, 17, 22]\nalpha = 30e-3  # @param {type: \"number\"}\nMs = 0.525  # @param {type: \"number\"}\nKu = 1.54e5  # @param {type: \"number\"}\nfor orient, irf in zip((\"4p\", \"2p\"), (0.75e-3, 0.4e-3)):\n    for f in tqdm(fscan):\n        hscan, vscan = simulate_lorentz(\n            Ms, Ku, f * 1e9, orient=orient, alpha=alpha, Irf=irf\n        )\n        if orient == \"2p\":\n            vscan -= vscan.max()\n        data[f\"{orient}\"].append(vscan)\n        data[f\"{orient}-field\"].append(hscan)\n</pre> from tqdm import tqdm  data = defaultdict(list) hscans = [] vscans = [] fmin = 12  # @param {type: \"number\"} fmax = 17  # @param {type: \"number\"} fscan = [9, 12, 17, 22] alpha = 30e-3  # @param {type: \"number\"} Ms = 0.525  # @param {type: \"number\"} Ku = 1.54e5  # @param {type: \"number\"} for orient, irf in zip((\"4p\", \"2p\"), (0.75e-3, 0.4e-3)):     for f in tqdm(fscan):         hscan, vscan = simulate_lorentz(             Ms, Ku, f * 1e9, orient=orient, alpha=alpha, Irf=irf         )         if orient == \"2p\":             vscan -= vscan.max()         data[f\"{orient}\"].append(vscan)         data[f\"{orient}-field\"].append(hscan) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4/4 [01:34&lt;00:00, 23.69s/it]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4/4 [01:35&lt;00:00, 23.78s/it]\n</pre> In\u00a0[14]: Copied! <pre># import scienceplots\n\nwith plt.style.context([\"nature\"]):\n    fig, ax = plt.subplots(2, 1, dpi=300, sharex=\"col\")\n    colors = plt.get_cmap(\"rainbow\")(np.linspace(0, 1, len(fscan)))\n    for j, orient in enumerate((\"4p\", \"2p\")):\n        for i, f in enumerate(fscan):\n            ax[j].plot(\n                np.asarray(data[f\"{orient}-field\"][i]) / 1e3,\n                np.asarray(data[orient][i]) * 1e6,\n                alpha=1,\n                linestyle=\"--\",\n                label=f\"{f} GHz\" if orient == \"4p\" else None,\n                color=colors[i],\n                linewidth=1,\n            )\n        # ax[j].set_xlim([300, 630])\n        ax[j].set_ylabel(r\"$V_\\mathrm{DC} (\\mathrm{\\mu V})$\")\n\n    ax[1].set_xlabel(\"H (kA/m)\")\n    # ax[1].legend()\n    import matplotlib.transforms as mtransforms\n\n    # ax[0].legend()\n    for label, ax_ in zip([\"(a)\", \"(b)\"], ax.flatten()):\n        trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72, fig.dpi_scale_trans)\n        ax_.text(\n            0.0,\n            1.0,\n            label,\n            transform=ax_.transAxes + trans,\n            fontsize=\"medium\",\n            verticalalignment=\"top\",\n            bbox=dict(facecolor=\"none\", edgecolor=\"none\", pad=3.0),\n        )\n    fig.subplots_adjust(hspace=0)\n    fig.align_ylabels()\n    fig.legend()\n    fig.tight_layout()\n</pre> # import scienceplots  with plt.style.context([\"nature\"]):     fig, ax = plt.subplots(2, 1, dpi=300, sharex=\"col\")     colors = plt.get_cmap(\"rainbow\")(np.linspace(0, 1, len(fscan)))     for j, orient in enumerate((\"4p\", \"2p\")):         for i, f in enumerate(fscan):             ax[j].plot(                 np.asarray(data[f\"{orient}-field\"][i]) / 1e3,                 np.asarray(data[orient][i]) * 1e6,                 alpha=1,                 linestyle=\"--\",                 label=f\"{f} GHz\" if orient == \"4p\" else None,                 color=colors[i],                 linewidth=1,             )         # ax[j].set_xlim([300, 630])         ax[j].set_ylabel(r\"$V_\\mathrm{DC} (\\mathrm{\\mu V})$\")      ax[1].set_xlabel(\"H (kA/m)\")     # ax[1].legend()     import matplotlib.transforms as mtransforms      # ax[0].legend()     for label, ax_ in zip([\"(a)\", \"(b)\"], ax.flatten()):         trans = mtransforms.ScaledTranslation(10 / 72, -5 / 72, fig.dpi_scale_trans)         ax_.text(             0.0,             1.0,             label,             transform=ax_.transAxes + trans,             fontsize=\"medium\",             verticalalignment=\"top\",             bbox=dict(facecolor=\"none\", edgecolor=\"none\", pad=3.0),         )     fig.subplots_adjust(hspace=0)     fig.align_ylabels()     fig.legend()     fig.tight_layout()"},{"location":"tutorials/simpler_harmonics/#simple-harmonic-hall-voltage-detection","title":"Simple harmonic Hall voltage detection\u00b6","text":"<p>In this tutorial, we will simulate the harmonic Hall voltage detection of a single junction.</p> <p>This notebook also shows how to parallelize the simulation using multiprocessing for faster simulations.</p>"},{"location":"tutorials/trajectory/","title":"Generating trajectories","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nfrom cmtj import Junction, Layer, CVector, ScalarDriver, AxialDriver, NullDriver\nimport numpy as np\nfrom typing import List, Dict\n# sphere points\nr = 1\npi = np.pi\ncos = np.cos\nsin = np.sin\nphi, theta = np.mgrid[0.0:pi:100j, 0.0:2.0 * pi:100j]\nx = r * sin(phi) * cos(theta)\ny = r * sin(phi) * sin(theta)\nz = r * cos(phi)\n\n\ndef plot_trajectory(log: Dict[str, List[float]], title: str):\n    with plt.style.context(['science', 'no-latex']):\n        fig = plt.figure(figsize=(12, 12))\n        ax = fig.add_subplot(1, 2, 1, projection='3d')\n        m = np.asarray([log[f'free_mx'], log[f'free_my'], log[f'free_mz']])\n        ax.plot3D(m[0], m[1], m[2], color='blue')\n        ax.set_axis_off()\n        ax.plot_surface(x,\n                        y,\n                        z,\n                        rstride=2,\n                        cstride=2,\n                        color='c',\n                        alpha=0.3,\n                        linewidth=0.1)\n        ax.scatter([0], [0], [1], color='crimson', alpha=1.0, s=50)\n        fig.savefig(f\"{title}.png\")\n</pre> import matplotlib.pyplot as plt from cmtj import Junction, Layer, CVector, ScalarDriver, AxialDriver, NullDriver import numpy as np from typing import List, Dict # sphere points r = 1 pi = np.pi cos = np.cos sin = np.sin phi, theta = np.mgrid[0.0:pi:100j, 0.0:2.0 * pi:100j] x = r * sin(phi) * cos(theta) y = r * sin(phi) * sin(theta) z = r * cos(phi)   def plot_trajectory(log: Dict[str, List[float]], title: str):     with plt.style.context(['science', 'no-latex']):         fig = plt.figure(figsize=(12, 12))         ax = fig.add_subplot(1, 2, 1, projection='3d')         m = np.asarray([log[f'free_mx'], log[f'free_my'], log[f'free_mz']])         ax.plot3D(m[0], m[1], m[2], color='blue')         ax.set_axis_off()         ax.plot_surface(x,                         y,                         z,                         rstride=2,                         cstride=2,                         color='c',                         alpha=0.3,                         linewidth=0.1)         ax.scatter([0], [0], [1], color='crimson', alpha=1.0, s=50)         fig.savefig(f\"{title}.png\")  In\u00a0[2]: Copied! <pre>demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.0)]\n\ndamping = 0.03\ncurrentDensity = 1e9\nbeta = 1\nspinPolarisation = 1.0\n\nl1 = Layer.createSTTLayer(id=\"free\",\n                          mag=CVector(0., 0., 1.),\n                          anis=CVector(0, 0., 1.),\n                          Ms=1.,\n                          thickness=1.4e-9,\n                          cellSurface=7e-10 * 7e-10,\n                          demagTensor=demagTensor,\n                          damping=damping,\n                          SlonczewskiSpacerLayerParameter=1.0,\n                          spinPolarisation=spinPolarisation,\n                          beta=beta)\n\nl1.setReferenceLayer(CVector(0, 1., 1.))\njunction = Junction([l1])\n\njunction.setLayerAnisotropyDriver(\"free\",\n                                  ScalarDriver.getConstantDriver(300e3))\njunction.setLayerCurrentDriver(\"free\",\n                               ScalarDriver.getConstantDriver(currentDensity))\n\njunction.runSimulation(150e-9, 1e-12, 1e-12, False, False)\nlog = junction.getLog()\nplot_trajectory(log, \"STT\")\n</pre> demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.0)]  damping = 0.03 currentDensity = 1e9 beta = 1 spinPolarisation = 1.0  l1 = Layer.createSTTLayer(id=\"free\",                           mag=CVector(0., 0., 1.),                           anis=CVector(0, 0., 1.),                           Ms=1.,                           thickness=1.4e-9,                           cellSurface=7e-10 * 7e-10,                           demagTensor=demagTensor,                           damping=damping,                           SlonczewskiSpacerLayerParameter=1.0,                           spinPolarisation=spinPolarisation,                           beta=beta)  l1.setReferenceLayer(CVector(0, 1., 1.)) junction = Junction([l1])  junction.setLayerAnisotropyDriver(\"free\",                                   ScalarDriver.getConstantDriver(300e3)) junction.setLayerCurrentDriver(\"free\",                                ScalarDriver.getConstantDriver(currentDensity))  junction.runSimulation(150e-9, 1e-12, 1e-12, False, False) log = junction.getLog() plot_trajectory(log, \"STT\")  <p>Now, let's try to narrow down the radius of the oscillation by increasing the current density 100 fold.</p> In\u00a0[3]: Copied! <pre>demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.0)]\n\ndamping = 0.03\ncurrentDensity = 1e9\nbeta = 1\nspinPolarisation = 1.0\n\nl1 = Layer.createSTTLayer(id=\"free\",\n                          mag=CVector(-1., -1., 0.),\n                          anis=CVector(-1., -1., 0.),\n                          Ms=1.,\n                          thickness=1.4e-9,\n                          cellSurface=7e-10 * 7e-10,\n                          demagTensor=demagTensor,\n                          damping=damping,\n                          SlonczewskiSpacerLayerParameter=1.0,\n                          spinPolarisation=spinPolarisation,\n                          beta=beta)\n\nl1.setReferenceLayer(CVector(1, 1., 0.))\njunction = Junction([l1])\n\njunction.setLayerAnisotropyDriver(\"free\",\n                                  ScalarDriver.getConstantDriver(300e3))\njunction.setLayerCurrentDriver(\n    \"free\", ScalarDriver.getConstantDriver(currentDensity))\n\njunction.runSimulation(1500e-9, 1e-12, 1e-12, False, False)\nlog = junction.getLog()\nplot_trajectory(log, \"STT\")\n</pre> demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.0)]  damping = 0.03 currentDensity = 1e9 beta = 1 spinPolarisation = 1.0  l1 = Layer.createSTTLayer(id=\"free\",                           mag=CVector(-1., -1., 0.),                           anis=CVector(-1., -1., 0.),                           Ms=1.,                           thickness=1.4e-9,                           cellSurface=7e-10 * 7e-10,                           demagTensor=demagTensor,                           damping=damping,                           SlonczewskiSpacerLayerParameter=1.0,                           spinPolarisation=spinPolarisation,                           beta=beta)  l1.setReferenceLayer(CVector(1, 1., 0.)) junction = Junction([l1])  junction.setLayerAnisotropyDriver(\"free\",                                   ScalarDriver.getConstantDriver(300e3)) junction.setLayerCurrentDriver(     \"free\", ScalarDriver.getConstantDriver(currentDensity))  junction.runSimulation(1500e-9, 1e-12, 1e-12, False, False) log = junction.getLog() plot_trajectory(log, \"STT\") In\u00a0[4]: Copied! <pre>demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.0)]\ndamping = 0.03\n\nl1 = Layer(id=\"free\",\n           mag=CVector(0., 0., 1.),\n           anis=CVector(0, 0., 1.),\n           Ms=1.2,\n           thickness=1.4e-9,\n           cellSurface=7e-10 * 7e-10,\n           demagTensor=demagTensor,\n           damping=damping)\njunction = Junction([l1])\n\njunction.setLayerExternalFieldDriver(\n    \"free\",\n    AxialDriver(NullDriver(), ScalarDriver.getConstantDriver(-250e3),\n                NullDriver()))\njunction.setLayerAnisotropyDriver(\n    \"free\", ScalarDriver.getSineDriver(900e3, 10e3, 7e9, 0))\n\njunction.runSimulation(2e-9, 1e-12, 1e-12, False, False)\nlog = junction.getLog()\nplot_trajectory(log, \"VCMA\")\n</pre> demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.0)] damping = 0.03  l1 = Layer(id=\"free\",            mag=CVector(0., 0., 1.),            anis=CVector(0, 0., 1.),            Ms=1.2,            thickness=1.4e-9,            cellSurface=7e-10 * 7e-10,            demagTensor=demagTensor,            damping=damping) junction = Junction([l1])  junction.setLayerExternalFieldDriver(     \"free\",     AxialDriver(NullDriver(), ScalarDriver.getConstantDriver(-250e3),                 NullDriver())) junction.setLayerAnisotropyDriver(     \"free\", ScalarDriver.getSineDriver(900e3, 10e3, 7e9, 0))  junction.runSimulation(2e-9, 1e-12, 1e-12, False, False) log = junction.getLog() plot_trajectory(log, \"VCMA\") In\u00a0[5]: Copied! <pre>demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.0)]\n\ndamping = 0.3\n\nl1 = Layer(id=\"free\",\n           mag=CVector(0., 0., 1.),\n           anis=CVector(0, 0., 1.),\n           Ms=1.6,\n           thickness=1.4e-9,\n           cellSurface=7e-10 * 7e-10,\n           demagTensor=demagTensor,\n           damping=damping)\n\njunction = Junction([l1])\n\njunction.setLayerExternalFieldDriver(\n    \"free\",\n    AxialDriver(ScalarDriver.getConstantDriver(200e3),\n                ScalarDriver.getStepDriver(300e3, 100e3, 0.01e-9, 0.1e-9),\n                NullDriver()))\njunction.setLayerAnisotropyDriver(\"free\",\n                                  ScalarDriver.getConstantDriver(800e3))\n\njunction.runSimulation(2e-9, 1e-12, 1e-12, False, False)\nlog = junction.getLog()\nplot_trajectory(log, \"Hoepulse\")\n</pre> demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.0)]  damping = 0.3  l1 = Layer(id=\"free\",            mag=CVector(0., 0., 1.),            anis=CVector(0, 0., 1.),            Ms=1.6,            thickness=1.4e-9,            cellSurface=7e-10 * 7e-10,            demagTensor=demagTensor,            damping=damping)  junction = Junction([l1])  junction.setLayerExternalFieldDriver(     \"free\",     AxialDriver(ScalarDriver.getConstantDriver(200e3),                 ScalarDriver.getStepDriver(300e3, 100e3, 0.01e-9, 0.1e-9),                 NullDriver())) junction.setLayerAnisotropyDriver(\"free\",                                   ScalarDriver.getConstantDriver(800e3))  junction.runSimulation(2e-9, 1e-12, 1e-12, False, False) log = junction.getLog() plot_trajectory(log, \"Hoepulse\") In\u00a0[6]: Copied! <pre>demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.)]\n\ndamping = 0.011\n\nl1 = Layer.createSTTLayer(id=\"free\",\n                          mag=CVector(1., 0., 0.),\n                          anis=CVector(1, 0., 0.),\n                          Ms=1,\n                          thickness=1.4e-9,\n                          cellSurface=7e-10 * 7e-10,\n                          demagTensor=demagTensor,\n                          damping=damping,\n                          SlonczewskiSpacerLayerParameter=1.0,\n                          spinPolarisation=spinPolarisation,\n                          beta=beta)\nl2 = Layer.createSTTLayer(id=\"bottom\",\n                          mag=CVector(1., 0., 0.),\n                          anis=CVector(1, 0., 0.),\n                          Ms=1.2,\n                          thickness=3e-9,\n                          cellSurface=7e-10 * 7e-10,\n                          demagTensor=demagTensor,\n                          SlonczewskiSpacerLayerParameter=1.0,\n                          spinPolarisation=spinPolarisation,\n                          beta=beta)\n\nl1.setReferenceLayer(CVector(0, 0, 1))\nl2.setReferenceLayer(CVector(0, 0, 1))\njunction = Junction([l1, l2])\njunction.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(-4e-5))\njunction.setLayerAnisotropyDriver(\"free\",\n                                  ScalarDriver.getConstantDriver(300e3))\njunction.setLayerAnisotropyDriver(\"bottom\",\n                                  ScalarDriver.getConstantDriver(800e3))\njunction.setLayerCurrentDriver(\"all\", ScalarDriver.getConstantDriver(1e12))\n\njunction.setLayerExternalFieldDriver(\n    \"free\",\n    AxialDriver(NullDriver(), ScalarDriver.getConstantDriver(100e3),\n                NullDriver()))\n\njunction.runSimulation(2e-9, 1e-12, 1e-12, False, False)\nlog = junction.getLog()\nplot_trajectory(log, \"Switching\")\n</pre> demagTensor = [CVector(0., 0., 0.), CVector(0., 0., 0.), CVector(0., 0., 1.)]  damping = 0.011  l1 = Layer.createSTTLayer(id=\"free\",                           mag=CVector(1., 0., 0.),                           anis=CVector(1, 0., 0.),                           Ms=1,                           thickness=1.4e-9,                           cellSurface=7e-10 * 7e-10,                           demagTensor=demagTensor,                           damping=damping,                           SlonczewskiSpacerLayerParameter=1.0,                           spinPolarisation=spinPolarisation,                           beta=beta) l2 = Layer.createSTTLayer(id=\"bottom\",                           mag=CVector(1., 0., 0.),                           anis=CVector(1, 0., 0.),                           Ms=1.2,                           thickness=3e-9,                           cellSurface=7e-10 * 7e-10,                           demagTensor=demagTensor,                           SlonczewskiSpacerLayerParameter=1.0,                           spinPolarisation=spinPolarisation,                           beta=beta)  l1.setReferenceLayer(CVector(0, 0, 1)) l2.setReferenceLayer(CVector(0, 0, 1)) junction = Junction([l1, l2]) junction.setIECDriver(\"free\", \"bottom\", ScalarDriver.getConstantDriver(-4e-5)) junction.setLayerAnisotropyDriver(\"free\",                                   ScalarDriver.getConstantDriver(300e3)) junction.setLayerAnisotropyDriver(\"bottom\",                                   ScalarDriver.getConstantDriver(800e3)) junction.setLayerCurrentDriver(\"all\", ScalarDriver.getConstantDriver(1e12))  junction.setLayerExternalFieldDriver(     \"free\",     AxialDriver(NullDriver(), ScalarDriver.getConstantDriver(100e3),                 NullDriver()))  junction.runSimulation(2e-9, 1e-12, 1e-12, False, False) log = junction.getLog() plot_trajectory(log, \"Switching\")"},{"location":"tutorials/trajectory/#generating-trajectories","title":"Generating trajectories\u00b6","text":"<p>In this notebook we will generate a couple of interesting trajectories using the core <code>cmtj</code> library.</p>"},{"location":"tutorials/trajectory/#first-steps","title":"First steps\u00b6","text":"<p>Firstly, we import all the necessary stuff from <code>cmtj</code> library and we define a sphere on which we will be plotting our simulated magnetisation dyamics</p>"},{"location":"tutorials/trajectory/#stt-trajectory","title":"STT trajectory\u00b6","text":"<p>Our first trajectory will be the STO (Spin-Transfer Oscillator) trajectory. We will use the STT modelling to induce oscillations of the magnetisation. This is achieved by pumping spin current into our layer. The constant current density supplied to the system sustains the oscillations.</p>"},{"location":"tutorials/trajectory/#vcma-trajectory","title":"VCMA trajectory\u00b6","text":"<p>VCMA (Voltage Controlled Magnetic Anistoropy) allows us to control the perpendicular anisotropy of the system. Here, we excite the perpendicular anisotropy of our layer with a small sinusoidal anisotropy change in the z direction. Since we applied a strong magentic field in the y direction, the magnetisation will eventually settle there after being \"popped\" from a steady starting state in the z direction.</p>"},{"location":"tutorials/trajectory/#oerstedexternalfield-excitation","title":"Oersted/ExternalField excitation\u00b6","text":"<p>The idea is very similar to the VCMA, but here the excitation comes through the $H_{OE}$ (which in this case is modelled as an external field). You may use <code>setLayerOerstedFieldDriver</code> instead of <code>setLayerExternalFieldDriver</code> to help readability, but keep in mind that for the computational engine these two are identical.</p>"},{"location":"tutorials/trajectory/#bilayer-switching","title":"Bilayer switching\u00b6","text":"<p>Finally, we will demonstrate the bilayer switching. Unlike in the other examples, we will use two layers since we need a pinning anisotropy in the bottom layer which is coupled to the top layer via the IEC interaction. The switching from parallel (initial) state to anti-parallel is achieved with STT, by supplying a sufficient spin current to the system.</p>"}]}